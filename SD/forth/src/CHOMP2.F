\.( CHOMP2.F ) \\ i find useful turn case-sensitive off to speed up writing codeCR CASEOFFForth definitions\ some of these load are temporarydecimal   10 load  \ Editordecimal   17 load  \ Case-Ofdecimal   20 load  \ Debuggerdecimal   40 load  \ RNDdecimal   41 load  \ COLOR words definitions decimal   50 load  \ BLEEPdecimal   80 load  \ STRING utility decimal  200 load  \ SPEED!empty-buffers \ Safer during debugging avoid any interference\ creates LAYER1,1 and LAYER1,2 screen-mode setup.( LAYER ) hex : (layer)    3 and  >r        0 0 0100 r> +    1 01D5 doscall    2drop 2drop;decimal: layer1,1    1 (layer);: layer1,2    2 (layer);.( BIN print utility ) cr: bin ( n -- )    base @ >r    2 base !    8 .r    r> base !;: d= ( d1 d2 -- f )            \  l1 h1 l2 h2     rot     \  l1 l2 h1 h2    =       \  l1 l2 f1    >r      \  l1 l2        \ f1    =       \  f2           \ f1    r>      \  f2 f1    and     \  f;    \ word that waits for next interruptcreate sync-video ( -- )    hex    76 c, \ HALT     DD C, E9 C,    smudge     decimal\ Useful to print six character at a time,\ tipical use:  \ CHAR R UDG+ ( PACMAN ) y x 22 ( AT position ) 6 16 ( YELLOW INK ).( Six-emitc ) :  six-emitc    emitc emitc emitc emitc emitc emitc;: sync-emitc ( c1 c2 c3 c4 c5 c6 -- )    sync-video    emitc emitc emitc emitc emitc emitc    emitc emitc emitc emitc emitc emitc;   0 variable udg_1\ reads last key pressed using system variable LASTKdecimal: lastk@ ( -- c )    23560 c@;\ between operator: true if n is between a and b: between  ( n  a b -- f )    >r     \ n  a     over   \ n  a  n    > 0=   \ n  a<=n    swap   \ a<=n  n        r>     \ a<=n  n  b    > 0=   \ a<=n  n<=b                   and    \ a<=n & n<=b    ;  decimal\ translate a capital letter in its udg character code: udg+  ( c1 -- c2 )    79 +      \ dup 164 > if    \    16 -    \ then;\ compile an udg literal in the current colon definition: [udg]  ( -- )    char udg+ [compile] literal ; immediate: udg@     65 - 8 * 23675 @ + ;    : .udg     cr    udg@ dup 8 + swap do        i c@ bin cr    loop    decimal;   .( UDG definition ) here udg_1 !\  UDG A B C D    0 c, 255 c,   0 c,   0 c,   0 c,   0 c,   0 c,   0 c,     0 c,   0 c,   0 c,   0 c,   0 c,   0 c, 255 c,   0 c,     0 c, 255 c,   0 c,   0 c,   0 c,   0 c, 255 c,   0 c,     0 c, 248 c,   4 c,   2 c,   2 c,   2 c,   2 c,   2 c,\  UDG E F G    0 c,  31 c,  32 c,  64 c,  64 c,  64 c,  64 c,  64 c,     0 c,  63 c,  64 c, 128 c, 128 c,  64 c,  63 c,   0 c,     0 c, 252 c,   2 c,   1 c,   1 c,   2 c, 252 c,   0 c, \  UDG H I J    2 c,   2 c,   2 c,   2 c,   2 c,   4 c, 248 c,   0 c,    64 c,  64 c,  64 c,  64 c,  64 c,  32 c,  31 c,   0 c,       2 c,   2 c,   2 c,  2  c,   2 c,   2 c,   2 c,   2 c,\  UDG K L M N O    0 c,  24 c,  36 c,  66 c,  66 c,  66 c,  66 c,  66 c,    66 c,  66 c,  66 c,  66 c,  66 c,  36 c,  24 c,   0 c,   64 c,  64 c,  64 c,  64 c,  64 c,  64 c,  64 c,  64 c,    66 c,  66 c,  66 c,  66 c,  66 c,  66 c,  66 c,  66 c,     0 c,   0 c,  56 c, 124 c, 124 c, 124 c,  56 c,   0 c,\  UDG P Q R S    28 c,  62 c,  31 c,  15 c,  31 c,  62 c,  28 c,   0 c,    0 c,  34 c, 119 c, 127 c, 127 c,  62 c,  28 c,   0 c,     0 c,  28 c,  62 c, 124 c, 120 c, 124 c,  62 c,  28 c,     0 c,  56 c, 124 c, 254 c, 254 c, 238 c,  68 c,   0 c, \  UDG T U   56 c, 126 c,  90 c, 219 c, 255 c, 255 c, 255 c, 147 c,     2 c,   6 c,  10 c,  20 c,  36 c, 238 c, 238 c, 102 c,\ set UDG system-variable to point to the above definitionudg_1 @ 23675 ! \ UDG.( Maze definition ) hp@ pointer p-maze-base cr p-maze-base hex u. hp@    h" EAAAAAAAAANAAAAAAAAAD"  drop    h" M.........N.........J"  drop    h" M.EAD.EAD.N.EAD.EAD.J"  drop    h" MOM J.M J.N.M J.M JOJ"  drop    h" M.IBH.IBH.L.IBH.IBH.J"  drop    h" M...................J"  drop    h" M.FCG.K.FCACG.K.FCG.J"  drop    h" M.....N...N...N.....J"  drop    h" IBBBB.MCG.L.FCJ.BBBBH"  drop    h"     J.N.......N.M    "  drop    h" BBBBH.L.E---D.L.IBBBB"  drop    h" /.......M   J.......\"  drop    h" AAAAD.K.I---H.K.EAAAA"  drop    h"     J.N.... ..N.M    "  drop    h" BBBBH.L.FCACG.L.IBBBB"  drop    h" M.........N.........J"  drop    h" MOFCD.FCG.L.FCG.ECGOJ"  drop    h" M...N...........N...J"  drop    h" AAD.L.FCCCCCCCG.L.EAA"  drop    h"   J...............M  "  drop    h"    AAAAAAAAAAAAAAA   "  drophp@ swap - constant maze-dim  \ maze is 21 x 21 plus len and pointerhp@ cell+ pointer p-maze-runcr p-maze-run hex u.decimal21    constant maze-height21    constant maze-width\ convert Upper-case to UDG: udg-maze-row ( a -- )    dup c@ over maze-dim + c!   \ copy length byte    dup maze-width + 1+ swap     do         i c@                   \ Change A-U character into UDG chr.        dup [char] A [char] U between         if            udg+         endif        i maze-dim + c!    loop;\ copy the MAZE-BASE definition to the MAZE-RUN area: set-maze-run ( -- )    p-maze-base     maze-height 0     do        dup cell+ udg-maze-row        @ far        loop    drop;.( Maze-array access. ) : maze  ( x y -- a )     p-maze-run + swap 1- 24 * + ;: maze@ ( x y -- c )     maze c@ ;: maze! ( c x y -- )     maze c! ;: ctype ( a n -- )    over + swap    ?do        i c@ emitc    loop;\ display the whole maze: display-maze ( -- )    0  0  at.  cr    1 22    do        050 i 16 + beep-pitch bleep-calc     -1 +loop    22 1    do        i 0  maze  count               space ctype cr        bleep    loop    0 0 at.    ;    \ _________________________________________________________.( Variables )   0 variable total      0 ,   0 variable score      0 ,   0 variable high-score 0 , 30 variable counting   3 variable lives  1 variable huntchar R udg+ variable pacman-face14 variable pacman-x12 variable pacman-y14 variable prev-pacman-x12 variable prev-pacman-ybl variable prev-pacmanchar T udg+ dup 2dup    variable ghost-face            ,    ,    , 2 variable ghost-prob          3 ,  1 ,  8 , 3 variable ghost-color         2 ,  1 ,  5 ,12 variable ghost-x            12 , 12 , 12 ,12 variable ghost-y            11 , 11 , 10 ,55 variable ghost-dir          53 , 53 , 55 ,12 variable prev-ghost-x       12 , 12 , 12 ,12 variable prev-ghost-y       11 , 11 , 10 ,bl variable prev-ghost-maze    bl , bl , bl ,.( pacman ) cr: pacman-xy@ ( -- x y )    pacman-x c@    pacman-y c@      ;    : pacman-xy! ( x y -- )    pacman-y c!          pacman-x c!;    : prev-pacman-xy@ ( -- x y )    prev-pacman-x c@    prev-pacman-y c@      ;    : prev-pacman-xy! ( x y -- )    prev-pacman-y c!         prev-pacman-x c!;    .( ghost ): ghost-face@ ( n -- c )    cells     ghost-face + c@;: ghost-color@ ( n -- c )    cells     ghost-color + c@;: prev-ghost-maze@ ( n -- c )    cells     prev-ghost-maze + c@;: prev-ghost-maze! ( c n -- )    cells     prev-ghost-maze + c!;: ghost-xy@ ( n -- x y )    cells dup       ( 2n 2n )    ghost-x + c@    ( 2n [a+2n] )    swap            ( [a+2n] 2n )    ghost-y + c@    ( [a+2n] [a+2n] )  ;    : ghost-xy! ( x y n -- )    cells   >r    ghost-y  r  + c!        ghost-x  r> + c!    ;    : prev-ghost-xy@ ( n -- x y )    cells dup     prev-ghost-x + c@    swap    prev-ghost-y + c@      ;    : prev-ghost-xy! ( x y n -- )    cells        >r    prev-ghost-y  r  + c!        prev-ghost-x  r> + c!    ;    .( init-all )decimal: init-all ( -- )    [char] R udg+ pacman-face !    14 12  pacman-xy!      14 12  prev-pacman-xy!    12 11  0 ghost-xy!    12 12  1 ghost-xy!    12 12  2 ghost-xy!    12 10  3 ghost-xy!     12 11  0 prev-ghost-xy!    12 12  1 prev-ghost-xy!    12 12  2 prev-ghost-xy!    12 10  3 prev-ghost-xy!    30     counting      !    56     23560        c! ;.( put ): put-pacman ( -- )    pacman-face @    pacman-xy@  swap 22   \ pacman at x,y    6  16                        \ yellow    bl     prev-pacman-xy@ swap 22   \ wipe previous    7 16      sync-emitc;: put-ghost ( n -- )   >r    r   ghost-face@           r   ghost-xy@  swap 22    hunt @ 0 < if 7 else  r ghost-color@ then 16    r   prev-ghost-maze@      r>  prev-ghost-xy@ swap 22    7 16      sync-emitc;: put-cherry ( -- )    14 11 maze@     [udg] U    - if        [udg] U dup  14 11 maze!        11 14 22   2 16            six-emitc     endif;        \ given the character c (destination) say if we can go there: ?pacman-trail ( c -- f )    >r    r    bl       =     \ blank    r    [char] . = or  \ dot    r    [udg]  U = or  \ cherry    r    [udg]  O = or  \ pill    r    [char] / = or  \ left tunnel    r>   [char] \ = or  \ right tunnel;\ given the character c (destination) say if we can go there: ?ghost-trail ( c -- f )    >r    r    bl       =     \ blank    r    [char] . = or  \ dot    r    [udg]  U = or  \ cherry    r    [udg]  O = or  \ pill    r>   [char] - = or  \ right tunnel;: pill-on ( -- )    -1 hunt !   10. total 2@ d+ total 2!     0 counting !;.( go ) cr: go-right ( -- )     pacman-xy@  1+ maze@     dup [char] \ = if 1 pacman-y ! endif    ?pacman-trail if         1 pacman-y +!        [udg] R pacman-face !    endif;: go-left ( -- )      pacman-xy@  1- maze@     dup [char] / = if 21 pacman-y ! endif    ?pacman-trail if         -1 pacman-y +!        [udg] P pacman-face !    endif;: go-up  ( -- )      pacman-xy@ swap 1- swap maze@     dup [udg] O = if pill-on endif    ?pacman-trail if         -1 pacman-x +!        [udg] Q pacman-face !    endif;: go-down  ( -- )    pacman-xy@ swap 1+ swap maze@     dup [udg] O = if pill-on endif    ?pacman-trail if         1 pacman-x +!        [udg] S pacman-face !    endif;.( pacman movement ) : pacman-movement ( c -- )    pacman-xy@  prev-pacman-xy!    case     56 of go-right endof     53 of go-left  endof     55 of go-up    endof     54 of go-down  endof     endcase;: pacman-eat-dot ( c -- )    [char] . = if        1.  score 2@ d+ score 2!        [  0025  -12  beep-pitch bleep-calc swap ] literal literal bleep    endif;: pacman-eat-pill ( c -- )    [udg] O = if        10. score 2@ d+ score 2!        [  0050  25  beep-pitch bleep-calc swap ] literal literal bleep        [  0050  39  beep-pitch bleep-calc swap ] literal literal bleep    endif;: pacman-eat-cherry ( c -- )    [udg] U = if        10. score 2@ d+ score 2!        10. total 2@ d+ total 2!        [  0050  29  beep-pitch bleep-calc swap ] literal literal bleep        [  0050  36  beep-pitch bleep-calc swap ] literal literal bleep    endif;: pacman-walk ( c -- )    >r     r  [udg]  O  =      r  [char] .  =  or      r> [udg]  U  =  or    0= if        pacman-xy@ prev-pacman-xy@ d=         0= if         [  0025 -14  beep-pitch bleep-calc swap ] literal literal bleep        endif    endif;.( ghost movement ) cr: ghost-right ( n -- )   >r    r ghost-xy@  1+  maze@     dup [char] \ = if 1 ghost-y ! endif    ?ghost-trail     if        1 ghost-y r cells + +!    then    r> drop;: ghost-left ( n -- )    >r    r ghost-xy@  1-  maze@     dup [char] / = if 21 ghost-y ! endif    ?ghost-trail     if        -1 ghost-y r cells + +!     then    r> drop;: ghost-down ( n -- )    >r    r ghost-xy@  swap 1+ swap maze@     ?ghost-trail     if        1 ghost-x r cells + +!    then    r> drop;: ghost-up ( n -- )    >r    r ghost-xy@  swap 1- swap maze@     ?ghost-trail     if         -1 ghost-x r cells + +!    then    r> drop;: ghost-movement ( c n -- )    >r    r  ghost-xy@         2dup    r  prev-ghost-xy!       maze@     r prev-ghost-maze!    case      56 of r  ghost-right endof    53 of r  ghost-left  endof    55 of r  ghost-up    endof    54 of r  ghost-down  endof    endcase    r> drop;: ghost-decision ( n -- )    >r    r      ghost-xy@     r prev-ghost-xy@     d= if            r cells         ghost-prob + @         rnd if            lastk@                    else            3 rnd 53 +         then        ghost-dir r cells + !    then     r> drop;.( init ) cr: init-display    0 paper. 0 border. 7 ink. cls     display-maze    0 20 at. ." high "    high-score 2@     <# # # # # # #> type    put-pacman    0 put-ghost    1 put-ghost    2 put-ghost    3 put-ghost;: interlude    27 0    do        020 i beep-pitch bleep-calc     1 +loop    1 28    do        020 i beep-pitch bleep-calc     -1 +loop    cls    10 31 at. [udg] O emitc    28 1    do        10 i at.         sync-video          bl emit        3 16 emitc emitc [udg] T emitc        sync-video          bl bl emitc emitc        6 16 emitc emitc [udg] R emitc        bleep        ?terminal if quit then    1 +loop    0 27    do        10 i at.         sync-video          7 16 emitc emitc [udg] T  emitc        bl bl emitc emitc        sync-video          6 16 emitc emitc [udg] P emitc        bl emit        bleep        ?terminal if quit then    -1 +loop;.( check ) : check-collision ( -- f )    0 ghost-xy@ pacman-xy@ d=    1 ghost-xy@ pacman-xy@ d=    2 ghost-xy@ pacman-xy@ d=    3 ghost-xy@ pacman-xy@ d=    or or or ;: ghost-is-eaten ( n -- )    >r    12 12  r>  ghost-xy!    10. score 2@ d+ score 2!    10. total 2@ d+ total 2!    sync-video     [ 0005 20  beep-pitch bleep-calc swap ] literal literal bleep    [ 0005 10  beep-pitch bleep-calc swap ] literal literal bleep    [ 0010 10  beep-pitch bleep-calc swap ] literal literal bleep    sync-video ;: ghost-catch    -1 lives +!    lives @ 0=     if        high-score 2@         score 2@ dminus d+        0< if score 2@  high-score 2! then        0.    score 2!        179.  total 2!    then    init-all    interlude         init-display;: resolve-collision ( -- )    hunt @ 1 =    if         ghost-catch    else        4 0 do            i ghost-xy@ pacman-xy@ d=            if                i ghost-is-eaten            then        loop    then;.( heart beat ) cr: heart-beat    \ move your pacman    lastk@   \ so pacman continues to walk if you don't press anything    pacman-movement    put-pacman     check-collision if resolve-collision then        pacman-x @ pacman-y @ maze@           \ takes current cell    bl pacman-x @ pacman-y @ maze!        \ blank current cell    dup pacman-eat-dot    dup pacman-eat-pill    dup pacman-eat-cherry        pacman-walk    \ move four ghosts    4 0 do         i ghost-decision         i cells ghost-dir + @        i ghost-movement         i put-ghost    loop    check-collision if resolve-collision then    1  counting +!    60 counting @ < if 1 hunt ! endif    100 rnd 0= if put-cherry endif        \ display lives and score       0  1 at.     6 16 emitc emitc \ for ink 6    [udg] P emitc     7 16 emitc emitc \ for ink 7    bl emitc lives ?    0 6  at. ." score "     score 2@     <# # # # # # #> type        2 24 at. ." hunt " hunt ?    3 24 at. ." totl " total ?    4 24 at. 6              16  emitc emitc   pacman-xy@ swap . .     5 24 at. 0 ghost-color@ 16  emitc emitc  0 ghost-xy@ swap . .     6 24 at. 1 ghost-color@ 16  emitc emitc  1 ghost-xy@ swap . .     7 24 at. 2 ghost-color@ 16  emitc emitc  2 ghost-xy@ swap . .     8 24 at. 3 ghost-color@ 16  emitc emitc  3 ghost-xy@ swap . . ;.( run game ): run-game    0 speed!    begin        heart-beat        check-collision if resolve-collision then                score 2@ total 2@ d=         if             interlude                 init-all            set-maze-run            init-display        then                ?terminal     until    3 speed!;.( new-game ): new-game    layer1,1    0 speed!    0 paper. 0 border. 7 ink. cls     interlude    0.  total 2!    0.  score 2!    init-all    set-maze-run    init-display    run-game    0 0 at.    quit;: T heart-beat ;: K check-collision ;\ new-gamequitquitquitstop-me-here                 1 ghost-xy@              2 ghost-xy@              3 ghost-xy@             