File: c:\Zx\forth\F15\!Blocks-64.bin
Created: Tue Aug 24 23:12:39 2021

Index:

    1 #1
    2 #2
    3 # -16
    4 is undefined.
    5 ( Error messages    from #17 to #31 )
    6 ( Error messages    from #33 to #47 )
    7 ( Error messages    from #49 to #63 )
    8 ( Print a complete error list )
    9 ." Assembler. "          CR
   10 ( v-Forth 1.5 - Recompilation )
   11 ( Autoexec 1/3 )
   12 ( Autoexec 2/3 )
   13 ( Autoexec 3/3 )
   14 ( Autoexec 3/3 - previous version )
   15 ( Autoexec 3/3 )
   16 
   17 
   18 .( Case-of structure. )   CR
   19 ( Case-Of structure  2/2 )
   20 .( Decompiler / Inspector. ) CR
   21 ( Debugger             2/6 )
   22 ( Debugger             3/6 )
   23 ( Debugger             4/6 )
   24 ( Debugger             5/6 )
   25 ( Debugger             6/6 )
   26 ( Stack viewer             )
   27 ( Long memory dump )
   28 ( Vocabulary viewer        )
   29 ( Simple Word RENAMEr )
   30 ( 2CONSTANT )
   31 ( SET-FENCE )
   32 ( HIDE )
   33 ( USED-BY )
   34 ( DUMP WORDS )
   35 ( Restore AUTOEXEC )
   36 ( RECURSE )
   37 ( RECURSE - GDC )
   38 ( RND Test )
   39 ( CHOOSE - Brodie )
   40 .( RND ) CR
   41 .( Color and attributes  ) CR
   42 ( AT TAB                   )
   43 ( POINT SCREEN$ )
   44 ( PLOT )
   45 ( DRAW                     )
   46 ( PAINT )
   47 ( PAINT )
   48 ( Mr Jones' keyboard test )
   49 ( Mr Jones' keyboard test )
   50 .( BLEEP ) CR
   51 ( BLEEP )
   52 ( Pitch bend )
   53 ( KEYBOARD-TEST )
   54 ( ?ESCAPE experiment       )
   55 ( ms delay )
   56 #1
   57 ( FRAMES )
   58 ( FRAMES 2 )
   59 ( TEST )
   60 ( Interrupt Handler )
   61 ( Interrupt Handler )
   62 ( Interrupt Handler )
   63 ( Interrupt Handler )
   64 ( Interrupt Handler )
   65 ( Interrupt Handler )
   66 ( Interrupt Handler )
   67 ( Interrupt Handler )
   68 ( INTERRUPT - TEST )
   69 ( INTERRUPT )
   70 .( Compare Utility. ) CR
   71 .( Search utility. ) CR
   72 ( SEARCH )
   73 ( BSEARCH SEARCH-ALL )
   74 ( LOCATE )
   75 ( LOCATE )
   76 
   77 
   78 
   79 
   80 .( Heap Memory Management ) CR
   81 ( Heap Memory Management )
   82 ( Heap Memory Management )
   83 ( Heap Memory Management )
   84 ( Heap Memory Management )
   85 ( S" Counted Strings in Heap )
   86 ( S" Counted Strings in Heap )
   87 ( Allocate RAM banks $20-$27  or 32-39  for string heap )
   88 
   89 
   90 .( Line editor. )         CR
   91 ( Line Editor          2/6 )
   92 ( Line Editor          3/6 )
   93 ( Line Editor          4/6 )
   94 ( Line Editor          5/6 )
   95 ( Line Editor          6/6 )
   96 
   97 
   98 ( Editor utility           )
   99 .( Call utility. )        CR
  100 ." Assembler. "           CR
  101 .( Z80 Assembler. ) CR
  102 ( Z80 Utility - Sys depend )
  103 ( Z80 Utility - Sys depend )
  104 ( Z80 System independ. )
  105 ( Z80 System independ. )
  106 ( Z80 Generate errors )
  107 ( Assembler Z80 )
  108 ( Assembler Z80 )
  109 ( Assembler Z80 )
  110 ( Assembler Z80 )
  111 ( Assembler Z80 )
  112 ( Assembler Z80 )
  113 ( Assembler Z80 )
  114 ( Assembler Z80 )
  115 ( Assembler Z80 )
  116 ( Assembler Z80 )
  117 ( Assembler z80 )
  118 ( Assembler MMU config ) EXIT  seems bugged: don't use
  119 
  120 .( Z80 definitions. ) CR
  121 ( Z80 ) HEX
  122 ( Z80 ) HEX
  123 ( Z80 ) HEX
  124 ( Z80 immediate data )
  125 ( Z80 address )
  126 ( Z80 ) HEX
  127 ( Z80 relative jump )
  128 ( ED prefix )
  129 ( ED )
  130 ( ED )
  131 ( CB )
  132 ( IX IY )
  133 ( IX IY )
  134 ( IX IY )
  135 ( IX IY )
  136 ( IX IY )
  137 ( IX IY )
  138 ( IX IY )
  139 
  140 .( Z80 near structure )   CR
  141 ( Z80 Near struct. )
  142 ( Z80 Near struct. )
  143 ( Z80 Near struct. )
  144 ( Z80 Near struct. )
  145 ." Z80 far struct "
  146 ( TESTING )
  147 ( 128K memory BANK! TEST )
  148 ( 128K memory BANK! TEST )
  149 ( 128K memory BANK! TEST )
  150 ( TEST )
  151 ( TEST1 )
  152 ( TEST2 )
  153 ( TEST3 )
  154 ( TEST IF, THEN, )
  155 \ TEST
  156 \ TEST6
  157 \ TEST7
  158 \ TEST Z80N
  159 \ TEST Z80N
  160 .( Z80N Next extensions )
  161 ( Z80N Next extension )
  162 ( Z80N Next extension )
  163 
  164 
  165 ( M*/ )
  166 ( White noise Egghead 3 )
  167 ( White noise Egghead 3 )
  168 ( White noise Egghead 3 )
  169 ( Checksum of a RAM chunk )
  170 \ BURP
  171 ( Dump many pages )
  172 ( NEEDS )
  173 ( NEEDS )
  174 ( NEEDS )
  175 ( NEEDS )
  176 ( NEEDS )
  177 ( INCLUDE ) \ study and test
  178 ( DEFER IS - EXIT UNLOOP )
  179 ( CHECK NULL               )
  180 ( Fibonacci )
  181 ( SQRT )
  182 ( Primality Test )
  183 ( MARKER )
  184 ( TEST )
  185 ( SAVE-BYTES TEST )
  186 ( DOT example  .helloworld )
  187 ( search for AT position )
  188 ( TEST )
  189 ( TEST )
  190 .( Full Screen Editor. ) CR
  191 ( Full Screen Editor   2/7 )
  192 ( Full Screen Editor   3/7 )
  193 ( Full Screen Editor   4/7 )
  194 ( Full Screen Editor   5/7 )
  195 ( Full Screen Editor   6/7 )
  196 ( Full Screen Editor   7/7 )
  197 ( ON and OFF )
  198 ( \ comment )
  199 ( MARKER )
  200 .( .RESET & CPU SPEED )  CR
  201 ( DAA )
  202 ( PICK )
  203 ( U* )
  204 ( U* )
  205 ( U/   dn n -- r dq )
  206 ( U/ )
  207 ( U/ )
  208 ( UPPER )
  209 ( "NUL" )
  210 \ 1. F_GETLINE from handle( via F_READ and F_SEEK ) DECIMAL
  211 \ 2. include from handle
  212 \ 2. include from handle
  213 \ 3. an INCLUDE wrapper
  214 ( NEW UM* using MUL new OP-code )
  215 ( NEW UM* using MUL new OP-code )
  216 ( NEW UM* using MUL new OP-code )
  217 ( TEST )
  218 ( NEW UM* using MUL new OP-code )
  219 ( NEW UM* using MUL new OP-code )
  220 ( MOVE SP )
  221 ( MOVE RP )
  222 ( MOVE LIMIT )
  223 ( UP AND DOWN )
  224 ( 128K BANK! TEST )
  225 ( ?DO LOOP )
  226 ( ?DO LOOP )
  227 ( ?DO LOOP )
  228 ( ?DO LOOP )
  229 ( POSTPONE )
  230 \ 0. F_GETLINE from handle( F_READ and F_SEEK )
  231 \ 1. include from handle
  232 \ 2. include from handle
  233 \ 3. include from handle
  234 \ 4. an INCLUDE wrapper
  235 ( SM/REM and FM/MOD )
  236 ( Save RAM to BLOCKS )
  237 
  238 
  239 ( Rainbow effects )
  240 ( FIND )
  241 ( Square example )
  242 ( CUBES )
  243 ( CUBES )
  244 ( CUBES )
  245 ( Vectored execution )
  246 ( Buzzphrases Generator -- ver 1. )
  247 integrated          management          criteria
  248 
  249 
  250 \ BLOCK-SHIFT
  251 ( block move reorder )
  252 \ Print all blocsks to #13
  253 ( INITIALIZE-MMC )
  254 ( MICRODRIVE CARTRIDGE LAST BLOCK )
  255 
  256 
  257 
  258 
  259 \ Forth Application Tecniques - 5.1.1
  260 ( TRACE )
  261 ( TRACE )
  262 ( TRACE )
  263 ( TRACE )
  264 ( TRACE )
  265 ( TRACE )
  266 ( TEST )
  267 
  268 
  269 
  270 ( THROW - CATCH )
  271 ( THROW - CATCH )
  272 ( THROW - CATCH )
  273 ( THROW - CATCH )
  274 
  275 
  276 
  277 
  278 
  279 
  280 
  281 
  282 
  283 
  284 
  285 
  286 
  287 ( GREY-SCREEN example )
  288 ( GREY-SCREEN example )
  289 
  290 ( map - character replacing )
  291 ( map - character replacing )
  292 ( map - character replacing )
  293 ( map - character replacing )
  294 ( GREY-SCREEN example )
  295 
  296 
  297 
  298 
  299 
  300 ( Study:  MMU7 / set or get bank )
  301 ( Study: MMU7 / simplest )
  302 ( Study: MMU7 / simplest )
  303 ( Study: MMU7 / simplest )
  304 ( Study: MMU7 / simplest )
  305 ( Study: MMU7 / 16th byte )
  306 ( Study: MMU7 / 16th byte )
  307 ( Study: MMU7 / 16th byte )
  308 ( Study: MMU7 / 16th byte )
  309 #1
  310 ( LED - Large EDitor )
  311 ( LED - Large EDitor )
  312 ( LED - Large EDitor )
  313 ( LED - Large EDitor )
  314 ( LED - Large EDitor )
  315 ( LED - Large EDitor )
  316 ( LED - Large EDitor )
  317 ( LED - Large EDitor )
  318 ( LED - Large EDitor )
  319 ( LED - Large EDitor )
  320 ( LED - Large EDitor )
  321 ( LED - Large EDitor )
  322 ( LED - Large EDitor )
  323 ( LED - Large EDitor )
  324 ( LED - Large EDitor )
  325 ( LED - Large EDitor )
  326 ( LED - Large EDitor )
  327 ( LED - Large EDitor )
  328 ( MMU7 HEAP )
  329 ( MMU7 HEAP STRING )
  330 ( MMU7 HEAP STRING )
  331 ( MMU7 HEAP STRING )
  332 ( MMU7 HEAP POINTER )
  333 ( S" Counted Strings in Heap )
  334 \ TEST
  335 ( Testing where $6000 is paged )
  336 ( Testing where $6000 is paged )
  337 
  338 
  339 
  340 ( R/W : BLK-FH )
  341 ( R/W : BLK-READ )
  342 ( R/W : BLK-WRITE )
  343 ( R/W : BLK-INIT )
  344 ( blk-fname )
  345 ( r/w patch )
  346 ( r/w patch )
  347 ( study to improve +LOOP )
  348 ( standard +LOOP )
  349 ( standard +LOOP )
  350 ( Matt Davies'  .helloworld )
  351 
  352 
  353 
  354 
  355 
  356 
  357 
  358 
  359 
  360 ( F_STAT via RST 8 hook code )
  361 ( F_FGETPOS via RST 08 hook code )
  362 ( F_SEEK via RST 08 hook code )
  363 ( F_WRITE via RST 8 hook code )
  364 ( F_READ via RST 8 hook code )
  365 ( F_CLOSE via RST 8 hook code )
  366 ( F_OPEN via RST 8 hook code )
  367 ( F_OPEN via RST 8 hook code )
  368 ( F_FSTAT via RST 8 hook code )
  369 code F_SYNC  ( n -- f )
  370 ( M_DOSVERSION via RST 8 hook code )
  371 ( F_GETFREE via RST 08 hook code test )
  372 ( M_P3DOS )
  373 ( M_P3DOS )
  374 ( M_P3DOS )
  375 
  376 
  377 
  378 ( NextZXOS IDE_MODE 01d5 )
  379 ( IDE_BANK )
  380 ( NextZXOS - IDE_CAPACITY $01b4 )
  381 ( NextZXOS - DOS_FREE_SPACE $0121 )
  382 ( NextZXOS IDE_MODE 01d5 )
  383 ( NextZXOS IDE_MODE 01d5 )
  384 ( DOS_FLUSH $0142 )
  385 ( DOS_VERSION / IDE_VERSION )
  386 ( IDE_BASIC 1/3 )
  387 ( IDE_BASIC 2/3 )
  388 ( IDE_BASIC 3/3 )
  389 ( IDE_BASIC test )
  390 ( looking for AT position in LAYERs )
  391 ( looking for AT position in LAYERs )
  392 
  393 
  394 
  395 
  396 
  397 
  398 
  399 ( Sprite definition )
  400 ( Sprite struct definition )
  401 ( Sprite struct definition )
  402 ( Sprite Lib - Derek Bolli et Al. )
  403 ( Sprite Lib )
  404 ( Sprite Lib )
  405 ( Sprite Lib )
  406 ( Sprite )
  407 ( Sprite )
  408 ( Sprite Test )
  409 ( Sprite Test )
  410 ( Sprite definition )
  411 ( TEST )
  412 ( ISR-TEST )
  413 
  414 
  415 ( .HEX and .BIN utility )
  416 
  417 
  418 
  419 
  420 
  421 
  422 
  423 
  424 
  425 
  426 
  427 
  428 
  429 
  430 
  431 
  432 
  433 
  434 
  435 
  436 
  437 
  438 
  439 
  440 
  441 
  442 
  443 
  444 
  445 
  446 
  447 
  448 
  449 
  450 ( Floating Point Support )
  451 ( Floating Point Support )
  452 ( Floating Point Support )
  453 ( Floating Point Support )
  454 ( Floating Point Support )
  455 ( Floating Point Support )
  456 ( Floating Point Support )
  457 ( Floating Point Support )
  458 ( Floating Point Support )
  459 ( Floating Point Support )
  460 ( Floating Point Support )
  461 ( Floating Point Support )
  462 ( Floating Point Support )
  463 ( Floating Point Support )
  464 ( Floating Point Support )
  465 ( Floating Point Support )
  466 ( Floating Point Support )
  467 ( Floating Point Support )
  468 ( Floating Point Support )
  469 
  470 
  471 
  472 
  473 
  474 
  475 
  476 
  477 
  478 
  479 
  480 
  481 
  482 
  483 
  484 
  485 
  486 
  487 
  488 
  489 
  490 
  491 
  492 
  493 
  494 
  495 
  496 
  497 
  498 
  499 
  500 ( Next Registers )
  501 ( Next Registers )
  502 ( Next Registers )
  503 ( Next Registers )
  504 ( Next Registers )
  505 
  506 
  507 
  508 
  509 
  510 
  511 
  512 
  513 
  514 
  515 
  516 
  517 
  518 
  519 
  520 ( LAYER 2 palette picker )
  521 ( LAYER 2 palette picker )
  522 ( LAYER 2 palette picker )
  523 ( LAYER 2 palette picker )
  524 ( LAYER 2 palette picker )
  525 ( LAYER 2 palette picker )
  526 ( LAYER 2 palette picker )
  527 ( LAYER 2 palette picker )
  528 ( LAYER 2 palette picker )
  529 ( LAYER 2 palette picker )
  530 ( LAYER 2 palette picker )
  531 ( LAYER 2 palette picker )
  532 ( LAYER 2 palette picker )
  533 
  534 
  535 
  536 
  537 ( VALUE TO )
  538 \ test
  539 
  540 
  541 
  542 
  543 
  544 
  545 
  546 
  547 
  548 
  549 
  550 
  551 
  552 
  553 
  554 
  555 
  556 
  557 
  558 
  559 
  560 
  561 
  562 
  563 
  564 
  565 
  566 
  567 
  568 
  569 
  570 
  571 
  572 
  573 
  574 
  575 
  576 
  577 
  578 
  579 
  580 
  581 
  582 
  583 
  584 
  585 
  586 
  587 
  588 
  589 
  590 
  591 
  592 
  593 
  594 
  595 
  596 
  597 
  598 \ kempston test
  599 \ kempston test
  600 .( Chomp.f )
  601 ( Chomp.f )
  602 ( Chomp.f )
  603 ( Chomp.f )
  604 ( Chomp.f )
  605 ( Chomp.f )
  606 ( Chomp.f )
  607 
  608 
  609 
  610 .( Chomp.f - UDG )
  611 ( Chomp.f - UDG )
  612 ( Chomp.f - UDG )
  613 ( Chomp.f - UDG )
  614 .( Chomp.f - maze )
  615 ( Chomp.f - maze )
  616 ( Chomp.f - maze )
  617 ( Chomp.f - maze )
  618 ( Chomp.f - maze )
  619 ( Chomp.f - maze )
  620 .( Chomp.f - Sprite )
  621 ( Chomp.f - Sprite )
  622 ( Chomp.f - Sprite )
  623 ( chomp.f - Sprite )
  624 ( Chomp.f - Sprite )
  625 ( Chomp.f - Sprite )
  626 ( Chomp.f - Sprite )
  627 ( Chomp.f - Sprite )
  628 ( Chomp.f - Sprite )
  629 ( Chomp.f )
  630 .( Chomp.f - trail )
  631 ( Chomp.f - trail )
  632 ( Chomp.f - trail )
  633 ( Chomp.f - trail )
  634 ( Chomp.f - trail )
  635 ( Chomp.f - trail )
  636 ( Chomp.f - trail )
  637 ( Chomp.f - trail )
  638 ( Chomp.f - trail )
  639 ( Chomp.f - trail )
  640 ( Chomp.f - ghost )
  641 ( Chomp.f - ghost )
  642 ( Chomp.f - ghost )
  643 ( Chomp.f - ghost )
  644 ( Chomp.f - ghost )
  645 ( Chomp.f - ghost )
  646 ( Chomp.f - trail )
  647 
  648 
  649 
  650 ( Chomp.f )
  651 ( Chomp.f )
  652 ( Chomp.f )
  653 ( Chomp.f - Interlude )
  654 ( Chomp.f )
  655 ( Chomp.f )
  656 ( Chomp.f )
  657 ( Chomp.f )
  658 ( Chomp.f )
  659 ( Chomp.f )
  660 ( Chomp.f )
  661 ( Chomp.f )
  662 ( Chomp.f )
  663 ( Chomp.f )
  664 ( Chomp.f )
  665 ( Chomp.f )
  666 ( Chomp.f )
  667 ( Ghost.f )
  668 ( Ghost.f )
  669 
  670 
  671 
  672 
  673 
  674 
  675 
  676 
  677 
  678 
  679 
  680 
  681 
  682 
  683 
  684 
  685 
  686 
  687 
  688 
  689 
  690 
  691 
  692 
  693 
  694 
  695 
  696 
  697 
  698 
  699 
  700 \ notes on June-12 \ Ulrich Hoffmann
  701 \ notes on June-12 \ Bernd Ulmann
  702 
  703 
  704 
  705 
  706 
  707 
  708 
  709 
  710 
  711 
  712 
  713 
  714 
  715 
  716 
  717 
  718 
  719 
  720 
  721 
  722 
  723 
  724 
  725 
  726 
  727 
  728 
  729 
  730 
  731 
  732 
  733 
  734 
  735 
  736 
  737 
  738 
  739 
  740 
  741 
  742 
  743 
  744 
  745 
  746 
  747 
  748 
  749 
  750 
  751 
  752 
  753 
  754 
  755 
  756 
  757 
  758 
  759 
  760 
  761 
  762 
  763 
  764 
  765 
  766 
  767 
  768 
  769 
  770 
  771 
  772 
  773 
  774 
  775 
  776 
  777 
  778 
  779 
  780 
  781 
  782 
  783 
  784 
  785 
  786 
  787 
  788 
  789 
  790 
  791 
  792 
  793 
  794 
  795 
  796 
  797 
  798 
  799 
  800 ( Test Suite )
  801 ( Test Suite )
  802 ( Test Suite )
  803 ( Test Suite )
  804 ( Test Suite )
  805 ( Test Suite )
  806 ( Test Suite )
  807 ( Test Suite )
  808 ( Test Suite )
  809 ( Test Suite )
  810 ( Test Suite - Examples          )
  811 ( Test Suite - Basic assumptions )
  812 ( Test Suite - Constants         )
  813 ( Test Suite - Booleans          )
  814 ( Test Suite - Booleans          )
  815 ( Test Suite - Booleans          )
  816 ( Test Suite - Shifts            )
  817 ( Test Suite - Shifts            )
  818 ( Test Suite - Numeric Notation  )
  819 ( Test Suite - Comparison        )
  820 ( Test Suite - Comparison        )
  821 ( Test Suite - Comparison        )
  822 ( Test Suite - Comparison        )
  823 ( Test Suite - Comparison        )
  824 ( Test Suite - Comparison        )
  825 ( Test Suite - Comparison        )
  826 ( Test Suite - Comparison        )
  827 ( Test Suite - Comparison        )
  828 ( Test Suite - Stack Operator )
  829 
  830 
  831 
  832 
  833 
  834 
  835 
  836 
  837 
  838 
  839 
  840 
  841 
  842 
  843 
  844 
  845 
  846 
  847 
  848 
  849 
  850 
  851 
  852 
  853 
  854 
  855 
  856 
  857 
  858 
  859 
  860 
  861 
  862 
  863 
  864 
  865 
  866 
  867 
  868 
  869 
  870 
  871 
  872 
  873 
  874 
  875 
  876 
  877 
  878 
  879 
  880 
  881 
  882 
  883 
  884 
  885 
  886 
  887 
  888 
  889 ( temporary patch )
  890 
  891 
  892 
  893 
  894 
  895 
  896 
  897 
  898 
  899 
  900 ( Remy Sharp )
  901 ( Patricia Curtis )
  902 
  903 
  904 
  905 
  906 
  907 
  908 
  909 
  910 
  911 
  912 
  913 
  914 
  915 
  916 
  917 
  918 
  919 
  920 
  921 
  922 
  923 
  924 
  925 
  926 
  927 
  928 
  929 
  930 
  931 
  932 
  933 
  934 
  935 
  936 
  937 
  938 
  939 
  940 
  941 
  942 
  943 
  944 
  945 
  946 
  947 
  948 
  949 
  950 
  951 
  952 
  953 
  954 
  955 
  956 
  957 
  958 
  959 
  960 
  961 
  962 
  963 
  964 
  965 
  966 
  967 
  968 
  969 
  970 
  971 
  972 
  973 
  974 
  975 
  976 
  977 
  978 
  979 
  980 
  981 
  982 
  983 
  984 
  985 
  986 
  987 
  988 
  989 
  990 
  991 
  992 
  993 
  994 
  995 
  996 
  997 
  998 
  999 



Scr# 1 
  0 #1
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 2 
  0 #2
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 3 
  0 # -16
  1 # -15
  2 # -14
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 Another one
 15 Duplicate key on index

Scr# 4 
  0 is undefined.
  1 Stack is empty.
  2 Dictionary full.
  3 No such line.
  4 has already been defined.
  5 Invalid stream.
  6 No such block.
  7 Stack full.
  8 Old dictionary is full.
  9 Tape error.
 10 Wrong array index.
 11 Invalid floating point.
 12 Heap full.
 13 Division by zero.
 14 msg # 14
 15 msg # 15

Scr# 5 
  0 ( Error messages    from #17 to #31 )
  1 Can't be executed.
  2 Can't be compiled.
  3 Syntax error.
  4 Bad definition end.
  5 is a protected word.
  6 Aren't loading now.
  7 Forget across vocabularies.
  8 RS loading error.
  9 Cannot open stream.
 10 Error at postit time.
 11 Inconsistent fixup.
 12 Unexpected fixup/commaer.
 13 Commaer data error.
 14 Commaer wrong order.
 15 Programming error.

Scr# 6 
  0 ( Error messages    from #33 to #47 )
  1 Programming error.
  2 
  3 
  4 
  5 
  6 
  7 NextZXOS Seek error.
  8 NextZXOS Out of memory.
  9 NextZXOS Open error.
 10 NextZXOS Close error.
 11 File not found.
 12 NextZXOS DOS call error.
 13 NextZXOS Pos error.
 14 NextZXOS Read error.
 15 NextZXOS Write error.

Scr# 7 
  0 ( Error messages    from #49 to #63 )
  1 Exception raised.
  2 Incorrect result.
  3 Wrong number of results.
  4 Number of cell result before '->' does not match ...}T spec.
  5 Number of cell result before and after '->' does not match.
  6 Number of cell result after '->' below ...}T spec.
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 8 
  0 ( Print a complete error list )
  1 \ give 8 LOAD to display the error list page by page
  2 DECIMAL MARKER FORGET-THIS-TASK
  3 : LIST-A-PAGE ( n -- )
  4   DUP 1+ 16 * SWAP 16 * DO
  5     I 3 .R SPACE [CHAR] : EMIT SPACE I MESSAGE CR
  6   LOOP ;
  7 : LIST-OF-ERRORS ( -- )
  8   CR 4 0 DO I LIST-A-PAGE
  9     I 3 - IF ."   press any key..." KEY CR ENDIF
 10     ?TERMINAL IF LEAVE THEN
 11   LOOP
 12   FORGET-THIS-TASK ;
 13 \
 14 LIST-OF-ERRORS
 15 \

Scr# 9 
  0 ." Assembler. "          CR
  1 \
  2 \ Load ASSEMBLER vocabulary
  3 \
  4 NEEDS RENAME
  5 NEEDS CODE
  6 NEEDS INVERT
  7 DECIMAL 100 LOAD
  8 \
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 10 
  0 ( v-Forth 1.5 - Recompilation )
  1 \
  2 \ this screen is loaded during recompilation
  3 \
  4 10 LIST
  5 \
  6   3 F_CLOSE DROP
  7 \
  8 CR
  9 NEEDS   ASSEMBLER
 10 INCLUDE SRC/F15A.F
 11 CR
 12 
 13 
 14 
 15 

Scr# 11 
  0 ( Autoexec 1/3 )
  1 \ This is executed at first COLD start by AUTOEXEC
  2 \ Display System Info
  3 CR 7 REG@  3 AND  35   SWAP LSHIFT S>D
  4 <# # CHAR . HOLD #S #> TYPE SPACE ." MHz Z80n CPU Speed." CR
  5 S0 PAD  - U. ." bytes free in Dictionary." CR
  6 -1 HP @ - U. ." bytes free in Heap." CR
  7 CR
  8 -->
  9 \ __________________________________________________________
 10 \
 11 012345678901234567890123456789012345678901234567890123456789
 12 0    .    1    .    2    .    3    .    4    .    5    .
 13 \ Fancy 64-Columns Ruler
 14 \ __________________________________________________________
 15 

Scr# 12 
  0 ( Autoexec 2/3 )
  1 MARKER FORGET-TASK
  2 : ASK-Y/N ( -- )
  3 \ ask Y/n to continue loading Screen 3
  4   ." Autoexec says :" CR
  5   ." Do you wish to load Scr# 11 ? (Y/n) "
  6   KEY DUP EMIT
  7   UPPER
  8   [ CHAR N ] LITERAL
  9   = IF ." ok "
 10    FORGET-TASK  QUIT
 11   ELSE
 12    FORGET-TASK
 13  THEN ;
 14 ASK-Y/N --> to continue loading to next Screen
 15 

Scr# 13 
  0 ( Autoexec 3/3 )
  1 \
  2 \  NextZXOS version
  3 \
  4 CR  ." Loading the following utilities:" CR
  5 \ NEEDS    S"       \ Heap Memory Management
  6 \ NEEDS    POINTER
  7 NEEDS    WHERE    \ Line Editor
  8          NEEDS ROOM  NEEDS .PAD  NEEDS SAVE
  9 NEEDS    CASE     \ Case-Of
 10 NEEDS    SEE      \ Decompiler / Inspector
 11 NEEDS    EDIT     \ Full Screen Editor
 12 NEEDS    GREP     \ Screen Search utility
 13 NEEDS    LOCATE
 14 11 SCR !
 15 \

Scr# 14 
  0 ( Autoexec 3/3 - previous version )
  1 \
  2 \  NextZXOS version
  3 \
  4 CR  ." Loading the following utilities:" CR
  5 DECIMAL  80 LOAD  \ Heap Memory Management
  6 DECIMAL  90 LOAD  \ Line Editor
  7 DECIMAL  18 LOAD  \ Case-Of
  8 DECIMAL  20 LOAD  \ Decompiler / Inspector
  9 DECIMAL 190 LOAD  \ Full Screen Editor
 10 DECIMAL  70 LOAD  \ Screen Search utility
 11 11 SCR !
 12 \
 13 
 14 
 15 

Scr# 15 
  0 ( Autoexec 3/3 )
  1 \
  2 \  NextZXOS version
  3 \
  4 CR  ." Loading the following utilities:" CR
  5 NEEDS    S"       \ Heap Memory Management
  6 NEEDS    POINTER
  7 NEEDS    WHERE    \ Line Editor
  8 NEEDS    CASE     \ Case-Of
  9 NEEDS    SEE      \ Decompiler / Inspector
 10 NEEDS    EDITOR   \ Line Editor Vocabulary
 11 NEEDS    EDIT     \ Full Screen Editor
 12 NEEDS    GREP     \ Screen Search utility
 13 NEEDS    LOCATE
 14 11 SCR !
 15 \

Scr# 16 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 17 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 18 
  0 .( Case-of structure. )   CR
  1 \ Used in the form:
  2 \  n0 CASE  n1 OF .. ENDOF
  3 \           nz OF .. ENDOF  .. else-part
  4 \  ENDCASE
  5 : CASE ( n0 -- ) \ begin case-of structure
  6   ?COMP CSP @ !CSP 4 ; IMMEDIATE
  7 : (OF)  ( n0 nk -- ) \ run-time compiled by OF
  8   OVER = DUP IF SWAP DROP ENDIF ;
  9 : OF  ( n0 nk -- )
 10   4 ?PAIRS COMPILE (OF) COMPILE 0BRANCH HERE 0 ,
 11   5 ; IMMEDIATE
 12 : ENDOF  ( -- )
 13   5 ?PAIRS COMPILE BRANCH HERE 0 ,
 14   SWAP 2 [COMPILE] THEN 4 ; IMMEDIATE
 15 -->

Scr# 19 
  0 ( Case-Of structure  2/2 )
  1 : ENDCASE
  2   4 ?PAIRS COMPILE DROP
  3   BEGIN SP@ CSP @ -
  4   WHILE 2 [COMPILE] THEN
  5   REPEAT CSP ! ; IMMEDIATE
  6 EXIT
  7 \ Example:
  8 x CASE
  9 1 OF ... ENDOF
 10 2 OF ... ENDOF
 11 (else) ... ENDCASE
 12 
 13 
 14 
 15 

Scr# 20 
  0 .( Decompiler / Inspector. ) CR
  1 NEEDS INVV NEEDS TRUV
  2 : (DUMP)  ( a+4 a -- ) [ DECIMAL ]
  3   DO I C@ S>D <# # # #> TYPE SPACE LOOP ;
  4 : DUMP  ( a -- )
  5   BASE @ SWAP HEX DUP 64 + SWAP
  6   DO
  7     CR I S>D  <# # # # # #> TYPE  2 SPACES
  8     I 4 + I (DUMP) SPACE  I 8 + I 4 + (DUMP) SPACE
  9     I 8 + I  DO
 10       I C@ DUP 127 > IF INVV ENDIF
 11       127 AND DUP 32 < IF SPACE DROP ELSE EMIT ENDIF
 12       TRUV
 13     LOOP
 14     ?TERMINAL IF LEAVE ENDIF
 15   8 +LOOP BASE ! ; -->

Scr# 21 
  0 ( Debugger             2/6 )
  1 : .WORD >BODY NFA ID. ;
  2 : DEB-N ." Nfa: "   NFA DUP U. C@ . CR ;
  3 : DEB-C ." Cfa: "   CFA DUP U. @ U. CR ;
  4 : DEB-L ." Lfa: "   LFA DUP U. @ ID. CR ;
  5 : DEB-P ." Pfa: "   DUMP ;
  6 : DEB-LIT CELL+  DUP @ . ;
  7 : DEB-BRN DUP @ .WORD INVV DEB-LIT TRUV ;
  8 : DEB-STR DUP @ .WORD CELL+
  9   COUNT 2DUP INVV TYPE + CELL-
 10   TRUV SPACE ;
 11 -->
 12 
 13 
 14 
 15 

Scr# 22 
  0 ( Debugger             3/6 )
  1 ' : @      CONSTANT <:>
  2 ' ABORT    CONSTANT <AB>
  3 ' EXIT     CONSTANT <;S>
  4 ' (?DO)    CONSTANT <D>
  5 ' (+LOOP)  CONSTANT <+L>
  6 ' (LOOP)   CONSTANT <L>
  7 ' BRANCH   CONSTANT <B>
  8 ' 0BRANCH  CONSTANT <0B>
  9 ' LIT      CONSTANT <LIT>
 10 ' (.")     CONSTANT <.">
 11 ' QUIT     CONSTANT <Q>
 12 ' CONSTANT CONSTANT <C>
 13 ' VARIABLE CONSTANT <V>
 14 ' WARM     CONSTANT <!>
 15 -->

Scr# 23 
  0 ( Debugger             4/6 )
  1 : ?FWD DUP DUP @ U< IF INVV THEN ;
  2 : (DELOAD)
  3     CASE
  4       <D>   OF DEB-BRN ENDOF
  5       <+L>  OF DEB-BRN ENDOF
  6       <L>   OF DEB-BRN ENDOF
  7       <B>   OF DEB-BRN ENDOF
  8       <0B>  OF DEB-BRN ENDOF
  9       <LIT> OF DEB-LIT ENDOF
 10       <.">  OF DEB-STR ENDOF
 11       DUP .WORD
 12     ENDCASE
 13 ; -->
 14 
 15 

Scr# 24 
  0 ( Debugger             5/6 )
  1 : DELOAD
  2   BEGIN
  3     ?FWD DUP @
  4     (DELOAD)
  5     CELL+
  6     TRUV ?TERMINAL
  7     OVER @ <AB> = OR
  8     OVER @ <Q>  = OR
  9     OVER @ <;S> = OR
 10     OVER @ <!>  = OR
 11   UNTIL ;
 12 -->
 13 
 14 
 15 

Scr# 25 
  0 ( Debugger             6/6 )
  1 : (SEE)  ( cfa -- )
  2   BASE @ SWAP HEX CELL+
  3   DUP DEB-N  DUP DEB-L
  4   DUP DEB-C  DUP CFA @ <:> =
  5   IF
  6     DECIMAL DELOAD  DROP BASE !
  7   ELSE
  8     SWAP BASE ! DEB-P
  9   ENDIF ;
 10 \
 11 : SEE  ( -- )
 12   -FIND 0= 0 ?ERROR  .   CR (SEE) ;
 13 -->
 14 
 15 

Scr# 26 
  0 ( Stack viewer             )
  1 : DEPTH
  2   S0 @ SP@ - 2/ 1 - ;
  3 : .S  ( -- )    \ show Calc-Stack content
  4   DEPTH IF
  5     CR SP@ CELL-  S0 @
  6     CELL-  DO
  7       I @ U.
  8     -2 +LOOP
  9   ENDIF ;
 10 : DEB ( n -- )  \ show Debug n, Stack, Return-Stack content
 11   ." debug " . .S ."  -- "
 12   R0 @ RP@ 2+ ?DO
 13     I @ U.
 14   2 +LOOP ;
 15 

Scr# 27 
  0 ( Long memory dump )
  1 \ Utility to dump large intervals of memory
  2 \ usually 13 SELECT to redirect to stream #13 "output"
  3 : LDUMP  ( a1 a2 -- )
  4   SWAP DO
  5     I DUMP
  6   \ KEY
  7     ?TERMINAL IF LEAVE THEN
  8   64 +LOOP
  9 ;
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 28 
  0 ( Vocabulary viewer        )
  1 : .VOCAB   ( voc-link -- )
  2   BASE @ SWAP HEX
  3   DUP U.  CELL- CELL- NFA ID.
  4   BASE !
  5 ;
  6 : ?VOCAB   ( -- )
  7   CR ." Current "  CURRENT  @ .VOCAB
  8   CR ." Context "  CONTEXT  @ .VOCAB
  9   CR ." VocLink "  VOC-LINK @
 10   BEGIN
 11     DUP CELL- .VOCAB SPACE
 12     @ ?DUP 0=
 13   UNTIL
 14 ;
 15 

Scr# 29 
  0 ( Simple Word RENAMEr )
  1 \ old and new names have
  2 \ the same length
  3 HEX
  4 : RENAME
  5   ' >BODY NFA DUP C@ 1F AND
  6   2DUP + >R
  7   BL WORD      20 ALLOT
  8   COUNT 1F AND ROT MIN
  9   >R SWAP 1+ R>
 10   CMOVE
 11   R@ C@ 80 OR R> C!
 12   -20 ALLOT ;
 13 DECIMAL
 14 
 15 

Scr# 30 
  0 ( 2CONSTANT )
  1 : 2CONSTANT
  2   <BUILDS SWAP , , DOES>
  3   2@
  4 ;
  5 : 2VARIABLE
  6   VARIABLE , ;
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 31 
  0 ( SET-FENCE )
  1 \ Modify FENCE to prevent FORGET to clear below it.
  2 HERE FENCE !
  3 HERE HEX 1C +ORIGIN !
  4 LATEST   0C +ORIGIN !
  5 HERE HEX 1E +ORIGIN !
  6 VOC-LINK @ 20 +ORIGIN !
  7 DECIMAL
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 32 
  0 ( HIDE )
  1 \ used in the form HIDE A-WORD to prevent -FIND to find it
  2 \ patching the LFA of the definition that follows it.
  3 \ Cannot be used on the LATEST word, obviously.
  4 \
  5 \ ##  USE WITH CARE  ##
  6 \
  7 : HIDE
  8   ' >BODY LFA
  9   CONTEXT @
 10   BEGIN
 11   @ PFA LFA
 12   2DUP = OVER @ AND
 13   UNTIL
 14 ;
 15 

Scr# 33 
  0 ( USED-BY )
  1 \ search memory for a specific xt for debug purposes
  2 : USED-BY ( xt -- )
  3   HERE 0 +ORIGIN DO
  4     DUP I @ = IF I U. THEN
  5   LOOP
  6   -1 S0 @ DO
  7     DUP I @ = IF I U. THEN
  8   LOOP
  9   DROP ;
 10 HEX : EXAM FF58 EA40
 11   DO CR 2B EMIT I U.
 12   I USED-BY ?TERMINAL
 13   IF LEAVE THEN LOOP ;
 14 
 15 

Scr# 34 
  0 ( DUMP WORDS )
  1 \ Print all definitions to stream # 13
  2 : >OUTPUT 13 SELECT ;
  3 : DUMP-2-PRINTER
  4   0 HEX CONTEXT @ @
  5   BEGIN DUP PFA LFA @ DUP 0= ?TERMINAL OR UNTIL DROP
  6   BEGIN
  7     VIDEO DUP ID. >OUTPUT CR ." \  " DUP ID. CR
  8     PFA CFA CELL+ DUP DEB-N DUP DEB-L DUP DEB-C
  9     ." Pfa: " DUP U. @ U. CR
 10     DUP 0= ?TERMINAL OR CR CR
 11   UNTIL VIDEO DROP ;
 12 
 13 
 14 
 15 

Scr# 35 
  0 ( Restore AUTOEXEC )
  1 \ The following sequence restores AUTOEXEC within ABORT
  2 \ definition
  3 \
  4 \ ##  USE WITH CARE  ##
  5 \
  6 ' AUTOEXEC
  7 ' ABORT 7 CELLS +
  8 !
  9 DECIMAL 14 EMITC
 10 BYE
 11 \
 12 \ and remember Scr# 220
 13 \ to move up or down LIMIT
 14 
 15 

Scr# 36 
  0 ( RECURSE )
  1 : RECURSE ( -- )
  2   ?COMP
  3   LATEST PFA CFA , ;
  4 IMMEDIATE
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 37 
  0 ( RECURSE - GDC )
  1 NEEDS RECURSE
  2 \ here is two examples that use RECURSE
  3 : GCD ( a b -- gcd ) \ Greatest Commond Divisor between a and b
  4   ?DUP IF
  5     TUCK MOD
  6     RECURSE
  7   THEN ;
  8 : FACT1 ( n -- n  ) \ Factorial ( single precision )
  9   ?DUP IF DUP 1- RECURSE * ELSE 1 THEN ;
 10 : FACT  ( n -- d )  \ Factorial ( double precision up to 12! )
 11   1+ 1 0 ROT 1 DO      \ d
 12     SWAP I UM*         \ dL aL aH
 13     ROT  I UM*         \ aL aH bL bH
 14     ROT  0 D+ DROP     \ aL cL
 15   LOOP ;

Scr# 38 
  0 ( RND Test )
  1 : TEST
  2   0 SYS-SEED !
  3   32767 0 DO
  4     32767
  5     RND
  6     256 /MOD
  7     PLOT
  8     ?TERMINAL IF LEAVE THEN
  9   LOOP
 10 ;
 11 
 12 
 13 
 14 
 15 

Scr# 39 
  0 ( CHOOSE - Brodie )
  1 DECIMAL
  2 23670 CONSTANT SYS-SEED
  3 : RANDOM
  4   SYS-SEED @ 31421 *
  5   6927 + DUP SYS-SEED !
  6 ;
  7 : CHOOSE ( u1 -- u2 )
  8   RANDOM UM* NIP
  9 ;
 10 \
 11 : RANDOMIZE
 12   SYS-SEED ! ;
 13 EXIT
 14 
 15 

Scr# 40 
  0 .( RND ) CR
  1 DECIMAL
  2 23670 CONSTANT SYS-SEED
  3 \ gives a pseudo-random
  4 \ between 0 and n
  5 : RND ( n -- rnd(n)
  6   1+ SYS-SEED @
  7   8191 UM* \ it was U*
  8   1.  D+
  9   16381 UM/MOD
 10   DROP DUP SYS-SEED !
 11   SWAP MOD ;
 12 \
 13 : RANDOMIZE
 14   SYS-SEED ! ;
 15 EXIT

Scr# 41 
  0 .( Color and attributes  ) CR
  1 NEEDS CALL#
  2 HEX
  3 : PERM  0 1CAD CALL# DROP ;
  4 : BORDER. 2297 CALL# DROP ;
  5 DECIMAL
  6 : (COLOR)
  7   ROT AND SWAP EMITC EMITC
  8   PERM ;
  9 : INK.     16 7 (COLOR) ;
 10 : PAPER.   17 7 (COLOR) ;
 11 : FLASH.   18 1 (COLOR) ;
 12 : BRIGHT.  19 1 (COLOR) ;
 13 : INVERSE. 20 1 (COLOR) ;
 14 : OVER.    21 1 (COLOR) ;
 15 -->

Scr# 42 
  0 ( AT TAB                   )
  1 : AT.
  2   22 EMITC        SWAP
  3          EMITC EMITC ;
  4 : TAB.
  5   23 EMITC EMITC 0 EMITC ;
  6 : LVIDEO
  7   2 23659 C! 1 SELECT ;
  8 : ATTR  ( x y --- b )
  9   SWAP 32 * + 22528 + C@ ;
 10 EXIT
 11 : VIDEO
 12   2 DEVICE !
 13   1 23659 C! 2 SELECT ;
 14 
 15 

Scr# 43 
  0 ( POINT SCREEN$ )
  1 CODE  POINT  HEX
  2   E1 C, D1 C, C5 C, 454B ,
  3   CD C, 22AA , 47 C, 04 C,
  4   7E C, 07 C, 10 C, -3 C,
  5   E6 C, 01 C, 6F C, 26 C, 0 C,
  6   E5 C, E9DD , ( PSH1 )
  7 SMUDGE
  8 \
  9 CODE  SCREEN$  HEX
 10   E1 C, D1 C, C5 C, 454B ,
 11   CD C, 2538 , CD C, 2BF1 ,
 12   1A C, 6F C, 26 , C1 C,
 13   E5 C, E9DD , ( PSH1 )
 14 SMUDGE
 15 -->

Scr# 44 
  0 ( PLOT )
  1 NEEDS CALL#
  2 HEX
  3 CODE  PLOT   HEX
  4   E1 C, D1 C, C5 C,
  5   45 C, 4B C, CD C, 22E5 ,
  6   C1 C,
  7   DD C, E9 C, ( NEXT ) SMUDGE
  8 \
  9 -->
 10 : CIRCLE
 11   ROT 0 >W SWAP 0 >W 0 >W
 12   232D CALL#
 13   ;
 14 \
 15 -->

Scr# 45 
  0 ( DRAW                     )
  1 CODE  (DRAW)  HEX
  2   D1 C, E1 C, C5 C,
  3   4D C, 43 C, 5C C,
  4   CD C, 24BA ,
  5   C1 C,
  6   DD C, E9 C, ( NEXT ) SMUDGE
  7 : DRW1
  8   100 OVER +- SWAP ABS + ;
  9 : DRAW
 10   SWAP DRW1 SWAP DRW1
 11   (DRAW)
 12 ;
 13 -->
 14 
 15 

Scr# 46 
  0 ( PAINT )
  1 HEX
  2 : HIT ( x y d -- )
  3   >R
  4   BEGIN
  5    2DUP PLOT
  6    R@ + ABS 0B0 MOD
  7    2DUP POINT
  8   UNTIL
  9   R> DROP 2DROP ;
 10 : HIT2 ( x y -- )
 11   2DUP 1 HIT -1 HIT
 12   ?TERMINAL IF QUIT THEN
 13 ;
 14 -->
 15 

Scr# 47 
  0 ( PAINT )
  1 DECIMAL
  2 : HITX ( x y d -- )
  3   >R
  4   BEGIN
  5     SWAP R@ + 255 AND SWAP
  6     2DUP POINT 0=
  7   WHILE
  8     2DUP HIT2
  9   REPEAT
 10   R> DROP 2DROP
 11 ;
 12 : PAINT ( x y -- )
 13   2DUP HIT2
 14   2DUP 1 HITX -1 HITX
 15 ;

Scr# 48 
  0 ( Mr Jones' keyboard test )
  1 NEEDS ASSEMBLER
  2 CODE KEYBOARD?
  3   POP   HL|
  4   LD    A'|  L|
  5   ANDN  7    N,
  6   INC   A'|
  7   LD    H'|  A|
  8   SRL    L|
  9   SRL    L|
 10   SRL    L|
 11   LDN   A'|   5  N,
 12   SUBA   L|
 13   LD    L'|  A|
 14   LDN   A'|  HEX FE N,
 15 -->

Scr# 49 
  0 ( Mr Jones' keyboard test )
  1   HERE
  2     RRCA DEC H'|
  3   JRF   NZ'| BACK,
  4   INA   HEX FE P,
  5   HERE
  6     RRA  DEC L'|
  7   JRF   NZ'| BACK,
  8   CCF
  9   RL    L|
 10   PSH1
 11 C;
 12 DECIMAL
 13 
 14 
 15 

Scr# 50 
  0 .( BLEEP ) CR
  1 \
  2 ( n1 = {3.5M/Hz-241}/8 )
  3 ( n2 = 1000 * ms / Hz )
  4 \
  5 CODE  BLEEP  HEX
  6   E1 C, \ POP HL
  7   D1 C, \ POP DE
  8   C5 C, \ PUSH BC
  9   DD C, E5 C, \ PUSH IX
 10   CD C, 03B5 , \ CALL 03B5
 11   DD C, E1 C, \ POP IX
 12   C1 C, \ POP BC
 13   DD C, E9 C, ( NEXT )
 14 SMUDGE DECIMAL
 15 -->

Scr# 51 
  0 ( BLEEP )
  1 : BLEEP-CALC  ( ms Hz -- n1 n2 )
  2   >R R@ 1000 */
  3   3500.000 R> UM/MOD
  4   241 - 8 /
  5   SWAP DROP ;
  6 : BEEP-PITCH  ( BEEP pitch -- freq )
  7   69 SWAP -
  8   12 /MOD 14080
  9   SWAP 0 ?DO 2/ LOOP
 10   SWAP 0 ?DO 269 286 */ LOOP
 11 ;
 12 
 13 
 14 
 15 

Scr# 52 
  0 ( Pitch bend )
  1 CODE PITCH-BEND
  2   PUSH  BC|
  3   LDX   HL|  500  NN,
  4   LDN   B'|  250   N,
  5   HERE
  6     LDX   DE|    1  NN,
  7     PUSH  BC|  PUSH  HL|  PUSH  IX|
  8     CALL  949 AA,
  9     POP   IX|  POP   HL|  POP   BC|
 10     INCX  HL|
 11   DJNZ  BACK,
 12   POP   BC|
 13   NEXT C;
 14 
 15 

Scr# 53 
  0 ( KEYBOARD-TEST )
  1 : KEYBOARD-TEST
  2   BEGIN
  3     40 0 DO
  4       I KEYBOARD?
  5       IF I . CR THEN
  6     LOOP
  7     ?TERMINAL
  8   UNTIL
  9 ;
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 54 
  0 ( ?ESCAPE experiment       )
  1 CODE  ?ESCAPE
  2   HEX
  3   3E C, FE C, DB C, FE C,
  4   2F C, 5F C,
  5   3E C, F7 C, DB C, FE C,
  6   2F C,
  7   A3 C, E6 C, 01 C,
  8   26 C, 00 C, 6F C,
  9   E5 C, E9DD , ( PSH1 )
 10 SMUDGE DECIMAL EXIT
 11 : ESCAPE-TEST
 12   1000 0 DO 2E EMIT
 13     ?ESCAPE IF LEAVE THEN
 14   LOOP ;
 15 DECIMAL

Scr# 55 
  0 ( ms delay )
  1 DECIMAL NEEDS ASSEMBLER
  2 \ at 3.5MHz n ms delay
  3 CODE (ms) ( n -- )       \ 0 <= n <= 255
  4   POP  DE|               \   10 T
  5   LD   D'|  B|           \    4 T
  6   LDN  H'|  205  N,      \    7 T
  7   HERE    \ BEGIN,       \
  8     LD   B'|  H|         \    4 T
  9     HERE  NOP            \    4 T
 10     DJNZ  BACK,          \ 13/8 T : 3480 T =(4+13)*204 + 12
 11     DEC   E'|            \    4 T
 12   JRF  NZ'| BACK,        \ 12/7 T : 3500 T  ( -5 T on exit)
 13   LD   B'|  D|           \    4 T
 14   NEXT C;                \   10 T : 3500*n T + 30 T
 15 -->

Scr# 56 
  0 #1
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 57 
  0 ( FRAMES )
  1 : FRAMES ( n -- )  \ equivalent to Basic PAUSE n
  2   0 ?DO
  3     [ HEX ] 5C78 @
  4     BEGIN
  5       DUP [ HEX ] 5C78 @ -
  6     UNTIL
  7     DROP
  8   LOOP ;
  9 \
 10 : FRAMES@
 11   [ HEX ] 5C78 DUP CELL+ C@ >R @ R> ;
 12 \
 13 DECIMAL
 14 
 15 

Scr# 58 
  0 ( FRAMES 2 )
  1 : T FRAMES@ D. ;
  2 : TT 1FRAME 1FRAME
  3   FRAMES@ ROT MS FRAMES@
  4   2SWAP DMINUS D+ . . ;
  5 : TEST ( frames -- )
  6   400 18 DO
  7   I DUP . TT
  8   I 1+ DUP . TT
  9   I 2+ DUP . TT
 10   I 3 + DUP . TT
 11   CR 100 +LOOP
 12 ;
 13 
 14 
 15 

Scr# 59 
  0 ( TEST )
  1 HEX 5800
  2 CONSTANT ADDRESS
  3 20 VARIABLE DELAY
  4 : WAIT
  5   DELAY @ 0 DO 1FRAME LOOP
  6 ;
  7 : TEST1
  8   87 ADDRESS 2+ C!
  9   BEGIN
 10   00 ADDRESS C! WAIT
 11   3F ADDRESS C! WAIT
 12   ?TERMINAL
 13   UNTIL
 14 ;
 15 DECIMAL

Scr# 60 
  0 ( Interrupt Handler )
  1 HEX
  2 CODE  INT-EI
  3   FB C,                       \ ei
  4   DD C, E9 C, ( NEXT ) SMUDGE
  5 CODE  INT-DI
  6   F3 C,                       \ di
  7   DD C, E9 C, ( NEXT ) SMUDGE
  8 CODE  INT-IM1
  9   56ED ,                      \ im 1
 10   DD C, E9 C, ( NEXT ) SMUDGE
 11 CODE  INT-IM2
 12   5EED ,                      \ im 2
 13   DD C, E9 C, ( NEXT ) SMUDGE
 14 DECIMAL -->
 15 

Scr# 61 
  0 ( Interrupt Handler )
  1 HEX CODE  SETIREG
  2   E1 C,                       \ pop hl
  3   7D C,                       \ ld a,l
  4   47ED ,                      \ ld i,a
  5   DD C, E9 C, ( NEXT ) SMUDGE
  6 \
  7 : INT-OFF
  8   INT-DI
  9   0038 6364 !
 10   3F SETIREG INT-IM1
 11   INT-EI
 12 ;
 13 6302  CONSTANT INT-SAVE
 14 DECIMAL -->
 15 

Scr# 62 
  0 ( Interrupt Handler )
  1 HEX CODE  INT-RET
  2   ED C, 7B C, INT-SAVE ,      \ ld sp,(INT-SAVE)
  3   E1 C,                       \ pop hl
  4   22 C, 30 +ORIGIN ,          \ ld (RP), hl
  5   C1 C, D1 C, E1 C,           \ pop bc, de, hl
  6   D9 C,                       \ exx
  7   C1 C, D1 C, E1 C,           \ pop bc, de, hl
  8   F1 C, 08 C, F1 C,           \ pop af  ex af,af'  pop af
  9   DD C, E1 C,                 \ pop ix
 10   FB C,                       \ ei
 11   C9 C,                       \ ret
 12 SMUDGE
 13 DECIMAL -->
 14 
 15 

Scr# 63 
  0 ( Interrupt Handler )
  1 ' INT-RET                \ return handler
  2   VARIABLE  INT-W        \ word of interrupt handler
  3 ' INT-RET ,              \ followed by INT-RET
  4 \
  5 HEX
  6 CODE INT-SYNC
  7   76 C,                  \
  8   DD C, E9 C, ( NEXT ) SMUDGE
  9 -->
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 64 
  0 ( Interrupt Handler )
  1 HEX  CODE  INT-SUB
  2   FF C,                       \ rst 38h
  3   F3 C,                       \ di
  4   DD C, E5 C,                 \ push ix
  5   F5 C, 08 C, F5 C,           \ push af  ex af,af'  push af
  6   E5 C, D5 C, C5 C,           \ push hl, de, bc
  7   D9 C,                       \ exx
  8   E5 C, D5 C, C5 C,           \ push hl, de, bc
  9   \ RP
 10   2A C, 30 +ORIGIN ,          \ ld hl,(RP)
 11   E5 C,                       \ push hl
 12   \
 13   21 C, 6330 ,                \ ld hl,6330h
 14   22 C, 30 +ORIGIN ,          \ ld (RP),hl
 15 DECIMAL -->

Scr# 65 
  0 ( Interrupt Handler )
  1 HEX
  2   \ SP
  3   ED C, 73 C, INT-SAVE ,      \ ld (INT-SAVE),sp
  4   21 C, -04 ,                 \ ld hl,-04
  5   39 C, ( ADD HL,SP )         \ add hl,sp
  6   F9 C, ( LD  SP,HL  )        \ ld sp,hl
  7   \
  8   01 C, INT-W ,               \ ld bc, INT-W
  9   \
 10   DD C, 21 C,  (NEXT) ,       \ ld ix, (NEXT)
 11   DD C, E9 C, ( NEXT )        \ jp (ix)
 12   \
 13 SMUDGE
 14 DECIMAL -->
 15 

Scr# 66 
  0 ( Interrupt Handler )
  1 HEX
  2 : INT-ON
  3   63 6200 C! 6200 6201 100 CMOVE   \ setup vector table
  4   C3 6363 C!   \ jp
  5   [ ' INT-SUB >BODY ] LITERAL 6364 !
  6   INT-DI
  7   62 SETIREG INT-IM2
  8   INT-EI
  9 ;
 10 DECIMAL -->
 11 
 12 
 13 
 14 
 15 

Scr# 67 
  0 ( Interrupt Handler )
  1 -->
  2 HEX
  3 : INT-ON  ( 48K Version )
  4   [ ' INT-SUB 2+ ] LITERAL
  5   DUP INT-DI
  6   18 FFFF C!
  7   C3 FFF4 C!
  8      FFF5 !
  9   C3 FFE2 C!
 10      FFE3 !
 11   39 SETIREG \ last ROM page
 12   INT-IM2
 13   INT-EI
 14 ;
 15 

Scr# 68 
  0 ( INTERRUPT - TEST )
  1 HEX
  2 : TEST
  3   80 57FF C!
  4   5701 5700 FF  CMOVE>
  5   5700 4700 100 CMOVE
  6   4700 4F00 100 CMOVE
  7 ;
  8 DECIMAL
  9 \ -->
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 69 
  0 ( INTERRUPT )
  1 INT-OFF
  2 \ ' NOOP    INT-W !
  3   ' TEST    INT-W !
  4 INT-ON
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 70 
  0 .( Compare Utility. ) CR
  1 \ Compare two strings and return  0 if they're equal
  2 \ or  1 if s1 > s2  or  -1 if s1 < s2
  3 : COMPARE  ( a1 c1 a2 c2 -- -1|0|1 )
  4   ROT 2DUP SWAP - >R              \ a1 a2 c2 c1      \ c1-c2
  5   MIN                             \ a1 a2 min(c2,c1) \ c1-c2
  6   (COMPARE)                       \ b                \ c1-c2
  7   R> SWAP ?DUP                    \ c1-c2 b b<>0
  8   IF                              \ c1-c2 b that is not zero
  9     SWAP DROP                     \ b that is 1 or -1
 10   ELSE                            \ c1-c2
 11     1 SWAP *                      \ sign(c1-c2) or zero
 12   THEN ;                          \ n
 13 -->
 14 CREATE S1 ," Hello world!"
 15 CREATE S2 ," Hello world?"

Scr# 71 
  0 .( Search utility. ) CR
  1 : SEARCH.TRC  BLK @ 6 .R  >IN @ 6 .R ;
  2 : SEARCH.SHOW
  3   BLK @ B/SCR /MOD  DUP >R   6 .R  B/BUF * >IN @ +
  4   C/L /MOD  DUP >R           6 .R  PAD C@ 1+ -  6 .R
  5   R> R> 6 SPACES (LINE) 2/  TYPE   CR ;
  6 : SEARCH.SCR ( -- f )
  7   BL WORD COUNT
  8   PAD COUNT COMPARE ;
  9 \
 10 : LOCATE.SCR ( -- f )
 11   BL WORD @ 14849 =
 12   IF SEARCH.SCR
 13   ELSE 1 THEN ;
 14 -->
 15 : TESTX NOOP ;

Scr# 72 
  0 ( SEARCH )
  1 : SEARCH.BLK   ( b -- )
  2   BLK @ >R >IN @ >R
  3   0 >IN ! BLK !
  4   BEGIN
  5     SEARCH.SCR
  6     0= IF SEARCH.SHOW ENDIF
  7     HERE 1+ C@ 0=
  8   UNTIL
  9   R> >IN ! R> BLK !
 10 ;
 11 -->
 12 
 13 
 14 
 15 

Scr# 73 
  0 ( BSEARCH SEARCH-ALL )
  1 \ Search the following word and show result
  2 NEEDS SHOW-PROGRESS NEEDS TEXT
  3 : BSEARCH ( n m -- cccc )
  4   BL TEXT    ." ...Searching for "
  5   PAD COUNT TYPE CR
  6   ." Screen  Line  Char" CR
  7   1+ B/SCR *  SWAP B/SCR *
  8   DO
  9     I SHOW-PROGRESS
 10     I  SEARCH.BLK
 11     ?TERMINAL IF ." Stop at " I B/SCR / . LEAVE ENDIF
 12   LOOP
 13 ;
 14 : GREP       1 1000 BSEARCH ;
 15 -->

Scr# 74 
  0 ( LOCATE )
  1 : LOCATE.BLK   ( b -- )
  2   BLK @ >R >IN @ >R
  3   0 >IN !  BLK !
  4   BEGIN
  5     LOCATE.SCR
  6     0= IF CLS
  7       BLK @ B/SCR / LIST QUIT ENDIF
  8     ?TERMINAL \ ?ESCAPE
  9     IF ." Stop at " BLK ? QUIT THEN
 10     HERE 1+ C@ 0=
 11   UNTIL
 12   R> >IN ! R> BLK !
 13 ;
 14 -->
 15 

Scr# 75 
  0 ( LOCATE )
  1 NEEDS SHOW-PROGRESS
  2 : LOCATE ( -- cccc )
  3   BL TEXT
  4   2001 1 DO
  5     I SHOW-PROGRESS
  6     I LOCATE.BLK
  7   LOOP
  8   ." Not found. " ;
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 76 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 77 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 78 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 79 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 80 
  0 .( Heap Memory Management ) CR
  1 \ Convert an heap-pointer address into a real address
  2 \ between E000h and FFFFh and fit the 8K page on MMU7
  3 \ An "ha" uses 3 msb as page-number and lower bits as offset
  4 NEEDS >FAR
  5 : FAR  ( ha -- a )
  6   >FAR MMU7! ;
  7 \
  8 \ Get current Heap Pointer
  9 : HP@ ( -- ha )
 10   HP @ ;
 11 \
 12 \ like CONSTANT but return a Heap-Pointer-Address
 13 : POINTER ( ha -- ccc )
 14   <BUILDS , DOES> @ FAR ;
 15 -->

Scr# 81 
  0 ( Heap Memory Management )
  1 \ check if n bytes are available in this 8K-page in Heap
  2 \ otherwise skip HP to the beginning of next 8K-page
  3 HEX
  4 : SKIP-PAGE ( n -- )
  5   CELL+                         \ always needs 2 bytes more
  6   HP@ >FAR DROP 1FFF  AND       \ take offset only
  7   +  1FFF >                     \ check greater than a page
  8   IF
  9     [ 1FFF 1 >FAR DROP 0 >FAR DROP - / ]
 10     LITERAL HP@ OR 1+ HP !      \ HP goes to the next page
 11   THEN
 12   HP@ 0= [ DECIMAL ] 12 ?ERROR  \ out of memory
 13 ;
 14 \
 15 -->

Scr# 82 
  0 ( Heap Memory Management )
  1 \ Reserve n bytes of Heap, return heap-pointer address
  2 \ Heap is a linked-list starting from P:0002=$20:$E002
  3 \
  4 : HEAP ( n -- ha )
  5   DUP SKIP-PAGE     \ n         check 8k page boundary
  6   HP@ SWAP          \ ha  n
  7   CELL+             \ ha n+2    room for link to previous HP
  8   HP +!             \ ha        advance HP by n+2
  9   HP@ SWAP          \ hp ha
 10   TUCK              \ ha hp ha
 11   FAR !             \ ha        store previous HP
 12   CELL+             \ ha        final heap-address
 13 ;
 14 \
 15 -->

Scr# 83 
  0 ( Heap Memory Management )
  1 \ Accept a string and store it to Heap, return a
  2 \ heap-address pointer (to a counted string)
  3 \
  4 : H" ( -- ha )
  5   HP@ CELL+              \ ha
  6   [CHAR] "  WORD         \ ha a1     accept string from strm
  7   DUP C@ 1+              \ ha a1 u
  8   TUCK HEAP >FAR DROP    \ ha  u a1 a2
  9   DUP >R >FAR            \ ha  u a2
 10   ROT                    \ ha a1 a2 u
 11   CMOVE                  \ ha
 12 ;
 13 \ : C" H" DROP ;
 14 -->
 15 

Scr# 84 
  0 ( Heap Memory Management )
  1 \ immutable  string on heap
  2 : (S") R@ @ FAR COUNT R> CELL+ >R ;
  3 : S"  ( -- a n )
  4   STATE @
  5   IF
  6     COMPILE (S") H" ,
  7   ELSE
  8     H" FAR COUNT
  9   ENDIF
 10 ; IMMEDIATE
 11 \
 12 -->
 13 \
 14 : TEST_S"  S" HELLO WORLD" NOOP ;
 15 CR TEST_S" TYPE CR S" HELLO WORLD" TYPE

Scr# 85 
  0 ( S" Counted Strings in Heap )
  1 \ consume  c  and append to the string being created
  2 \ in Heap at ha
  3 \ return the same Heap-Pointer to the counted string
  4 \
  5 : +C ( ha c -- ha )
  6   OVER FAR                 \ ha c  a
  7   1 OVER CELL- +!          \ fix linked list pointer
  8   DUP C@ 1+ SWAP 2DUP      \ ha c  n  a  n  a
  9   C!                       \ ha c  n  a   :  fix length
 10   + C!                     \ ha           : store c
 11   1 HP +!                  \ ha
 12 ;
 13 -->
 14 
 15 

Scr# 86 
  0 ( S" Counted Strings in Heap )
  1 \ accept a string and store it to the being created on Heap
  2 \ appending to the existing string at "ha"
  3 \ return the same Heap-Pointer to the counted string on Heap
  4 \
  5 : +" ( ha -- ha )
  6   DUP FAR C@
  7   [CHAR] " WORD
  8   DUP C@ >R 1+
  9   HP@ FAR R@ CMOVE
 10   R@ HP +!
 11   R> +
 12   OVER FAR C!
 13   DUP FAR HP@ SWAP !
 14 ;
 15 -->

Scr# 87 
  0 ( Allocate RAM banks $20-$27  or 32-39  for string heap )
  1 : HEAP-DOS ( n -- )
  2   [ HEX ] 28 20 DO
  3     DUP  I  0  0  01BD  M_P3DOS
  4     2C ?ERROR  2DROP 2DROP
  5   LOOP DROP ;
  6 \
  7 : HEAP-INIT  2 HEAP-DOS ;
  8 : HEAP-DONE  3 HEAP-DOS ;
  9 HEAP-DONE HEAP-INIT
 10 WARNING @ 0 WARNING !
 11 : COLD HEAP-DONE COLD ; \ so COLD frees RAM first
 12 WARNING !
 13 DECIMAL
 14 
 15 

Scr# 88 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 89 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 90 
  0 .( Line editor. )         CR
  1 NEEDS INVV NEEDS TRUV -->
  2 \ See .pdf documentation.
  3 \
  4 \ Inverse/True Video
  5 : INVV ( -- )
  6   [ HEX 14 ] LITERAL EMITC
  7   1 EMITC
  8 ;
  9 : TRUV ( -- )
 10   [ HEX 14 ] LITERAL EMITC
 11   0 EMITC
 12 ;
 13 DECIMAL
 14 --> \ Continue LOADing
 15     \ on next Screen.

Scr# 91 
  0 ( Line Editor          2/6 )
  1 : TEXT ( c -- )     \ accept following text to PAD
  2   HERE C/L 1+ BLANKS WORD PAD C/L 1+ CMOVE ;
  3 : LINE ( n -- a )   \ leave address of current screen line n
  4   DUP 0 <        3 ?ERROR  \ error 3: No such line.
  5   DUP L/SCR < 0= 3 ?ERROR
  6   SCR @ (LINE) DROP ;
  7 : -MOVE ( a -- n )  \ move from a to current screen line n
  8   LINE C/L CMOVE UPDATE ;
  9 \
 10 --> \ continues to next
 11 \ Quick reference
 12 \ [ TIB ]  <->  [ PAD ]  <->   [BLOCK]
 13 \          TEXT        H  E  RE
 14 \                      D  S  INS
 15 

Scr# 92 
  0 ( Line Editor          3/6 )
  1 VOCABULARY EDITOR
  2 EDITOR DEFINITIONS
  3 : H ( n -- )        \ hold line n to PAD
  4   LINE PAD 1+ C/L DUP PAD C! CMOVE ;
  5 : E ( n -- )        \ blank line n of current screen
  6   LINE C/L BLANKS UPDATE ;
  7 : RE ( n -- )       \ replace line n using PAD content
  8   PAD 1+ SWAP -MOVE ;
  9 : D ( n -- )        \ remove line n from current screen
 10   DUP H L/SCR 1- DUP ROT ?DO I 1+ LINE I -MOVE LOOP E ;
 11 : S ( n -- )        \ shift lines >= n down by one
 12   DUP  L/SCR 1- DO  I 1- LINE  I -MOVE  -1 +LOOP E ;
 13 : INS ( n -- )      \ insert line n from PAD
 14   DUP S RE ;
 15 -->

Scr# 93 
  0 ( Line Editor          4/6 )
  1 : P ( n -- ) \ put line n
  2   126 TEXT RE ;
  3 : L ( -- ) \ list current
  4   SCR @ LIST ;
  5 : N ( -- ) \ next screen
  6   1 SCR +! L ;
  7 : B ( -- ) \ back screen
  8   -1 SCR +! L ;
  9 FORTH DEFINITIONS
 10 : BCOPY ( n1 n2 -- ) \ copy screen n1 to n2, overvriting it
 11   DUP SCR ! B/SCR * SWAP B/SCR *
 12   B/SCR 0 DO 2DUP
 13   BLOCK SWAP BLOCK B/BUF CMOVE UPDATE
 14   SWAP 1+ SWAP 1+
 15   LOOP 2DROP ;   -->

Scr# 94 
  0 ( Line Editor          5/6 )
  1 \ usually used after an error during LOAD:
  2 : WHERE ( n1 n2 -- ) \ display offending row after an error
  3   DUP B/SCR /MOD DUP SCR ! ." Screen# " DECIMAL . CR
  4   B/BUF * ROT + C/L /MOD DUP 3 .R SPACE
  5   ROT B/SCR / (LINE) -TRAILING TYPE
  6   CR 2+ SPACES [CHAR] ^ EMIT SPACE
  7 ;
  8 -->
  9 \
 10 \ quick reference
 11 [TIB] <> [PAD]  <>  [BLOCK]
 12               H E RE
 13      TEXT     D S INS
 14 
 15 

Scr# 95 
  0 ( Line Editor          6/6 )
  1 : .PAD ( -- ) \ show PAD content
  2   PAD C/L -TRAILING TYPE ;
  3 : SAVE ( -- ) \ save all modified screens flushing to disk
  4   UPDATE FLUSH ;
  5 : UNUSED ( -- n ) \ return free dictionary space
  6   SP@ PAD - ;
  7 : ROOM ( -- ) \ display room available in dictionary
  8   UNUSED U. ." bytes free." CR ;
  9 EXIT
 10 \
 11 \ omitted:
 12 : BMOVE OVER SWAP BCOPY
 13   BCLEAR ;
 14 EXIT
 15 

Scr# 96 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 97 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 98 
  0 ( Editor utility           )
  1 \ multiple BCOPY
  2 : MBCOPY ( b1 b2 n --- )
  3   FLUSH
  4   >R 2DUP > IF
  5     R> 0 DO 2DUP BCOPY
  6     1 + SWAP 1 + SWAP
  7     46 EMIT LOOP
  8   ELSE
  9     R@ + 1 - SWAP R@ + 1 - SWAP
 10     0 R> DO 2DUP BCOPY
 11     1 - SWAP 1 - SWAP
 12     46 EMIT -1 +LOOP
 13   THEN
 14   2DROP ;
 15 

Scr# 99 
  0 .( Call utility. )        CR
  1 \ CALL# ( n1 a -- n2 )
  2 \ must save BC and IX
  3 HEX
  4 CODE  CALL#  ( n1 -- n2 )
  5   E1 C, D1 C,         \ pop hl   pop de
  6   C5 C, DD C, E5 C,   \ push bc  push ix
  7   4B C, 42 C, 7B C,   \ ld a,e   ld bc,de
  8   CD C,  (NEXT) 0A + ,   \ call hl
  9   69 C, 60 C,         \ ld hl,bc
 10   DD C, E1 C, C1 C,   \ pop ix   pop bc
 11   E5 C,               \ push hl
 12   DD C, E9 C,         \ jp ix
 13   SMUDGE
 14 DECIMAL
 15 

Scr# 100 
  0 ." Assembler. "           CR
  1 \ Loads ASSEMBLER vocabulary
  2 NEEDS INVERT  NEEDS CODE  NEEDS RENAME  CR
  3 FORTH  DEFINITIONS   MARKER FORGET-ASSEMBLER \ MARKER-ASM
  4 VOCABULARY TOOLS-ASM IMMEDIATE
  5 VOCABULARY FORTH-ASM
  6 \
  7 \ DECIMAL 118 LOAD \ MMU allocation ( Seems bugged )
  8 : ASSEMBLER FORTH-ASM 1 MMU7! ; IMMEDIATE
  9 DECIMAL 101 LOAD \ tools
 10 DECIMAL 120 LOAD \ Z80
 11 DECIMAL 140 LOAD \ structure
 12 DECIMAL 160 LOAD \ Z80N
 13 DECIMAL 117 LOAD \ final CODE patch
 14 ." Done " CR EXIT
 15 

Scr# 101 
  0 .( Z80 Assembler. ) CR
  1 ASSEMBLER TOOLS-ASM DEFINITIONS
  2   DP @ LP ! HEX E080 DP !
  3 NEEDS INVERT  \ : INVERT -1 XOR ;
  4 : @+ >R R@ CELL+ R> @ ;
  5 : !+ >R R@ ! R> CELL+ ;
  6 : @- 0 CELL+ - >R R@ @ R> ;
  7 1 VARIABLE TABL1 1 ,
  8 : ROTLEFT  TABL1 + @
  9   UM* \ U*
 10   OR ;
 11 \
 12 CHAR - CONSTANT &-
 13 CHAR ~ CONSTANT &~
 14 -->
 15 

Scr# 102 
  0 ( Z80 Utility - Sys depend )
  1 \ ## : % COMPILE ' <NAME ;
  2 \ ## : % POSTPONE ' <NAME ;
  3 \ ## : %ID. ID. ;
  4 : %>BODY PFA CELL+ ;
  5 \ ## : %BODY> 0 CELL+ - NFA ;
  6 : %>CODE PFA CFA CELL+ ;
  7 \ ## : IGNORE? 1+ C@ &~ = ;
  8 : (>NEXT%) PFA LFA @ ;
  9 \ ## : VOCEND?
 10 \ ## @ FFFF AND A081 = ; \ this is the ghost word inside VOCAB
 11 \ ## : >NEXT% BEGIN (>NEXT%)
 12 \ ##   DUP 1+ C@ &- - UNTIL ;
 13 -->
 14 
 15 

Scr# 103 
  0 ( Z80 Utility - Sys depend )
  1 : STARTVOC ' ASSEMBLER 2 +
  2   CELL+ @ ;
  3 : IS-A <BUILDS
  4   0 ,
  5   DOES>
  6   @ SWAP %>CODE @ = ;
  7 : REMEMBER HERE LATEST
  8   (>NEXT%) %>BODY ! ;
  9   IMMEDIATE
 10 : CONTAINED-IN OVER AND = ;
 11 -->
 12 
 13 
 14 
 15 

Scr# 104 
  0 ( Z80 System independ. )
  1 \ 0 VARIABLE TABLE FF ,
  2 \ FFFF , FFFFFF , FFFFFFFF ,
  3 \ : FIRSTBYTES CELLS TABLE
  4 \   + @ AND ;
  5 0 VARIABLE TALLY-BI
  6 0 VARIABLE TALLY-BY
  7 0 VARIABLE TALLY-BA
  8 0 VARIABLE ISS
  9 0 VARIABLE ISL
 10 0 VARIABLE PREVIOUS
 11 : !TALLY 0 TALLY-BY !
 12  0 TALLY-BI ! 0 TALLY-BA !
 13  0 PREVIOUS ! ;
 14 -->
 15 

Scr# 105 
  0 ( Z80 System independ. )
  1 : AT-REST? TALLY-BI @ 0=
  2  TALLY-BY @ 0= AND ;
  3 : BADPAIRS? DUP 2 * AND
  4  AAAAAAAA AND ;
  5 : BAD?
  6  TALLY-BA @ BADPAIRS? ;
  7 \ ## : COMPATIBLE?
  8 \ ##  TALLY-BA @ OR BADPAIRS?
  9 \ ##  0= ;
 10 DECIMAL
 11 -->
 12 
 13 
 14 
 15 

Scr# 106 
  0 ( Z80 Generate errors )
  1 : CHECK26 AT-REST? 0=
  2   26 ?ERROR ;
  3 : CHECK27 BAD? 27 ?ERROR ;
  4 : CHECK31 2DUP SWAP
  5   CONTAINED-IN 0= 31 ?ERROR ;
  6 : CHECK33 2DUP SWAP INVERT
  7   CONTAINED-IN 0= 33 ?ERROR ;
  8 : CHECK28 2DUP AND 28 ?ERROR ;
  9 : CHECK29 2DUP OR -1 -
 10   29 ?ERROR ;
 11 : CHECK30 DUP PREVIOUS @ <
 12   30 ?ERROR DUP PREVIOUS ! ;
 13 HEX
 14 -->
 15 

Scr# 107 
  0 ( Assembler Z80 )
  1 : OR!
  2   >R R@ @ CHECK28 OR R> ! ;
  3 : OR!U >R R@ @ OR R> ! ;
  4 : AND! >R INVERT R@ @
  5   CHECK29 AND R> ! ;
  6 -->
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 108 
  0 ( Assembler Z80 )
  1 \ ## : >DATA %>BODY ;
  2 \ ## : >BI %>BODY CELL+ ;
  3 \ ## : >BY %>BODY 2 CELLS + ;
  4 \ ## : >BA %>BODY 3 CELLS + ;
  5 \ ## : >CNT %>BODY 4 CELLS + ;
  6 \ ## : >DIS %>BODY 5 CELLS ;
  7 : CORRECT,-
  8   ISL @ 1 CELLS - ALLOT ;
  9 : !POSTIT
 10   HERE ISS ! 0 PREVIOUS ! ;
 11 : TALLY:, @+ TALLY-BI !
 12   @+ TALLY-BY ! @+ TALLY-BA !
 13   @ ISL ! ;
 14 -->
 15 

Scr# 109 
  0 ( Assembler Z80 )
  1 : POSTIT CHECK26 !POSTIT
  2   HERE ISS ! @+ , TALLY:,
  3   CORRECT,- ;
  4 IS-A IS-CBPI : CBPI CHECK33
  5 <BUILDS , , , , 1 , DOES>
  6 REMEMBER CB C, POSTIT ;
  7 IS-A IS-EDPI : EDPI CHECK33
  8 <BUILDS , , , , 1 , DOES>
  9 REMEMBER ED C, POSTIT ;
 10 IS-A IS-DDPI : DDPI CHECK33
 11 <BUILDS , , , , 1 , DOES>
 12 REMEMBER DD C, POSTIT ;
 13 IS-A IS-FDPI : FDPI CHECK33
 14 <BUILDS , , , , 1 , DOES>
 15 REMEMBER FD C, POSTIT ; -->

Scr# 110 
  0 ( Assembler Z80 )
  1 IS-A IS-1PI : 1PI CHECK33
  2 <BUILDS , , , , 1 , DOES>
  3 REMEMBER POSTIT ;
  4 IS-A IS-2PI : 2PI CHECK33
  5 <BUILDS , , , , 2 , DOES>
  6 REMEMBER POSTIT ;
  7 IS-A IS-3PI : 3PI CHECK33
  8 <BUILDS , , , , 3 , DOES>
  9 REMEMBER POSTIT ;
 10 : IS-PI >R R@ IS-1PI
 11  R@ IS-2PI  R@ IS-3PI  OR OR
 12  R@ IS-CBPI R@ IS-EDPI OR OR
 13  R@ IS-DDPI R@ IS-FDPI OR OR
 14  R> DROP ;
 15 -->

Scr# 111 
  0 ( Assembler Z80 )
  1 : TALLY:|
  2   @+ TALLY-BI AND!
  3   @+ TALLY-BY OR!
  4   @  TALLY-BA OR!U ;
  5 : FIXUP> @+ ISS @ OR!
  6   TALLY:| CHECK27 ;
  7 IS-A IS-XFI : XFI CHECK31
  8 <BUILDS , , , , DOES>
  9 REMEMBER FIXUP> ;
 10 : CORRECT-R 0 CELL+ ISL @
 11 - ROTLEFT ;
 12 -->
 13 
 14 
 15 

Scr# 112 
  0 ( Assembler Z80 )
  1 : TALLY:|R @+ CORRECT-R
  2  TALLY-BI AND! @+ TALLY-BY OR!
  3  @ TALLY-BA OR!U ;
  4 : FIXUP< @+ CORRECT-R ISS
  5  @ OR! TALLY:|R CHECK27 ;
  6 IS-A IS-XFIR : XFIR CHECK31
  7 <BUILDS , , , , DOES>
  8 REMEMBER FIXUP< ;
  9 : TALLY:,, CELL+ @+ CHECK30
 10 TALLY-BY AND! @ TALLY-BA
 11 OR!U ;
 12 : COMMA @+ >R TALLY:,,
 13  CHECK27 R> EXECUTE ;
 14 -->
 15 

Scr# 113 
  0 ( Assembler Z80 )
  1 IS-A IS-COMMA
  2 : COMMAER
  3 <BUILDS , 0 , , , , , DOES>
  4 REMEMBER COMMA ;
  5 0 VARIABLE PRO-TALLY
  6   2 CELLS ALLOT
  7 : T! PRO-TALLY !+ !+ !+ DROP ;
  8 : T@ PRO-TALLY 3 CELLS +
  9   @- @- @- DROP ;
 10 -->
 11 
 12 
 13 
 14 
 15 

Scr# 114 
  0 ( Assembler Z80 )
  1 : 1FAMILY, 0 DO DUP >R T@
  2   R> 1PI OVER + LOOP
  3   DROP DROP ;
  4 : 2FAMILY, 0 DO DUP >R T@
  5   R> 2PI OVER + LOOP
  6   DROP DROP ;
  7 : 3FAMILY, 0 DO DUP >R T@
  8   R> 3PI OVER + LOOP
  9   DROP DROP ;
 10 : XFAMILY| 0 DO DUP >R T@
 11   R> XFI OVER + LOOP
 12   DROP DROP ;
 13 : XFAMILY|R 0 DO DUP >R T@
 14   R> XFIR OVER + LOOP
 15   DROP DROP ; -->

Scr# 115 
  0 ( Assembler Z80 )
  1 : CBFAMILY, 0 DO DUP >R T@
  2   R> CBPI OVER + LOOP
  3   DROP DROP ;
  4 : EDFAMILY, 0 DO DUP >R T@
  5   R> EDPI OVER + LOOP
  6   DROP DROP ;
  7 -->
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 116 
  0 ( Assembler Z80 )
  1 : DDFAMILY, 0 DO DUP >R T@
  2   R> DDPI OVER + LOOP
  3   DROP DROP ;
  4 : FDFAMILY, 0 DO DUP >R T@
  5   R> FDPI OVER + LOOP
  6   DROP DROP ;
  7 \
  8 EXIT
  9 \ stop
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 117 
  0 ( Assembler z80 )
  1 FORTH DEFINITIONS RENAME CODE MCOD
  2 : CODE ?EXEC MCOD \ previous def of CODE
  3   [COMPILE] ASSEMBLER
  4   TOOLS-ASM
  5   !TALLY !CSP ; IMMEDIATE
  6 : C;  \ Ends a CODE definition
  7   CURRENT @ CONTEXT !  ?EXEC
  8   TOOLS-ASM  CHECK26  CHECK27
  9   SMUDGE ; IMMEDIATE
 10 \
 11 ' ASSEMBLER ' ;CODE >BODY 4 CELLS + ! ( patch to ;CODE )
 12 \
 13 FORTH DEFINITIONS
 14 \
 15 ." Done" CR

Scr# 118 
  0 ( Assembler MMU config ) EXIT  seems bugged: don't use
  1 HEX 1F CONSTANT ASM-PAGE
  2 : ASM-MMU  ( n -- )
  3   DUP 1 - IF  ASM-PAGE 0 0 01BD M_P3DOS  2C ?ERROR
  4               2DROP 2DROP THEN ;
  5 : ASM-MMU-DONE 3 ASM-MMU ;
  6 : FORGET-ASSEMBLER
  7   3 ASM-MMU \ free  8K-page
  8   [ ' CODE <NAME 1+ HEX ] LITERAL
  9   4F43 OVER ! C544 SWAP CELL+ ! \ Rename CODE
 10   MARKER-ASM ;
 11 : ASSEMBLER FORTH-ASM  ASM-PAGE MMU7! ; IMMEDIATE
 12 \
 13 3 ASM-MMU
 14 2 ASM-MMU   \ Allocate MMU page 3F
 15 

Scr# 119 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 120 
  0 .( Z80 definitions. ) CR
  1 ASSEMBLER DEFINITIONS HEX
  2 TOOLS-ASM
  3 \
  4 0 1 0 800 ' C,
  5   COMMAER N,
  6 0 0 CELL+ 0 200 ' ,
  7   COMMAER NN,
  8 0 0 CELL+ 0 400 ' ,
  9   COMMAER AA,
 10 0 1 0 100 ' C,
 11   COMMAER P,
 12 0 1 0 1000 ' C,
 13   COMMAER D,
 14 -->
 15 

Scr# 121 
  0 ( Z80 ) HEX
  1 00 00 00 T!
  2 08 07 8 1FAMILY,
  3   RLCA RRCA RLA  RRA  DAA  CPL  SCF  CCF
  4 \
  5 08 00 2 1FAMILY,   NOP       EXAFAF
  6 \
  7 08 E3 4 1FAMILY,   EX(SP)HL  EXDEHL  DI  EI
  8 \
  9 00 00 238 T!
 10 08 00 8 XFAMILY|
 11    00| 08| 10| 18|
 12    20| 28| 30| 38|
 13 00 00 238 C7 1PI    RST
 14 -->
 15 \ RST 38|  DAA

Scr# 122 
  0 ( Z80 ) HEX
  1 00 00 07 T!
  2 01 00 8 XFAMILY|
  3   B|  C|    D|  E|
  4   H|  L| (HL)|  A|
  5 08 80 8 1FAMILY,
  6  ADDA ADCA SUBA SBCA
  7  ANDA XORA ORA  CPA
  8 \
  9 00 00 00 76 1PI HALT
 10 -->
 11 \ ADDA B|
 12 \ HALT
 13 
 14 
 15 

Scr# 123 
  0 ( Z80 ) HEX
  1 00 00 30 T!
  2 10 00 4 XFAMILY|
  3   BC| DE| HL| SP|
  4 01 02 2 1FAMILY,
  5   LD(X)A INCX
  6 01 09 3 1FAMILY,
  7   ADDHL  LDA(X)  DECX
  8 00 0200 30 01 1PI LDX
  9 00 00 30 30 XFI AF|
 10 00 00 30 T!
 11 04 C1 2 1FAMILY,
 12   POP PUSH
 13 -->
 14 \ LD(X)A BC|
 15 \ LDX BC| nn NN,

Scr# 124 
  0 ( Z80 immediate data )
  1 00 0100 00 T!
  2 08 D3 2 1FAMILY,
  3   OUTA  INA
  4 00 0800 00 T!
  5 08 C6 8 1FAMILY,
  6   ADDN ADCN SUBN SBCN
  7   ANDN XORN ORN  CPN
  8 00 00 00 T!
  9 10 C9 4 1FAMILY,
 10   RET EXX JPHL LDSPHL
 11 -->
 12 \ OUTA n P,   INA n P,
 13 \ ADDN n N,
 14 
 15 

Scr# 125 
  0 ( Z80 address )
  1 00 0400 00 T!
  2 08 22 4 1FAMILY,
  3   LD()HL LDHL() LD()A LDA()
  4 0A C3 2 1FAMILY,
  5   JP CALL
  6 00 00 38 T!
  7 \ LD B'| C| LD()A nn AA,
  8 08 00 8 XFAMILY|
  9   B'| C'| D'| E'|
 10   H'| L'| (HL)'| A'|
 11 01 04 2 1FAMILY,
 12   INC DEC
 13 00 00 3F 40 1PI LD
 14 00 0800 38 06 1PI LDN
 15 -->

Scr# 126 
  0 ( Z80 ) HEX
  1 00 00 138 T!
  2 08 00 8 XFAMILY|
  3   NZ|  Z|  NC|  CY|
  4   PO| PE|   P|   M|
  5 00 00 138 C0 1PI  RETF
  6 00 0400 138 T!
  7 \
  8 02 C2 2 1FAMILY,
  9  JPF CALLF
 10 -->
 11 \ JPF Z| aa AA,
 12 \ CALLF PO| aa AA,
 13 \ RETF NC|
 14 \ and CY| instead of C|
 15 

Scr# 127 
  0 ( Z80 relative jump )
  1 HEX
  2 00 1000 00 T!
  3 08 10 2 1FAMILY,
  4   DJNZ JR
  5 00 00 218 T!
  6 \
  7 \
  8 08 00 4 XFAMILY|
  9   NZ'| Z'| NC'| CY'|
 10 00 1000 218 20 1PI JRF
 11 -->
 12 \ JRF Z'| d D,
 13 \ JR d D,
 14 \ DJNZ d D,
 15 

Scr# 128 
  0 ( ED prefix )
  1 00 00 30 T!
  2 08 42 2 EDFAMILY,
  3  SBCHL  ADCHL
  4 00 0400 30 T!
  5 08 43 2 EDFAMILY,
  6   LD()X  LDX()
  7 00 00 38 T!
  8 01 40 2 EDFAMILY,
  9   IN(C)  OUT(C)
 10 -->
 11 \ SBCHL BC| ADCHL SP|
 12 \ LDX() BC| nn AA,
 13 \ LD()X SP| nn AA,
 14 \ IN(C) L'|
 15 \ OUT(C) H'|

Scr# 129 
  0 ( ED )
  1 00 00 00 T!
  2 01 44 4 EDFAMILY,
  3   NEG RETN IM0 LDIA
  4 02 4D 2 EDFAMILY,
  5   RETI LDRA
  6 01 56 2 EDFAMILY,
  7   IM1 LDAI
  8 01 5E 2 EDFAMILY,
  9   IM2 LDAR
 10 08 67 2 EDFAMILY,
 11   RRD RLD
 12 -->
 13 
 14 
 15 

Scr# 130 
  0 ( ED )
  1 00 00 00 T!
  2 01 A0 4 EDFAMILY,
  3   LDI  CPI  INI  OUTI
  4 01 A8 4 EDFAMILY,
  5   LDD  CPD  IND  OUTD
  6 01 B0 4 EDFAMILY,
  7   LDIR CPIR INIR OTIR
  8 01 B8 4 EDFAMILY,
  9   LDDR CPDR INDR OTDR
 10 -->
 11 
 12 
 13 
 14 
 15 

Scr# 131 
  0 ( CB )
  1 00 00 07 T!
  2 08 00 8 CBFAMILY,
  3   RLC  RRC  RL  RR
  4   SLA  SRA  SLL SRL
  5 00 00 43F T!
  6 40 40 3 CBFAMILY,
  7   BIT  RES  SET
  8 00 00 438 T!
  9 08 00 8 XFAMILY|
 10   0| 1| 2| 3| 4| 5| 6| 7|
 11 -->
 12 \ RLC B|
 13 \ BIT 3| B|
 14 \ RES 3| B|
 15 \ SET 3| B|

Scr# 132 
  0 ( IX IY )
  1 HEX
  2 00 00 00 T!
  3 02 E3 1 DDFAMILY,
  4   EX(SP)IX
  5 02 E3 1 FDFAMILY,
  6   EX(SP)IY
  7 \
  8 10 E9 2 DDFAMILY,
  9   JPIX  LDSPIX
 10 10 E9 2 FDFAMILY,
 11   JPIY  LDSPIY
 12 \
 13 -->
 14 \
 15 

Scr# 133 
  0 ( IX IY )
  1 HEX
  2 00 00 30 T!
  3 00 09 1 DDFAMILY, ADDIX
  4 00 09 1 FDFAMILY, ADDIY
  5 \
  6 00 0400 00 T!
  7 \
  8 08 22 2 DDFAMILY,
  9   LD()IX LDIX()
 10 08 22 2 FDFAMILY,
 11   LD()IY  LDIY()
 12 -->
 13 \ ADDIX IX|  ADDIX SP|
 14 \ LD()IY aa AA,
 15 \ LDIY() aa AA,

Scr# 134 
  0 ( IX IY )
  1 : I)
  2 HERE 1 - C@
  3 HERE 2 - C@ [ HEX ] CB - IF
  4 -1 ALLOT SWAP C, C,
  5 ELSE
  6 -2 ALLOT SWAP C, CB C, C,
  7 ENDIF ;
  8 TOOLS-ASM
  9 00 00 07 T!
 10 00 06 1 XFAMILY| (I
 11 : (IX+  (I  DD I) ;
 12 : (IY+  (I  FD I) ;
 13 TOOLS-ASM
 14 -->
 15 \ LD B'| (IY+ d )|    ADCA (IY+ d )|   SRA (IY+ d )|

Scr# 135 
  0 ( IX IY )
  1 HEX
  2 : )|
  3   HERE 1 - C@
  4   HERE 2 - C@
  5   CB = IF SWAP ENDIF
  6   HERE 1 - C! C, ;
  7 \
  8 : IXY| ( n -- )
  9  DUP HERE 2 - C@ - IF
 10   HERE 1- C@
 11   -1 ALLOT SWAP C, C,
 12  ENDIF ;
 13 TOOLS-ASM
 14 -->
 15 

Scr# 136 
  0 ( IX IY )
  1 \ INC DEC  (IX'+ d )|
  2 \ LDN  (IX'+ d )|  n N,
  3 00 00 38 T!
  4 00 30 1 XFAMILY|   (I'
  5 : (IX'+ (I' DD I) ;
  6 : (IY'+ (I' FD I) ;
  7 TOOLS-ASM
  8 \ LD(IX+ d )|  r|
  9 00 00 07 T!
 10 00 70 1 DDFAMILY, LD(IX+
 11 00 70 1 FDFAMILY, LD(IY+
 12 : )'| ' EXECUTE )| ;
 13 TOOLS-ASM
 14 -->
 15 

Scr# 137 
  0 ( IX IY )
  1 \ LDIXL A|
  2 00 00 07 T!
  3 08 60 2
  4    DDFAMILY, LDIXH LDIXL
  5 08 60 2
  6    FDFAMILY, LDIYH LDIYL
  7 -->
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 138 
  0 ( IX IY )
  1 HEX
  2 : IX| HL| DD IXY| ;
  3 : IY| HL| FD IXY| ;
  4 : IXL| L| DD IXY| ;
  5 : IXH| H| DD IXY| ;
  6 : IYL| L| FD IXY| ;
  7 : IYH| H| FD IXY| ;
  8 TOOLS-ASM
  9 \ LDX IY| nn NN,
 10 \ POP IY|  LD A'| IXL|
 11 \ DP @ U. KEY \ verify...
 12 \
 13 DECIMAL
 14 
 15 

Scr# 139 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 140 
  0 .( Z80 near structure )   CR
  1 ASSEMBLER DEFINITIONS HEX
  2 \
  3 : NEXT                     JPIX ;
  4 : PSH1           PUSH HL|  JPIX ;
  5 : PSH2 PUSH DE|  PUSH HL|  JPIX ;
  6 \
  7 : HOLDPLACE HERE 0 D, ;
  8 : DISP, OVER -
  9   1 - SWAP C! ;
 10 : BACK,
 11  HOLDPLACE SWAP DISP, ;
 12 \
 13 : | ;
 14 -->
 15 

Scr# 141 
  0 ( Z80 Near struct. )
  1 : THEN, HERE DISP, ;
  2 : ELSE, JR HOLDPLACE
  3   SWAP THEN, ;
  4 \
  5 DECIMAL
  6 EXIT
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 142 
  0 ( Z80 Near struct. )
  1 EXIT
  2 \
  3 : IF, JRF Z'|
  4   HOLDPLACE ;
  5 : -IF, JRF NZ'|
  6   HOLDPLACE ;
  7 : <IF, JRF CY'|
  8   HOLDPLACE ;
  9 : -<IF, JRF NC'|
 10   HOLDPLACE ;
 11 
 12 
 13 
 14 
 15 

Scr# 143 
  0 ( Z80 Near struct. )
  1 EXIT
  2 : BEGIN, HERE ;
  3 : UNTIL, IF, SWAP DISP, ;
  4 : -UNTIL, -IF, SWAP DISP, ;
  5 : <UNTIL, <IF, SWAP DISP, ;
  6 : -<UNTIL, -<IF, SWAP DISP, ;
  7 : WHILE, IF, ;
  8 : -WHILE, -IF, ;
  9 : <WHILE, <IF, ;
 10 : -<WHILE, -<IF, ;
 11 : REPEAT, JR HOLDPLACE
 12   ROT DISP, THEN, ;
 13 -->
 14 
 15 

Scr# 144 
  0 ( Z80 Near struct. )
  1 EXIT
  2 : DJNZ,
  3   DJNZ HOLDPLACE
  4   SWAP DISP, ;
  5 FORTH DEFINITIONS
  6 DECIMAL
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 145 
  0 ." Z80 far struct "
  1 : THEN' HERE SWAP ! ;
  2 : HOLDPLACE' HERE 0 AA, ;
  3 : IF' JPF Z| HOLDPLACE' ;
  4 : ELSE' JP HOLDPLACE
  5         SWAP THEN' ;
  6 : BEGIN' HERE ;
  7 : UNTIL' IF' DROP THEN' ;
  8 : WHILE' IF' ;
  9 : REPEAT' ELSE' DROP THEN' ;
 10 DECIMAL
 11 FORTH DEFINITIONS
 12 
 13 
 14 
 15 

Scr# 146 
  0 ( TESTING )
  1 : T?
  2  TALLY-BY ?
  3  TALLY-BI ?
  4  TALLY-BA ?
  5 ;
  6 : H?
  7  HEX
  8  HERE 8 - DUMP
  9 ;
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 147 
  0 ( 128K memory BANK! TEST )
  1 HEX
  2 \ BANKM : 5B5C
  3 : ?BANK BASE @
  4   5B5C C@ 2 BASE ! .
  5   BASE ! ;
  6 : TEST
  7   BANK!
  8   C000 @ U.
  9   10 BANK!
 10 ;
 11 
 12 
 13 
 14 
 15 

Scr# 148 
  0 ( 128K memory BANK! TEST )
  1 \ between 0 and 7
  2 \ set bank n at C000
  3 CODE BANK! ( n -- )
  4  LDAR
  5  DI
  6  EXAFAF
  7  LD   D'|   B|
  8  LD   E'|   C|
  9  POP  BC|
 10  LDX  HL|  HEX  5B5C NN,
 11  LD   A'| (HL)|
 12  ANDN HEX  F8  N,
 13  ORA   C|
 14  LDX  BC|  HEX  7FFD NN,
 15 -->

Scr# 149 
  0 ( 128K memory BANK! TEST )
  1  OUT(C) A'|
  2  LD  (HL)'|   A|
  3  LD     B'|   D|
  4  LD     C'|   E|
  5  EXAFAF
  6  JPF    PO|  HERE 3 + A,
  7  EI
  8  NEXT
  9 C;
 10 \
 11 HEX
 12 : BANK@
 13  5B5C @ 7 AND
 14 ;
 15 

Scr# 150 
  0 ( TEST )
  1 CODE TEST
  2  RLCA RRCA RLA RRA
  3  DAA CPL SCF CCF
  4  NOP EXAFAF EX(SP)HL EXDEHL
  5  DI EI HALT RET EXX
  6  JPHL LDSPHL
  7  RST 00| RST 38|
  8  ADDA B| ADCA C| SUBA D|
  9  SBCA E| ANDA H| XORA L|
 10  ORA (HL)| CPA A|
 11  LD(X)A BC| LDA(X) DE|
 12  INCX HL| DECX SP|
 13  ADDHL BC| ADDHL SP|
 14 C;
 15 -->

Scr# 151 
  0 ( TEST1 )
  1 CODE TEST1
  2  LDX  BC| 1234 NN,
  3  LDX  SP| 5678 NN,
  4  PUSH AF| POP HL|
  5  OUTA 254 P, INA 254 P,
  6  ADDN 1 N, ADCN 2 N,
  7  SUBN 3 N, SBCN 4 N,
  8  ANDN 5 N, XORN 6 N,
  9  ORN  7 N, CPN  8 N,
 10  LD()HL 1234 AA,
 11  LDHL() 1234 AA,
 12  LD()A  1234 AA,
 13  LDA()  1234 AA,
 14 C;
 15 -->

Scr# 152 
  0 ( TEST2 )
  1 CODE TEST2
  2  JP 1234 AA, CALL 1234 AA,
  3  INC B'| DEC A'|
  4  LD D'| E|  LD (HL)'| A|
  5  LDN B'| 1 N, LDN A'| 8 N,
  6  JPF Z| 1234 AA,
  7  CALLF M| 1234 AA,
  8  RETF PE|
  9  DJNZ -10 D, JR +10 D,
 10  JRF NZ'| +10 D,
 11  JRF CY'| -10 D,
 12  SBCHL DE| ADCHL SP|
 13  LDX() BC| 1234 AA,
 14  LD()X SP| 1234 AA,
 15 C; -->

Scr# 153 
  0 ( TEST3 )
  1 CODE TEST3
  2  IN(C) D'|  OUT(C) E'|
  3  NEG RETN IM0 LDIA RETI LDRA
  4  IM1 LDAI IM2 LDAR RRD RLD
  5  LDI   CPI   INI   OUTI
  6  LDD   CPD   IND   OUTD
  7  LDIR  CPIR  INIR  OTIR
  8  LDDR  CPDR  INDR  OTDR
  9  RLC B| RRC C| RL D| RR E|
 10  SLA H| SRA L| SRL (HL)|
 11  BIT 2| D|  BIT 3| E|
 12  RES 4| H|  RES 5| L|
 13  SET 6| (HL)| SET 7| A|
 14 C;
 15 EXIT

Scr# 154 
  0 ( TEST IF, THEN, )
  1 CODE TEST4
  2 BEGIN,
  3 NOP NOP NOP
  4 END,
  5 NEXT
  6 C;
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 155 
  0 \ TEST
  1 CODE TEST5
  2 INCX IX|  DECX IY|
  3 PUSH IX|  POP  IY|
  4 EX(SP)IX  JPIY
  5 LDSPIX    LDSPIY
  6 ADDIX BC| ADDIX DE|
  7 ADDIX IX| ADDIX SP|
  8 ADDIY BC| ADDIY DE|
  9 ADDIY IY| ADDIY SP|
 10 LD()IX 4 AA, LDIX() 3 AA,
 11 LD()IY 5 AA, LDIY() 6 AA,
 12 LDX IX| 7 NN,
 13 LDX IY| 8 NN,
 14 C;
 15 

Scr# 156 
  0 \ TEST6
  1 CODE TEST6
  2  ADCA (HL)|
  3  ADCA (IY+ 9 )|
  4  INC (HL)'|
  5  INC (IY'+ 9 )|
  6  LDN (HL)'|      5 N,
  7  LDN (IY'+ 9 )|  5 N,
  8  SRA  (HL)|
  9  SRA (IY+  9 )|
 10  SET 0| (HL)|
 11  SET 0| (IY+ 9 )|
 12  LDIX() 1234 AA,
 13 C;
 14 EXIT
 15 

Scr# 157 
  0 \ TEST7
  1 CODE TEST7
  2     LDX HL| 0 NN,
  3     BIT 5| (IY+ 1 )|
  4     IF, INC L'| THEN,
  5 PSH1 C;
  6 \
  7 : KEYIN
  8   BEGIN
  9   TEST7
 10   ?ESCAPE
 11   UNTIL ;
 12 
 13 
 14 
 15 

Scr# 158 
  0 \ TEST Z80N
  1 HEX CODE TEST8
  2  TESTN FF N,
  3  SWAPNIB MIRRORA
  4  LDIX LDDX LDIRX LDDRX
  5  LDWS LDPIRX
  6  OUTINB JP(C)
  7  PIXELDN PIXELAD SETAE
  8  BSLADE,B BSRADE,B BSRLDE,B
  9  BSRFDE,B BRLCDE,B
 10  MUL
 11  ADDHL,A ADDDE,A ADDBC,A
 12  ADDBC, 07654 NN,
 13  NEXTREGA 3 P,
 14  NEXTREG  3 P, 4 N,
 15  PUSHN 07654 LH,  NEXT C;

Scr# 159 
  0 \ TEST Z80N
  1 HEX CODE TEST9
  2  DECIMAL
  3  NEXTREG 87 P, 1 N,
  4  NEXTREGA 87 P,
  5 NEXT C;
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 160 
  0 .( Z80N Next extensions )
  1 ASSEMBLER DEFINITIONS HEX
  2 : <, 100 /MOD C, C, ;
  3 TOOLS-ASM
  4 0 1 0 4000 ' <, COMMAER LH,
  5 \
  6 00 0900 00 91 EDPI NEXTREG
  7 \ NEXTREG reg P, n N,
  8 00 0100 00 92 EDPI NEXTREGA
  9 \  NEXTREGA r P,
 10 00 4000 00 8A EDPI PUSHN
 11 \   PUSHN nn LH,
 12 00 0800 00 27 EDPI TESTN
 13 \  TESTN n N,
 14 -->
 15 

Scr# 161 
  0 ( Z80N Next extension )
  1 \
  2 00 00 00 T!
  3 01 23 2 EDFAMILY,
  4  SWAPNIB MIRRORA
  5 08 A4 4 EDFAMILY,
  6  LDIX LDDX LDIRX LDDRX
  7 \
  8 12 A5 2 EDFAMILY,
  9  LDWS LDPIRX
 10 08 90 2 EDFAMILY,
 11  OUTINB JP(C)
 12 01 93 3 EDFAMILY,
 13  PIXELDN PIXELAD SETAE
 14 -->
 15 

Scr# 162 
  0 ( Z80N Next extension )
  1 01 28 5 EDFAMILY,
  2  BSLADE,B BSRADE,B BSRLDE,B
  3  BSRFDE,B BRLCDE,B
  4 01 30 4 EDFAMILY,
  5  MUL
  6  ADDHL,A ADDDE,A ADDBC,A
  7 00 0200 00 T!
  8 01 34 3 EDFAMILY,
  9  ADDHL, ADDDE, ADDBC,
 10 \ ADDBC, nn NN,
 11 \
 12 FORTH DEFINITIONS DECIMAL
 13 \
 14  DP @ LP @ DP !  LP !
 15 \

Scr# 163 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 164 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 165 
  0 ( M*/ )
  1 : M*/ ( d  m  n  -- d2 )
  2   2dup xor 3 pick xor >R      \ l h m n        R: s
  3   abs >R abs >R DABS          \ l h            R: s n m
  4   swap R@ um* rot R> um*      \ l L h H        R: s n
  5   rot 0 D+                    \ l dx
  6   R@ um/mod                   \ l r1 q1
  7   rot rot                     \ q1 l r1
  8   R> um/mod                   \ q1 r2 q2       R: s
  9   nip swap                    \ q2 q1
 10   R> D+-                      \ d              R:
 11 ;
 12 
 13 
 14 
 15 

Scr# 166 
  0 ( White noise Egghead 3 )
  1 CODE WHITE-NOISE
  2  DI  PUSH BC|
  3 HERE CALL HERE AA,
  4  EI  POP  BC|  NEXT
  5 HERE SWAP 1+ !
  6 HERE LDN  E'|  250  N,
  7      LDX  HL|    0 NN,
  8 HERE PUSH DE|
  9      LDN  B'|   32  N,
 10 HERE PUSH BC|
 11      LD   A'| (HL)|
 12      INCX HL|
 13      ANDN 248 N,
 14      OUTA 254 P,
 15      LD   A'|   E|  -->

Scr# 167 
  0 ( White noise Egghead 3 )
  1      CPL
  2 HERE DEC  A'|
  3      JRF NZ'| BACK,
  4      POP  BC|
  5      DJNZ     BACK,
  6      POP  DE|
  7      LD   A'|    E|
  8      SUBN 24 N,
  9      CPN  30 N,
 10      RETF  Z|
 11      RETF CY|
 12      LD   E'|    A|
 13 -->
 14 
 15 

Scr# 168 
  0 ( White noise Egghead 3 )
  1      CPL
  2 \
  3 HERE LDN  B'| 40 N,
  4 HERE DJNZ BACK,
  5      DEC  A'|
  6      JRF NZ'| BACK,
  7      JR       BACK,
  8 C;
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 169 
  0 ( Checksum of a RAM chunk )
  1 CODE CHECKSUM ( a n -- n2 )
  2  HEX D1 C,       \   POP    DE|
  3      E1 C,       \   POP    HL|
  4      AF C,       \   XORA    A|
  5      14 C,       \   INC    D'|
  6      AE C,       \   XORA (HL)|
  7      23 C,       \   INCX   HL|
  8      1D C,       \   DEC    E'|
  9      20 C, FB C, \   JRF   NZ'|  BACK,
 10      15 C,       \   DEC    D'|
 11      20 C, F8 C, \   JRF   NZ'|  BACK,
 12      5F C,       \   LD     E'|  A|
 13      D5 C,       \   PUSH  DE|
 14      DD C, E9 C, \   NEXT  C;
 15 SMUDGE DECIMAL

Scr# 170 
  0 \ BURP
  1 \ Example
  2 : BURP
  3 [ HEX ] 7999 6000
  4 DO
  5  I HEX . I DECIMAL . CR
  6  ?TERMINAL IF QUIT THEN
  7 [ HEX ] 100
  8 +LOOP
  9 ;
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 171 
  0 ( Dump many pages )
  1 \ Dumps from a1 to a2
  2 DECIMAL
  3 : MDUMP ( a1 a2 -- )
  4  SWAP DO
  5   I DUMP
  6  64 +LOOP
  7 ;
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 172 
  0 ( NEEDS )
  1 \ check for cccc exists in vocabulary
  2 \ if it doesn't then  INCLUDE  inc/cccc.F
  3 DECIMAL
  4 \ temp filename cccc.f as counted string zero-padded
  5 CREATE   NEEDS-W     35 ALLOT   \ 32 + .F + 0x00 = len 35
  6 \ temp complete path+filename
  7 CREATE   NEEDS-FN    40 ALLOT
  8 \ constant path
  9 CREATE   NEEDS-INC   ," inc/"
 10 CREATE   NEEDS-LIB   ," lib/"
 11 -->
 12 
 13 
 14 
 15 

Scr# 173 
  0 ( NEEDS )
  1 \ Concatenate path at a and filename and include it
  2 \ No error is issued if filename doesn't exist.
  3 : NEEDS/  ( a -- )             \ a       \ has  path/
  4   COUNT TUCK                   \ n a n
  5   NEEDS-FN SWAP CMOVE          \ n       \ Path
  6   NEEDS-FN +                   \ a1+n    \ concat
  7   NEEDS-W 1+ SWAP 35 CMOVE     \         \ Filename
  8   NEEDS-FN                     \ a3
  9   PAD 1 F_OPEN                 \ fh f
 10   IF 43 MESSAGE DROP  \ just message, no fatal error
 11   ELSE F_INCLUDE      \ using filehandle
 12   ENDIF
 13 ;
 14 -->
 15 

Scr# 174 
  0 ( NEEDS )
  1 \ replace illegal characters in name with tilde ~
  2 : NEEDS-CHECK ( -- )
  3   NEEDS-W COUNT OVER + SWAP
  4   DO
  5 \   I C@ EMIT
  6     I C@ [CHAR] " =
  7     IF [CHAR] ~ I C! THEN
  8   LOOP ;
  9 -->
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 175 
  0 ( NEEDS )
  1 \ include  "path/cccc.f" if cccc is not defined
  2 \ filename cccc.f is temporary stored at NEEDS-W
  3 : NEEDS-PATH  ( a -- )
  4   -FIND 0= IF                     \ a
  5     NEEDS-W    35 ERASE           \ a
  6     HERE C@ 1+ HERE OVER          \ a n here n
  7     NEEDS-W    SWAP CMOVE         \ a n
  8     NEEDS-CHECK                   \ a n
  9     NEEDS-W  +                    \ a a1+n
 10     [ HEX 662E DECIMAL ] LITERAL  \ a a1+n ".F"
 11     SWAP !                        \ a
 12     NEEDS/                        \   (uses path passed)
 13   ELSE                            \ a cfa b
 14     DROP 2DROP                    \
 15   ENDIF ; -->

Scr# 176 
  0 ( NEEDS )
  1 \ check for cccc exists in vocabulary
  2 \ if it doesn't then  INCLUDE  inc/cccc.F
  3 \ search in inc subdirectory
  4 : NEEDS
  5   >IN @
  6   NEEDS-INC NEEDS-F        \ search in "inc/"
  7   >IN !
  8   NEEDS-LIB NEEDS-F        \ 2nd chance at "lib/"
  9 ;
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 177 
  0 ( INCLUDE ) \ study and test
  1 0 VARIABLE SOURCE-ID
  2 : INCLUDE ( -- )
  3   PAD 96 ERASE
  4   BL WORD COUNT PAD SWAP CMOVE
  5   PAD  PAD 96 +  1  F_OPEN
  6   43 ?ERROR
  7   SOURCE-ID @ >R  BLK @ >R
  8   SOURCE-ID !
  9   R> R> EXIT
 10   SOURCE-ID @ F_CLOSE DROP
 11   R> BLK ! R> SOURCE-ID !
 12 ;
 13 
 14 
 15 

Scr# 178 
  0 ( DEFER IS - EXIT UNLOOP )
  1 : UNLOOP R> R> 2DROP ;
  2 : ['] COMPILE LIT ' , ; IMMEDIATE
  3 : DEFER  ( -- cccc )
  4   <BUILDS [ ' NOOP ] LITERAL ,
  5    DOES> @ EXECUTE ; IMMEDIATE
  6 : IS ( xt -- )
  7   ' >BODY CELL+
  8   STATE @ IF
  9     COMPILE LIT , COMPILE !
 10   ELSE ! THEN ; IMMEDIATE
 11 : :NONAME ( -- xt )
 12   ?EXEC HERE [ ' ' @ ] LITERAL , !CSP [COMPILE] ]
 13 ;
 14 
 15 

Scr# 179 
  0 ( CHECK NULL               )
  1 : J RP@ 6 + @ ;
  2 : CHECKNULL
  3 #SEC 1 DO
  4 I .
  5 I BLOCK @ 2020 = IF
  6 ." WRONG " ENDIF
  7 CR
  8 ?ESCAPE IF QUIT ENDIF
  9 LOOP
 10 ;
 11 
 12 
 13 
 14 
 15 

Scr# 180 
  0 ( Fibonacci )
  1 ( n -- d )
  2 \ n must be between 0 and 46
  3 NEEDS 2OVER
  4 : FIBO ( n -- d )
  5  0. ROT
  6  ?DUP IF
  7   1- 1. ROT
  8   0 DO
  9    2SWAP 2OVER
 10    D+
 11   LOOP
 12   2SWAP 2DROP
 13  ENDIF
 14 ;
 15 

Scr# 181 
  0 ( SQRT )
  1 \ Extract square root of d (Newton method)
  2 \ 0 <= 0 < 1073741824
  3 \ n = ( n + d/n )/ 2
  4 : DSQRT ( d  -- n  )
  5   32768                     \  d n
  6   15 0 DO                   \  d
  7    >R 2DUP R@ UM/MOD        \  d r q     R: n
  8    NIP R> + 1 RSHIFT        \  d (q+n)/2
  9   LOOP
 10   NIP NIP
 11 ;
 12 : SQRT
 13   0 MSQRT
 14 ;
 15 

Scr# 182 
  0 ( Primality Test )
  1 NEEDS DSQRT
  2 : ?PRIME ( d -- f )
  3   OVER 1 AND IF
  4     2DUP DSQRT 1+          \ d  lim
  5     2 DO                   \ d
  6       2DUP I UM/MOD DROP   \ d  mod
  7       0= IF                \ d
  8         2DROP 0 0 LEAVE
  9       THEN
 10     1 I 2 > 1 AND + +LOOP OR 0= 0=
 11   ELSE DROP 2 = THEN
 12 ;
 13 : T 0 ?PRIME IF ." PRIME  " THEN ;
 14 : TT 30000  1  DO I . I T LOOP ;
 15 

Scr# 183 
  0 ( MARKER )
  1 : MARKER ( -- cccc )
  2   <BUILDS
  3    VOC-LINK @ , CURRENT @ , CONTEXT @ ,
  4    LATEST           , \ value for DP
  5    LATEST PFA LFA @ , \ value for LATEST
  6   DOES>
  7    DUP @ VOC-LINK !   CELL+
  8    DUP @ CURRENT  !   CELL+
  9    DUP @ CONTEXT  !   CELL+
 10    DUP @ DP       !   CELL+  @ CURRENT @ !
 11 ; IMMEDIATE
 12 HERE LATEST HEX .S
 13 MARKER TEST
 14 SEE TEST
 15 

Scr# 184 
  0 ( TEST )
  1 \ Given an address, compute the relative address from $2000
  2 : DOT-RELATIVE ( a1 -- a2 )
  3   HERE SWAP - [ HEX ] 2000 + \
  4 ; DECIMAL
  5 0 VARIABLE FH
  6 \ accept volatile filename at PAD
  7 : FILENAME" ( -- )  \
  8   [CHAR] " WORD COUNT    \ a+1 n
  9   TUCK OVER + 0          \ n a+1 a+n+1 0
 10   SWAP !                 \ n a+1
 11   PAD ROT 1+             \ a+1 pad n+1
 12   CMOVE ;
 13 -->
 14 
 15 

Scr# 185 
  0 ( SAVE-BYTES TEST )
  1 \ save bytes to filename held in PAD
  2 \ create new file, error if it already exists
  3 \ PAD is volatile
  4 : SAVE-BYTES ( a n -- )
  5   PAD DUP 10 - 06 F_OPEN          \ a n u f
  6   41 ?ERROR                       \ a n u
  7   DUP FH ! F_WRITE                \ m f
  8   47 ?ERROR                       \ m
  9   DROP FH @ F_CLOSE               \ f
 10   42 ?ERROR
 11 ;
 12 \ filename" prova.txt"
 13 \ PAD 64 save-bytes
 14 
 15 

Scr# 186 
  0 ( DOT example  .helloworld )
  1 create Org Assembler
  2         ldx   hl|   Here   0  NN,
  3   Here  ld    a'|   (hl)|
  4         anda   a|
  5         retf   z|
  6         rst   10|
  7         incx  hl|
  8         jr    Back,  \ to the closest Here
  9 \
 10   Org dot-relative  ," Hello, World!"  1+ swap !
 11 \
 12 Org   Here Org -    \  start-addres & length
 13 Filename" /dot/helloworld" save-bytes
 14 \
 15 

Scr# 187 
  0 ( search for AT position )
  1 \ : save-page [ hex ] E000 2000 save-bytes ;
  2 \
  3 decimal
  4 filename" L2_10_0100.bin"  16 mmu7! 01 00 AT. save-page
  5 filename" L2_10_0201.bin"  16 mmu7! 02 01 AT. save-page
  6 filename" L2_10_0302.bin"  16 mmu7! 03 02 AT. save-page
  7 filename" L2_10_0403.bin"  16 mmu7! 04 03 AT. save-page
  8 filename" L2_10_0131.bin"  16 mmu7! 01 31 AT. save-page
  9 filename" L2_10_0232.bin"  16 mmu7! 02 32 AT. save-page
 10 filename" L2_10_0333.bin"  16 mmu7! 03 33 AT. save-page
 11 filename" L2_10_0449.bin"  16 mmu7! 04 49 AT. save-page
 12 filename" L2_10_0162.bin"  16 mmu7! 01 62 AT. save-page
 13 filename" L2_10_0263.bin"  16 mmu7! 02 63 AT. save-page
 14 
 15 

Scr# 188 
  0 ( TEST )
  1 : AT. 22 EMITC SWAP EMITC EMITC ;
  2 hex
  3 : T
  4   AT.
  5   10 mmu7!
  6   FB00 PAD  100 CMOVE
  7   CLS  PAD  DUMP
  8 ;
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 189 
  0 ( TEST )
  1  123
  2  456
  3    789
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 190 
  0 .( Full Screen Editor. ) CR
  1 DECIMAL   0 VARIABLE NROW               \ current row
  2           0 VARIABLE NCOL               \ current columns
  3 : HOMEC   0 NROW ! 0 NCOL ! ;           \ cursor at home
  4 : ADDRC   ( -- a )                      \ calc cursor addr
  5   NROW @ LINE NCOL @ + ;
  6 : TO-SCR  ( row1 col1 -- col2 row2 )    \ translate xy
  7   0 + SWAP 2 + ;
  8 : AT-XY   ( col row -- )                \ set print position
  9   22 EMITC  EMITC EMITC ;               \ using standard AT
 10 : HOME 0 0 AT-XY ;                      \ cursor at home
 11 : BUZZ    7 EMIT ;                      \ sound BEL
 12 : CURC! ( c -- )    \ store chr to current screen position
 13   ADDRC  C! UPDATE ;
 14 : CURC@ ( -- c )    \ fetch chr from current screen position
 15   ADDRC  C@ ; -->

Scr# 191 
  0 ( Full Screen Editor   2/7 )
  1 NEEDS INVV NEEDS TRUV
  2 \
  3 : RULER 6 0 DO ." +----.----" LOOP ." +--" ;
  4 : UPC     NROW @  0 > IF -1  NROW +!  ELSE  BUZZ  THEN ;
  5 : DOWNC   NROW @ 15 < IF  1  NROW +!  ELSE  BUZZ  THEN ;
  6 : LEFTC   NCOL @  0 > IF -1  ELSE  UPC    63 THEN NCOL +! ;
  7 : RIGHTC  NCOL @ 63 < IF  1  ELSE  DOWNC -63 THEN NCOL +! ;
  8 : PUTPAGE ." Screen # " SCR @ . CR RULER CR
  9           L/SCR 0 DO I SCR @ (LINE) TYPE CR LOOP RULER ;
 10 : REFRESH                             \ refresh current line
 11   NROW @ SCR @  OVER 0 TO-SCR AT-XY  (LINE) TYPE ;
 12 -->
 13 
 14 
 15 

Scr# 192 
  0 ( Full Screen Editor   3/7 )
  1 : EDIT-FRAME
  2   0 19 AT-XY
  3   INVV ."  row:" TRUV 5 SPACES INVV ."  col:" TRUV 5 SPACES
  4   INVV ."  hex:" TRUV 5 SPACES INVV ."  dec:" TRUV 6 SPACES
  5   INVV ."  chr:" TRUV
  6   CR INVV ."  pad:" TRUV PAD COUNT 59 MIN TYPE
  7   0 21 AT-XY  INVV ."  cmd:" TRUV
  8   CR ." U-ndo    B-ack    D-el     I-nsert   H-old"
  9   CR ." Q-uit    N-ext    S-hift   R-eplace  P-ut hex byte"
 10   56 0 AT-XY  INVV ."   edit  " TRUV ;
 11 : EDIT-STAT CURC@
 12   25 19 AT-XY  HEX DUP 3 .R  36 19 AT-XY  DECIMAL DUP 3 .R
 13   47 19 AT-XY  32 MAX EMIT
 14   15 19 AT-XY  NCOL @  3 .R  05 19 AT-XY  NROW @      3 .R ;
 15 -->

Scr# 193 
  0 ( Full Screen Editor   4/7 )
  1 : BYTE ( -- b ) \ accept two hex digit as a byte
  2   KEY DUP EMIT 10 DIGIT DROP 4 LSHIFT
  3   KEY DUP EMIT 10 DIGIT DROP + ;
  4 : UNDO  ( -- ) \ discard changes on current Screen
  5   B/SCR 0 DO
  6     SCR @ B/SCR * I +
  7     BLOCK CELL-
  8     0 SWAP !
  9   LOOP ;
 10 HEX
 11 : DONEC             8F 26 +ORIGIN C!    \ reset cursor face
 12                     5F 28 +ORIGIN C! ;  \ reset cursor face
 13 : INITC   CURC@ BL MAX 26 +ORIGIN C!    \ change cursor face
 14                     8F 28 +ORIGIN C! ;
 15 DECIMAL -->

Scr# 194 
  0 ( Full Screen Editor   5/7 )
  1 : CMD    ( c -- )   \ handle EDIT key options
  2   6 21 AT-XY DONEC KEY UPPER BL MAX DUP EMIT
  3   CASE
  4   [CHAR] P OF BYTE CURC! ENDOF  \ put a byte at cursor
  5   [CHAR] H OF NROW @ H   ENDOF  \ copy to PAD
  6   [CHAR] S OF NROW @ S   ENDOF  \ shift down one row
  7   [CHAR] R OF NROW @ RE  ENDOF  \ replace row from PAD
  8   [CHAR] I OF NROW @ INS ENDOF  \ insert row from PAD
  9   [CHAR] D OF NROW @ D   ENDOF  \ delete row + copy to PAD
 10   [CHAR] N OF  1 SCR +! HOMEC ENDOF  \ next screen
 11   [CHAR] B OF -1 SCR +! HOMEC ENDOF  \ prev screen
 12   [CHAR] U OF UNDO BUZZ  ENDOF
 13   [CHAR] Q OF ."  ok" CR C/L 2 * SPACES
 14               0 21 AT-XY QUIT ENDOF
 15   ENDCASE 0 0 AT-XY PUTPAGE EDIT-FRAME ; -->

Scr# 195 
  0 ( Full Screen Editor   6/7 )
  1 : DELC    ( -- )    \ back-space
  2   NCOL @  0 > IF -1 NCOL +! THEN
  3   ADDRC DUP 1+ SWAP C/L NCOL @ - 1- CMOVE UPDATE
  4   BL NROW @ LINE C/L + 1- C! ;
  5 : INSC    ( -- )    \ insert blank at cursor and shift the rest
  6   ADDRC DUP 1+      C/L NCOL @ - 1- CMOVE>
  7   BL ADDRC  C!  UPDATE ;
  8 : CTRLC  ( c -- )   \ manage control keys
  9   CASE 08 OF LEFTC  ENDOF      09 OF RIGHTC ENDOF
 10        10 OF DOWNC  ENDOF      11 OF UPC    ENDOF
 11        12 OF DELC   REFRESH ENDOF
 12        13 OF DOWNC 0 NCOL ! ENDOF
 13        07 OF CMD            ENDOF
 14   ENDCASE ;
 15 -->

Scr# 196 
  0 ( Full Screen Editor   7/7 )
  1 : EDIT     ( -- )
  2   CLS HOMEC PUTPAGE EDIT-FRAME
  3   BEGIN
  4     EDIT-STAT  INITC
  5     CURC@ NROW @ NCOL @ TO-SCR  2DUP AT-XY
  6     KEY  ?TERMINAL IF DROP 0 INSC   REFRESH THEN
  7     DUP BL < IF
  8       >R AT-XY EMIT R>  CTRLC
  9     ELSE
 10       CURC! AT-XY DROP CURC@ EMIT RIGHTC
 11     THEN
 12   AGAIN  \ quit using EDIT-key + Q
 13   ;
 14 
 15 

Scr# 197 
  0 ( ON and OFF )
  1 CODE OFF
  2    XORA      A|
  3    JR    HOLDPLACE            \ resolve to HERE below
  4    SMUDGE
  5 CODE ON
  6    LDN      A'|  -1  N,
  7    HERE DISP,
  8    POP      HL|
  9    LD    (HL)'|   A|
 10    INCX     HL|
 11    LD    (HL)'|   A|
 12    NEXT  C;
 13 EXIT
 14 : ON  ( a -- ) -1 SWAP ! ;
 15 : OFF ( a -- )  0 SWAP ! ;

Scr# 198 
  0 ( \ comment )
  1 : \
  2   BLK @
  3   IF
  4     BLK @ 1 >
  5     IF
  6       >IN @ C/L MOD C/L SWAP - >IN +!
  7     ELSE
  8       B/BUF CELL- >IN !
  9     ENDIF
 10   ELSE
 11     80 >IN !
 12   ENDIF
 13 ; IMMEDIATE
 14 
 15 

Scr# 199 
  0 ( MARKER )
  1 : MARKER ( -- cccc )
  2   <BUILDS
  3    VOC-LINK @ , CURRENT @ , CONTEXT @ ,
  4    LATEST           , \ value for DP
  5    LATEST PFA LFA @ , \ value for LATEST
  6   DOES>
  7    DUP @ VOC-LINK !   CELL+
  8    DUP @ CURRENT  !   CELL+
  9    DUP @ CONTEXT  !   CELL+
 10    DUP @ DP       !   CELL+  @ CURRENT @ !
 11 ; IMMEDIATE
 12 HERE LATEST HEX .S
 13 MARKER TEST
 14 SEE TEST
 15 

Scr# 200 
  0 .( .RESET & CPU SPEED )  CR
  1 HEX
  2 : SPEED!
  3      7 243B P!
  4  3 AND 253B P!
  5 ;
  6 \
  7 \ EXIT
  8 \
  9 : .RESET
 10  2 253B P!
 11  2 243B P!
 12 ;
 13 
 14 
 15 

Scr# 201 
  0 ( DAA )
  1 HEX
  2 CODE TEST-DAA
  3  POP HL|
  4  LD A'| L|
  5  CPN 10 N,
  6  SBCN 69 N,
  7  DAA
  8  LD L'| A|
  9  PSH1
 10  C;
 11 
 12 
 13 
 14 
 15 

Scr# 202 
  0 ( PICK )
  1 CODE PICK ( n -- v-nth )
  2  POP   HL|
  3  ADDHL HL|
  4  ADDHL SP|
  5  LD    A'|  (HL)|
  6  INCX  HL|
  7  LD    H'|  (HL)|
  8  LD    L'|     A|
  9  PSH1
 10 C;
 11 
 12 
 13 
 14 
 15 

Scr# 203 
  0 ( U* )
  1 CODE U*
  2  POP DE|
  3  POP HL|
  4  PUSH BC|
  5 \
  6  LD  C'|  L|
  7  LD  B'|  H|
  8  LDX HL| 0 NN,
  9  LDN A'| DECIMAL 16 N,
 10  HERE \ BEGIN,
 11   ADDHL HL|
 12   RL E|
 13   RL D|
 14   JRF NC'| HOLDPLACE
 15 -->

Scr# 204 
  0 ( U* )
  1    ADDHL BC|
  2    JRF NC'| HOLDPLACE
  3     INCX DE|
  4    HERE DISP, \ THEN,
  5   HERE DISP, \ THEN,
  6   DEC A'|
  7  JRF NZ'| HOLDPLACE
  8  SWAP DISP, \ -UNTIL,
  9  EXDEHL
 10 \
 11  POP BC|
 12  PSH2
 13  C;
 14 
 15 

Scr# 205 
  0 ( U/   dn n -- r dq )
  1 CODE U/
  2  POP  DE| \ Divisor
  3  POP  HL| \ High
  4  EX(SP)IX \ Low
  5  PUSH BC|
  6  LD   A'|    H|
  7  LD   C'|    L|
  8  LDX  HL|    0  NN,
  9  LDN  B'| DECIMAL 32 N,
 10  HERE DUP \ BEGIN,
 11   ADDIX IX|
 12   RL     C|
 13   RLA
 14   ADCHL HL|
 15 -->

Scr# 206 
  0 ( U/ )
  1   JRF CY'| HOLDPLACE
  2    SBCHL DE|
  3    JRF NC'| HOLDPLACE
  4     ADDHL DE|
  5     ROT DJNZ HOLDPLACE
  6     SWAP DISP,
  7    SWAP ELSE,
  8     ORA A|  SBCHL DE|
  9    SWAP THEN,
 10    INC IX|
 11   THEN,
 12  DNJZ BACK,
 13 -->
 14 
 15 

Scr# 207 
  0 ( U/ )
  1  LD   D'|  A|
  2  LD   E'|  C|
  3  POP  BC|
  4  POP  IX|
  5  PUSH HL|
  6  PUSH IX|
  7  PUSH DE|
  8  NEXT
  9 C;
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 208 
  0 ( UPPER )
  1 CODE UPPER ( c1 -- c2 )
  2 POP   HL|
  3 LD A'| L|
  4 CPN HEX 61 N,
  5 JRF CY'| HOLDPLACE
  6  CPN HEX 7B N,
  7  JRF NC'| HOLDPLACE
  8   SUBN HEX 20 N,
  9  HERE DISP,
 10 HERE DISP,
 11 LD L'| A|
 12 PSH1
 13 C;
 14 DECIMAL
 15 

Scr# 209 
  0 ( "NUL" )
  1 \
  2 : X
  3   BLK @ 1 > IF
  4     1 BLK +!
  5     0 >IN  !
  6     BLK @ B/SCR 1 - AND 0=
  7     IF ?EXEC   R> DROP   ENDIF
  8   ELSE
  9      R> DROP
 10   ENDIF
 11 ; IMMEDIATE
 12 \
 13 DECIMAL 128  ' X <NAME 1+ C! \ patch
 14 \
 15 

Scr# 210 
  0 \ 1. F_GETLINE from handle( via F_READ and F_SEEK ) DECIMAL
  1 marker TASK
  2 : F_GETLINE ( a fh -- a n )
  3   DUP >R F_FGETPOS 44 ?ERROR            \ a d       \ fh
  4   ROT DUP 1+ B/BUF CELL-                \ d a a 510
  5   1- R@  F_READ 46 ?ERROR                \ d a n
  6   IF \ at least 1 chr was read          \ d a
  7     10 ENCLOSE DROP NIP SWAP            \ d b a
  8     13 ENCLOSE DROP NIP ROT MIN         \ d a m
  9   \ 0 \ 2dup + @ 2573 = if 1 else 0 then >r \ d a m f
 10     DUP >R 2SWAP R> 0 D+ R> F_SEEK ?ERROR \ a m
 11     2DUP + 0 SWAP C!
 12   ELSE
 13     R> 2SWAP 2DROP DROP 0
 14   ENDIF ; -->
 15 

Scr# 211 
  0 \ 2. include from handle
  1 : F_INCLUDE  ( fh -- )
  2   BLK @ >R  >IN @ >R  SOURCE-ID @ >R
  3   R@ IF R@ F_FGETPOS 44 ?ERROR ELSE 0 0 THEN >R >R
  4   SOURCE-ID !
  5   BEGIN
  6     1 BLOCK
  7     DUP B/BUF BLANKS
  8     1+ SOURCE-ID @ F_GETLINE       \ a n
  9     TUCK                           \ n a n
 10     2DUP +                         \ n a n a+n
 11     OVER B/BUF SWAP 2+ -           \ n a n a+n b-n-1
 12     BLANKS                         \ n a n
 13     + 1+ 0 SWAP C!                 \ n
 14 -->
 15 

Scr# 212 
  0 \ 2. include from handle
  1 \
  2   WHILE
  3     1 BLK ! 0 >IN !  INTERPRET
  4   REPEAT
  5   SOURCE-ID @  0 SOURCE-ID !  F_CLOSE 42 ?ERROR
  6   R> R> R>   DUP SOURCE-ID !
  7   IF SOURCE-ID @ F_SEEK 43 ?ERROR ELSE 2DROP THEN
  8   R> >IN !  R> BLK ! ;
  9  -->
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 213 
  0 \ 3. an INCLUDE wrapper
  1 : OPEN#    ( -- fh )  \ used in the form OPEN FFFF
  2   [CHAR] "  WORD COUNT OVER + 0 SWAP !
  3   PAD 1 F_OPEN 43 ?ERROR ;
  4 : INCLUDE
  5   OPEN# DUP F_INCLUDE F_CLOSE DROP ;
  6 EXIT
  7 \
  8 \ 5 VALUE FH
  9 \ CREATE FILENAME ," Test.f"
 10 \ FILENAME 1+ PAD 1 F_OPEN 43 ?ERROR TO FH
 11 \ FILENAME COUNT TYPE
 12 \ : G 1 BLOCK FH F_GETLINE ;
 13 \ FH F_CLOSE . CR
 14 
 15 

Scr# 214 
  0 ( NEW UM* using MUL new OP-code )
  1 CASEOFF
  2 CODE U* ( n1 n2 -- d ) \ unsigned multiply
  3  pop de|  pop hl|  push bc|
  4  ld   c'|   e|
  5  ld   b'|   d|
  6  ld   d'|   l|
  7  mul
  8  ld   a'|   e|
  9  exafaf
 10  ld   a'|   h|
 11  ld   e'|   c|
 12  ld   c'|   d|
 13 -->
 14 
 15 

Scr# 215 
  0 ( NEW UM* using MUL new OP-code )
  1  ld   d'|   h|
  2  ld   h'|   b|
  3  mul
  4  exdehl
  5  mul
  6  addhl de|
  7  ld   e'|   c|
  8  ldn  d'|   00 n,
  9  exafaf  \ saves carry flag
 10  ld   c'|   a|
 11  addhl de|
 12  exafaf \ restore carry flag
 13  ld   e'|   a|
 14  ld   d'|   b|
 15 -->

Scr# 216 
  0 ( NEW UM* using MUL new OP-code )
  1  mul
  2  ldn  a'|  00  n,
  3  adca  d|
  4  ld   d'|   a|
  5  ld   b'|   l|
  6  ld   l'|   h|
  7  ldn  h'|  00  n,
  8  addhl de|
  9  ld   d'|   b|
 10  ld   e'|   c|
 11  pop  bc|
 12  PSH2
 13 c;
 14 
 15 

Scr# 217 
  0 ( TEST )
  1 HEX
  2 : TEST
  3  FFFF 0 DO
  4   I I 1- U*
  5   I I 1- UM*
  6   DMINUS D+ AND IF I . CR QUIT THEN
  7  LOOP
  8 ;
  9 DECIMAL
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 218 
  0 ( NEW UM* using MUL new OP-code )
  1 code u* ( n1 n2 -- d )
  2  pop de|  pop hl|  push bc|
  3  ld   b'|   l|
  4  ld   c'|   e|
  5  ld   e'|   l|
  6  ld   l'|   d|
  7  push hl|
  8  ld   l'|   c|
  9  mul
 10  exdehl
 11  mul
 12  xora  a|
 13  addhl de|
 14  adca  a|
 15 -->

Scr# 219 
  0 ( NEW UM* using MUL new OP-code )
  1  ld   e'|   c|
  2  ld   d'|   b|
  3  mul
  4  ld   b'|   a|
  5  ld   c'|   h|
  6  ld   a'|   d|
  7  adda  l|
  8  ld   h'|   a|
  9  ld   l'|   e|
 10  pop  de|
 11  mul
 12  exdehl
 13  adchl bc|
 14  pop bc|  psh2  c;
 15 

Scr# 220 
  0 ( MOVE SP )
  1 ." Moving utility." CR
  2 \ Use: HEX D900 MOVE-SP
  3 \ or   HEX F840 MOVE-SP
  4 HEX
  5 : MOVE-SP ( a -- )
  6   DUP 16 +ORIGIN !
  7   DUP 12 +ORIGIN !
  8   DUP        S0  !
  9   DUP        TIB !
 10   S0 @ SP!
 11 ;
 12 DECIMAL
 13 -->
 14 
 15 

Scr# 221 
  0 ( MOVE RP )
  1 \ Use: HEX D9A0 MOVE-RP
  2 \ or   HEX F8E0 MOVE-RP
  3 HEX
  4 : MOVE-RP ( a -- )
  5   DUP R0 @ 80 -
  6   SWAP 80 - C0 CMOVE
  7   DUP 14 +ORIGIN !
  8   DUP 2E +ORIGIN !
  9   DUP         R0 !
 10 ;
 11 \
 12 DECIMAL
 13 -->
 14 
 15 

Scr# 222 
  0 ( MOVE LIMIT )
  1 \ Use: HEX E000 MOVE-LIMIT
  2 \ or   HEX FF58 MOVE-LIMIT
  3 HEX
  4 : MOVE-LIMIT ( a -- )
  5   DUP LIMIT !
  6   DUP 24 +ORIGIN !
  7   204 #BUFF * - DUP FIRST !
  8   DUP USE !
  9   DUP PREV !
 10   22 +ORIGIN !
 11 ;
 12 DECIMAL
 13 -->
 14 7 TO #BUFF
 15 

Scr# 223 
  0 ( UP AND DOWN )
  1 HEX
  2 : UP ( -- ) \ Move SP, RP, User's, Buffers to high memory
  3   FF58 MOVE-LIMIT
  4   F0E0 MOVE-RP
  5   F040 MOVE-SP
  6   EMPTY-BUFFERS ;
  7 \
  8 : DOWN ( -- ) \ Move SP, RP, User's, Buffers to low memory
  9   D0E8 MOVE-SP
 10   D188 MOVE-RP
 11   E000 MOVE-LIMIT
 12   EMPTY-BUFFERS ;
 13 DECIMAL
 14 
 15 

Scr# 224 
  0 ( 128K BANK! TEST )
  1 HEX
  2 \ BANKM : 5B5C
  3 : ?BANK BASE @
  4   5B5C C@ 2 BASE ! .
  5   BASE ! ;
  6 : TEST
  7   BANK!
  8   C000 @ U.
  9   10 BANK!
 10 ;
 11 
 12 
 13 
 14 
 15 

Scr# 225 
  0 ( ?DO LOOP )
  1 : BACK-
  2  BACK
  3  SP@ CSP @ -
  4  IF 2+ [COMPILE] THEN
  5  ENDIF
  6  ?CSP CSP !
  7 ;
  8 -->
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 226 
  0 ( ?DO LOOP )
  1 : ?DO
  2  COMPILE (?DO)
  3  CSP @ !CSP
  4  HERE 0 , 0
  5  HERE 3
  6 ; IMMEDIATE
  7 \
  8 : DO
  9  COMPILE (DO)
 10  CSP @ !CSP
 11  HERE 3
 12 ; IMMEDIATE
 13 -->
 14 
 15 

Scr# 227 
  0 ( ?DO LOOP )
  1 : LOOP
  2  3 ?PAIRS
  3  COMPILE (LOOP)
  4  BACK-
  5 ; IMMEDIATE
  6 \
  7 : +LOOP
  8  3 ?PAIRS
  9  COMPILE (+LOOP)
 10  BACK-
 11 ; IMMEDIATE
 12 
 13 
 14 
 15 

Scr# 228 
  0 ( ?DO LOOP )
  1 : TYPE
  2  OVER + SWAP
  3  ?DO
  4   I C@ EMIT
  5  LOOP
  6 ;
  7 : TEST
  8  0 0
  9  ?DO I . CR LOOP
 10 ;
 11 
 12 
 13 
 14 
 15 

Scr# 229 
  0 ( POSTPONE )
  1 DECIMAL
  2 : POSTPONE  ( -- cccc )
  3  ?COMP -FIND \ xt b f
  4  0= 0 ?ERROR
  5  192 < IF COMPILE COMPILE THEN
  6  ,
  7 ; IMMEDIATE
  8 EXIT
  9 \ test
 10 : TEST1 POSTPONE 0BRANCH HERE 0 ,
 11  2 ; IMMEDIATE
 12 : TEST2 POSTPONE 13 EMITC ;
 13 
 14 
 15 

Scr# 230 
  0 \ 0. F_GETLINE from handle( F_READ and F_SEEK )
  1 MARKER TASK DECIMAL
  2 : F_GETLINE ( a m fh -- n )
  3   >R TUCK R@ F_FGETPOS 44 ?ERROR        \ m a m d     \ R:fh
  4   2SWAP     OVER 1+ SWAP                \ m d a a+1 m
  5   R@ F_READ 46 ?ERROR                   \ m d a f
  6   IF    \ at least 1 chr was read       \ m d a
  7     10 ENCLOSE DROP NIP   SWAP          \ m d b a
  8     13 ENCLOSE DROP NIP   ROT MIN       \ m d a n
  9     DUP >R 2SWAP R> 0 D+                \ m a n d+n   \ R:fh
 10     R> F_SEEK 45 ?ERROR                 \ m a n       \ R:
 11   ELSE
 12     R> 2SWAP 2DROP DROP 0               \ m a 0
 13   ENDIF                                 \ m a n
 14   -->
 15 

Scr# 231 
  0 \ 1. include from handle
  1 \
  2   >R                                    \ m a         \ R:n
  3 \ shift one byte
  4   DUP DUP 1+ SWAP                       \ m a a+1 a
  5   R@ CMOVE                              \ m a
  6 \ zero pad
  7   2DUP +                                \ m a m+a
  8   0 SWAP CELL- !                        \ m a
  9 \ trailing blanks
 10   R@ + 1-                               \ m a+n-1
 11   SWAP R@ -                             \ a+n-1 m-n+1
 12   BLANKS                                \
 13   R>                                    \ n           \ R:
 14 ;
 15 -->

Scr# 232 
  0 \ 2. include from handle
  1 : F_INCLUDE  ( fh -- )
  2   BLK @ >R  >IN @ >R  SOURCE-ID @ >R
  3   R@ IF R@ F_FGETPOS 44 ?ERROR ELSE 0 0 THEN
  4   >R >R
  5   SOURCE-ID !
  6   BEGIN
  7     1 BLOCK B/BUF 2DUP  BLANKS
  8     SWAP 1+ SWAP CELL- SOURCE-ID @ F_GETLINE \  n
  9   \ CR 1 BLOCK OVER TYPE
 10   WHILE
 11     1 BLK ! 0 >IN !  INTERPRET
 12   REPEAT
 13   -->
 14 
 15 

Scr# 233 
  0 \ 3. include from handle
  1 \
  2   SOURCE-ID @  0 SOURCE-ID !  F_CLOSE 42 ?ERROR
  3   R> R> R>   DUP SOURCE-ID !
  4   IF SOURCE-ID @ F_SEEK 43 ?ERROR ELSE 2DROP THEN
  5   R> >IN !  R> BLK ! ;
  6 \
  7 \ : X 1 BLOCK 512 BLANKS ;
  8 \ : G 1 BLOCK 1+ 510 3 F_GETLINE ;
  9 \ : T 1 BLOCK DUMP 1 BLOCK 448 + DUMP ;
 10  -->
 11 
 12 
 13 
 14 
 15 

Scr# 234 
  0 \ 4. an INCLUDE wrapper
  1 : OPEN<    ( -- fh )  \ used in the form OPEN FFFF
  2   BL        WORD COUNT OVER + 0 SWAP !
  3   PAD 1 F_OPEN 43 ?ERROR ;
  4 : INCLUDE
  5   OPEN< DUP F_INCLUDE F_CLOSE DROP ;
  6 EXIT
  7 \
  8 \ 5 VALUE FH
  9 \ CREATE FILENAME ," Test.f"
 10 \ FILENAME 1+ PAD 1 F_OPEN 43 ?ERROR TO FH
 11 \ FILENAME COUNT TYPE
 12 \ : G 1 BLOCK FH F_GETLINE ;
 13 \ FH F_CLOSE . CR
 14 
 15 

Scr# 235 
  0 ( SM/REM and FM/MOD )
  1 : SM/REM ( d n -- n2 n3 )
  2   DUP >R ABS                \  d  un         \ ns
  3   -ROT DUP >R DABS ROT      \  ud un         \ ns ds
  4   UM/MOD                    \  ur uq         \ ns ds
  5   SWAP R@ +-                \  uq  r         \ ns ds
  6   SWAP R> R> XOR +- ;       \  r  q
  7 : FM/MOD ( d n -- n2 n3 )
  8   DUP >R SM/REM OVER DUP    \  r  q  r  r    \ ns
  9   0= 0= SWAP 0<             \  r  q  r!0 r<0
 10   R@ 0< XOR AND             \  r  q  r!0 r<0&n<0
 11   IF 1- SWAP R> + SWAP      \  r+n q-1
 12   ELSE R> DROP THEN         \  r  q
 13 ;
 14 
 15 

Scr# 236 
  0 ( Save RAM to BLOCKS )
  1 : 1K>BLOCK ( a n -- )
  2   BLOCK B/BUF CMOVE UPDATE
  3 ;
  4 : 8K>BLOCKS ( a n -- )
  5   B/SCR *
  6   16 0 DO
  7     OVER I B/BUF * +
  8     OVER I         +
  9   \ CR 2DUP DECIMAL U. HEX U.
 10     1K>BLOCK
 11   LOOP
 12   2DROP
 13 ;
 14 
 15 

Scr# 237 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 238 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 239 
  0 ( Rainbow effects )
  1 HEX  CODE  SYNC
  2  76 C,       \ halt i.e. sync with interrupt
  3  DD C, E9 C, ( NEXT ) SMUDGE
  4 : RAINBOW
  5 BEGIN
  6  SYNC
  7  40 0 DO
  8   8 0 DO
  9    I FFFE P!
 10   LOOP
 11  LOOP
 12  ?TERMINAL
 13 UNTIL
 14 ;
 15 DECIMAL

Scr# 240 
  0 ( FIND )
  1 : (FOUND) ( xt b -- ) ROT DROP 192 < IF -1 ELSE 1 THEN ;
  2 : FIND  ( a -- a 0  |  xt 1  |  xt -1  )
  3   DUP CONTEXT @ @ (FIND) IF (FOUND) ELSE
  4   DUP LATEST      (FIND) IF (FOUND) ELSE
  5   THEN THEN ;
  6 EXIT
  7 \ LARGE LETTER F
  8 : STAR   42 EMIT ;
  9 : STARS   0 DO STAR LOOP ;
 10 : MARGIN CR 15 SPACES ;
 11 : BLIP   MARGIN STAR ;
 12 : BAR    MARGIN 5 STARS ;
 13 : F      BAR BLIP BAR
 14          BLIP BLIP CR ;
 15 F

Scr# 241 
  0 ( Square example )
  1 0 variable board 7 allot
  2 : square ( square# -- addr ) board + ;
  3 : clear  board 9 erase ; clear
  4 : bar    ." | " ;
  5 : dashes cr 9 0 do [char] - emit loop cr ;
  6 : .box ( square# -- )
  7   square c@  dup 0= if 2 spaces
  8     else dup 1 = if ." X " else ." O "
  9     then then drop ;
 10 : display ( -- )
 11   cr 9 0 do i if i 3 mod 0 = if dashes else bar then then
 12   i .box loop cr quit ;
 13 : play  1- 0 max 8 min square c! ;
 14 : x! ( square# -- )  1 swap play display ;
 15 : o! ( square# -- ) -1 swap play display ;

Scr# 242 
  0 ( CUBES )
  1 : CUBE ( n  -- d  )
  2   >R R@ ABS DUP UM*      \ u1 u2
  3   R@ ABS UM* DROP 0 SWAP \ u1 ud2
  4   ROT R@ ABS UM*         \ ud2 ud1
  5   D+ R> D+-  ;           \ d
  6 0 VARIABLE %CUBE 145 4 * 2+ ALLOT
  7 : %CUBE# 2* 2* %CUBE + ; \ address of cube
  8 : BUILD%CUBE 144 0 DO I CUBE I %CUBE# 2! LOOP ; BUILD%CUBE
  9 NEEDS J
 10 NEEDS K
 11 -->
 12 : J RP@ 6 + @ ;
 13 : K RP@ 10 + @ ;
 14 -->
 15 

Scr# 243 
  0 ( CUBES )
  1 NEEDS 2OVER
  2 : ISCUBE? ( d -- n tf | ff )
  3   ABS DMINUS
  4   144 0 DO
  5     I %CUBE# 2@ 2OVER D+ OR 0=
  6     IF 2DROP 0 I  LEAVE THEN
  7   LOOP NIP
  8   DUP 0< IF DROP 0 ELSE 1 THEN
  9 ;
 10 -->
 11 
 12 
 13 
 14 
 15 

Scr# 244 
  0 ( CUBES )
  1 : CUBES
  2   100 1 DO
  3     100 I DO
  4       100 I DO
  5         I %CUBE# 2@    J %CUBE# 2@ D+ K %CUBE# 2@ D+
  6         ISCUBE? IF
  7           CR K . J . I . SPACE .
  8         THEN
  9       LOOP
 10     LOOP
 11   LOOP
 12 ;
 13 
 14 
 15 

Scr# 245 
  0 ( Vectored execution )
  1 MARKER TASK                          needs [']
  2 : hello ." hello " ;
  3 : goodbye ." goodbye " ;
  4 0 variable 'aloha
  5 : aloha 'aloha @ execute ;
  6 
  7 ' hello 'aloha !
  8 
  9 : say  ' 'aloha ! ;
 10 : coming  ['] hello 'aloha ! ;
 11 : going ['] goodbye 'aloha ! ;
 12 
 13 
 14 
 15 

Scr# 246 
  0 ( Buzzphrases Generator -- ver 1. )
  1 needs choose
  2 : buzzword  ( n -- )
  3   10 choose 247 (line) drop
  4   + 20 -trailing type ;
  5 : 1adj    0 buzzword ;
  6 : 2adj   20 buzzword ;
  7 : noun   40 buzzword ;
  8 : phrase    1adj space 2adj space noun space ;
  9 : paragraph
 10   cr  ." by using "  phrase  cr ." coordinated with "
 11   phrase  ." it is possible" CR ." for even the most "
 12   phrase  cr  ." to function as "
 13   phrase  cr  ." within the constraint of "
 14   phrase  ." ." ;
 15 \ paragraph

Scr# 247 
  0 integrated          management          criteria
  1 total               organization        flexibility
  2 systematized        monitored           capability
  3 parallel            reciprocal          mobility
  4 functional          digital             programming
  5 responsive          logistical          concepts
  6 optimal             transitional        time phasing
  7 synchronized        incremental         projections
  8 compatible          third generation    hardware
  9 qualified           policy              through-put
 10 partial             decision            engineering
 11 
 12 
 13 
 14 
 15 

Scr# 248 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 249 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 250 
  0 \ BLOCK-SHIFT
  1 \ change line 3
  2 : BLOCK-SHIFT
  3   99 118
  4  DO
  5  I . ." TO " I 1+ . CR
  6  I I 1+ BCOPY
  7  ?TERMINAL IF LEAVE THEN
  8  -1
  9  +LOOP
 10 ;
 11 
 12 
 13 
 14 
 15 

Scr# 251 
  0 ( block move reorder )
  1 \ Utility used while
  2 \ reordering all screens
  3 DECIMAL  3 LOAD
  4 DECIMAL 41 LOAD
  5 : BLOCK-SHIFT
  6  CLS
  7  350 1 DO
  8   0. AT. I . SPACE
  9   I I 10000 +
 10   BCOPY
 11   ?TERMINAL IF LEAVE THEN
 12  LOOP
 13 ;
 14 
 15 

Scr# 252 
  0 \ Print all blocsks to #13
  1 \ The "blocks2txt.pl" Perl script does the same faster
  2 : >OUTPUT 13
  3   DUP DEVICE ! SELECT ;
  4 : PRINT-ALL-BLOCKS
  5   >OUTPUT
  6   ." This list is produced via Scr# 252 " CR CR
  7   1 1000 INDEX CR CR
  8   1001 1 DO
  9     VIDEO I 5 .R
 10     I BLOCK >OUTPUT I LIST CR
 11     VIDEO 5 0 DO 8 EMITC LOOP
 12     ?TERMINAL IF LEAVE THEN
 13   LOOP
 14   VIDEO CR ;
 15 

Scr# 253 
  0 ( INITIALIZE-MMC )
  1 \ this erases blocks from
  2 \ # 302 up
  3 EXIT STOP STOP
  4 : INITIALIZE-MMC
  5 #SEC
  6 302
  7 DO I . I BCLEAR
  8 ?TERMINAL IF LEAVE THEN
  9 LOOP
 10 ;
 11 
 12 
 13 
 14 
 15 

Scr# 254 
  0 ( MICRODRIVE CARTRIDGE LAST BLOCK )
  1 \ At least one block should
  2 \ be unusable due to the
  3 \ ring-junction on the tape
  4 \ so this block shouldn't be
  5 \ available.
  6 \ More: Real cartridges can
  7 \ have up to 85-90 K
  8 \ This means 170-180 blocks.
  9 \
 10 \ Old version of this system uses Micro-
 11 \ drives #2 to #8 to stor
 12 \ 889 KBytes of Screen Data
 13 \
 14 \ See Screen # 1778
 15 

Scr# 255 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 256 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 257 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 258 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 259 
  0 \ Forth Application Tecniques - 5.1.1
  1 MARKER THAT
  2 : I'M
  3   BL WORD
  4   COUNT TYPE CR
  5 ;
  6 : MEET
  7   ." HI " I'M ;
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 260 
  0 ( TRACE )
  1 \
  2 \ tracer word
  3 \
  4 ' NOOP   VARIABLE TRACER
  5 ' NOOP , \ patched to TR-EXIT  on scr# 262
  6 \
  7 \ saved Instruction Pointer (BC register)
  8 \
  9 ' QUIT >BODY VARIABLE TR-IP
 10 R0 @         VARIABLE TR-RP
 11 S0 @         VARIABLE TR-SP
 12 0            VARIABLE TR-X
 13 0            VARIABLE TR-Y
 14 1            VARIABLE TR-MMU
 15 -->

Scr# 261 
  0 ( TRACE )
  1 HEX CODE TROFF                \ disable tracing
  2   DD C, 21 C,  (NEXT) ,       \ ld ix, (NEXT)
  3   DD C, E9 C,                 \ jpix
  4   SMUDGE
  5 \
  6 : AT@ ( -- row col )
  7   MMU7@ >R  10 MMU7!
  8 \ FB23  @  FB21  @  FB2D  @
  9   FB22 C@ 8 /       FB24 C@
 10   R> MMU7! ;
 11 -->
 12 : AT! ( col row -- )
 13   MMU7@ >R  10 MMU7!
 14   FB2D  !  FB21  !  FB23  !
 15   R> MMU7! ;

Scr# 262 
  0 ( TRACE )
  1 HEX CODE TR-ENTER
  2   ED C, 73 C, TR-SP  ,    \ ld (TR-SP),sp     ; save SP
  3   ED C, 43 C, TR-IP  ,    \ ld (TR-IP),bc     ; save BC (IP)
  4   2A C, 30 +ORIGIN   ,    \ ld hl,(RP)        ; save RP
  5   22 C,       TR-RP  ,    \ ld (TR-RP),hl
  6 \
  7   01 C,      TRACER  ,    \ ld bc,TRACER      ; goto tracer
  8   DD C, 21 C, (NEXT) ,    \ ld ix,(NEXT)      ; disable trc
  9   DD C, E9 C,             \ jp (ix)
 10   SMUDGE
 11 \
 12 : AT. 16 EMITC SWAP EMITC EMITC ;
 13 -->
 14 
 15 

Scr# 263 
  0 ( TRACE )
  1 HEX CODE TR-EXIT
  2   ED C, 7B C, TR-SP  ,            \ ld sp,(TR-SP)
  3   ED C, 4B C, TR-IP  ,            \ ld bc,(TR-IP)
  4   2A C,       TR-RP  ,            \ ld hl,(TR-RP)
  5   22 C, 30 +ORIGIN   ,            \ ld (RP),hl
  6 \
  7   DD C, 21 C, ' TR-ENTER >BODY ,  \ ld ix, TR-ENTER->BODY
  8   C3 C, (NEXT) ,                  \ jp (NEXT)
  9   SMUDGE
 10   ' TR-EXIT   TRACER CELL+ !      \ patch to TRACER
 11 \
 12 -->
 13 
 14 
 15 

Scr# 264 
  0 ( TRACE )
  1 HEX CODE TRON                     \ Restore tracing
  2   DD C, 21 C, ' TR-ENTER  >BODY , \ ld ix, TR-ENTER->BODY
  3   C3 C, (NEXT) ,                  \ jp (NEXT)
  4   SMUDGE
  5 \
  6 : -SPACES
  7   1F AND
  8   0 DO 8 EMITC LOOP ;
  9 \
 10 -->
 11 
 12 
 13 
 14 
 15 

Scr# 265 
  0 ( TRACE )
  1 NEEDS INVV NEEDS TRUV NEEDS .WORD
  2 TROFF DECIMAL
  3 : TRACE
  4   14 SELECT 0 0 AT. INVV       BASE @ HEX
  5 \ TR-RP @ CELL- R0 @ DO I U. I @ CELL- @ DUP U. .WORD
  6 \ 32 SPACES CR  -2 +LOOP 5 SPACES
  7 \ TR-IP @ @ DUP U. .WORD CR
  8 \ CR .S
  9   ?TERMINAL IF TROFF QUIT THEN
 10   BASE ! DEVICE @ SELECT ;
 11 ' TRACE TRACER !
 12 \ ' NOOP  TRACER !
 13 
 14 
 15 

Scr# 266 
  0 ( TEST )
  1 MARKER TASK
  2 : TEST
  3   22 0 DO
  4     I 33 AT. AT@
  5     I 0 AT. I 3 DECIMAL .R SPACE
  6   \ 8 / 3 .R SPACE
  7     HEX U. U.
  8   LOOP DECIMAL ;
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 267 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 268 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 269 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 270 
  0 ( THROW - CATCH )
  1 MARKER EXCEPTION-TASK
  2 \
  3 \ HEX 46 USER HANDLER
  4 0 HANDLER !
  5 \
  6 -->
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 271 
  0 ( THROW - CATCH )
  1 : CATCH ( xt -- n | ff )
  2   SP@       >R           \ xt   save data stack pointer
  3   HANDLER @ >R           \ xt   and previous handler
  4   RP@ HANDLER !          \ xt   set current handler
  5   EXECUTE                \      execute returns if no THROW
  6   R> HANDLER !           \      restore previous handler
  7   R> DROP                \      discard saved data stack ptr
  8   0                      \ ff
  9 ;
 10 -->
 11 
 12 
 13 
 14 
 15 

Scr# 272 
  0 ( THROW - CATCH )
  1 : THROW ( ... n -- ... n )
  2   ?DUP IF                \ n       0 THROW is no-op
  3     HANDLER @ ?DUP IF    \ n       there was a CATCH to
  4       RP!                \ n       restore prev return stack
  5       R> HANDLER !       \ n       restore prev handler
  6       R> SWAP >R         \ sp      n on return stack
  7       SP! DROP R>        \ n       restore stack
  8       \ Return to the caller of CATCH because return
  9       \ stack is restored to the state that existed
 10       \ when CATCH began execution
 11     ELSE
 12       ERROR              \         default error handler
 13     THEN
 14   THEN
 15 ;

Scr# 273 
  0 ( THROW - CATCH )
  1 NEEDS ['] DECIMAL
  2 : could-fail ( -- c )
  3   KEY DUP [CHAR] Q = IF 49 THROW THEN ;
  4 : do-it ( a b -- c ) 2DROP could-fail ;
  5 : try-it ( -- )
  6   1 2 ['] do-it CATCH IF
  7     ( x1 x2 ) 2DROP ." There was an exception" CR
  8   ELSE ." The character was " EMIT CR
  9   THEN
 10 ;
 11 : retry-it ( -- )
 12   BEGIN 1 2 ['] do-it CATCH WHILE
 13     ( x1 x2 ) 2DROP ." Exception, keep trying" CR
 14   REPEAT ." The character was " EMIT CR
 15 ;

Scr# 274 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 275 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 276 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 277 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 278 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 279 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 280 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 281 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 282 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 283 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 284 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 285 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 286 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 287 
  0 ( GREY-SCREEN example )
  1 HEX
  2 CODE GREY-SCREEN
  3  PUSH BC|
  4  LDX  HL|  4000  NN,
  5  LDX  DE|  AA55  NN,
  6  LDX  BC|  000C  NN,
  7 HERE HERE
  8  LD   A'|  (HL)|
  9  XORA  E|
 10  LD (HL)'|    A|
 11  INCX HL|
 12  DJNZ BACK,
 13 -->
 14 
 15 

Scr# 288 
  0 ( GREY-SCREEN example )
  1 HERE
  2  LD   A'|  (HL)|
  3  XORA  D|
  4  LD (HL)'|    A|
  5  INCX HL|
  6  DJNZ BACK,
  7  DEC  C'|
  8  JRF NZ'| BACK,
  9  POP BC|
 10 NEXT C;
 11 DECIMAL
 12 
 13 
 14 
 15 

Scr# 289 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 290 
  0 ( map - character replacing )
  1 \ translate c using mapping a1 -> a2. n is mapping length
  2 code (map) ( a2 a1 n c1 -- c2 )
  3   exx
  4   pop   hl|               \ c
  5   ld    a'|   l|          \ character to map
  6   pop   bc|               \ n length of a1 map-string
  7   pop   hl|               \ a1 map-string
  8   ld    d'|   b|
  9   ld    e'|   c|          \ length in de too
 10   cpir
 11 -->
 12 
 13 
 14 
 15 

Scr# 291 
  0 ( map - character replacing )
  1   pop   hl|               \ a2 map-string
  2   jrf  nz'|  holdplace
  3     addhl de|
  4     decx  hl|
  5     sbchl bc|
  6     ld    a'| (hl)|
  7   here disp,
  8   ld    l'|   a|
  9   ldn   h'|   0  N,
 10   push  hl|
 11   exx
 12   jpix
 13 c;
 14 -->
 15 

Scr# 292 
  0 ( map - character replacing )
  1 create ncdm  \  ^`%&$_{}~
  2 hex 5E C, 60 C, 25 C, 26 C, 24 C, 5F C, 7B C, 7D C, 7E C,
  3 create ndom  \  :?/*|\<>"
  4 hex 3A C, 3F C, 2F C, 2A C, 7C C, 5C C, 3C C, 3E C, 22 C,
  5 \
  6 : needs-check
  7   needs-w count over + swap
  8   Do
  9     ncdm ndom 9 i c@ (map) i c!
 10   Loop
 11 ;
 12 
 13 
 14 
 15 

Scr# 293 
  0 ( map - character replacing )
  1 : t
  2   >r cod  count  dom  count rot min
  3   r@ . r@ emit space r> (map) dup . emit cr ;
  4 \
  5  char \ t
  6  char / t
  7  char : t
  8  char | t
  9  char " t
 10  char < t
 11  char > t
 12  char ? t
 13  char * t
 14 
 15 

Scr# 294 
  0 ( GREY-SCREEN example )
  1 HERE
  2  LD   A'|  (HL)|
  3  XORA  D|
  4  LD (HL)'|    A|
  5  INCX HL|
  6  DJNZ BACK,
  7  DEC  C'|
  8  JRF NZ'| BACK,
  9  POP BC|
 10 NEXT C;
 11 DECIMAL
 12 
 13 
 14 
 15 

Scr# 295 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 296 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 297 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 298 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 299 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 300 
  0 ( Study:  MMU7 / set or get bank )
  1 \ set MMU7 to 8K-page given between 0 and 233
  2 \ to fit *ANY* page
  3 DECIMAL
  4 CODE MMU7! ( n -- )
  5  POP   HL|
  6  LD    A'|  L|
  7  NEXTREGA 87 P,
  8  NEXT
  9 C;
 10 \ query current page in MMU7
 11 : MMU7@ ( -- n )
 12   87 REG@
 13 ;
 14 
 15 

Scr# 301 
  0 ( Study: MMU7 / simplest )
  1 \ decode bits 765 of H as 8K-page 64-71
  2 \ lower bits of H and L are offset from E000h
  3 \
  4 \ heap pointer:                pppb bbbb  bbbb bbbb
  5 \ page:offset:     0100 0ppp : 111b bbbb  bbbb bbbb
  6 \
  7 CODE >FAR ( ha -- a n )
  8  POP   DE|
  9  LD    A'|  D|
 10  ANDN  HEX  E0 N,
 11  RLCA
 12  RLCA
 13  RLCA
 14 -->
 15 

Scr# 302 
  0 ( Study: MMU7 / simplest )
  1 \
  2  ORN   HEX  40 N,
  3 \
  4  LD    L'|  A|
  5  LDN   H'|  00 N,
  6  LD    A'|  D|
  7  ORN   HEX  E0 N,
  8  LD    D'|  A|
  9  PSH2
 10 C;
 11 -->
 12 
 13 
 14 
 15 

Scr# 303 
  0 ( Study: MMU7 / simplest )
  1 \ reverse of >FAR: encodes a FAR address 8K-page in bits 765
  2 \ of H, lower bits of HL are offset at E000h
  3 \
  4 CODE <FAR ( a n -- ha )
  5  POP   DE|
  6  POP   HL|
  7  LD    A'|  E|
  8  ANDN  HEX  07 N,    \ page number is betwen 0 and 7
  9  RRCA
 10  RRCA
 11  RRCA
 12 -->
 13 
 14 
 15 

Scr# 304 
  0 ( Study: MMU7 / simplest )
  1 \
  2  LD    D'|  A|
  3  LD    A'|  H|
  4  ANDN  HEX  1F N,
  5  ORA    D|
  6  LD    H'|  A|
  7  PSH1
  8 C;
  9 DECIMAL
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 305 
  0 ( Study: MMU7 / 16th byte )
  1 \ decode 7 top bits of H as 8K-page 72-199
  2 \ lsb of H and all L are offset rounded at 16th byte
  3 \
  4 \ heap pointer              pppp pppb   bbbb bbbb
  5 \ page:offset   xppp pppp : 111b bbbb   bbbb 0000
  6 \
  7 CODE >FAR ( a1 -- a2 n )
  8  POP   HL|
  9  LD    A'|   H|
 10  SRL    A|
 11  ADDN  HEX  48  N,
 12  LD    E'|   A|        \ page
 13  LDN   D'|   0  N,
 14 -->
 15 

Scr# 306 
  0 ( Study: MMU7 / 16th byte )
  1 \
  2  ADDHL HL|
  3  ADDHL HL|
  4  ADDHL HL|
  5  ADDHL HL|               \ shift hl 4 bits left
  6  LD    A'|   H|
  7  ORN   HEX  E0  N,
  8  LD    H'|   A|          \ E000 offset
  9  PUSH  HL|
 10  PUSH  DE|
 11  NEXT C;
 12 -->
 13 
 14 
 15 

Scr# 307 
  0 ( Study: MMU7 / 16th byte )
  1 \ reverse of >FAR, encodes 8K-page in bits 7-1 of H
  2 \ bit 1 of H and L are the address rounded at 16 byte
  3 \
  4 CODE <FAR ( a2 b -- a1 )
  5  POP   DE|          \ page 72-199
  6  POP   HL|          \ offset at E000
  7  LD    A'|   E|
  8  SUBN  HEX  48  N,
  9  ADDHL HL|
 10  ADDHL HL|
 11  ADDHL HL|
 12  ADDHL HL|
 13  -->
 14 
 15 

Scr# 308 
  0 ( Study: MMU7 / 16th byte )
  1 \
  2  RLA                     \ A receives HL msb
  3  LD    L'|   H|
  4  LD    H'|   A|
  5  PUSH  HL|
  6  NEXT C;
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 309 
  0 #1
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 310 
  0 ( LED - Large EDitor )
  1 \ Large file EDitor: each line can be 85 characters long
  2 \ then maximum line number is 14.592
  3 decimal  marker TASK
  4  85 CONSTANT COLS/ROW            \ columns per row
  5   8 1024 * COLS/ROW / CONSTANT ROWS/PAGE   \ rows per 8K
  6        512 COLS/ROW / CONSTANT LED-CHARSIZE
  7 1  VARIABLE LED-LN              \ line number
  8 1  VARIABLE LED-MAX             \ max line number
  9 0  VARIABLE LED-ROW
 10 0  VARIABLE LED-COL
 11 1  VARIABLE LED-HOME            \ first line to display
 12 CREATE LED-FN DECIMAL  80 ALLOT \ filename
 13 0 variable LED-FH               \ filehandle of open file
 14 \
 15 -->

Scr# 311 
  0 ( LED - Large EDitor )
  1 \ Since 8Kpages #32-39 are used by HEAP, we can use #40-223
  2 \ for this Large-file EDitor
  3 : >>FAR ( row -- n a ) \ given a row-number ret page+offset
  4   rows/page /mod  [ decimal ] 40 +
  5   dup 223 >  if 40 error endif  \ out-of-memory
  6   swap cols/row  * [ HEX ] E000 OR swap ;
  7 \
  8 \ Row-ADdress
  9 : LED-RAD  ( row -- a )
 10   >>FAR MMU7! ;
 11 \
 12 : LED-CLOSE
 13   led-fh @ f_close [ decimal ] 42 ?error
 14   0 led-fh ! ;
 15 -->

Scr# 312 
  0 ( LED - Large EDitor )
  1 \ assumes to read page np.
  2 \ returns actual characters read. 0 means EOF
  3 \ row is stored in 8K-pages RAM 40-223
  4 decimal needs SHOW-PROGRESS
  5 : LED-RD1  ( np -- b )
  6   1 block   \ use block 1 as special buffer  \ np a a
  7   dup b/buf 2- led-fh @ f_getline >R         \ np a     \ b
  8   swap led-rad COLS/ROW 2dup blanks          \ a a1 n1
  9   cmove R>                                   \ b
 10 ;
 11 -->
 12 
 13 
 14 
 15 

Scr# 313 
  0 ( LED - Large EDitor )
  1 \ load filename specified in LED-FN
  2 \ Filehandle must be already open for read
  3 decimal
  4 : LED-LOAD
  5   begin
  6     led-ln @  show-progress
  7     1 led-ln +!
  8     led-ln @ led-rd1
  9     ?terminal 1 AND 1- AND
 10   0= until \ end of file
 11   led-ln @ 1- led-max !
 12 ;
 13 -->
 14 
 15 

Scr# 314 
  0 ( LED - Large EDitor )
  1 \ accept text for filename and keep it in LED-FN
  2 decimal
  3 : LED-FILE
  4   led-fn 80 erase
  5   bl word led-fn over c@ 1+   \ a1 a2 n
  6   cmove
  7 ;
  8 : LED-OPEN    \ open file and load to RAM
  9   led-file
 10   led-fn 1+ pad 1 f_open 43 ?error led-fh !
 11   0 led-ln !
 12   led-load
 13   led-close
 14 ;
 15 -->

Scr# 315 
  0 ( LED - Large EDitor )
  1 \ write line # np to file
  2 \ n.b. trailing spaces are always removed
  3 : LED-WR1  ( np -- )
  4   led-rad COLS/ROW -TRAILING                      \ a n
  5   2DUP  + [ HEX ] 0A  SWAP C!                     \ a n
  6   2DUP 1+ LED-FH @ F_WRITE [ decimal ] 47 ?ERROR  \ a n n
  7   DROP  + [ HEX ] 20  SWAP C!                     \
  8 ;
  9 -->
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 316 
  0 ( LED - Large EDitor )
  1 \ save current filename
  2 : LED-SAVE
  3   led-fn 1+ pad [ hex 0C 02 + ] LITERAL
  4   f_open [ decimal ] 43 ?error
  5   led-fh  !
  6   LED-MAX @ 1+ 1 ?DO
  7     I show-progress
  8     I LED-WR1
  9     ?terminal if leave then \ can be interrupted via BREAK
 10   LOOP
 11   led-fh @ f_close
 12   0 led-fh !
 13 ;
 14 -->
 15 

Scr# 317 
  0 ( LED - Large EDitor )
  1 DECIMAL
  2 : LED-LINE ( n -- a )     \ address of current screen line n
  3   LED-HOME @ + LED-RAD ;
  4 : LED-PAD ( -- a )          \ dedicated PAD
  5   HERE 168 + ;
  6 : LED-DISPLAY               \ display current screen
  7   16 0 DO
  8     I LED-HOME @ +  LED-MAX @ < IF
  9       I led-line COLS/ROW TYPE
 10     ELSE
 11       COLS/ROW 1 do [char] # emit loop
 12     ENDIF
 13     CR
 14   LOOP
 15 ; -->

Scr# 318 
  0 ( LED - Large EDitor )
  1 : LED-MOVE ( a n -- )      \ move from a to line n
  2   led-line COLS/ROW cmove ;
  3 : H ( n -- )               \ hold line to pad
  4   led-line pad 1+ cols/row dup pad c! cmove ;
  5 : E ( n -- )               \ erase line
  6   led-line cols/row blanks ;
  7 : RE ( n -- )              \ restore line from pad
  8   pad 1+ swap led-move ;
  9 : D ( n -- )               \ delete line
 10   dup H led-max @ dup 1- rot     \  m m-1 n
 11   ?Do
 12     i 1+ led-line led-pad cols/row cmove
 13     led-pad i led-move
 14   Loop E  -1 led-max +! ;
 15 -->

Scr# 319 
  0 ( LED - Large EDitor )
  1 : S ( n -- )                \ insert blank line
  2   dup 1- led-max @          \ n n m
  3   ?do
  4     i       led-line led-pad cols/row cmove
  5     led-pad i 1+ led-move
  6   -1 +Loop 1 led-max +!
  7   E
  8 ;
  9 : INS ( n -- )              \ insert line from pad
 10   dup S RE ;
 11 -->
 12 
 13 
 14 
 15 

Scr# 320 
  0 ( LED - Large EDitor )
  1 DECIMAL   0 VARIABLE NROW               \ current row
  2           0 VARIABLE NCOL               \ current columns
  3 : HOMEC   0 NROW ! 0 NCOL ! ;           \ cursor at home
  4 : ADDRC   ( -- a )                      \ calc cursor addr
  5   LED-HOME @ NROW @ + LED-RAD NCOL @ + ;
  6 : TO-SCR  ( row1 col1 -- col2 row2 )    \ translate xy
  7   0 + SWAP 2 + ;
  8 : AT-XY   ( col row -- )                \ set print position
  9   22 EMITC  EMITC EMITC ;               \ using standard AT.
 10 : HOME 0 0 AT-XY ;                      \ cursor at home
 11 : BUZZ    7 EMIT ;                      \ sound BEL
 12 : CURC! ( c -- )    \ store chr to current screen position
 13   ADDRC  C! ;
 14 : CURC@ ( -- c )    \ fetch chr from current screen position
 15   ADDRC  C@ ; -->

Scr# 321 
  0 ( LED - Large EDitor )
  1 : EDIT-FRAME
  2   0 19 AT-XY
  3   INVV ."  row:" TRUV 8 SPACES INVV ."  col:" TRUV 5 SPACES
  4   INVV ."  hex:" TRUV 5 SPACES INVV ."  dec:" TRUV 6 SPACES
  5   INVV ."  chr:" TRUV
  6   CR INVV ."  pad:" TRUV PAD COUNT 55 MIN TYPE
  7   0 21 AT-XY  INVV ."  cmd:" TRUV
  8   CR ." W-RITE   B-ack    D-el     I-nsert   H-old"
  9   CR ." Q-uit    N-ext    S-hift   R-eplace  P-ut hex byte"
 10   COLS/ROW 10 -  0 AT-XY  INVV ."   LED   " TRUV ;
 11 : EDIT-STAT CURC@
 12   28 19 AT-XY  HEX DUP 3 .R  39 19 AT-XY  DECIMAL DUP 3 .R
 13   50 19 AT-XY  32 MAX EMIT
 14   18 19 AT-XY  NCOL @  3 .R
 15   05 19 AT-XY  NROW @  LED-HOME @ + 6 .R ; -->

Scr# 322 
  0 ( LED - Large EDitor )
  1 NEEDS INVV NEEDS TRUV
  2 : RULER COLS/ROW 10 DO
  3         ." |----.----"  10 +LOOP  ;
  4 : PUTPAGE 0 0 AT-XY LED-FN COUNT TYPE CR RULER CR
  5           LED-DISPLAY RULER ;
  6 : PREVP   1 led-home @ < if -16 led-home +! else buzz then ;
  7 : NEXTP  16 led-home +! led-max @ led-home @ <
  8             if PREVP buzz then ;
  9 : UPC    NROW @  0 > IF -1  NROW +!  ELSE  prevp putpage THEN ;
 10 : DOWNC  NROW @ 15 < IF  1  NROW +!  ELSE  nextp putpage THEN ;
 11 : LEFTC  NCOL @  0 > IF -1  ELSE  UPC    80 THEN NCOL +! ;
 12 : RIGHTC NCOL @ 80 < IF  1  ELSE  DOWNC -80 THEN NCOL +! ;
 13 -->
 14 
 15 

Scr# 323 
  0 ( LED - Large EDitor )
  1 : BYTE ( -- b ) \ accept two hex digit as a byte
  2   KEY DUP EMIT 10 DIGIT DROP 4 LSHIFT
  3   KEY DUP EMIT 10 DIGIT DROP + ;
  4 HEX
  5 : DONEC             8F 26 +ORIGIN C!    \ reset cursor face
  6                     5F 28 +ORIGIN C! ;  \ reset cursor face
  7 : INITC   CURC@ BL MAX 26 +ORIGIN C!    \ change cursor face
  8                     8F 28 +ORIGIN C! ;
  9 DECIMAL
 10 : REFRESH                           \ refresh current line
 11   NROW @ 0 TO-SCR AT-XY COLS/ROW  spaces
 12   NROW @ 0 TO-SCR AT-XY NROW @ LED-line COLS/ROW type ;
 13 -->
 14 
 15 

Scr# 324 
  0 ( LED - Large EDitor )
  1 : CMD    ( c -- )   \ handle EDIT key options
  2   6 21 AT-XY DONEC KEY UPPER BL MAX DUP EMIT CASE
  3   [CHAR] P OF BYTE CURC! ENDOF  \ put a byte at cursor
  4   [CHAR] H OF NROW @ H   ENDOF  \ copy to PAD
  5   [CHAR] S OF NROW @ S   ENDOF  \ shift down one row
  6   [CHAR] R OF NROW @ RE  ENDOF  \ replace row from PAD
  7   [CHAR] I OF NROW @ INS ENDOF  \ insert row from PAD
  8   [CHAR] D OF NROW @ D   ENDOF  \ delete row + copy to PAD
  9   [CHAR] N OF NEXTP      ENDOF  \ next page
 10   [CHAR] B OF PREVP      ENDOF  \ prev page
 11   [CHAR] W OF LED-save   ENDOF
 12   [CHAR] Q OF ."  ok" CR C/L 2 * SPACES
 13               0 21 AT-XY 30 EMITC 8 EMITC  QUIT ENDOF
 14   ENDCASE PUTPAGE EDIT-FRAME ; -->
 15 

Scr# 325 
  0 ( LED - Large EDitor )
  1 : DELC    ( -- )    \ back-space
  2   NCOL @  0 > IF -1 NCOL +! THEN
  3   ADDRC DUP 1+ SWAP C/L NCOL @ - 1- CMOVE UPDATE
  4   BL NROW @ LINE C/L + 1- C! ;
  5 : INSC    ( -- )    \ insert blank at cursor and shift the rest
  6   ADDRC DUP 1+      C/L NCOL @ - 1- CMOVE>
  7   BL ADDRC  C!  UPDATE ;
  8 : CTRLC  ( c -- )   \ manage control keys
  9   CASE 08 OF LEFTC  ENDOF      09 OF RIGHTC ENDOF
 10        10 OF DOWNC  ENDOF      11 OF UPC    ENDOF
 11        12 OF DELC   REFRESH ENDOF
 12        13 OF DOWNC 0 NCOL ! ENDOF
 13        07 OF CMD            ENDOF
 14   ENDCASE ;
 15 -->

Scr# 326 
  0 ( LED - Large EDitor )
  1 : LED-EDIT ( -- )
  2   30 EMITC LED-CHARSIZE EMITC  \ change chr width
  3   1 LED-HOME !
  4   CLS HOMEC PUTPAGE EDIT-FRAME
  5   BEGIN
  6     EDIT-STAT  INITC
  7     CURC@ NROW @ NCOL @ TO-SCR  2DUP AT-XY
  8     KEY  ?TERMINAL IF DROP 0 INSC   REFRESH THEN
  9     DUP BL < IF
 10       >R AT-XY EMIT R>  CTRLC
 11     ELSE
 12       CURC! AT-XY DROP CURC@ EMIT RIGHTC
 13     THEN
 14   AGAIN  \ quit using EDIT-key + Q
 15 ; -->

Scr# 327 
  0 ( LED - Large EDitor )
  1 : LED
  2   LED-OPEN LED-EDIT
  3 ;
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 328 
  0 ( MMU7 HEAP )
  1 \ reserve n bytes on heap, retunrs heap-pointer to them
  2 : HEAP ( n -- ha )
  3   dup ?page
  4   hp@ swap
  5   cell+
  6   hp +!
  7   hp@ swap
  8   tuck   far !
  9 ;
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 329 
  0 ( MMU7 HEAP STRING )
  1 \ accepts a string and stores it to Heap,
  2 \ returns a Pointer to a counted string
  3 : +" ( ha -- ha )
  4  DUP FAR C@
  5  [CHAR] " WORD
  6  DUP C@ >R 1+
  7  HP@ FAR R@ CMOVE
  8  R@ HP+!
  9  R> +
 10  OVER FAR C!
 11 ;
 12 -->
 13 
 14 
 15 

Scr# 330 
  0 ( MMU7 HEAP STRING )
  1 \ accepts a string and store it to Heap, returns a
  2 \ pointer to a counted string
  3 : H" ( -- ha )
  4  HP @
  5  [CHAR] " WORD  DUP C@ 1+ >R
  6  OVER FAR  TUCK CELL+  R@ CMOVE
  7  R> CELL+ HP +!
  8  HP @ [ HEX ] 1FFF AND 1EFF >
  9  IF 1FFF OR 1+ HP ! THEN
 10  HP @ OVER !
 11 ;
 12 DECIMAL
 13 
 14 
 15 

Scr# 331 
  0 ( MMU7 HEAP STRING )
  1 \ given a pointer, prints the counted string
  2 \
  3 : .H
  4   FAR
  5   COUNT TYPE
  6 ;
  7 -->
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 332 
  0 ( MMU7 HEAP POINTER )
  1 \ like CONSTANT but it returns a FAR-resolved pointer
  2 : POINTER ( a -- cccc )
  3  <BUILDS
  4   ,
  5  DOES>
  6   @ FAR
  7 ;
  8 -->
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 333 
  0 ( S" Counted Strings in Heap )
  1 : (S")  R@ R> CELL+ >R  @ FAR COUNT ;
  2 \
  3 : S"  ( -- a n )
  4   STATE @ IF
  5    COMPILE (S") H" ,
  6   ELSE
  7    H" FAR COUNT
  8   ENDIF
  9 ; IMMEDIATE
 10 \
 11 : TEST_S"  S" HELLO WORLD" NOOP ;
 12 EXIT
 13 CR TEST_S" TYPE
 14 CR S" HELLO WORLD" TYPE
 15 

Scr# 334 
  0 \ TEST
  1 : Q CR
  2  ." HP  " HP@ U. CR
  3  ." P   " CURPAGE ? CR
  4 ;
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 335 
  0 ( Testing where $6000 is paged )
  1 HEX
  2 : T
  3   MMU7
  4   E000 DUMP
  5   FD38 DUMP
  6 ;
  7 DECIMAL
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 336 
  0 ( Testing where $6000 is paged )
  1 DECIMAL 14 EMITC
  2 HEX 8F EMITC 8F EMITC
  3 DECIMAL
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 337 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 338 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 339 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 340 
  0 ( R/W : BLK-FH )
  1 1 variable blk-fh
  2 \ seek block n  within blocks!.bin  file
  3 : blk-seek  ( n -- )
  4   b/buf m*
  5   blk-fh @
  6   f_seek
  7   [ hex ] 2D ?error
  8 ;
  9 -->
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 341 
  0 ( R/W : BLK-READ )
  1 \ read block n to address a
  2 : blk-read  ( a n -- )
  3   blk-seek
  4   b/buf
  5   blk-fh @
  6   f_read
  7   [ hex ] 2E ?error
  8   drop
  9 ;
 10 -->
 11 
 12 
 13 
 14 
 15 

Scr# 342 
  0 ( R/W : BLK-WRITE )
  1 \ write block n from address a
  2 : blk-write  ( a n -- )
  3   blk-seek
  4   b/buf
  5   blk-fh @
  6   f_write
  7   [ hex ] 2E ?error
  8   drop
  9 ;
 10 -->
 11 
 12 
 13 
 14 
 15 

Scr# 343 
  0 ( R/W : BLK-INIT )
  1 : blk-init
  2  blk-fh @ f_close drop   \ ignore error
  3  filename
  4  here 3 f_open
  5  44 ?error
  6  blk-fh !
  7 ;
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 344 
  0 ( blk-fname )
  1 : STRING"
  2   [CHAR] " WORD   COUNT 1+ ALLOT ;
  3 create blk-fname
  4   STRING" !Block-64.bin" 0 c,
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 345 
  0 ( r/w patch )
  1 ' r/w 32 + @ .word
  2 ' r/w 38 + @ .word
  3 ' nxtrd ' r/w 32 + !
  4 ' nxtwr ' r/w 38 + !
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 346 
  0 ( r/w patch )
  1 ' r/w 32 + @ .word
  2 ' r/w 38 + @ .word
  3 ' blk-read ' r/w 32 + !
  4 ' blk-write ' r/w 38 + !
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 347 
  0 ( study to improve +LOOP )
  1 CODE (-LOOP)
  2   ldx      hl|  2  NN,   \ to consume increment
  3   addhl    sp|           \ save SP
  4   exx
  5   pop      bc|           \ increment
  6   ldhl()   hex 30 +origin AA,
  7   ldsphl                 \ use SP as temp RP
  8   pop      hl|           \ index
  9   pop      de|           \ limit
 10   anda      a|
 11   sbchl    de|           \ index - limit
 12   addhl    bc|           \ index - limit + increment
 13 -->
 14 
 15 

Scr# 348 
  0 ( standard +LOOP )
  1   jpf      NC|   HERE 0 AA,
  2   \ stay in loop, increment index
  3     ldhl()   hex 30 +origin AA,
  4     ldsphl               \ redo SP from RP
  5     pop      hl|
  6     addhl    bc|
  7     push     hl|
  8     exx
  9     ldsphl               \ restore SP
 10     jp ' BRANCH >BODY AA,
 11   HERE SWAP !
 12 -->
 13 
 14 
 15 

Scr# 349 
  0 ( standard +LOOP )
  1   ldx      hl|  0  NN,
  2   addhl    sp|
  3   ld()hl   hex 30 +origin AA,
  4   exx
  5   ldsphl               \ restore SP
  6   incx     bc|
  7   incx     bc|
  8   Next
  9   C;
 10 \
 11 \ patch to +LOOP
 12 \ ' (-loop) ' +loop 8 + !
 13 \ rollback
 14 \ ' (+loop) ' +loop 8 + !
 15 

Scr# 350 
  0 ( Matt Davies'  .helloworld )
  1 CODE .helloworld
  2         ldx  hl|   here  0  NN,
  3   here  ld   a'|   (hl)|
  4         anda  a|
  5         retf  z|
  6         rst  10|
  7         incx hl|
  8         jr   BACK,
  9         c;
 10   here  ," Hello, World!"  1+ swap !
 11 \
 12 \
 13 
 14 
 15 

Scr# 351 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 352 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 353 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 354 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 355 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 356 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 357 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 358 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 359 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 360 
  0 ( F_STAT via RST 8 hook code )
  1 CASEOFF
  2 code F_STAT ( fspec buff -- f )
  3   pop   de|      \ 11-byte buffer
  4   ex(sp)ix       \ filespec nul-terminated
  5   push  bc|
  6   ldn   a'|   char  *  n,
  7   rst   08|   hex  AC  c,
  8   pop   bc|
  9   pop   ix|
 10   sbchl hl|
 11   push  hl|
 12   jpix
 13 c;
 14 -->
 15 

Scr# 361 
  0 ( F_FGETPOS via RST 08 hook code )
  1 code F_FGETPOS ( n -- d f )
  2   pop   hl|
  3   ld    a'|   l|
  4   push  ix|
  5   push  bc|
  6   rst  08|   hex  9F  c,
  7   ld    h'|   b|
  8   ld    l'|   c|
  9   pop   bc|
 10   pop   ix|
 11   push  de|
 12   push  hl|
 13   sbchl hl|
 14   push  hl|
 15   jpix    c;  -->

Scr# 362 
  0 ( F_SEEK via RST 08 hook code )
  1 code F_SEEK ( d n -- f )
  2   pop   hl|     ld   a'|  l|
  3   ld    h'|   b|
  4   ld    l'|   c|
  5   pop   bc|
  6   pop   de|
  7   push  ix|
  8   push  hl|
  9   ldx   ix| 0 nn,
 10   rst  08|   hex  9F  c,
 11   pop   bc|
 12   pop   ix|
 13   sbchl hl|
 14   push  hl|
 15   jpix    c;  -->

Scr# 363 
  0 ( F_WRITE via RST 8 hook code )
  1 code F_WRITE ( addr bytes n -- actual f )
  2   ld    d'|   b|
  3   ld    e'|   c|
  4   pop   hl|     \ file handle number
  5   ld    a'|   l|
  6   pop   bc|     \ bytes to read
  7   ex(sp)ix
  8   push  de|
  9   rst   08|   hex  9E  c,
 10   pop   bc|
 11   pop   ix|
 12   push  de|
 13   sbchl hl|
 14   push  hl|
 15   jpix    c;  -->

Scr# 364 
  0 ( F_READ via RST 8 hook code )
  1 code F_READ ( addr bytes n -- actual f )
  2   ld    d'|   b|
  3   ld    e'|   c|
  4   pop   hl|     \ file handle number
  5   ld    a'|   l|
  6   pop   bc|     \ bytes to read
  7   ex(sp)ix
  8   push  de|
  9   rst   08|   hex  9D  c,
 10   pop   bc|
 11   pop   ix|
 12   push  de|
 13   sbchl hl|
 14   push  hl|
 15   jpix    c;  -->

Scr# 365 
  0 ( F_CLOSE via RST 8 hook code )
  1 code F_CLOSE ( n -- f )
  2   pop   hl|
  3   ld    a'|   l|
  4   push  ix|
  5   push  bc|
  6   rst   08|   hex  9B  c,
  7   pop   bc|
  8   pop   ix|
  9   sbchl hl|
 10   push  hl|
 11   jpix
 12 c;
 13 -->
 14 
 15 

Scr# 366 
  0 ( F_OPEN via RST 8 hook code )
  1 code F_OPEN ( fspec buff mode -- n f )
  2   ld    h'|   b|
  3   ld    l'|   c|
  4   pop   bc|      \ mode
  5   ld    b'|   c|
  6   pop   de|      \ 8-byte buffer if any
  7   ex(sp)ix       \ filespec nul-terminated
  8   push  hl|      \ this push bc
  9   ldn   a'|   char  *  n,
 10   rst   08|   hex  9A  c,
 11   pop   bc|
 12   pop   ix|
 13 -->
 14 
 15 

Scr# 367 
  0 ( F_OPEN via RST 8 hook code )
  1   sbchl hl|
  2   ld    e'|   a|
  3   ldn   d'|   0  n,
  4   push  de|
  5   push  hl|
  6   jpix
  7 c;
  8 -->
  9 \ CREATE FILENAME 30 ALLOT
 10 \ FILENAME 30 ERASE
 11 \ S" test.txt"   \ new Counted String
 12 \ FILENAME SWAP CMOVE
 13 \ FILENAME PAD 1 F_OPEN
 14 \ DROP
 15 \ F_CLOSE

Scr# 368 
  0 ( F_FSTAT via RST 8 hook code )
  1 code F_FSTAT ( addr n -- f )
  2   pop   de|       \ file handle number
  3   ex(sp)ix        \ 11-byte buffer
  4   push  bc|
  5   ld    a'|   e|
  6   rst   08|   hex  A1  c,
  7   pop   bc|
  8   pop   ix|
  9   sbchl hl|
 10   push  hl|
 11   jpix
 12 c;
 13 -->
 14 \ 2 PAD F_FSTAT
 15 

Scr# 369 
  0 code F_SYNC  ( n -- f )
  1   pop   hl|
  2   push  ix|
  3   push  bc|
  4   ld    a'|   l|
  5   rst   08|   hex  9C  c,
  6   pop   bc|
  7   pop   ix|
  8   sbchl hl|
  9   push  hl|
 10   jpix
 11 c;
 12 -->
 13 \ 2 F_SYNC works
 14 
 15 

Scr# 370 
  0 ( M_DOSVERSION via RST 8 hook code )
  1 \ Get API version/mode information
  2 \ Entry: none
  3 \ Exit: Fc=1, error; A=14 "no such device"
  4 \ Fc=0, success. BC="NX"; DE=maj.min in BCD format
  5 \   HL="en" or "es" for English/Spanish
  6 code M_DOSVERSION ( -- n )
  7   push  ix|
  8   push  bc|
  9   rst   08|   hex  88  c,
 10   pop   bc|
 11   pop   ix|
 12   push  de|
 13   jpix
 14 c;
 15 DECIMAL

Scr# 371 
  0 ( F_GETFREE via RST 08 hook code test )
  1 code f_getfree ( drive -- d )
  2   pop   hl|
  3   push  ix|
  4   push  bc|
  5   ld    a'|   l|
  6   rst   08|   hex  B1  c,
  7   ld    h'|   b|
  8   ld    l'|   c|
  9   pop   bc|
 10   pop   ix|
 11   push  de|
 12   push  hl|
 13   jpix
 14 c;
 15 

Scr# 372 
  0 ( M_P3DOS )
  1 CASEOFF
  2 \ n1 n2 n3 n4 a -- n5 n6 n7 n8
  3 \ hl de bc  a   -- hl de bc  a  flag
  4 code M_P3DOS
  5   pop   de|   \ call ID
  6   pop   hl|
  7   ld    a'|    l|
  8   exx
  9   pop   bc|
 10   pop   de|
 11   pop   hl|
 12   exx
 13   push  bc|
 14   push  ix|
 15 -->

Scr# 373 
  0 ( M_P3DOS )
  1   ld()x sp|   hex 02C +origin  aa,
  2   ldx   sp|  hex  -2 +origin  nn,
  3 \
  4 \  use page 7 RAM bank
  5   ldn   c'|   7   n,
  6 \ nop nop
  7   rst   08|    hex  94  c,
  8 \
  9   ldx() sp|   hex 02C +origin  aa,
 10   push  ix|
 11   pop   hl|
 12   ld()x hl|  hex 02a +origin  aa,
 13 -->
 14 
 15 

Scr# 374 
  0 ( M_P3DOS )
  1   pop   ix|
  2   ex(sp)hl    \ retrieve BC
  3   push  de|
  4   push  bc|
  5   ld    c'|    l|
  6   ld    b'|    h|
  7   ldn   h'|    0   n,
  8   ld    l'|    a|
  9   push  hl|
 10   sbchl  hl|
 11   push   hl|
 12   jpix
 13 c;
 14 decimal
 15 

Scr# 375 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 376 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 377 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 378 
  0 ( NextZXOS IDE_MODE 01d5 )
  1 : IDE_MODE! ( hl de bc a -- )
  2   >R 0 0 R> 1
  3   [ HEX ] 01D5 M_P3DOS [ DECIMAL ]
  4   44 ?ERROR 2DROP 2DROP VIDEO ;
  5 HEX
  6 : LAYER: <builds C, , does> dup C@   \ ide_mode!
  7    swap 1+ @ ide_mode! 1E emitc emitc ;
  8 : LAYER0 0000 IDE_MODE! ; \ ULA
  9   0100 04  LAYER: LAYER10  \ Lo-Res
 10   0101 04  LAYER: LAYER11  \ ULA Enhanced
 11   0102 08  LAYER: LAYER12  \ Hi-Res
 12   0103 04  LAYER: LAYER13  \ Hi-Col
 13   0200 04  LAYER: LAYER2
 14 DECIMAL
 15 

Scr# 379 
  0 ( IDE_BANK )
  1 HEX
  2 : IDE_BANK_ALLOC
  3   0002 SWAP 0 0 01BD M_P3DOS
  4   44 ?ERROR
  5   2DROP SWAP DROP ;
  6 DECIMAL
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 380 
  0 ( NextZXOS - IDE_CAPACITY $01b4 )
  1 \ M_P3DOS expects hl, de, bc, a, address
  2 \         returns hl, de, bc, a as error code
  3 : IDE_CAPACITY ( n -- d )
  4 \ n: unit (0 or 1)
  5 \ d: total card capacity in sectors.
  6   >R  0 ( hl )   0 ( de )  R> 1 AND ( bc )  0 ( a )
  7   [ HEX ] 01B4 M_P3DOS [ DECIMAL ]
  8   44 ?ERROR
  9   2DROP ( bc a ) SWAP ( hl,de )
 10 ;
 11 EXIT
 12 > TEST <
 13 0 IDE_CAPACITY D.
 14 
 15 

Scr# 381 
  0 ( NextZXOS - DOS_FREE_SPACE $0121 )
  1 \ c: drive letter UpperCase
  2 \ d: total card capacity in sectors.
  3 : DOS_FREE_SPACE ( c -- d )
  4   >R  0  0  0  R>
  5   [ HEX ] 0121 M_P3DOS [ DECIMAL ]
  6   44 ?ERROR
  7   DROP ( a ) ROT ( de bc hl ) DROP SWAP
  8   \
  9 ;
 10 EXIT
 11 > TEST <
 12 CHAR C DOS_FREE_SPACE D.
 13 
 14 
 15 

Scr# 382 
  0 ( NextZXOS IDE_MODE 01d5 )
  1 \ Set current NextBasic display mode
  2 : IDE_MODE! ( hl de bc a -- )
  3   >R 0 0 R> 1
  4   [ HEX ] 01D5 M_P3DOS [ DECIMAL ]
  5   44 ?ERROR 2DROP 2DROP VIDEO
  6 ;
  7 HEX
  8 : LAYER0  0000 IDE_MODE!  ;
  9 : LAYER10 0100 IDE_MODE!  1E EMITC 4 EMITC ; \ Lo-Res
 10 : LAYER11 0101 IDE_MODE!  1E EMITC 4 EMITC ; \ ULA
 11 : LAYER12 0102 IDE_MODE!  1E EMITC 8 EMITC ; \ Hi-Res
 12 : LAYER13 0103 IDE_MODE!  1E EMITC 4 EMITC ; \ Hi-Col
 13 : LAYER2  0200 IDE_MODE!  1E EMITC 4 EMITC ;
 14 
 15 

Scr# 383 
  0 ( NextZXOS IDE_MODE 01d5 )
  1 \ Query current NextBasic display mode information
  2 : IDE_MODE@ ( -- hl de bc a )
  3   0 0 0 0
  4   [ HEX ] 01D5 M_P3DOS [ DECIMAL ]
  5   44 ?ERROR
  6 ;
  7 \
  8 \ hex 1840 0 800 9
  9 \ hex 1820 7 800 5
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 384 
  0 ( DOS_FLUSH $0142 )
  1 \ Flush any pending write to SD
  2 : DOS_FLUSH ( c -- )
  3   >R 0 0 0 R>
  4   [ HEX ] 0142 M_P3DOS [ DECIMAL ]
  5   44 ?ERROR
  6   DROP 2DROP
  7 ;
  8 \ CHAR C DOS_FLUSH
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 385 
  0 ( DOS_VERSION / IDE_VERSION )
  1 \ TO BE TESTED YET !
  2 : DOS_VERSION ( -- n )
  3   0 0 0 0
  4   [ HEX ] 0103 M_P3DOS [ DECIMAL ]
  5   44 ?ERROR
  6   DROP NIP
  7 ;
  8 : IDE_VERSION ( -- n )
  9   0 0 0 0
 10   [ HEX ] 00A0 M_P3DOS [ DECIMAL ]
 11   44 ?ERROR
 12   DROP NIP
 13 ;
 14 
 15 

Scr# 386 
  0 ( IDE_BASIC 1/3 )
  1 HEX
  2 : IDE_BASIC
  3   PAD 0 0 0
  4 \ [ HEX ] 0 7AEF C! [ DECIMAL ]
  5   [ HEX ] 01C0 M_P3DOS [ DECIMAL ]
  6 \ [ HEX ] 7 7AEF C! [ DECIMAL ]
  7 ;
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 387 
  0 ( IDE_BASIC 2/3 )
  1 : TEST
  2   PAD 40 ERASE
  3   [ HEX ]  0DF7 PAD !  [ DECIMAL ]
  4   IDE_BASIC
  5 ;
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 388 
  0 ( IDE_BASIC 3/3 )
  1 \ NOT VERIFIED YET !
  2  POP    AF|
  3  LDX()  SP|  HEX 02C +ORIGIN AA, \ restore Forth SP
  4 \
  5  LDX    HL|  0 NN,
  6  JRF   CY'|  HOLDPLACE
  7   INC   L'|
  8  HERE  DISP,
  9  PSH1
 10 C;
 11 \ PROG 23635
 12 \ 23635 @ 4 + DUMP
 13 
 14 
 15 

Scr# 389 
  0 ( IDE_BASIC test )
  1 \ NOT VERIFIED YET !
  2 0 VARIABLE PROGR
  3 80 ALLOT
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 390 
  0 ( looking for AT position in LAYERs )
  1 \ search memory for a specific xt for debug purposes
  2 DECIMAL
  3 : AT.
  4 22 EMITC 31 AND SWAP 21 MIN EMITC EMITC ;
  5 HEX
  6 : LOOK-FOR
  7   0F MMU7!
  8   FFFF  E000  DO
  9     0D 11 AT.
 10     0D11 I @ = IF I U. THEN
 11     100D I @ = IF I U. THEN
 12   LOOP
 13   1 MMU7! ;
 14 
 15 

Scr# 391 
  0 ( looking for AT position in LAYERs )
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 392 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 393 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 394 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 395 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 396 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 397 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 398 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 399 
  0 ( Sprite definition )
  1 0
  2   2  +FIELD  _spriteid
  3   2  +FIELD  _xcoord
  4   2  +FIELD  _ycoord
  5   1  +FIELD  _pattern
  6   1  +FIELD  _mflipflags
  7   1  +FIELD  _anchor
  8   1  +FIELD  _visible
  9 CONSTANT SPRITE-LEN
 10 \
 11 CREATE SPRITE       SPRITE-LEN  ALLOT
 12 -->
 13 
 14 
 15 

Scr# 400 
  0 ( Sprite struct definition )
  1 \
  2 NEEDS ASSEMBLER
  3 NEEDS OPEN<         \ later we use as OPEN< filename.f
  4 NEEDS J
  5 NEEDS BINARY
  6 \
  7 MARKER TASK
  8 \
  9 : db .s ."  << " ;
 10 CODE WAIT halt next C;
 11 : PAUSE 0 ?DO WAIT LOOP ;
 12 \
 13 : +FIELD ( n1 n2 <name> -- n3 )
 14   <BUILDS OVER , + DOES> @ + ;
 15 -->

Scr# 401 
  0 ( Sprite struct definition )
  1 0
  2   2  +FIELD  _spriteid   \ to attr. 3 bits 5:0
  3   2  +FIELD  _xcoord     \ to attr. 0 + attr. 2 bit 0
  4   2  +FIELD  _ycoord     \ to attr. 1
  5   1  +FIELD  _rotmir     \ to attr. 2 bits 3:1
  6   1  +FIELD  _pattern    \ to attr. 2 bits 7:4
  7   1  +FIELD  _anchor     \ to attr. 4 ...
  8 CONSTANT SPRITE-OB
  9 \
 10 CREATE SPRITE  SPRITE-OB  ALLOT
 11 -->
 12 
 13 
 14 
 15 

Scr# 402 
  0 ( Sprite Lib - Derek Bolli et Al. )
  1 BINARY 00000010 CONSTANT SPRITE-ROT
  2        00000100 CONSTANT SPRITE-VFLIP
  3        00001000 CONSTANT SPRITE-HFLIP
  4 \
  5 HEX 303B CONSTANT SPRITE-SLOT-SELECT-PORT
  6     0057 CONSTANT SPRITE-ATTRIBUTE-PORT
  7     005B CONSTANT SPRITE-PATTERN-PORT
  8 DECIMAL
  9    256 CONSTANT SPRITE-BUFLEN
 10 \
 11 CREATE SPRITE-BUFFER SPRITE-BUFLEN ALLOT
 12        SPRITE-BUFFER SPRITE-BUFLEN ERASE
 13 -->
 14 
 15 

Scr# 403 
  0 ( Sprite Lib )
  1 \ transmit 256 bytes of sprite data from address a
  2 \ : SPRITE-DATA>    ( a -- )
  3 \ 256 OVER + SWAP DO
  4 \   I C@ SPRITE-PATTERN-PORT P!
  5 \ LOOP ;
  6 
  7 CODE SPRITE-DATA> ( a -- )
  8   pop     hl|
  9   push    bc|
 10   ldx     bc|  SPRITE-PATTERN-PORT  NN,
 11   otir
 12   pop     bc|
 13   next
 14   C; -->
 15 

Scr# 404 
  0 ( Sprite Lib )
  1 \ init sprite number id
  2 : SPRITE-INIT ( id -- )
  3   SPRITE-SLOT-SELECT-PORT P!        \ select sprite id
  4   SPRITE-BUFFER
  5   SPRITE-DATA>
  6 ;
  7 \ set current sprite current attribute
  8 : SPRITE-ATTR ( b -- )
  9 \ base @ >R dup hex . dup binary . cr R> base !
 10   SPRITE-ATTRIBUTE-PORT P!
 11 ;
 12 DECIMAL -->
 13 
 14 
 15 

Scr# 405 
  0 ( Sprite Lib )
  1 \ setup up to  64 sprites read from <file>
  2 : SPRITE-LOAD< ( <file> -- )
  3   OPEN< >R                      \ open file and save fh
  4   064 0 DO
  5     SPRITE-BUFFER SPRITE-BUFLEN \ since we are inside a loop
  6     J                           \ get filehandle using J
  7     F_READ                      \ read from file
  8     IF      LEAVE               \ non-zero means error
  9     ELSE    I SPRITE-INIT       \ setup this sprite
 10     ENDIF
 11     DROP             \ discard actual bytes read in any case
 12   LOOP
 13   R>  F_CLOSE  42 ?ERROR
 14 ; -->
 15 

Scr# 406 
  0 ( Sprite )
  1 HEX
  2 : SPRITE-UPDATE      ( a n -- )
  3   SPRITE-SLOT-SELECT-PORT P!
  4   DUP  _xcoord     C@        SPRITE-ATTR     \ attribute 0
  5   DUP  _ycoord     C@        SPRITE-ATTR     \ attribute 1
  6   DUP  _xcoord 1+  C@  1 AND
  7   OVER _rotmir     C@ 0E AND OR
  8   OVER _pattern    C@ F0 AND OR
  9                              SPRITE-ATTR     \ attribute 2
 10   DUP  _spriteid   C@ C0 OR  SPRITE-ATTR     \ attribute 3
 11   DROP ;
 12 DECIMAL -->
 13 
 14 
 15 

Scr# 407 
  0 ( Sprite )
  1 CODE SPRITE-HIDE    ( n -- )
  2   exx
  3   pop     hl|
  4   ldx     bc|   SPRITE-SLOT-SELECT-PORT  NN,
  5   out(c)  l'|
  6   ldx     bc|   SPRITE-ATTRIBUTE-PORT    NN,
  7   out(c)  (hl)'|      \ Attribute 0
  8   out(c)  (hl)'|      \ Attribute 1
  9   out(c)  (hl)'|      \ Attribute 2
 10   out(c)  (hl)'|      \ Attribute 3
 11   exx
 12   next
 13   C;
 14 DECIMAL
 15 

Scr# 408 
  0 ( Sprite Test )
  1 \
  2 \ open<   ../../demos/NextBASIC/basicSprites/DKSprite.spr
  3 \
  4 \
  5 SPRITE-LOAD< ../../demos/NextBASIC/basicSprites/DKSprite.spr
  6 \
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 409 
  0 ( Sprite Test )
  1 HEX
  2 FE 08 REG!   \ no contention on Peripeal 3 Setting
  3 E3 14 REG!   \ Global Transparency Colour
  4 18 40 REG!   \ Palette Index Register
  5 E3 41 REG!   \ Palette Data
  6 02 07 REG!   \ Go 7 MHz
  7 \
  8 BINARY 00001011 HEX 15 REG!
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 410 
  0 ( Sprite definition )
  1 DECIMAL
  2 \
  3   1  SPRITE  _spriteid   !
  4 010  SPRITE  _xcoord     !
  5 010  SPRITE  _ycoord     !
  6   0  SPRITE  _pattern    c!
  7   0  SPRITE  _rotmir     c!
  8   0  SPRITE  _anchor     c!
  9 \
 10 SPRITE 0 SPRITE-UPDATE
 11 
 12 
 13 
 14 
 15 

Scr# 411 
  0 ( TEST )
  1 \
  2 : TEST
  3   60 0 DO
  4     I 1 AND    SPRITE _spriteid !
  5     I 4 *      SPRITE _xcoord !
  6     SPRITE  0  SPRITE-UPDATE
  7     04 pause
  8   LOOP
  9   0 SPRITE-HIDE
 10 ;
 11 
 12 
 13 
 14 
 15 

Scr# 412 
  0 ( ISR-TEST )
  1 \
  2 NEEDS INTERRUPT
  3 : ISR-TEST
  4   23672 ( FRAMES ) @ 7 AND 0= IF
  5     SPRITE _xcoord @ 320 >
  6     IF -20 SPRITE _xcoord ! THEN
  7     5  SPRITE _xcoord  +!
  8     SPRITE _xcoord @ 1 AND
  9     SPRITE _spriteid !
 10     SPRITE  0  SPRITE-UPDATE
 11   ENDIF
 12 ;
 13 INT-OFF
 14 ' ISR-TEST INT-W !
 15 \ INT-ON

Scr# 413 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 414 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 415 
  0 ( .HEX and .BIN utility )
  1 DECIMAL
  2 : .HEX ( n -- ) \ print n in hexadecimal
  3   BASE @        \ save current base
  4   16 BASE !     \ set to hexadecimal
  5   SWAP U.       \ print number
  6   BASE !
  7 ;
  8 : .BIN ( n -- ) \ print n in binary
  9   BASE @        \ save current base
 10   2 BASE !      \ set to binary
 11   SWAP U.       \ print number
 12   BASE !
 13 ;
 14 
 15 

Scr# 416 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 417 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 418 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 419 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 420 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 421 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 422 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 423 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 424 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 425 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 426 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 427 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 428 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 429 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 430 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 431 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 432 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 433 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 434 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 435 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 436 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 437 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 438 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 439 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 440 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 441 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 442 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 443 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 444 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 445 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 446 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 447 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 448 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 449 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 450 
  0 ( Floating Point Support )
  1 NEEDS ASSEMBLER
  2 NEEDS 2ROT
  3 NEEDS [']
  4 MARKER TASK
  5 : .BIN BASE @ >R 2 BASE ! . R> BASE ! ;
  6 CREATE TEST ," 6172.5 "
  7 \
  8 : FORGET-FP
  9   ['] NUMBER
 10   [ ' INTERPRET >BODY HEX 20 + ] LITERAL !
 11   TASK
 12 ;
 13 DECIMAL
 14 -->
 15 

Scr# 451 
  0 ( Floating Point Support )
  1 CODE FOP ( b -- ) HEX
  2 \ Floating point opration
  3   POP     HL|
  4   LD      A'|   L|
  5   LD()A   HERE 0 AA,
  6   PUSH    BC|
  7   RST     28|    HERE SWAP !
  8                  38 C, 38 C,
  9   POP     BC|
 10   NEXT
 11 C;
 12 -->
 13 
 14 
 15 

Scr# 452 
  0 ( Floating Point Support )
  1 CODE >W  ( d -- ) \ push to FP Stack
  2   POP     HL|
  3   POP     DE|
  4   PUSH    BC|
  5   RL       L|
  6   RL       H|
  7   RR       L|
  8   LDN     B'|  HEX FC  N,
  9 \ LD      B'|     E|
 10   LD      C'|     E|
 11   LD      E'|     L|
 12   LD      A'|     H|
 13 -->
 14 
 15 

Scr# 453 
  0 ( Floating Point Support )
  1   ANDA     A|
  2   JRF    NZ'|  HOLDPLACE
  3       LD      H'|    D|   \ swap C and D
  4       LD      D'|    C|
  5       LD      C'|    H|
  6   HERE DISP,
  7   CALL HEX 2AB6 AA,
  8   POP BC|
  9   NEXT
 10 C;
 11 -->
 12 
 13 
 14 
 15 

Scr# 454 
  0 ( Floating Point Support )
  1 CODE W>  ( -- d ) \ pop from FP Stack
  2   PUSH    BC|
  3   CALL   HEX 2BF1 AA,
  4   ANDA     A|
  5   JRF    NZ'|  HOLDPLACE
  6       LD      H'|    D|     \ swap C and D
  7       LD      D'|    C|
  8       LD      C'|    H|
  9   HERE DISP,
 10   LD      H'|     A|
 11   LD      L'|     E|
 12   LD      E'|     C|
 13 -->
 14 
 15 

Scr# 455 
  0 ( Floating Point Support )
  1   RL       L|
  2   RR       H|
  3   RR       L|
  4   POP     BC|
  5   PSH2
  6 C;
  7 -->
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 456 
  0 ( Floating Point Support )
  1 DECIMAL
  2 : FLOATING 1 NMODE ! ;
  3 : INTEGER  0 NMODE ! ;
  4 \
  5 : ',C,   ( b -- cccc ) ' , C, ;
  6 : FCHECK ( -- )        >R R@ @ EXECUTE R> ;
  7 : 0FOP1  ( a -- d )    CELL+ C@ FOP W> ;
  8 : 2>W    ( d d -- )    2SWAP >W >W ;
  9 : 1FOP1  <BUILDS ',C, DOES>
 10   FCHECK >R               >W R> 0FOP1           ;
 11 : 2FOP1  <BUILDS ',C, DOES>
 12   FCHECK >R           2>W    R> 0FOP1           ;
 13 : 2FOP2  <BUILDS ',C, DOES>
 14   FCHECK >R           2>W    R> 0FOP1  W> 2SWAP ;
 15 -->

Scr# 457 
  0 ( Floating Point Support )
  1 DECIMAL
  2 : ?FZERO  2DUP OR 0=  13 ?ERROR ;
  3 : ?FNEG   DUP     0<  11 ?ERROR ;
  4 : ?FNPOS  ?FNEG ?FZERO ;
  5 \
  6 03  2FOP1   F-        NOOP
  7 04  2FOP1   F*        NOOP
  8 05  2FOP1   F/        ?FZERO
  9 15  2FOP1   F+        NOOP
 10 27  1FOP1   FNEGATE   NOOP
 11 41  1FOP1   FSGN      NOOP
 12 42  1FOP1   FABS      NOOP
 13 50  2FOP2   F/MOD     ?FZERO
 14 06  2FOP1   F**       ?FNEG
 15 -->

Scr# 458 
  0 ( Floating Point Support )
  1 : (INTG)  ( d a -- d1 a1 )
  2   BEGIN
  3     1+ DUP >R          \ d a
  4     C@ BASE @ DIGIT    \ d n 1  |  d 0
  5   WHILE                \ d n    |  d
  6     0 2SWAP            \ d n 0
  7     BASE @ 0           \ d n 0 b 0
  8     F* F+              \ d
  9     R>                 \ d a
 10   REPEAT
 11   R>                   \ d a
 12 ;
 13 -->
 14 
 15 

Scr# 459 
  0 ( Floating Point Support )
  1 : (FRAC)   ( d a -- d1 a1 )
  2   1 0 ROT              \ d df a
  3   BEGIN
  4     1+ DUP >R          \ d df a
  5     C@ BASE @ DIGIT    \ d df n 1  |  d df 0
  6   WHILE                \ d df n    |  d df
  7     0 2SWAP            \ d dn df
  8     BASE @ 0 F/        \ d dn df
  9     2DUP 2ROT          \ d df df dn
 10     F* 2ROT F+         \ df d
 11     2SWAP 1 DPL +!     \ d df
 12     R>                 \ d df a
 13   REPEAT
 14   2DROP
 15   R> ; -->             \ d df a

Scr# 460 
  0 ( Floating Point Support )
  1 : (EXP)   ( d a -- d1 a1 )
  2   0 0 ROT (SGN) >R       \ d  0. a      R: s
  3   (NUMBER)               \ d  n. a
  4   R> SWAP >R >R          \ d  n.        R: a s
  5   DROP EXP !             \ d
  6   BASE @ 0               \ d  b.
  7   BEGIN
  8     EXP @ 0 2 UM/MOD
  9     EXP !
 10     IF
 11       2SWAP 2OVER R@
 12       IF F/ ELSE F* THEN
 13       2SWAP
 14     ENDIF
 15 -->

Scr# 461 
  0 ( Floating Point Support )
  1     2DUP
  2     F*
  3     EXP @ 0=
  4   UNTIL
  5   2DROP
  6   R>
  7   DROP
  8   R>
  9 ;
 10 -->
 11 
 12 
 13 
 14 
 15 

Scr# 462 
  0 ( Floating Point Support )
  1 : FNUMBER ( a -- d )
  2   NMODE @
  3   IF 0 0
  4     ROT (SGN) >R -1 DPL ! (INTG)
  5     DUP C@       [CHAR] . = IF 0 DPL ! (FRAC) THEN
  6     DUP C@ UPPER [CHAR] E = IF 1 DPL +! (EXP) THEN
  7     C@ BL - 0 ?ERROR
  8     R> IF FNEGATE THEN
  9 \   DPL @ 1+ IF 1 0 F/ THEN
 10   ELSE
 11     NUMBER  ( previous version )
 12   ENDIF
 13 ;
 14 ' FNUMBER ' INTERPRET >BODY HEX 20 + ! \ Patch Interpret.
 15 -->

Scr# 463 
  0 ( Floating Point Support )
  1 DECIMAL
  2 : F0< NIP 0< ;
  3 : F0> NIP 0> ;
  4 : F<  F- F0< ;
  5 : F>  2SWAP F< ;
  6 \
  7 37 1FOP1 FLN    ?FNPOS
  8 38 1FOP1 FEXP   NOOP
  9 39 1FOP1 FINT   NOOP
 10 40 1FOP1 FSQRT  ?FNEG
 11 58 1FOP1 FFIX   NOOP
 12 : FMOD    F/MOD 2DROP ;
 13 : FLOG10  FLN 10 0 FLN F/ ;
 14 -->
 15 

Scr# 464 
  0 ( Floating Point Support )
  1 DECIMAL
  2 : ?FTRG  2DUP FABS 1 0 F> 11 ?ERROR ;
  3 \
  4 31 1FOP1 FSIN    NOOP
  5 32 1FOP1 FCOS    NOOP
  6 33 1FOP1 FTAN    NOOP
  7 34 1FOP1 FARCSIN ?FTRG
  8 35 1FOP1 FARCCOS ?FTRG
  9 36 1FOP1 FARCTAN NOOP
 10 \
 11 NEEDS 2CONSTANT
 12 1 0 FARCTAN 4 0 F* 2CONSTANT PI
 13 -->
 14 
 15 

Scr# 465 
  0 ( Floating Point Support )
  1 : D>F
  2   DUP 0< >R DABS 0 SWAP 0
  3   0 [ HEX 4880 DECIMAL ] LITERAL
  4   F* F+
  5   R> IF FNEGATE THEN 1 0 F/
  6 ;
  7 : F>D
  8   DUP 0< >R FABS
  9   0 [ HEX 4880 DECIMAL ] LITERAL
 10   F/MOD FINT   SWAP  2SWAP FINT D+
 11   R> IF DNEGATE THEN
 12 ;
 13 : FLOAT S>D D>F ;
 14 : FIX   F>D DROP ;
 15 -->

Scr# 466 
  0 ( Floating Point Support )
  1 : F.R  ( d u -- )
  2   BASE @ >R DECIMAL           \ d u
  3   \
  4   >R <# 2DUP FABS 2DUP OR     \ d d f   Non-zero?
  5   IF FLOG10 F>D THEN          \ d e     magnitude 10^n
  6   TUCK DABS 2DUP >R >R        \ d s e   R: e
  7 \ OVER ABS PLACE @ >          \ d s e
  8   #S SIGN [CHAR] E HOLD 2DROP \
  9   10 0   R> R@  DABS  F**     \ d e     \ calc magnitude
 10   R> 0< IF F* ELSE F/ THEN    \ d       \ reduce mantissa
 11   TUCK FABS  10 0  PLACE @ 0  \ s d 10 n
 12 -->
 13 
 14 
 15 

Scr# 467 
  0 ( Floating Point Support )
  1   F** F*                             \ s d*10^n
  2   [ 1 0 2 0 F/ ] DLITERAL F+         \ rounded
  3   F>D PLACE @ ?DUP                   \
  4   IF 0 DO # LOOP [CHAR] . HOLD THEN  \ decimal part
  5   #S SIGN #> R> OVER - SPACES TYPE   \ integer part
  6   \
  7   R> BASE !                          \ restore base
  8 ;
  9 -->
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 468 
  0 ( Floating Point Support )
  1 : F. 0 F.R SPACE ;
  2 : PLACES PLACE ! ;
  3 \
  4 : FP-INIT
  5   ['] FNUMBER [ ' INTERPRET >BODY HEX 20 + ] LITERAL !
  6 ;
  7 DECIMAL
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 469 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 470 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 471 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 472 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 473 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 474 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 475 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 476 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 477 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 478 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 479 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 480 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 481 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 482 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 483 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 484 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 485 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 486 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 487 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 488 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 489 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 490 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 491 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 492 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 493 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 494 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 495 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 496 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 497 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 498 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 499 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 500 
  0 ( Next Registers )
  1 \ HEX 253B CONSTANT REG-DATA
  2 \ HEX 243B CONSTANT REG-SELECT
  3 \ : REG-RD ( p -- v ) REG-SELECT P! REG-DATA P@ ;   \ REG@
  4 \ : REG-WR ( v p -- ) REG-SELECT P! REG-DATA P! ;   \ REG!
  5 \
  6 : B.  ( n -- ) \ display a number in binary
  7  BASE @ >R  S>D  2DUP HEX <# # # #> TYPE SPACE
  8  2 BASE ! <# 8 0 DO # LOOP #> TYPE  R> BASE ! ;
  9 \
 10 CR ." Machine ID    " 00 REG@   B.
 11 CR ." Core Version  " 01 REG@   B.
 12 CR ." Machine type  " 03 REG@   B.
 13 CR ." CPU Speed     " 07 REG@   7 AND DUP .
 14 DECIMAL 35 SWAP LSHIFT S>D <# # CHAR . HOLD #S #>
 15 SPACE TYPE SPACE ." MHz" CR

Scr# 501 
  0 ( Next Registers )
  1 HEX
  2 CR ." Reset         " 02 REG@   B.
  3 CR ." Peripheal 1   " 05 REG@   B.
  4 CR ." Peripheal 2   " 06 REG@   B.
  5 CR ." Peripheal 3   " 08 REG@   B.
  6 CR ." Peripheal 4   " 09 REG@   B.
  7 CR ." Core Boot     " 10 REG@   B.
  8 CR ." Video Timing  " 11 REG@   B.
  9 CR ." Layer 2 Active RAM Bank " 12 REG@   B.
 10 CR ." Layer 2 Shadow RAM Bank " 13 REG@   B.
 11 CR ." Global Transparency Colour " 14 REG@   B.
 12 CR ." Sprite and Layer System Setup " 15 REG@   B.
 13 CR ." Layer 2 Horizontal Scroll Control " 16 REG@   B.
 14 CR ." Layer 2 Vertical Scroll Control   " 17 REG@   B.
 15 -->

Scr# 502 
  0 ( Next Registers )
  1 HEX
  2 CR ." Layer 2 Clip Window Definition    " 18 REG@   B.
  3 CR ." Sprites Clip Window Definition    " 19 REG@   B.
  4 CR ." Layer 0 Clip Window Definition    " 1A REG@   B.
  5 CR ." Layer 3 Clip Window Definition    " 1B REG@   B.
  6 CR ." Clip Window Control               " 1C REG@   B.
  7 CR ." Active Video Line " 1E REG@   100 * 1F REG@   + .
  8 CR ." Line Interrupt Control      " 22 REG@   .
  9 CR ." Line Interrupt Value        " 23 REG@   .
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 503 
  0 ( Next Registers )
  1 HEX
  2 CR ." ULA Horizontal Scroll Control " 26 REG@   .
  3 CR ." ULA Vertical   Scroll Control " 27 REG@   .
  4 CR ." Stored Palette Value  " 28 REG@   .
  5 CR ." Layer 3 Horizontal Scroll Control "
  6                           2F REG@   100 * 30 REG@   + .
  7 CR ." Layer 3 Vetical Scroll Control " 31 REG@   .
  8 CR ." Layer 1,0 Horizontal Scroll Control " 32 REG@   .
  9 CR ." Layer 1,0 Vertical   Scroll Control " 33 REG@   .
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 504 
  0 ( Next Registers )
  1 HEX
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 505 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 506 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 507 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 508 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 509 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 510 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 511 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 512 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 513 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 514 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 515 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 516 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 517 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 518 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 519 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 520 
  0 ( LAYER 2 palette picker )
  1 MARKER TASK
  2 \
  3 NEEDS VALUE    NEEDS TO
  4 NEEDS CALL#
  5 NEEDS LAYER2   NEEDS LAYER12
  6 NEEDS CASE
  7 -->
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 521 
  0 ( LAYER 2 palette picker )
  1 decimal
  2 \ compose Layer2 BRG color given its component b g r
  3 : BGR ( b g r -- n )
  4   8 * + 4 * + ;
  5 \
  6 0 0 5 BGR constant KRED
  7 0 5 0 BGR constant KGRN
  8 2 0 0 BGR constant KBLU
  9 2 5 5 BGR constant KWHT
 10 \
 11 0 value RED   0 value GRN   0 value BLU
 12 0 value dy    0 value dx    0 value COL
 13 0 value x     0 value y
 14 : RGB? RED . GRN . BLU . ;
 15 -->

Scr# 522 
  0 ( LAYER 2 palette picker )
  1 \
  2 \ array that keep track of color behind each cell
  3 \
  4 create ARY  22 22 * ALLOT
  5 : ARY!  ( c x y -- )
  6   22 * + ARY + c! ;
  7 : ARY@  ( x y -- c )
  8   22 * + ARY + c@ ;
  9 \
 10 \ to display big square
 11 create h-bar ,"  ---- "
 12 create v-bar ," |    |"
 13 -->
 14 
 15 

Scr# 523 
  0 ( LAYER 2 palette picker )
  1 \
  2 \ standard  Colors
  3 HEX
  4 : border.   2297 CALL# DROP ;
  5 DECIMAL
  6 : at.       22 emitc  swap  emitc emitc ;
  7 : ink.      16 emitc   emitc ;
  8 : paper.    17 emitc   emitc ;
  9 : condensed 30 emitc 4 emitc ;
 10 : large     30 emitc 8 emitc ;
 11 \
 12 -->
 13 
 14 
 15 

Scr# 524 
  0 ( LAYER 2 palette picker )
  1 : scr-init
  2   LAYER2 large  7 border. 0 ink. KWHT paper. CLS
  3   22  0 at. ." Use CURSOR KEYS to move"
  4   23  0 at. ." ENTER stops and returns byte"
  5    3 22 at. KRED ink. ." 32 x RED"
  6    4 22 at. KGRN ink. ."  4 x GREEN"
  7    5 22 at. KBLU ink. ."  1 x BLUE"     0 ink.
  8    8 24 at. h-bar count type
  9   13 9 do i 24 at. v-bar count type loop
 10   13 24 at. h-bar count type
 11 ;
 12 : scr-done
 13   1 border. LAYER12
 14 ;
 15 -->

Scr# 525 
  0 ( LAYER 2 palette picker )
  1 \
  2 \ to display and populate ARY
  3 : set-block ( q -- )
  4   case
  5     0 of     red       grn    endof
  6     1 of  15 red -     grn    endof
  7     2 of  15 red -  15 grn -  endof
  8     3 of     red    15 grn -  endof
  9   endcase
 10   3 + to y
 11   3 + to x
 12   x y at. col ink.  143 emitc
 13   col x y ary!
 14 ;
 15 -->

Scr# 526 
  0 ( LAYER 2 palette picker )
  1 \
  2 \ display contour numeric frame
  3 : draw-frame ( -- )
  4   GRN 0= if
  5     KRED ink.
  6     03 RED + 1 AT. RED 1 .R  03 RED + 20 AT. RED 1 .R
  7     18 RED - 1 AT. RED 1 .R  18 RED - 20 AT. RED 1 .R
  8   endif
  9   RED 0= if
 10     KGRN ink.
 11     20 y AT. GRN 1 .R   1 y AT. GRN 1 .R
 12   endif
 13 ;
 14 -->
 15 

Scr# 527 
  0 ( LAYER 2 palette picker )
  1 \
  2 \ to complete numeric frame
  3 : draw-corner ( q -- )
  4   case
  5     0   of 01 01 endof
  6     1   of 20 01 endof
  7     3   of 01 20 endof
  8     2   of 20 20 endof
  9   endcase
 10   AT.  KBLU ink.  BLU 1 .R
 11 ;
 12 -->
 13 
 14 
 15 

Scr# 528 
  0 ( LAYER 2 palette picker )
  1 \
  2 \ each single square: q is the quadrant
  3 : draw-block ( q -- )
  4   BLU GRN RED BGR  TO COL
  5   dup set-block
  6   draw-corner
  7   draw-frame
  8 ;
  9 -->
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 529 
  0 ( LAYER 2 palette picker )
  1 : draw-grid
  2   8 0 do
  3     i to RED
  4     8 0 do
  5       i to GRN
  6       0 to BLU 0 draw-block
  7       1 to BLU 1 draw-block
  8       2 to BLU 2 draw-block
  9       3 to BLU 3 draw-block
 10     loop
 11   loop
 12 ;
 13 -->
 14 
 15 

Scr# 530 
  0 ( LAYER 2 palette picker )
  1 \ display big squared-sample
  2 : sample
  3   x y ary@ ink.
  4   13 09 DO
  5     i 25 at. 143 dup 2dup emitc emitc emitc emitc
  6   LOOP
  7 ;
  8 : display-numbers
  9   0 ink.  [char] 0 to BL
 10   x y ary@  DUP DUP
 11   19 24 at.   2 base ! 8 .R
 12   15 24 at.   [char] $ emit  hex 2 .R
 13   17 24 at.   decimal  3 .R   32 to BL
 14 ;
 15 -->

Scr# 531 
  0 ( LAYER 2 palette picker )
  1 \
  2 \ decide cursor movement from character given
  3 : direction ( c -- )
  4   case
  5   [char] 7 of x 1 -  3 max to x endof
  6   [char] 8 of y 1 + 18 min to y endof
  7   [char] 5 of y 1 -  3 max to y endof
  8   [char] 6 of x 1 + 18 min to x endof
  9   endcase
 10 ;
 11 -->
 12 
 13 
 14 
 15 

Scr# 532 
  0 ( LAYER 2 palette picker )
  1 : COLOR-PICKER
  2   scr-init draw-grid  3 to x  3 to y
  3   begin
  4     sample display-numbers
  5     0 ink.  x y at. key
  6   dup 13 - while
  7     x y ary@ ink. x y at. 143 emitc
  8     direction
  9   repeat drop
 10   condensed scr-done
 11 ;
 12 : PICK-COLOR ( -- b )
 13   color-picker x y ary@
 14 ;
 15 

Scr# 533 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 534 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 535 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 536 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 537 
  0 ( VALUE TO )
  1 NEEDS [']
  2 : (TO) ( xt -- ccc )
  3   ' >BODY  STATE @
  4   IF COMPILE LIT  ,  ,
  5   ELSE SWAP EXECUTE THEN
  6 ;
  7 : TO ( n -- ccc )
  8   ['] !   (TO)
  9 ; IMMEDIATE
 10 \
 11 : +TO ( n -- ccc )
 12   ['] +!  (TO)
 13 ; IMMEDIATE
 14 -->
 15 

Scr# 538 
  0 \ test
  1 : VALUE ( x ccc -- )
  2         ( -- n )
  3  [COMPILE] CONSTANT
  4 ; IMMEDIATE
  5 \
  6 EXIT
  7 123 VALUE XXX
  8 456 VALUE YYY
  9 789 VALUE ZZZ
 10 XXX    TO ZZZ
 11 : TEST
 12  ZZZ TO YYY
 13 ;
 14 
 15 

Scr# 539 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 540 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 541 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 542 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 543 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 544 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 545 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 546 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 547 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 548 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 549 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 550 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 551 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 552 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 553 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 554 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 555 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 556 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 557 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 558 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 559 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 560 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 561 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 562 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 563 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 564 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 565 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 566 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 567 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 568 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 569 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 570 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 571 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 572 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 573 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 574 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 575 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 576 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 577 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 578 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 579 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 580 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 581 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 582 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 583 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 584 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 585 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 586 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 587 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 588 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 589 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 590 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 591 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 592 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 593 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 594 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 595 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 596 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 597 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 598 
  0 \ kempston test
  1  marker task
  2 \
  3  : .bin
  4    base @ >r 2 base ! . r> base !
  5  ;
  6  : test
  7    begin
  8      0 0 at.
  9      31  p@
 10      . space
 11    ?terminal
 12    until
 13  ;
 14  \
 15 EXIT

Scr# 599 
  0 \ kempston test
  1 marker task
  2 needs at.
  3 : test
  4   begin
  5     223 p@ 0 0 at. . 3 spaces
  6   ?terminal until
  7 ;
  8 \
  9 EXIT
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 600 
  0 .( Chomp.f )
  1 MARKER TASK
  2 FORTH DEFINITIONS CASEOFF
  3 FLUSH EMPTY-BUFFERS
  4 NEEDS VALUE  NEEDS TO  NEEDS CASE
  5 NEEDS LAYERS
  6 NEEDS SPEED!
  7 NEEDS CHOOSE     \ random numbers
  8 decimal  50 load \ bleep
  9 decimal  41 load \ attributes
 10 decimal 601 load
 11 decimal 610 load
 12 decimal 630 load
 13 decimal 650 load
 14 decimal 660 load
 15 \

Scr# 601 
  0 ( Chomp.f )
  1 CODE sync-vid HEX
  2  76 C,       \ halt
  3  DD C, E9 C, \ jp (ix)
  4  smudge
  5 \
  6 : c+! ( n a )
  7   tuck c@ + swap c! ;
  8 \
  9 : d+! ( n a )
 10   tuck 2@      \ a n d
 11   rot s>d d+  \ a d+n
 12   rot 2! ;
 13 decimal
 14 -->
 15 

Scr# 602 
  0 ( Chomp.f )
  1 : b.     ( n -- )
  2   base @ swap 2 base !
  3   8 .r  base ! ;
  4 \ double equals
  5 : D= ( d1 d2 -- f )
  6   rot =      \ l1 l2 h2=h1
  7   swap rot   \ h1=h2 l2 l1
  8   = and ;
  9 \ true if n between a and b
 10 : between ( n a b -- f )
 11   rot tuck < 0= \ a n b>n
 12   swap rot < 0= \ b>n n>a
 13   and ;
 14 -->
 15 

Scr# 603 
  0 ( Chomp.f )
  1 : six-emitc
  2   emitc emitc emitc
  3   emitc emitc emitc ;
  4 \
  5 : sync-emit
  6   sync-vid
  7   emitc emitc emitc emitc
  8   emitc emitc emitc emitc
  9   emitc emitc emitc emitc ;
 10 \
 11 -->
 12 
 13 
 14 
 15 

Scr# 604 
  0 ( Chomp.f )
  1 decimal 23560 constant LASTK
  2  0 variable total 0 ,
  3  0 variable score 0 ,
  4  0 variable high-score 0 ,
  5 30 variable counting
  6  3 variable lives
  7  1 variable hunt
  8 -->
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 605 
  0 ( Chomp.f )
  1 : pill-on
  2   -1 hunt !
  3   10  total d+!
  4   0 counting ! ;
  5 \
  6 : bip ( n1 n2 -- n3 n4 )
  7   beep-pitch
  8   bleep-calc
  9   swap ;
 10 \
 11 : 2lit ( n1 n2 -- )
 12   [compile] literal
 13   [compile] literal
 14 ; immediate -->
 15 

Scr# 606 
  0 ( Chomp.f )
  1   char 8  value    key-right
  2   char 5  value    key-left
  3   char 7  value    key-up
  4   char 6  value    key-down
  5        9  value    key+right
  6        8  value    key+left
  7       11  value    key+up
  8       10  value    key+down
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 607 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 608 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 609 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 610 
  0 .( Chomp.f - UDG )
  1 decimal
  2 : UDG+ ( c1 -- c2 )
  3  upper 79 + ;
  4 \ compile and UDG literal
  5 : [UDG] ( -- )
  6  char UDG+ [compile] literal ;
  7  IMMEDIATE
  8 \ given c return UDG address
  9 : UDG@ ( c -- a )
 10  upper 65 - 8 * 23675 @ + ;
 11 \ given c print binary repres.
 12 : .UDG ( c -- )
 13  cr UDG@ dup 8 + swap do
 14   i c@ b.     cr
 15  loop ; -->

Scr# 611 
  0 ( Chomp.f - UDG )
  1 : UDGize ( a -- )
  2  count over + swap do
  3   i c@ upper [char] A [char] U
  4   between if
  5    i c@ upper UDG+ i c!
  6   endif
  7  loop ;
  8 \
  9 : Gtype ( a c -- )
 10  over + swap ?do
 11   i c@ emitc loop ;
 12 : UDGs
 13   [char] V [char] A do
 14    i UDG+ emitc loop ;
 15 -->

Scr# 612 
  0 ( Chomp.f - UDG )
  1 create UDG_1
  2 hex
  3 FF00 , 0000 , 0000 , 0000 , \ A
  4 0000 , 0000 , 0000 , 00FF , \ B
  5 FF00 , 0000 , 0000 , 00FF , \ C
  6 F800 , 0204 , 0202 , 0202 , \ D
  7 1F00 , 4020 , 4040 , 4040 , \ E
  8 3F00 , 8040 , 4080 , 003F , \ F
  9 FC00 , 0102 , 0201 , 00FC , \ G
 10 0202 , 0202 , 0402 , 00F8 , \ H
 11 4040 , 4040 , 2040 , 001F , \ I
 12 0202 , 0202 , 0202 , 0202 , \ J
 13 -->
 14 
 15 

Scr# 613 
  0 ( Chomp.f - UDG )
  1 hex
  2 1800 , 4224 , 4242 , 4242 , \ K
  3 4242 , 4242 , 2442 , 0018 , \ L
  4 4040 , 4040 , 4040 , 4040 , \ M
  5 4242 , 4242 , 4242 , 4242 , \ N
  6 0000 , 7C38 , 7C7C , 0038 , \ O
  7 3E1C , 0F1F , 3E1F , 001C , \ P
  8 2200 , 7F77 , 3E7F , 001C , \ Q
  9 1C00 , 7C3E , 7C78 , 1C3E , \ R
 10 3800 , FE7C , EEFE , 0044 , \ S
 11 7E38 , DB5A , FFFF , 93FF , \ T
 12 0602 , 140A , EE24 , 66EE , \ U
 13 UDG_1 5C7B ! \ UDG
 14 -->
 15 

Scr# 614 
  0 .( Chomp.f - maze )
  1 decimal
  2 21 constant maze-h
  3 21 constant maze-w
  4 create maze-run
  5 24 21 * allot
  6 create maze-base
  7 -->
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 615 
  0 ( Chomp.f - maze )
  1 ," EAAAAAAAAANAAAAAAAAAD "
  2 ," M.........N.........J "
  3 ," M.EAD.EAD.N.EAD.EAD.J "
  4 ," MOM J.M J.N.M J.M JOJ "
  5 ," M.IBH.IBH.L.IBH.IBH.J "
  6 ," M...................J "
  7 ," M.FCG.K.FCACG.K.FCG.J "
  8 ," M.....N...N...N.....J "
  9 ," IBBBB.MCG.L.FCJ.BBBBH "
 10 ,"     J.N.......N.M     "
 11 ," BBBBH.L.E---D.L.IBBBB "
 12 -->
 13 
 14 
 15 

Scr# 616 
  0 ( Chomp.f - maze )
  1 ," /.......M   J.......\ "
  2 ," AAAAD.K.I---H.K.EAAAA "
  3 ,"     J.N.... ..N.N     "
  4 ," BBBBH.L.FCACG.L.IBBBB "
  5 ," M.........N.........J "
  6 ," MOFCD.FCG.L.FCG.ECGOJ "
  7 ," M...N...........N...J "
  8 ," AAD.L.FCCCCCCCG.L.EAA "
  9 ,"   J...............M   "
 10 ,"    AAAAAAAAAAAAAAA    "
 11 -->
 12 
 13 
 14 
 15 

Scr# 617 
  0 ( Chomp.f - maze )
  1 decimal
  2 : maze-copy ( a1 a2 -- )
  3  maze-h 0 do
  4   2dup 24 cmove
  5   dup udgize
  6   swap 24 + swap 24 +
  7  loop
  8  2drop ;
  9 \
 10 : set-maze-run
 11   maze-base
 12   maze-run
 13   maze-copy ;
 14 set-maze-run
 15 -->

Scr# 618 
  0 ( Chomp.f - maze )
  1 : maze^ ( x y -- a )
  2  maze-run + swap 1-
  3  24 * + ;
  4 \
  5 : maze@ ( x y -- c )
  6  maze^ c@ ;
  7 \
  8 : maze! ( c x y -- )
  9  maze^ c! ;
 10 \
 11 -->
 12 
 13 
 14 
 15 

Scr# 619 
  0 ( Chomp.f - maze )
  1 : maze.
  2  0 0 at.
  3  1 22 do
  4   025 i 16 +
  5   beep-pitch bleep-calc
  6  -1 +loop
  7  maze-run
  8  22 1 do
  9   cr space
 10   dup count gtype 24 +
 11  >R bleep R>
 12  loop
 13  drop
 14 ;
 15 -->

Scr# 620 
  0 .( Chomp.f - Sprite )
  1 create Array   6 08 * allot
  2 0 variable Sprite^
  3 0 value    Sprite-no
  4 : sprite# ( n -- )
  5   dup 3 lshift array +
  6   sprite^ ! to sprite-no ;
  7 \
  8 : sprite@ ( -- a )
  9   sprite^ @ ;
 10 \
 11 : all-ghost  ( v i -- )
 12   32 Array  + swap Array  +
 13   do dup i c! 08 +loop
 14   drop ;
 15 -->

Scr# 621 
  0 ( Chomp.f - Sprite )
  1 \ creates an index of Ghost
  2 : index-of ( n -- )
  3   <builds c, does> c@ + ;
  4 \ creates a ghost pointer
  5 : name-of  ( n -- creates )
  6   <builds c, does> c@ dup
  7   3 lshift Array + sprite^ !
  8   to sprite-no ;
  9 -->
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 622 
  0 ( Chomp.f - Sprite )
  1 \ array index by name
  2 0 name-of Inky
  3 1 name-of Pinky
  4 2 name-of Blinky
  5 3 name-of Ted
  6 \
  7 0 index-of face
  8 1 index-of color
  9 2 index-of x-pos
 10 3 index-of y-pos
 11 4 index-of dir
 12 5 index-of x-pre
 13 6 index-of y-pre
 14 7 index-of maze
 15 -->

Scr# 623 
  0 ( chomp.f - Sprite )
  1 \ shorthand for x-pos,y-pos
  2 : xy-pos@  ( -- x y )
  3   sprite@
  4   dup    x-pos c@
  5   swap   y-pos c@ ;
  6 : xy-pre@  ( -- x y )
  7   sprite@
  8   dup    x-pre c@
  9   swap   y-pre c@ ;
 10 : xy-pre! ( x y -- )
 11   >R sprite@ x-pre c!
 12   R> sprite@ y-pre c! ;
 13 \
 14 -->
 15 

Scr# 624 
  0 ( Chomp.f - Sprite )
  1 : Ghost-color ( -- )
  2  Inky   1 sprite@ color c!
  3  Pinky  3 sprite@ color c!
  4  Blinky 5 sprite@ color c!
  5  Ted    2 sprite@ color c!
  6 ;
  7 : Ghost-white ( -- )
  8  7  0 color  all-ghost
  9 ;
 10 ghost-color
 11 -->
 12 
 13 
 14 
 15 

Scr# 625 
  0 ( Chomp.f - Sprite )
  1 : Ghost-init  ( -- )
  2  12 0 x-pos  all-ghost
  3  11 0 y-pos  all-ghost
  4  55 0 dir    all-ghost
  5  bl 0 maze   all-ghost
  6  Inky   10 sprite@ y-pos c!
  7  Inky   xy-pos@ xy-pre!
  8  Pinky  12 sprite@ y-pos c!
  9  Pinky  xy-pos@ xy-pre!
 10  Ted    11 sprite@ x-pos c!
 11  Ted    xy-pos@ xy-pre!
 12  Blinky xy-pos@ xy-pre!
 13  [char] T udg+
 14  0 face all-ghost
 15 ; -->

Scr# 626 
  0 ( Chomp.f - Sprite )
  1 4 name-of Pacman
  2 : pacman-init
  3   Pacman [char] R UDG+
  4      sprite@ face  c!
  5   14 sprite@ x-pos c!
  6   12 sprite@ y-pos c!
  7   14 sprite@ x-pre c!
  8   12 sprite@ y-pre c!
  9    6 sprite@ color c!
 10   56 sprite@ dir   c!
 11   bl sprite@ maze  c!
 12 ;
 13 ghost-init
 14 pacman-init
 15 -->

Scr# 627 
  0 ( Chomp.f - Sprite )
  1 5 name-of Cherry
  2 : cherry-init
  3   Cherry [char] U UDG+
  4      sprite@ face  c!
  5   14 sprite@ x-pos c!
  6   12 sprite@ y-pos c!
  7   14 sprite@ x-pre c!
  8   12 sprite@ y-pre c!
  9    2 sprite@ color c!
 10   00 sprite@ dir   c!
 11   bl sprite@ maze  c!
 12 ;
 13 cherry-init -->
 14 
 15 

Scr# 628 
  0 ( Chomp.f - Sprite )
  1 \ draw current sprite
  2 : sprite-put ( -- )
  3   sprite@ face  c@
  4   sprite@ color c@   16
  5   xy-pos@ swap      22
  6   sprite@ maze  c@
  7   xy-pre@ swap      22
  8   4 16
  9   sync-emit
 10 ;
 11 \ usage:
 12 \ Blinky  sprite-put
 13 -->
 14 
 15 

Scr# 629 
  0 ( Chomp.f )
  1 : init-all
  2   ghost-init
  3   pacman-init
  4   cherry-init
  5   00 counting !
  6   key-right LASTK c!
  7 ;
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 630 
  0 .( Chomp.f - trail )
  1 : ?pac-trail  ( c -- )
  2  case
  3   bl       of 1 endof
  4   [char] . of 1 endof
  5   [udg]  U of 1 endof
  6   [udg]  O of 1 endof
  7   [char] / of 1 endof
  8   [char] \ of 1 endof
  9   0 swap
 10  endcase ;
 11 -->
 12 
 13 
 14 
 15 

Scr# 631 
  0 ( Chomp.f - trail )
  1 : ?ghost-trail  ( c -- )
  2  case
  3   bl       of 1 endof
  4   [char] . of 1 endof
  5   [udg]  U of 1 endof
  6   [udg]  O of 1 endof
  7   [char] - of 1 endof
  8   0 swap
  9  endcase ;
 10 -->
 11 
 12 
 13 
 14 
 15 

Scr# 632 
  0 ( Chomp.f - trail )
  1 : go-right
  2   Pacman
  3   xy-pos@      1+      maze@
  4   dup [char] \ = if
  5    1 sprite@ y-pos c!
  6   endif
  7   ?pac-trail if
  8    [char] R UDG+
  9    sprite@ face  c!
 10    1  sprite@ y-pos c+!
 11 \ else 2 choose if key-up
 12 \  else key-down then
 13 \  sprite@ dir c!
 14   endif ;
 15 -->

Scr# 633 
  0 ( Chomp.f - trail )
  1 : go-left
  2   Pacman
  3   xy-pos@      1-      maze@
  4   dup [char] / = if
  5    21 sprite@ y-pos c!
  6   endif
  7   ?pac-trail if
  8    [char] P UDG+
  9     sprite@ face  c!
 10    -1 sprite@ y-pos c+!
 11 \ else 2 choose if key-up
 12 \  else key-down then
 13 \  sprite@ dir c!
 14   endif ;
 15 -->

Scr# 634 
  0 ( Chomp.f - trail )
  1 : go-up
  2   Pacman
  3   xy-pos@ swap 1- swap maze@
  4   ?pac-trail if
  5    [char] Q UDG+
  6    sprite@ face  c!
  7    -1 sprite@ x-pos c+!
  8 \ else 2 choose if
  9 \  key-right else key-left then
 10 \  sprite@ dir c!
 11   endif ;
 12 -->
 13 
 14 
 15 

Scr# 635 
  0 ( Chomp.f - trail )
  1 : go-down
  2   Pacman
  3   xy-pos@ swap 1+ swap maze@
  4   ?pac-trail if
  5    [char] S UDG+
  6    sprite@ face  c!
  7    1  sprite@ x-pos c+!
  8 \ else 2 choose if
  9 \  key-left else key-right then
 10 \  sprite@ dir c!
 11   endif ;
 12 -->
 13 
 14 
 15 

Scr# 636 
  0 ( Chomp.f - trail )
  1 : pacman-move ( c -- )
  2  case
  3  key-right of go-right endof
  4  key-left  of go-left  endof
  5  key-up    of go-up    endof
  6  key-down  of go-down  endof
  7  endcase
  8  31 p@ case
  9  1         of go-right endof
 10  2         of go-left  endof
 11  4         of go-down  endof
 12  8         of go-up    endof
 13  endcase
 14 ;
 15 -->

Scr# 637 
  0 ( Chomp.f - trail )
  1 : pacman-eat-pill ( c -- )
  2   [udg] O = if
  3    -1 hunt !
  4    10 score d+!
  5    10 total d+!
  6    [ 50 25 bip ] 2lit bleep
  7    [ 50 39 bip ] 2lit bleep
  8    0 counting !
  9    ghost-white
 10   endif ;
 11 \
 12 -->
 13 
 14 
 15 

Scr# 638 
  0 ( Chomp.f - trail )
  1 : pacman-walk ( c -- )
  2   >r r@ [udg]  O =
  3      r@ [char] . = or
  4      r> [udg]  U = or
  5   0= if
  6    pacman
  7    xy-pos@ xy-pre@ d=
  8    0= if
  9 \   [ 12 -14 bip ] 2lit
 10 \   bleep
 11    endif
 12   endif
 13 ;
 14 -->
 15 

Scr# 639 
  0 ( Chomp.f - trail )
  1 : pacman-eat-cherry ( c -- )
  2   [udg] U = if
  3    10 score d+!
  4    10 total d+!
  5    [ 50 29 bip ] 2lit bleep
  6    [ 50 36 bip ] 2lit bleep
  7   endif ; -->
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 640 
  0 ( Chomp.f - ghost )
  1 : ghost-right ( c -- )
  2   xy-pos@ 1+ maze@
  3   ?ghost-trail if
  4      1  sprite@ y-pos c+!
  5   else
  6    2 choose if
  7     key-down
  8    else
  9     key-up
 10    endif
 11    sprite@ dir c!
 12   endif
 13 ;
 14 -->
 15 

Scr# 641 
  0 ( Chomp.f - ghost )
  1 : ghost-left  ( c -- )
  2   xy-pos@ 1- maze@
  3   ?ghost-trail if
  4     -1  sprite@ y-pos c+!
  5   else
  6    2 choose if
  7     key-up
  8    else
  9     key-down
 10    endif
 11    sprite@ dir c!
 12   endif
 13 ;
 14 -->
 15 

Scr# 642 
  0 ( Chomp.f - ghost )
  1 : ghost-down  ( c -- )
  2   xy-pos@ swap 1+ swap maze@
  3   ?ghost-trail if
  4      1  sprite@ x-pos c+!
  5   else
  6    2 choose if
  7     key-right
  8    else
  9     key-left
 10    endif
 11    sprite@ dir c!
 12   endif
 13 ;
 14 -->
 15 

Scr# 643 
  0 ( Chomp.f - ghost )
  1 : ghost-up    ( c -- )
  2   xy-pos@ swap 1- swap maze@
  3   ?ghost-trail if
  4     -1  sprite@ x-pos c+!
  5   else
  6    2 choose if
  7     key-left
  8    else
  9     key-right
 10    endif
 11    sprite@ dir c!
 12   endif
 13 ;
 14 -->
 15 

Scr# 644 
  0 ( Chomp.f - ghost )
  1 : ghost-move ( c -- )
  2  case
  3   key-right of
  4    ghost-right endof
  5   key-left  of
  6    ghost-left  endof
  7   key-up    of
  8    ghost-up    endof
  9   key-down  of
 10    ghost-down  endof
 11  endcase ;
 12 \
 13 -->
 14 
 15 

Scr# 645 
  0 ( Chomp.f - ghost )
  1 : ghost-decision ( -- )
  2   xy-pos@ xy-pre@ d= if
  3    4 choose
  4    case
  5    0 of key-left  endof
  6    1 of key-down  endof
  7    2 of key-up    endof
  8    3 of key-right endof
  9    endcase
 10   endif
 11   sprite@ dir c!
 12 ;
 13 -->
 14 
 15 

Scr# 646 
  0 ( Chomp.f - trail )
  1 \
  2 : pacman-eat-dot ( c -- )
  3   [char] . = if
  4    1  score d+!
  5 \  [ 12 -12 bip ] 2lit
  6 \  bleep
  7   endif ;
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 647 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 648 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 649 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 650 
  0 ( Chomp.f )
  1 : init-display
  2  0 paper. 0 border. 4 ink.
  3  cls maze.
  4  0 20 at. ." high "
  5  high-score 2@
  6  <# # # # # # # #> type
  7  5 0 do
  8   i  sprite#
  9   sprite-put
 10  loop
 11 ;
 12 -->
 13 
 14 
 15 

Scr# 651 
  0 ( Chomp.f )
  1 : inter-hunt
  2   0 27 do
  3    10 i at. sync-vid
  4    7 16 bl emit emitc emitc
  5    [udg] T emitc sync-vid
  6    bl bl emitc emitc
  7    6 16 emitc emitc
  8    [udg] P emitc
  9    bl emit sync-vid
 10    bleep
 11    ?terminal if quit then
 12   -1 +loop ;
 13  -->
 14 
 15 

Scr# 652 
  0 ( Chomp.f )
  1 : inter-flee
  2   28 1 do
  3    10 i at. sync-vid
  4    3 16 bl emit emitc emitc
  5    [udg] T emitc sync-vid
  6    bl bl emitc emitc
  7    6 16 emitc emitc
  8    [udg] R emitc
  9    sync-vid
 10    bleep
 11    ?terminal if quit then
 12   1 +loop ;
 13  -->
 14 
 15 

Scr# 653 
  0 ( Chomp.f - Interlude )
  1 : inter-sound
  2   27 0 do
  3    012 i bip swap
  4   01 +loop
  5   1 28 do
  6    012 i bip swap
  7   -1 +loop ;
  8 \
  9 : interlude
 10   inter-sound cls
 11   10 30 at.
 12   [udg]  O  emitc
 13   inter-flee
 14   inter-hunt ;
 15 -->

Scr# 654 
  0 ( Chomp.f )
  1 : catch? ( -- f )
  2   pacman xy-pos@
  3   inky   xy-pos@ d=
  4   pacman xy-pos@
  5   pinky  xy-pos@ d=
  6   pacman xy-pos@
  7   blinky xy-pos@ d=
  8   pacman xy-pos@
  9   ted    xy-pos@ d=
 10   or or or ;
 11 -->
 12 
 13 
 14 
 15 

Scr# 655 
  0 ( Chomp.f )
  1 : ghost-eaten ( n -- )
  2   sprite#
  3   12 sprite@ x-pos c!
  4   12 sprite@ y-pos c!
  5   bl sprite@ maze  c!
  6   10 score d+!
  7   10 total d+!
  8   [  5 20 bip ] 2lit bleep
  9   [  5 10 bip ] 2lit bleep
 10   [ 10 10 bip ] 2lit bleep
 11 ;
 12 -->
 13 
 14 
 15 

Scr# 656 
  0 ( Chomp.f )
  1 : ghost-catch
  2   -1 lives +!
  3   lives @ 0= if
  4    high-score 2@ score 2@
  5    dnegate d+ 0< if
  6      score 2@ high-score 2!
  7    endif
  8    0. score 2!
  9    180. total 2!
 10   endif
 11   init-all
 12   interlude
 13   init-display ;
 14 -->
 15 

Scr# 657 
  0 ( Chomp.f )
  1 : catch!
  2   hunt @ 1 = if
  3    ghost-catch
  4   else
  5    4 0 do
  6     i sprite# xy-pos@
  7     pacman    xy-pos@ d= if
  8      i ghost-eaten
  9     endif
 10    loop
 11   endif ;
 12 -->
 13 
 14 
 15 

Scr# 658 
  0 ( Chomp.f )
  1 : count-down
  2   hunt @ -1 = if 1 counting +!
  3    56 counting @ < if
  4     ghost-color endif
  5    57 counting @ < if
  6     ghost-white endif
  7    58 counting @ < if
  8     ghost-color endif
  9    59 counting @ < if
 10     ghost-white endif
 11    60 counting @ < if
 12     ghost-color
 13     1 hunt ! endif
 14   endif
 15 ; -->

Scr# 659 
  0 ( Chomp.f )
  1 : put-cherry
  2   100 choose 0= if
  3    cherry sprite-put
  4    [udg] U xy-pos@ maze!
  5   endif ;
  6 \
  7 : key-decode ( c1 -- c2 )
  8   case
  9   key+up of key-up endof
 10   key+down of key-down endof
 11   key+left of key-left endof
 12   key+right of key-right endof
 13   dup
 14   endcase ;
 15 

Scr# 660 
  0 ( Chomp.f )
  1 : move-pacman
  2   pacman xy-pos@ xy-pre!
  3   LASTK key-decode c@
  4 \ sprite dir c@
  5   pacman-move sprite-put
  6   xy-pos@ maze@
  7   bl xy-pos@ maze!
  8   catch? if catch! then
  9   dup pacman-eat-dot
 10   dup pacman-eat-pill
 11   dup pacman-eat-cherry
 12       pacman-walk
 13 ;
 14 -->
 15 

Scr# 661 
  0 ( Chomp.f )
  1 : move-four-ghosts
  2   4 0 do
  3     i sprite# xy-pos@ xy-pre!
  4     23672 @ 1 and hunt @ - 1- if
  5   \   ghost-decision
  6       sprite@ dir c@
  7       ghost-move then
  8     sprite-put
  9     xy-pos@ maze@
 10     sprite@ maze c!
 11     catch? if catch! then
 12   loop
 13 ; -->
 14 
 15 

Scr# 662 
  0 ( Chomp.f )
  1 : dashboard
  2   0  1 at.
  3   6 16 emitc emitc \ yellow
  4   [udg] P emitc
  5   7 16 emitc emitc \ white
  6   bl emitc lives ?
  7   0  6 at. ." score "
  8   score 2@
  9   <# # # # # # # #> type
 10 ;
 11 -->
 12 
 13 
 14 
 15 

Scr# 663 
  0 ( Chomp.f )
  1 needs .s
  2 : debug
  3   2 24 at. 6 16 emitc emitc
  4   pacman xy-pos@ swap . .
  5   3 24 at. LASTK c@ .
  6 \ 22 1 at. hex sprite 8 +
  7 \ sprite@ (dump) decimal
  8   5 24 at. total 2@ D.
  9   7 24 at. counting @ .
 10   9 24 at.
 11   sprite@ maze c@ emitc
 12   0 0 at. .s
 13   11 24 at. hunt @ .
 14 \ 22 22 at. ." KEY" key drop
 15 ; -->

Scr# 664 
  0 ( Chomp.f )
  1 : heart-beat
  2   move-pacman
  3   move-four-ghosts
  4   put-cherry
  5   count-down
  6   dashboard
  7 \ debug
  8 ;
  9 : T heart-beat ;
 10 : C catch? . ;
 11 : M init-display ;
 12 -->
 13 
 14 
 15 

Scr# 665 
  0 ( Chomp.f )
  1 : phase-complete
  2   score 2@ total 2@ d= if
  3    180  total D+!
  4    init-all
  5    set-maze-run
  6    interlude
  7    init-display
  8    key-right LASTK c!
  9   endif ;
 10 -->
 11 
 12 
 13 
 14 
 15 

Scr# 666 
  0 ( Chomp.f )
  1 : run-game
  2   begin
  3    lives @
  4   while
  5    heart-beat
  6    phase-complete
  7    ?terminal if quit then
  8   repeat
  9 ;
 10 -->
 11 
 12 
 13 
 14 
 15 

Scr# 667 
  0 ( Ghost.f )
  1 : game
  2   LAYER11 1 SPEED! 30 emitc 8 emitc
  3   3 lives !
  4   0 paper. 0 border. 4 ink.
  5   1 bright. perm
  6   interlude
  7   180. total 2!
  8   0.   score 2!
  9   init-all
 10   set-maze-run
 11   init-display
 12   run-game
 13   22 0 at.
 14   LAYER12 3 SPEED!
 15 ; -->

Scr# 668 
  0 ( Ghost.f )
  1 CR CR
  2 .( Use GAME to start game. ) CR
  3 .( Arrorw keys to move. ) CR
  4 .( Cursor Joystick should work. ) CR
  5 .( BREAK stops: give LAYER12 to pass to 64 columns. ) CR
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 669 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 670 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 671 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 672 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 673 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 674 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 675 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 676 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 677 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 678 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 679 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 680 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 681 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 682 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 683 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 684 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 685 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 686 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 687 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 688 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 689 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 690 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 691 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 692 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 693 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 694 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 695 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 696 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 697 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 698 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 699 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 700 
  0 \ notes on June-12 \ Ulrich Hoffmann
  1 NEEDS BOUNDS ( a n -- a1 a2 )
  2 NEEDS SQRT
  3 : +Field ( n1 n2 <name> -- n3 )
  4   <builds over , + does> @ + ;
  5 0
  6  1 cells +Field _x
  7  1 cells +Field _y
  8 Constant Point \ is the size of that structure
  9 Create P  Point allot
 10 3 P _x ! 4 P _y !
 11 P _x @ dup * P _y @ dup * sqrt \ distance from orgin
 12 
 13 
 14 
 15 

Scr# 701 
  0 \ notes on June-12 \ Bernd Ulmann
  1 \ analog computing
  2 \ Pablo Hugo Reda : ESP32 Forth Computer
  3 \ Ulrich Hoffmann
  4 \ Greg:
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 702 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 703 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 704 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 705 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 706 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 707 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 708 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 709 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 710 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 711 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 712 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 713 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 714 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 715 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 716 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 717 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 718 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 719 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 720 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 721 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 722 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 723 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 724 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 725 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 726 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 727 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 728 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 729 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 730 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 731 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 732 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 733 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 734 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 735 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 736 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 737 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 738 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 739 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 740 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 741 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 742 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 743 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 744 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 745 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 746 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 747 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 748 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 749 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 750 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 751 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 752 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 753 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 754 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 755 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 756 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 757 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 758 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 759 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 760 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 761 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 762 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 763 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 764 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 765 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 766 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 767 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 768 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 769 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 770 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 771 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 772 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 773 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 774 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 775 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 776 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 777 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 778 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 779 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 780 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 781 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 782 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 783 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 784 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 785 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 786 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 787 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 788 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 789 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 790 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 791 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 792 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 793 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 794 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 795 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 796 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 797 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 798 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 799 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 800 
  0 ( Test Suite )
  1 MARKER TEST-SUITE
  2 DECIMAL NEEDS DEPTH
  3 NEEDS <>
  4 \
  5 \ FORTH DEFINITIONS  VOCABULARY TEST-SUITE
  6 \ TEST-SUITE DEFINITIONS
  7 \
  8 0 VARIABLE ACTUAL-DEPTH
  9 CREATE ACTUAL-RESULTS 30 CELLS ALLOT
 10 0 VARIABLE START-DEPTH
 11 0 VARIABLE XCURSOR
 12 ' ERROR VARIABLE ERROR-XT
 13 : ERROR ERROR-XT @ EXECUTE ;
 14 -->
 15 

Scr# 801 
  0 ( Test Suite )
  1 : SOURCE ( -- a b )
  2   BLK @ IF
  3     >IN @ BLK @ B/SCR /MOD -ROT          \ scr  in  r
  4     B/BUF * + C/L / SWAP                 \ row  scr
  5     (LINE)                               \ a n
  6   ELSE
  7     TIB @ 24
  8   THEN
  9 ;
 10 : ERROR1 ( n -- )
 11   SOURCE -TRAILING CR TYPE CR
 12   MESSAGE CR
 13 ;
 14 -->
 15 

Scr# 802 
  0 ( Test Suite )
  1 \
  2 \
  3 : T{  ( -- )  \ record pre-test depth
  4   DEPTH START-DEPTH !
  5   0 XCURSOR !
  6 ;
  7 -->
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 803 
  0 ( Test Suite )
  1 \
  2 : ->   ( ... -- ) \ record depth and contents of stack
  3   DEPTH DUP ACTUAL-DEPTH !       \ record depth
  4   START-DEPTH @ > IF             \ is there something on stack
  5     DEPTH START-DEPTH @ - 0 DO   \ so save them
  6       ACTUAL-RESULTS I CELLS + !
  7     LOOP
  8   THEN
  9 ;
 10 -->
 11 
 12 
 13 
 14 
 15 

Scr# 804 
  0 ( Test Suite )
  1 : }T    ( ... -- )  \  compare stack images
  2   DEPTH ACTUAL-DEPTH @ = IF
  3     DEPTH START-DEPTH @ > IF
  4       DEPTH START-DEPTH @ - 0 DO
  5         ACTUAL-RESULTS I CELLS + @
  6         <> IF 50 ERROR   LEAVE THEN
  7                \ Incorrect result.
  8       LOOP
  9     THEN
 10   ELSE
 11     51 ERROR
 12      \ Wrong number of results.
 13   THEN
 14 ;
 15 -->

Scr# 805 
  0 ( Test Suite )
  1 : ...}T  \ ( ... -- )
  2   XCURSOR @ START-DEPTH @ + ACTUAL-DEPTH @ <> IF
  3     52 ERROR
  4   \ Number of cell result before '->' does not match ...}T spec
  5   ELSE DEPTH START-DEPTH @ = NOT IF
  6     53 ERROR
  7   \ Number of cell result before and after '->' does not match
  8   THEN THEN
  9 ;
 10 -->
 11 
 12 
 13 
 14 
 15 

Scr# 806 
  0 ( Test Suite )
  1 : XTESTER \ ( X -- )
  2   DEPTH 0=  ACTUAL-DEPTH @ XCURSOR @ START-DEPTH @ + 1+ <
  3   OR IF
  4     54 ERROR
  5   ELSE
  6     50 ERROR
  7     1 XCURSOR +!
  8   THEN
  9 ;
 10 -->
 11 
 12 
 13 
 14 
 15 

Scr# 807 
  0 ( Test Suite )
  1 : X}T XTESTER ...}T ;
  2 : XX}T XTESTER XTESTER ...}T ;
  3 : XXX}T XTESTER XTESTER XTESTER ...}T ;
  4 : XXXX}T XTESTER XTESTER XTESTER XTESTER ...}T ;
  5 -->
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 808 
  0 ( Test Suite )
  1 1 VARIABLE VERBOSE
  2 \
  3 : TESTING \ ( -- ) talking comment
  4   SOURCE
  5   VERBOSE @ IF
  6     -TRAILING TYPE
  7   THEN
  8   [COMPILE] \
  9   CR
 10 ;
 11 -->
 12 
 13 
 14 
 15 

Scr# 809 
  0 ( Test Suite )
  1 \
  2 ' ERROR1 ERROR-XT !      \ this activates new error handler
  3 \
  4 TESTING Test Suite
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 810 
  0 ( Test Suite - Examples          )
  1 \
  2 TESTING EXAMPLES
  3 T{  1 1   +     ->     2  }T  \ Ok
  4 T{  1 2 3 SWAP  -> 1 3 2  }T  \ Ok
  5 -->
  6 
  7 T{  1 2 3 SWAP  -> 1 2 3  }T  \ Incorrect result
  8 T{  1 2   SWAP  -> 1      }T  \ Wrong number of results.
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 811 
  0 ( Test Suite - Basic assumptions )
  1 NEEDS INVERT
  2 \
  3 TESTING Test Suite - Basic Assumptions
  4 \
  5 MARKER DONE  HEX
  6 \
  7 T{   ->   }T
  8 T{   : BITSSET? IF 0 0 ELSE 0 THEN ; ->   }T
  9 T{   0 BITSSET? -> 0    }T
 10 T{   1 BITSSET? -> 0 0  }T
 11 T{  -1 BITSSET? -> 0 0  }T
 12 \
 13 -->
 14 
 15 

Scr# 812 
  0 ( Test Suite - Constants         )
  1 \
  2  0 CONSTANT 0S
  3 -1 CONSTANT 1S
  4 1S 1 RSHIFT INVERT CONSTANT  MSB
  5 \
  6 TESTING F.6.1.0950 - CONSTANT
  7 T{  123 CONSTANT X123 ->       }T
  8 T{  X123              -> 123   }T
  9 T{  : EQU CONSTANT ;  ->       }T
 10 T{  X123 EQU Y123     ->       }T
 11 T{  Y123              -> X123  }T
 12 \
 13 -->
 14 
 15 

Scr# 813 
  0 ( Test Suite - Booleans          )
  1 TESTING F.6.1.1720 - INVERT
  2 T{   0S  INVERT  ->  1S   }T
  3 T{   1S  INVERT  ->  0S   }T
  4 -->
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 814 
  0 ( Test Suite - Booleans          )
  1 TESTING F.6.1.0720 - AND
  2 T{ 0 0 AND -> 0 }T
  3 T{ 0 1 AND -> 0 }T
  4 T{ 1 0 AND -> 0 }T
  5 T{ 1 1 AND -> 1 }T
  6 T{ 0 INVERT 1 AND -> 1 }T
  7 T{ 1 INVERT 1 AND -> 0 }T
  8 T{ 0S 0S AND -> 0S }T
  9 T{ 0S 1S AND -> 0S }T
 10 T{ 1S 0S AND -> 0S }T
 11 T{ 1S 1S AND -> 1S }T
 12 -->
 13 
 14 
 15 

Scr# 815 
  0 ( Test Suite - Booleans          )
  1 TESTING F.6.1.1980 - OR
  2 T{ 0S 0S OR  -> 0S }T
  3 T{ 0S 1S OR  -> 1S }T
  4 T{ 1S 0S OR  -> 1S }T
  5 T{ 1S 1S OR  -> 1S }T
  6 
  7 TESTING F.6.1.2490 - XOR
  8 T{ 0S 0S XOR -> 0S }T
  9 T{ 0S 1S XOR -> 1S }T
 10 T{ 1S 0S XOR -> 1S }T
 11 T{ 1S 1S XOR -> 0S }T
 12 -->
 13 
 14 
 15 

Scr# 816 
  0 ( Test Suite - Shifts            )
  1 TESTING F.6.1.0320 - 2*
  2 T{    0S  2*       ->   0S  }T
  3 T{     1  2*       ->    2  }T
  4 T{  4000  2*       -> 8000  }T
  5 T{    1S  2* 1 XOR ->   1S  }T
  6 T{   MSB  2*       ->   0S  }T
  7 
  8 TESTING F.6.1.0330 - 2/
  9 T{           0S 2/ ->   0S  }T
 10 T{            1 2/ ->    0  }T
 11 T{         4000 2/ -> 2000  }T
 12 T{           1S 2/ ->   1S  }T
 13 T{     1S 1 XOR 2/ ->   1S  }T
 14 T{  MSB 2/ MSB AND ->  MSB  }T
 15 -->

Scr# 817 
  0 ( Test Suite - Shifts            )
  1 TESTING F.6.1.1805 - LSHIFT
  2 T{     1 0 LSHIFT  ->    1  }T
  3 T{     1 1 LSHIFT  ->    2  }T
  4 T{     1 2 LSHIFT  ->    4  }T
  5 T{     1 F LSHIFT  -> 8000  }T \ biggest guaranteed shift
  6 T{    1S 1 LSHIFT 1 XOR -> 1S }T
  7 T{   MSB 1 LSHIFT  ->    0  }T
  8 TESTING F.6.1.2162 - RSHIFT
  9 T{     1 0 RSHIFT  ->    1  }T
 10 T{     1 1 RSHIFT  ->    0  }T
 11 T{     2 1 RSHIFT  ->    1  }T
 12 T{     4 2 RSHIFT  ->    1  }T
 13 T{  8000 F RSHIFT  ->    1  }T \ biggest
 14 T{   MSB 1 RSHIFT MSB AND ->   0  }T
 15 T{   MSB 1 RSHIFT     2*  -> MSB  }T    -->

Scr# 818 
  0 ( Test Suite - Numeric Notation  )
  1 --> DECIMAL TESTING Numeric Notation
  2 T{  #1289        -> 1289        }T
  3 T{  #123456789.  -> 123456789.  }T
  4 T{  #-1289       -> -1289       }T
  5 T{  #-123456789. -> 123456789.  }T
  6 T{  $12eF        -> 4847        }T
  7 T{  $12aBcDeF    -> 313249263.  }T
  8 T{  $-12eF       -> 4847        }T
  9 T{  $-12aBcDeF   -> 313249263.  }T
 10 T{  %10010110    -> 150         }T
 11 T{  %10010110.   -> 150.        }T
 12 T{  %-10010110   -> 150         }T
 13 T{  %-10010110.  -> 150.        }T
 14 T{  'z'          -> 122         }T
 15 -->

Scr# 819 
  0 ( Test Suite - Comparison        )
  1 TESTING Comparison
  2 0 INVERT CONSTANT MAX-UINT
  3 0 INVERT 1 RSHIFT CONSTANT MAX-INT
  4 0 INVERT 1 RSHIFT INVERT CONSTANT MIN-INT
  5 0 INVERT 1 RSHIFT CONSTANT MID-UINT
  6 0 INVERT 1 RSHIFT INVERT CONSTANT MID-UINT+1
  7 0S CONSTANT <FALSE>
  8 
  9 \ Not standard
 10 1  CONSTANT <TRUE>
 11 -->
 12 
 13 
 14 
 15 

Scr# 820 
  0 ( Test Suite - Comparison        )
  1 TESTING F.6.1.0270 - 0=
  2 T{         0 0= -> <TRUE>   }T
  3 T{         1 0= -> <FALSE>  }T
  4 T{         2 0= -> <FALSE>  }T
  5 T{        -1 0= -> <FALSE>  }T
  6 T{  MAX-UINT 0= -> <FALSE>  }T
  7 T{  MIN-INT  0= -> <FALSE>  }T
  8 T{  MAX-INT  0= -> <FALSE>  }T
  9 -->
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 821 
  0 ( Test Suite - Comparison        )
  1 TESTING F.6.1.0530 -  =
  2 T{  0  0      = -> <TRUE>   }T
  3 T{  1  1      = -> <TRUE>   }T
  4 T{ -1 -1      = -> <TRUE>   }T
  5 T{  1  0      = -> <FALSE>  }T
  6 T{ -1  0      = -> <FALSE>  }T
  7 T{  0  1      = -> <FALSE>  }T
  8 T{  0 -1      = -> <FALSE>  }T
  9 -->
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 822 
  0 ( Test Suite - Comparison        )
  1 TESTING F.6.1.0250 - 0<
  2 T{        0 0< -> <FALSE> }T
  3 T{       -1 0< -> <TRUE>  }T   \ Because it gives 1
  4 T{  MIN-INT 0< -> <TRUE>  }T   \ Because it gives 1
  5 T{        1 0< -> <FALSE> }T
  6 T{  MAX-INT 0< -> <FALSE> }T
  7 \
  8 \
  9 -->
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 823 
  0 ( Test Suite - Comparison        )
  1 TESTING F.6.1.0480 -  <
  2 T{        0       1 < -> <TRUE>   }T
  3 T{        1       2 < -> <TRUE>   }T
  4 T{       -1       0 < -> <TRUE>   }T
  5 T{       -1       1 < -> <TRUE>   }T
  6 T{  MIN-INT       0 < -> <TRUE>   }T
  7 T{  MIN-INT MAX-INT < -> <TRUE>   }T
  8 T{        0 MAX-INT < -> <TRUE>   }T
  9 T{        0       0 < -> <FALSE>  }T
 10 T{        1       1 < -> <FALSE>  }T
 11 T{        1       0 < -> <FALSE>  }T
 12 T{        2       1 < -> <FALSE>  }T
 13 T{        0      -1 < -> <FALSE>  }T
 14 T{        1      -1 < -> <FALSE>  }T
 15 -->

Scr# 824 
  0 ( Test Suite - Comparison        )
  1 T{        0 MIN-INT < -> <FALSE>  }T
  2 T{  MAX-INT MIN-INT < -> <FALSE>  }T
  3 T{  MAX-INT       0 < -> <FALSE>  }T
  4 \
  5 TESTING F.6.1.0540 -  >
  6 T{        0       1 > -> <FALSE>  }T
  7 T{        1       2 > -> <FALSE>  }T
  8 T{       -1       0 > -> <FALSE>  }T
  9 T{       -1       1 > -> <FALSE>  }T
 10 T{  MIN-INT       0 > -> <FALSE>  }T
 11 T{  MIN-INT MAX-INT > -> <FALSE>  }T
 12 T{        0 MAX-INT > -> <FALSE>  }T
 13 T{        0       0 > -> <FALSE>  }T
 14 T{        1       1 > -> <FALSE>  }T
 15 -->

Scr# 825 
  0 ( Test Suite - Comparison        )
  1 T{        1       0 > -> <TRUE>   }T
  2 T{        2       1 > -> <TRUE>   }T
  3 T{        0      -1 > -> <TRUE>   }T
  4 T{        1      -1 > -> <TRUE>   }T
  5 T{        1 MIN-INT > -> <TRUE>   }T
  6 T{  MAX-INT MIN-INT > -> <TRUE>   }T
  7 T{  MAX-INT       0 > -> <TRUE>   }T
  8 -->
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 826 
  0 ( Test Suite - Comparison        )
  1 TESTING F.6.1.2340 -  U<
  2 T{         0        1 U< -> <TRUE>   }T
  3 T{         1        2 U< -> <TRUE>   }T
  4 T{         0 MID-UINT U< -> <TRUE>   }T
  5 T{         0 MAX-UINT U< -> <TRUE>   }T
  6 T{  MID-UINT MAX-UINT U< -> <TRUE>   }T
  7 T{         0        0 U< -> <FALSE>  }T
  8 T{         1        1 U< -> <FALSE>  }T
  9 T{         1        0 U< -> <FALSE>  }T
 10 T{         2        1 U< -> <FALSE>  }T
 11 T{  MID-UINT        0 U< -> <FALSE>  }T
 12 T{  MAX-UINT        0 U< -> <FALSE>  }T
 13 T{  MID-UINT MID-UINT U< -> <FALSE>  }T
 14 -->
 15 

Scr# 827 
  0 ( Test Suite - Comparison        )
  1 TESTING F.6.1.1880 -  MIN
  2 T{        0       1 MIN ->       0  }T
  3 T{        1       2 MIN ->       1  }T
  4 T{       -1       0 MIN ->      -1  }T
  5 T{       -1       1 MIN ->      -1  }T
  6 T{  MIN-INT       0 MIN -> MIN-INT  }T
  7 T{  MIN-INT MAX-INT MIN -> MIN-INT  }T
  8 T{        0 MAX-INT MIN ->       0  }T
  9 T{        0       0 MIN ->       0  }T
 10 T{        1       1 MIN ->       1  }T
 11 T{        2       1 MIN ->       1  }T
 12 T{        0      -1 MIN ->      -1  }T
 13 T{        1      -1 MIN ->      -1  }T
 14 
 15 

Scr# 828 
  0 ( Test Suite - Stack Operator )
  1 \
  2 TESTING DEPTH
  3 \
  4 T{ s0 @ sp! 0 DEPTH -> 0 1 }T
  5 \
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 829 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 830 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 831 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 832 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 833 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 834 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 835 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 836 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 837 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 838 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 839 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 840 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 841 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 842 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 843 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 844 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 845 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 846 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 847 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 848 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 849 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 850 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 851 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 852 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 853 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 854 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 855 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 856 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 857 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 858 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 859 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 860 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 861 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 862 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 863 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 864 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 865 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 866 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 867 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 868 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 869 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 870 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 871 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 872 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 873 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 874 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 875 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 876 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 877 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 878 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 879 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 880 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 881 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 882 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 883 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 884 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 885 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 886 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 887 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 888 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 889 
  0 ( temporary patch )
  1 hex
  2  28 79f9 c!
  3  28 7a21 c!
  4  28 7a27 c!
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 890 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 891 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 892 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 893 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 894 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 895 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 896 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 897 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 898 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 899 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 900 
  0 ( Remy Sharp )
  1 CODE CHARSETMOVE
  2  PUSH BC|
  3  LDX HL| 15616 NN,
  4  LDX DE| 16384 NN,
  5  LDX BC|   768 NN,
  6  LDIR
  7  POP BC|
  8  NEXT C;
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 901 
  0 ( Patricia Curtis )
  1 MARKER DONE
  2 CODE TEST
  3   XORA   A|
  4   LDN   A'|  -126 N,
  5   CPN  10  N,
  6   LDN   A'|   5  N,
  7   CPN   2  N,
  8   LDN   A'|  -3  N,
  9   CPN  -6  N,
 10   NEXT
 11 C;
 12 
 13 
 14 
 15 

Scr# 902 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 903 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 904 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 905 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 906 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 907 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 908 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 909 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 910 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 911 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 912 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 913 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 914 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 915 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 916 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 917 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 918 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 919 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 920 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 921 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 922 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 923 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 924 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 925 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 926 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 927 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 928 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 929 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 930 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 931 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 932 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 933 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 934 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 935 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 936 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 937 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 938 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 939 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 940 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 941 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 942 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 943 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 944 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 945 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 946 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 947 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 948 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 949 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 950 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 951 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 952 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 953 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 954 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 955 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 956 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 957 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 958 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 959 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 960 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 961 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 962 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 963 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 964 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 965 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 966 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 967 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 968 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 969 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 970 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 971 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 972 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 973 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 974 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 975 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 976 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 977 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 978 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 979 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 980 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 981 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 982 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 983 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 984 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 985 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 986 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 987 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 988 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 989 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 990 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 991 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 992 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 993 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 994 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 995 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 996 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 997 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 998 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 999 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 
