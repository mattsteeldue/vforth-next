File: c:\Zx\forth\F15\!Blocks-64.bin
Created: Sat May  8 22:10:24 2021

Index:

    1 
    2 #2
    3 #3
    4 is undefined.
    5 ( Error messages    2/4 )
    6 ( Error messages    3/4 )
    7 ( Error messages    3/4 )
    8 ( Print a complete error list )
    9 ." Assembler. "          CR
   10 ( v-Forth 1.5 - Recompilation )
   11 ( Autoexec 1/3 )
   12 ( Autoexec 2/3 )
   13 ( Autoexec 3/3 )
   14 ( Autoexec 3/3 - previous version )
   15 ( Autoexec 3/3 )
   16 
   17 
   18 .( Case-of structure. )   CR
   19 ( Case-Of structure  2/2 )
   20 .( Decompiler / Inspector. ) CR
   21 ( Debugger             2/6 )
   22 ( Debugger             3/6 )
   23 ( Debugger             4/6 )
   24 ( Debugger             5/6 )
   25 ( Debugger             6/6 )
   26 ( Stack viewer             )
   27 ( Long memory dump )
   28 ( Vocabulary viewer        )
   29 ( Simple Word RENAMEr )
   30 ( 2CONSTANT )
   31 ( SET-FENCE )
   32 ( HIDE )
   33 ( USED-BY )
   34 ( DUMP WORDS )
   35 ( Restore AUTOEXEC )
   36 ( RECURSE )
   37 ( RECURSE - GDC )
   38 ( RND Test )
   39 ( CHOOSE - Brodie )
   40 .( RND ) CR
   41 .( Color and attributes  ) CR
   42 ( AT TAB                   )
   43 ( POINT SCREEN$ )
   44 ( PLOT )
   45 ( DRAW                     )
   46 ( PAINT )
   47 ( PAINT )
   48 ( Mr Jones' keyboard test )
   49 ( Mr Jones' keyboard test )
   50 .( BLEEP ) CR
   51 ( BLEEP )
   52 ( Pitch bend )
   53 ( KEYBOARD-TEST )
   54 ( ?ESCAPE experiment       )
   55 ( MS delay )
   56 
   57 ( FRAMES )
   58 ( FRAMES 2 )
   59 ( TEST )
   60 ( Interrupt Handler )
   61 ( Interrupt Handler )
   62 ( Interrupt Handler )
   63 ( Interrupt Handler )
   64 ( Interrupt Handler )
   65 ( Interrupt Handler )
   66 ( Interrupt Handler )
   67 ( Interrupt Handler )
   68 ( INTERRUPT - TEST )
   69 ( INTERRUPT )
   70 .( Compare Utility. ) CR
   71 .( Search utility. ) CR
   72 ( SEARCH )
   73 ( BSEARCH SEARCH-ALL )
   74 ( LOCATE )
   75 ( LOCATE )
   76 
   77 
   78 
   79 
   80 .( Heap Memory Management ) CR
   81 ( Heap Memory Management )
   82 ( Heap Memory Management )
   83 ( Heap Memory Management )
   84 ( Heap Memory Management )
   85 ( S" Counted Strings in Heap )
   86 ( S" Counted Strings in Heap )
   87 ( Allocate RAM banks $40-$47 for string heap )
   88 
   89 
   90 .( Line editor. )         CR
   91 ( Line Editor          2/6 )
   92 ( Line Editor          3/6 )
   93 ( Line Editor          4/6 )
   94 ( Line Editor          5/6 )
   95 ( Line Editor          6/6 )
   96 
   97 
   98 ( Editor utility           )
   99 .( Call utility. )        CR
  100 ." Assembler. "           CR
  101 .( Z80 Assembler. ) CR
  102 ( Z80 Utility - Sys depend )
  103 ( Z80 Utility - Sys depend )
  104 ( Z80 System independ. )
  105 ( Z80 System independ. )
  106 ( Z80 Generate errors )
  107 ( Assembler Z80 )
  108 ( Assembler Z80 )
  109 ( Assembler Z80 )
  110 ( Assembler Z80 )
  111 ( Assembler Z80 )
  112 ( Assembler Z80 )
  113 ( Assembler Z80 )
  114 ( Assembler Z80 )
  115 ( Assembler Z80 )
  116 ( Assembler Z80 )
  117 ( Assembler z80 )
  118 ( Assembler MMU config ) ;S seems bugged: don't use
  119 
  120 .( Z80 definitions. ) CR
  121 ( Z80 ) HEX
  122 ( Z80 ) HEX
  123 ( Z80 ) HEX
  124 ( Z80 immediate data )
  125 ( Z80 address )
  126 ( Z80 ) HEX
  127 ( Z80 relative jump )
  128 ( ED prefix )
  129 ( ED )
  130 ( ED )
  131 ( CB )
  132 ( IX IY )
  133 ( IX IY )
  134 ( IX IY )
  135 ( IX IY )
  136 ( IX IY )
  137 ( IX IY )
  138 ( IX IY )
  139 
  140 .( Z80 near structure )   CR
  141 ( Z80 Near struct. )
  142 ( Z80 Near struct. )
  143 ( Z80 Near struct. )
  144 ( Z80 Near struct. )
  145 ." Z80 far struct "
  146 ( TESTING )
  147 ( 128K memory BANK! TEST )
  148 ( 128K memory BANK! TEST )
  149 ( 128K memory BANK! TEST )
  150 ( TEST )
  151 ( TEST1 )
  152 ( TEST2 )
  153 ( TEST3 )
  154 ( TEST IF, THEN, )
  155 \ TEST
  156 \ TEST6
  157 \ TEST7
  158 \ TEST Z80N
  159 \ TEST Z80N
  160 .( Z80N Next extensions )
  161 ( Z80N Next extension )
  162 ( Z80N Next extension )
  163 
  164 
  165 
  166 ( White noise Egghead 3 )
  167 ( White noise Egghead 3 )
  168 ( White noise Egghead 3 )
  169 ( Checksum of a RAM chunk )
  170 \ BURP
  171 ( Dump many pages )
  172 ( NEEDS )
  173 ( NEEDS )
  174 ( NEEDS )
  175 ( NEEDS )
  176 ( NEEDS )
  177 ( INCLUDE ) \ study and test
  178 ( DEFER IS - EXIT UNLOOP )
  179 ( CHECK NULL               )
  180 ( Fibonacci )
  181 ( DSQRT )
  182 ( Primality Test )
  183 ( MARKER )
  184 ( TEST )
  185 ( TEST )
  186 ( DOT example  .helloworld )
  187 ( search for AT position )
  188 ( TEST )
  189 ( TEST )
  190 .( Full Screen Editor. ) CR
  191 ( Full Screen Editor   2/7 )
  192 ( Full Screen Editor   3/7 )
  193 ( Full Screen Editor   4/7 )
  194 ( Full Screen Editor   5/7 )
  195 ( Full Screen Editor   6/7 )
  196 ( Full Screen Editor   7/7 )
  197 \ TEST
  198 ( \ comment )
  199 ( MARKER )
  200 .( .RESET & CPU SPEED )  CR
  201 ( DAA )
  202 ( PICK )
  203 ( U* )
  204 ( U* )
  205 ( U/   dn n -- r dq )
  206 ( U/ )
  207 ( U/ )
  208 ( UPPER )
  209 ( "NUL" )
  210 \ 1. F_GETLINE from handle( via F_READ and F_SEEK ) DECIMAL
  211 \ 2. include from handle
  212 \ 2. include from handle
  213 \ 3. an INCLUDE wrapper
  214 ( NEW UM* using MUL new OP-code )
  215 ( NEW UM* using MUL new OP-code )
  216 ( NEW UM* using MUL new OP-code )
  217 ( TEST )
  218 ( NEW UM* using MUL new OP-code )
  219 ( NEW UM* using MUL new OP-code )
  220 ( MOVE SP )
  221 ( MOVE RP )
  222 ( MOVE LIMIT )
  223 ( UP AND DOWN )
  224 ( 128K BANK! TEST )
  225 ( ?DO LOOP )
  226 ( ?DO LOOP )
  227 ( ?DO LOOP )
  228 ( ?DO LOOP )
  229 ( POSTPONE )
  230 \ 1. F_GETLINE from handle( F_READ and F_SEEK ) DECIMAL
  231 \ 2. include from handle
  232 \ 2. include from handle
  233 \ 3. an INCLUDE wrapper
  234 
  235 
  236 
  237 
  238 
  239 ( Rainbow effects )
  240 \ LARGE LETTER F
  241 ( Square example )
  242 ( CUBES )
  243 ( CUBES )
  244 ( CUBES )
  245 
  246 
  247 
  248 
  249 
  250 \ BLOCK-SHIFT
  251 ( block move reorder )
  252 \ Print all blocsks to #13
  253 ( INITIALIZE-MMC )
  254 ( MICRODRIVE CARTRIDGE )
  255 
  256 
  257 
  258 
  259 \ Forth Application Tecniques - 5.1.1
  260 ( TRACE )
  261 ( TRACE )
  262 ( TRACE )
  263 ( TRACE )
  264 ( TRACE )
  265 ( TRACE )
  266 
  267 
  268 
  269 
  270 
  271 
  272 
  273 
  274 
  275 
  276 
  277 
  278 
  279 
  280 
  281 
  282 
  283 
  284 
  285 
  286 
  287 ( GREY-SCREEN example )
  288 ( GREY-SCREEN example )
  289 
  290 ( map - character replacing )
  291 ( map - character replacing )
  292 ( map - character replacing )
  293 ( map - character replacing )
  294 ( GREY-SCREEN example )
  295 
  296 
  297 
  298 
  299 
  300 ( Study:  MMU7 / set or get bank )
  301 ( Study: MMU7 / simplest )
  302 ( Study: MMU7 / simplest )
  303 ( Study: MMU7 / simplest )
  304 ( Study: MMU7 / simplest )
  305 ( Study: MMU7 / 16th byte )
  306 ( Study: MMU7 / 16th byte )
  307 ( Study: MMU7 / 16th byte )
  308 ( Study: MMU7 / 16th byte )
  309 
  310 ( LED - Large EDitor )
  311 ( LED - Large EDitor )
  312 ( LED - Large EDitor )
  313 ( LED - Large EDitor )
  314 ( LED - Large EDitor )
  315 ( LED - Large EDitor )
  316 ( LED - Large EDitor )
  317 ( LED - Large EDitor )
  318 
  319 
  320 
  321 
  322 
  323 
  324 ( MMU7 / simplest )
  325 ( MMU Heap Management )
  326 ( MMU7 HEAP )
  327 ( MMU7 HEAP )
  328 ( MMU7 HEAP STRING )
  329 ( MMU7 HEAP STRING )
  330 ( MMU7 HEAP STRING )
  331 ( MMU7 HEAP POINTER )
  332 ( S" Counted Strings in Heap )
  333 \ TEST
  334 ( Testing where $6000 is paged )
  335 ( Testing where $6000 is paged )
  336 
  337 
  338 
  339 
  340 ( R/W : BLK-FH )
  341 ( R/W : BLK-READ )
  342 ( R/W : BLK-WRITE )
  343 ( R/W : BLK-INIT )
  344 ( blk-fname )
  345 ( r/w patch )
  346 ( r/w patch )
  347 
  348 
  349 
  350 ( Matt Davies'  .helloworld )
  351 
  352 
  353 
  354 
  355 
  356 
  357 
  358 
  359 
  360 ( F_STAT via RST 8 hook code )
  361 ( F_FGETPOS via RST 08 hook code )
  362 ( F_SEEK via RST 08 hook code )
  363 ( F_WRITE via RST 8 hook code )
  364 ( F_READ via RST 8 hook code )
  365 ( F_CLOSE via RST 8 hook code )
  366 ( F_OPEN via RST 8 hook code )
  367 ( F_OPEN via RST 8 hook code )
  368 ( F_FSTAT via RST 8 hook code )
  369 code F_SYNC  ( n -- f )
  370 ( M_DOSVERSION via RST 8 hook code )
  371 ( F_GETFREE via RST 08 hook code test )
  372 ( M_P3DOS )
  373 ( M_P3DOS )
  374 ( M_P3DOS )
  375 
  376 
  377 
  378 
  379 ( IDE_BANK )
  380 ( NextZXOS - IDE_CAPACITY $01b4 )
  381 ( NextZXOS - DOS_FREE_SPACE $0121 )
  382 ( NextZXOS IDE_MODE 01d5 )
  383 ( NextZXOS IDE_MODE 01d5 )
  384 ( DOS_FLUSH $0142 )
  385 ( DOS_VERSION / IDE_VERSION )
  386 ( IDE_BASIC 1/3 )
  387 ( IDE_BASIC 2/3 )
  388 ( IDE_BASIC 3/3 )
  389 ( IDE_BASIC test )
  390 ( looking for AT position in LAYERs )
  391 
  392 
  393 
  394 
  395 
  396 
  397 
  398 
  399 
  400 
  401 
  402 
  403 
  404 
  405 ( .HEX and .BIN utility )
  406 
  407 
  408 
  409 
  410 
  411 
  412 
  413 
  414 
  415 
  416 
  417 
  418 
  419 
  420 
  421 
  422 
  423 
  424 
  425 
  426 
  427 
  428 
  429 
  430 
  431 
  432 
  433 
  434 
  435 
  436 
  437 
  438 
  439 
  440 
  441 
  442 
  443 
  444 
  445 
  446 
  447 
  448 
  449 
  450 
  451 
  452 
  453 
  454 
  455 
  456 
  457 
  458 
  459 
  460 
  461 
  462 
  463 
  464 
  465 
  466 
  467 
  468 
  469 
  470 
  471 
  472 
  473 
  474 
  475 
  476 
  477 
  478 
  479 
  480 
  481 
  482 
  483 
  484 
  485 
  486 
  487 
  488 
  489 
  490 
  491 
  492 
  493 
  494 
  495 
  496 
  497 
  498 
  499 
  500 ( Next Registers )
  501 ( Next Registers )
  502 ( Next Registers )
  503 ( Next Registers )
  504 ( Next Registers )
  505 
  506 
  507 
  508 
  509 
  510 
  511 
  512 
  513 
  514 
  515 
  516 
  517 
  518 
  519 
  520 ( LAYER 2 palette picker )
  521 ( LAYER 2 palette picker )
  522 ( LAYER 2 palette picker )
  523 ( LAYER 2 palette picker )
  524 ( LAYER 2 palette picker )
  525 ( LAYER 2 palette picker )
  526 ( LAYER 2 palette picker )
  527 
  528 
  529 
  530 
  531 
  532 
  533 
  534 
  535 
  536 
  537 ( VALUE TO )
  538 \ test
  539 
  540 
  541 
  542 
  543 
  544 
  545 
  546 
  547 
  548 
  549 
  550 
  551 
  552 
  553 
  554 
  555 
  556 
  557 
  558 
  559 
  560 
  561 
  562 
  563 
  564 
  565 
  566 
  567 
  568 
  569 
  570 
  571 
  572 
  573 
  574 
  575 
  576 
  577 
  578 
  579 
  580 
  581 
  582 
  583 
  584 
  585 
  586 
  587 
  588 
  589 
  590 
  591 
  592 
  593 
  594 
  595 
  596 
  597 
  598 
  599 
  600 .( Chomp.f )
  601 ( Chomp.f )
  602 ( Chomp.f )
  603 ( Chomp.f )
  604 ( Chomp.f )
  605 ( Chomp.f )
  606 ( Chomp.f )
  607 
  608 
  609 
  610 .( Chomp.f - UDG )
  611 ( Chomp.f - UDG )
  612 ( Chomp.f - UDG )
  613 ( Chomp.f - UDG )
  614 .( Chomp.f - maze )
  615 ( Chomp.f - maze )
  616 ( Chomp.f - maze )
  617 ( Chomp.f - maze )
  618 ( Chomp.f - maze )
  619 ( Chomp.f - maze )
  620 .( Chomp.f - Sprite )
  621 ( Chomp.f - Sprite )
  622 ( Chomp.f - Sprite )
  623 ( chomp.f - Sprite )
  624 ( Chomp.f - Sprite )
  625 ( Chomp.f - Sprite )
  626 ( Chomp.f - Sprite )
  627 ( Chomp.f - Sprite )
  628 ( Chomp.f - Sprite )
  629 ( Chomp.f )
  630 .( Chomp.f - trail )
  631 ( Chomp.f - trail )
  632 ( Chomp.f - trail )
  633 ( Chomp.f - trail )
  634 ( Chomp.f - trail )
  635 ( Chomp.f - trail )
  636 ( Chomp.f - trail )
  637 ( Chomp.f - trail )
  638 ( Chomp.f - trail )
  639 ( Chomp.f - trail )
  640 ( Chomp.f - ghost )
  641 ( Chomp.f - ghost )
  642 ( Chomp.f - ghost )
  643 ( Chomp.f - ghost )
  644 ( Chomp.f - ghost )
  645 ( Chomp.f - ghost )
  646 
  647 
  648 
  649 
  650 ( Chomp.f )
  651 ( Chomp.f )
  652 ( Chomp.f )
  653 ( Chomp.f - Interlude )
  654 ( Chomp.f )
  655 ( Chomp.f )
  656 ( Chomp.f )
  657 ( Chomp.f )
  658 ( Chomp.f )
  659 ( Chomp.f )
  660 ( Chomp.f )
  661 ( Chomp.f )
  662 ( Chomp.f )
  663 ( Chomp.f )
  664 ( Chomp.f )
  665 ( Chomp.f )
  666 ( Chomp.f )
  667 ( Ghost.f )
  668 ( Ghost.f )
  669 
  670 
  671 
  672 
  673 
  674 
  675 
  676 
  677 
  678 
  679 
  680 
  681 
  682 
  683 
  684 
  685 
  686 
  687 
  688 
  689 
  690 
  691 
  692 
  693 
  694 
  695 
  696 
  697 
  698 
  699 
  700 
  701 
  702 
  703 
  704 
  705 
  706 
  707 
  708 
  709 
  710 
  711 
  712 
  713 
  714 
  715 
  716 
  717 
  718 
  719 
  720 
  721 
  722 
  723 
  724 
  725 
  726 
  727 
  728 
  729 
  730 
  731 
  732 
  733 
  734 
  735 
  736 
  737 
  738 
  739 
  740 
  741 
  742 
  743 
  744 
  745 
  746 
  747 
  748 
  749 
  750 
  751 
  752 
  753 
  754 
  755 
  756 
  757 
  758 
  759 
  760 



Scr# 1 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 2 
  0 #2
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 3 
  0 #3
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 4 
  0 is undefined.
  1 Stack is empty.
  2 Dictionary full.
  3 No such line.
  4 has already been defined.
  5 Invalid stream.
  6 No such block.
  7 Stack full.
  8 Old dictionary is full.
  9 Tape error.
 10 Wrong array index.
 11 Invalid floating point.
 12 Heap full.
 13 msg # 13
 14 msg # 14
 15 msg # 15

Scr# 5 
  0 ( Error messages    2/4 )
  1 Can't be executed.
  2 Can't be compiled.
  3 Syntax error.
  4 Bad definition end.
  5 is a protected word.
  6 Aren't loading now.
  7 Forget across vocabularies.
  8 RS loading error.
  9 Cannot open stream.
 10 Error at postit time.
 11 Inconsistent fixup.
 12 Unexpected fixup/commaer.
 13 Commaer data error.
 14 Commaer wrong order.
 15 Programming error.

Scr# 6 
  0 ( Error messages    3/4 )
  1 Programming error.
  2 
  3 
  4 
  5 
  6 
  7 
  8 NextZXOS Out of memory.
  9 NextZXOS Open error.
 10 NextZXOS Close error.
 11 File not found.
 12 NextZXOS DOS call error.
 13 NextZXOS Pos error.
 14 NextZXOS Read error.
 15 NextZXOS Write error.

Scr# 7 
  0 ( Error messages    3/4 )
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 Msg # 63

Scr# 8 
  0 ( Print a complete error list )
  1 \ give 8 LOAD to display the error list page by page
  2 DECIMAL MARKER FORGET-THIS-TASK
  3 : LIST-A-PAGE ( n -- )
  4   DUP 1+ 16 * SWAP 16 * DO
  5     I 3 .R SPACE [CHAR] : EMIT SPACE I MESSAGE CR
  6   LOOP ;
  7 : LIST-OF-ERRORS ( -- )
  8   CR 4 0 DO I LIST-A-PAGE
  9     I 3 - IF ."   press any key..." KEY CR ENDIF
 10     ?TERMINAL IF LEAVE THEN
 11   LOOP
 12   FORGET-THIS-TASK ;
 13 \
 14 LIST-OF-ERRORS
 15 \

Scr# 9 
  0 ." Assembler. "          CR
  1 \
  2 \ Load ASSEMBLER vocabulary
  3 \
  4 DECIMAL  29 LOAD  \ RENAME
  5 DECIMAL 100 LOAD
  6 \
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 10 
  0 ( v-Forth 1.5 - Recompilation )
  1 \
  2 \ this screen is loaded during recompilation
  3 \
  4   INCLUDE src/F15a.f
  5 \
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 11 
  0 ( Autoexec 1/3 )
  1 \ This is executed at first COLD start by AUTOEXEC
  2 CR 7 REG@  3 AND  35   SWAP LSHIFT S->D
  3 <# # CHAR . HOLD #S #> TYPE SPACE ." MHz Z80n CPU Speed." CR
  4 S0 PAD  - U. ." bytes free in Dictionary." CR
  5 -1 HP @ - U. ." bytes free in Heap." CR
  6 CR
  7 -->
  8 
  9 \ __________________________________________________________
 10 \
 11 012345678901234567890123456789012345678901234567890123456789
 12 0    .    1    .    2    .    3    .    4    .    5    .
 13 \ Fancy 64-Columns Ruler
 14 \ __________________________________________________________
 15 

Scr# 12 
  0 ( Autoexec 2/3 )
  1 MARKER FORGET-TASK
  2 : ASK-Y/N ( -- )
  3 \ ask Y/n to continue loading Screen 3
  4   ." Autoexec says :" CR
  5   ." Do you wish to load Scr# 11 ? (Y/n) "
  6   KEY DUP EMIT
  7   UPPER
  8   [ CHAR N ] LITERAL
  9   = IF ." ok "
 10    FORGET-TASK  QUIT
 11   ELSE
 12    FORGET-TASK
 13  THEN ;
 14 ASK-Y/N --> to continue loading to next Screen
 15 

Scr# 13 
  0 ( Autoexec 3/3 )
  1 \
  2 \  NextZXOS version
  3 \
  4 CR  ." Loading the following utilities:" CR
  5 \ NEEDS    S"       \ Heap Memory Management
  6 \ NEEDS    POINTER
  7 NEEDS    WHERE    \ Line Editor
  8          NEEDS ROOM  NEEDS .PAD  NEEDS SAVE
  9 NEEDS    CASE     \ Case-Of
 10 NEEDS    SEE      \ Decompiler / Inspector
 11 NEEDS    EDIT     \ Full Screen Editor
 12 NEEDS    GREP     \ Screen Search utility
 13 NEEDS    LOCATE
 14 11 SCR !
 15 \

Scr# 14 
  0 ( Autoexec 3/3 - previous version )
  1 \
  2 \  NextZXOS version
  3 \
  4 CR  ." Loading the following utilities:" CR
  5 DECIMAL  80 LOAD  \ Heap Memory Management
  6 DECIMAL  90 LOAD  \ Line Editor
  7 DECIMAL  18 LOAD  \ Case-Of
  8 DECIMAL  20 LOAD  \ Decompiler / Inspector
  9 DECIMAL 190 LOAD  \ Full Screen Editor
 10 DECIMAL  70 LOAD  \ Screen Search utility
 11 11 SCR !
 12 \
 13 
 14 
 15 

Scr# 15 
  0 ( Autoexec 3/3 )
  1 \
  2 \  NextZXOS version
  3 \
  4 CR  ." Loading the following utilities:" CR
  5 NEEDS    S"       \ Heap Memory Management
  6 NEEDS    POINTER
  7 NEEDS    WHERE    \ Line Editor
  8 NEEDS    CASE     \ Case-Of
  9 NEEDS    SEE      \ Decompiler / Inspector
 10 NEEDS    EDIT     \ Full Screen Editor
 11 NEEDS    GREP     \ Screen Search utility
 12 NEEDS    LOCATE
 13 11 SCR !
 14 \
 15 

Scr# 16 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 17 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 18 
  0 .( Case-of structure. )   CR
  1 \ Used in the form:
  2 \  n0 CASE  n1 OF .. ENDOF
  3 \           nz OF .. ENDOF  .. else-part
  4 \  ENDCASE
  5 : CASE ( n0 -- ) \ begin case-of structure
  6   ?COMP CSP @ !CSP 4 ; IMMEDIATE
  7 : (OF)  ( n0 nk -- ) \ run-time compiled by OF
  8   OVER = DUP IF SWAP DROP ENDIF ;
  9 : OF  ( n0 nk -- )
 10   4 ?PAIRS COMPILE (OF) COMPILE 0BRANCH HERE 0 ,
 11   5 ; IMMEDIATE
 12 : ENDOF  ( -- )
 13   5 ?PAIRS COMPILE BRANCH HERE 0 ,
 14   SWAP 2 [COMPILE] THEN 4 ; IMMEDIATE
 15 -->

Scr# 19 
  0 ( Case-Of structure  2/2 )
  1 : ENDCASE
  2   4 ?PAIRS COMPILE DROP
  3   BEGIN SP@ CSP @ -
  4   WHILE 2 [COMPILE] THEN
  5   REPEAT CSP ! ; IMMEDIATE
  6 ;S
  7 \ Example:
  8 x CASE
  9 1 OF ... ENDOF
 10 2 OF ... ENDOF
 11 (else) ... ENDCASE
 12 
 13 
 14 
 15 

Scr# 20 
  0 .( Decompiler / Inspector. ) CR
  1 : (DUMP)  ( a+4 a -- ) [ DECIMAL ]
  2   DO I C@ S->D <# # # #> TYPE SPACE LOOP ;
  3 : DUMP  ( a -- )
  4   BASE @ SWAP HEX DUP 64 + SWAP
  5   DO
  6     CR I S->D  <# # # # # #> TYPE  2 SPACES
  7     I 4 + I (DUMP) SPACE  I 8 + I 4 + (DUMP) SPACE
  8     I 8 + I  DO
  9       I C@ DUP 127 > IF INVV ENDIF
 10       127 AND DUP 32 < IF SPACE DROP ELSE EMIT ENDIF
 11       TRUV
 12     LOOP
 13     ?TERMINAL IF LEAVE ENDIF
 14   8 +LOOP
 15   BASE ! ; -->

Scr# 21 
  0 ( Debugger             2/6 )
  1 : .WORD >BODY NFA ID. ;
  2 : DEB-N ." Nfa: "   NFA DUP U. C@ . CR ;
  3 : DEB-C ." Cfa: "   CFA DUP U. @ U. CR ;
  4 : DEB-L ." Lfa: "   LFA DUP U. @ ID. CR ;
  5 : DEB-P ." Pfa: "   DUMP ;
  6 : DEB-LIT CELL+  DUP @ . ;
  7 : DEB-BRN DUP @ .WORD INVV DEB-LIT TRUV ;
  8 : DEB-STR DUP @ .WORD CELL+
  9   COUNT 2DUP INVV TYPE + CELL-
 10   TRUV SPACE ;
 11 -->
 12 
 13 
 14 
 15 

Scr# 22 
  0 ( Debugger             3/6 )
  1 ' : @      CONSTANT <:>
  2 ' ABORT    CONSTANT <AB>
  3 ' ;S       CONSTANT <;S>
  4 ' (?DO)    CONSTANT <D>
  5 ' (+LOOP)  CONSTANT <+L>
  6 ' (LOOP)   CONSTANT <L>
  7 ' BRANCH   CONSTANT <B>
  8 ' 0BRANCH  CONSTANT <0B>
  9 ' LIT      CONSTANT <LIT>
 10 ' (.")     CONSTANT <.">
 11 ' QUIT     CONSTANT <Q>
 12 ' CONSTANT CONSTANT <C>
 13 ' VARIABLE CONSTANT <V>
 14 ' WARM     CONSTANT <!>
 15 -->

Scr# 23 
  0 ( Debugger             4/6 )
  1 : ?FWD DUP DUP @ U< IF INVV THEN ;
  2 : (DELOAD)
  3     CASE
  4       <D>   OF DEB-BRN ENDOF
  5       <+L>  OF DEB-BRN ENDOF
  6       <L>   OF DEB-BRN ENDOF
  7       <B>   OF DEB-BRN ENDOF
  8       <0B>  OF DEB-BRN ENDOF
  9       <LIT> OF DEB-LIT ENDOF
 10       <.">  OF DEB-STR ENDOF
 11       DUP .WORD
 12     ENDCASE
 13 ; -->
 14 
 15 

Scr# 24 
  0 ( Debugger             5/6 )
  1 : DELOAD
  2   BEGIN
  3     ?FWD DUP @
  4     (DELOAD)
  5     CELL+
  6     TRUV ?TERMINAL
  7     OVER @ <AB> = OR
  8     OVER @ <Q>  = OR
  9     OVER @ <;S> = OR
 10     OVER @ <!>  = OR
 11   UNTIL ;
 12 -->
 13 
 14 
 15 

Scr# 25 
  0 ( Debugger             6/6 )
  1 : (SEE)  ( cfa -- )
  2   BASE @ SWAP HEX CELL+
  3   DUP DEB-N  DUP DEB-L
  4   DUP DEB-C  DUP CFA @ <:> =
  5   IF
  6     DECIMAL DELOAD  DROP BASE !
  7   ELSE
  8     SWAP BASE ! DEB-P
  9   ENDIF ;
 10 \
 11 : SEE  ( -- )
 12   -FIND 0= 0 ?ERROR  .   CR (SEE) ;
 13 -->
 14 
 15 

Scr# 26 
  0 ( Stack viewer             )
  1 : DEPTH
  2   S0 @ SP@ - 2/ 1 - ;
  3 : .S  ( -- )    \ show Calc-Stack content
  4   DEPTH IF
  5     CR SP@ CELL-  S0 @
  6     CELL-  DO
  7       I @ U.
  8     -2 +LOOP
  9   ENDIF ;
 10 : DEB ( n -- )  \ show Debug n, Stack, Return-Stack content
 11   ." debug " . .S ."  -- "
 12   R0 @ RP@ 2+ ?DO
 13     I @ U.
 14   2 +LOOP ;
 15 

Scr# 27 
  0 ( Long memory dump )
  1 \ Utility to dump large intervals of memory
  2 \ usually 13 SELECT to redirect to stream #13 "output"
  3 : LDUMP  ( a1 a2 -- )
  4   SWAP DO
  5     I DUMP
  6   \ KEY
  7     ?TERMINAL IF LEAVE THEN
  8   64 +LOOP
  9 ;
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 28 
  0 ( Vocabulary viewer        )
  1 : ?VOCAB
  2   CR ." Current "
  3   CURRENT @ 4 - NFA ID.
  4   CR ." Context "
  5   CONTEXT @ 4 - NFA ID.
  6   CR ." VocLink "
  7   VOC-LINK @ 6 - NFA ID.
  8 ;
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 29 
  0 ( Simple Word RENAMEr )
  1 \ old and new names have
  2 \ the same length
  3 HEX
  4 : RENAME
  5   ' >BODY NFA DUP C@ 1F AND
  6   2DUP + >R
  7   BL WORD      20 ALLOT
  8   COUNT 1F AND ROT MIN
  9   >R SWAP 1+ R>
 10   CMOVE
 11   R C@ 80 OR R> C!
 12   -20 ALLOT ;
 13 DECIMAL
 14 
 15 

Scr# 30 
  0 ( 2CONSTANT )
  1 : 2CONSTANT
  2   <BUILDS SWAP , , DOES>
  3   2@
  4 ;
  5 : 2VARIABLE
  6   VARIABLE , ;
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 31 
  0 ( SET-FENCE )
  1 \ Modify FENCE to prevent FORGET to clear below it.
  2 HERE FENCE !
  3 HERE HEX 1C +ORIGIN !
  4 LATEST   0C +ORIGIN !
  5 HERE HEX 1E +ORIGIN !
  6 VOC-LINK @ 20 +ORIGIN !
  7 DECIMAL
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 32 
  0 ( HIDE )
  1 \ used in the form HIDE A-WORD to prevent -FIND to find it
  2 \ patching the LFA of the definition that follows it.
  3 \ Cannot be used on the LATEST word, obviously.
  4 \
  5 \ ##  USE WITH CARE  ##
  6 \
  7 : HIDE
  8   ' >BODY LFA
  9   CONTEXT @
 10   BEGIN
 11   @ PFA LFA
 12   2DUP = OVER @ AND
 13   UNTIL
 14 ;
 15 

Scr# 33 
  0 ( USED-BY )
  1 \ search memory for a specific xt for debug purposes
  2 : USED-BY ( xt -- )
  3   HERE 0 +ORIGIN DO
  4     DUP I @ = IF I U. THEN
  5   LOOP
  6   -1 S0 @ DO
  7     DUP I @ = IF I U. THEN
  8   LOOP
  9   DROP ;
 10 HEX : EXAM FF58 EA40
 11   DO CR 2B EMIT I U.
 12   I USED-BY ?TERMINAL
 13   IF LEAVE THEN LOOP ;
 14 
 15 

Scr# 34 
  0 ( DUMP WORDS )
  1 \ Print all definitions to stream # 13
  2 : >OUTPUT 13 SELECT ;
  3 : DUMP-2-PRINTER
  4   0 HEX CONTEXT @ @
  5   BEGIN DUP PFA LFA @ DUP 0= ?TERMINAL OR UNTIL DROP
  6   BEGIN
  7     VIDEO DUP ID. >OUTPUT CR ." \  " DUP ID. CR
  8     PFA CFA CELL+ DUP DEB-N DUP DEB-L DUP DEB-C
  9     ." Pfa: " DUP U. @ U. CR
 10     DUP 0= ?TERMINAL OR CR CR
 11   UNTIL VIDEO DROP ;
 12 
 13 
 14 
 15 

Scr# 35 
  0 ( Restore AUTOEXEC )
  1 \ The following sequence restores AUTOEXEC within ABORT
  2 \ definition
  3 \
  4 \ ##  USE WITH CARE  ##
  5 \
  6 ' AUTOEXEC
  7 ' ABORT 7 CELLS +
  8 !
  9 DECIMAL 14 EMITC
 10 BYE
 11 \
 12 \ and remember Scr# 220
 13 \ to move up or down LIMIT
 14 
 15 

Scr# 36 
  0 ( RECURSE )
  1 : RECURSE ( -- )
  2   ?COMP
  3   LATEST PFA CFA , ;
  4 IMMEDIATE
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 37 
  0 ( RECURSE - GDC )
  1 \ here is two examples that use RECURSE
  2 NEED RECURSE
  3 \ Greatest Common Divisor betwenn a and b
  4 : GCD ( a b -- gcd )
  5   ?DUP IF
  6     TUCK MOD
  7     RECURSE
  8   THEN ;
  9 \ Factorial
 10 : FACT ( n -- d  )
 11   ?DUP   IF
 12     DUP 1- RECURSE *
 13   ELSE
 14          1 THEN ;
 15 

Scr# 38 
  0 ( RND Test )
  1 : TEST
  2   0 SYS-SEED !
  3   32767 0 DO
  4     32767
  5     RND
  6     256 /MOD
  7     PLOT
  8     ?TERMINAL IF LEAVE THEN
  9   LOOP
 10 ;
 11 
 12 
 13 
 14 
 15 

Scr# 39 
  0 ( CHOOSE - Brodie )
  1 DECIMAL
  2 23670 CONSTANT SYS-SEED
  3 : RANDOM
  4   SYS-SEED @ 31421 *
  5   6927 + DUP SYS-SEED !
  6 ;
  7 : CHOOSE ( u1 -- u2 )
  8   RANDOM UM* NIP
  9 ;
 10 \
 11 : RANDOMIZE
 12   SYS-SEED ! ;
 13 ;S
 14 
 15 

Scr# 40 
  0 .( RND ) CR
  1 DECIMAL
  2 23670 CONSTANT SYS-SEED
  3 \ gives a pseudo-random
  4 \ between 0 and n
  5 : RND ( n -- rnd(n)
  6   1+ SYS-SEED @
  7   8191 UM* \ it was U*
  8   1.  D+
  9   16381 UM/MOD
 10   DROP DUP SYS-SEED !
 11   SWAP MOD ;
 12 \
 13 : RANDOMIZE
 14   SYS-SEED ! ;
 15 ;S

Scr# 41 
  0 .( Color and attributes  ) CR
  1 NEEDS CALL#
  2 HEX
  3 : PERM  0 1CAD CALL# DROP ;
  4 : BORDER. 2297 CALL# DROP ;
  5 DECIMAL
  6 : (COLOR)
  7   ROT AND SWAP EMITC EMITC
  8   PERM ;
  9 : INK.     16 7 (COLOR) ;
 10 : PAPER.   17 7 (COLOR) ;
 11 : FLASH.   18 1 (COLOR) ;
 12 : BRIGHT.  19 1 (COLOR) ;
 13 : INVERSE. 20 1 (COLOR) ;
 14 : OVER.    21 1 (COLOR) ;
 15 -->

Scr# 42 
  0 ( AT TAB                   )
  1 : AT.
  2   22 EMITC 31 AND SWAP
  3   21 MIN EMITC EMITC ;
  4 : TAB.
  5   23 EMITC EMITC 0 EMITC ;
  6 : LVIDEO
  7   2 23659 C! 1 SELECT ;
  8 : ATTR  ( x y --- b )
  9   SWAP 32 * + 22528 + C@ ;
 10 ;S
 11 : VIDEO
 12   2 DEVICE !
 13   1 23659 C! 2 SELECT ;
 14 -->
 15 

Scr# 43 
  0 ( POINT SCREEN$ )
  1 CODE  POINT  HEX
  2   E1 C, D1 C, C5 C, 454B ,
  3   CD C, 22AA , 47 C, 04 C,
  4   7E C, 07 C, 10 C, -3 C,
  5   E6 C, 01 C, 6F C, 26 C, 0 C,
  6   E5 C, E9DD , ( PSH1 )
  7 SMUDGE
  8 \
  9 CODE  SCREEN$  HEX
 10   E1 C, D1 C, C5 C, 454B ,
 11   CD C, 2538 , CD C, 2BF1 ,
 12   1A C, 6F C, 26 , C1 C,
 13   E5 C, E9DD , ( PSH1 )
 14 SMUDGE
 15 -->

Scr# 44 
  0 ( PLOT )
  1 NEEDS CALL#
  2 HEX
  3 CODE  PLOT   HEX
  4   E1 C, D1 C, C5 C,
  5   45 C, 4B C, CD C, 22E5 ,
  6   C1 C,
  7   DD C, E9 C, ( NEXT ) SMUDGE
  8 \
  9 -->
 10 : CIRCLE
 11   ROT 0 >W SWAP 0 >W 0 >W
 12   232D CALL#
 13   ;
 14 \
 15 -->

Scr# 45 
  0 ( DRAW                     )
  1 CODE  (DRAW)  HEX
  2   D1 C, E1 C, C5 C,
  3   4D C, 43 C, 5C C,
  4   CD C, 24BA ,
  5   C1 C,
  6   DD C, E9 C, ( NEXT ) SMUDGE
  7 : DRW1
  8   100 OVER +- SWAP ABS + ;
  9 : DRAW
 10   SWAP DRW1 SWAP DRW1
 11   (DRAW)
 12 ;
 13 -->
 14 
 15 

Scr# 46 
  0 ( PAINT )
  1 HEX
  2 : HIT ( x y d -- )
  3   >R
  4   BEGIN
  5    2DUP PLOT
  6    R + ABS 0B0 MOD
  7    2DUP POINT
  8   UNTIL
  9   R> DROP 2DROP ;
 10 : HIT2 ( x y -- )
 11   2DUP 1 HIT -1 HIT
 12   ?TERMINAL IF QUIT THEN
 13 ;
 14 -->
 15 

Scr# 47 
  0 ( PAINT )
  1 DECIMAL
  2 : HITX ( x y d -- )
  3   >R
  4   BEGIN
  5     SWAP R + 255 AND SWAP
  6     2DUP POINT 0=
  7   WHILE
  8     2DUP HIT2
  9   REPEAT
 10   R> DROP 2DROP
 11 ;
 12 : PAINT ( x y -- )
 13   2DUP HIT2
 14   2DUP 1 HITX -1 HITX
 15 ;

Scr# 48 
  0 ( Mr Jones' keyboard test )
  1 NEEDS ASSEMBLER
  2 CODE KEYBOARD?
  3   POP   HL|
  4   LD    A'|  L|
  5   ANDN  7    N,
  6   INC   A'|
  7   LD    H'|  A|
  8   SRL    L|
  9   SRL    L|
 10   SRL    L|
 11   LDN   A'|   5  N,
 12   SUBA   L|
 13   LD    L'|  A|
 14   LDN   A'|  HEX FE N,
 15 -->

Scr# 49 
  0 ( Mr Jones' keyboard test )
  1   HERE
  2     RRCA DEC H'|
  3   JRF   NZ'| BACK,
  4   INA   HEX FE P,
  5   HERE
  6     RRA  DEC L'|
  7   JRF   NZ'| BACK,
  8   CCF
  9   RL    L|
 10   PSH1
 11 C;
 12 DECIMAL
 13 
 14 
 15 

Scr# 50 
  0 .( BLEEP ) CR
  1 \
  2 ( n1 = {3.5M/Hz-241}/8 )
  3 ( n2 = 1000 * ms / Hz )
  4 \
  5 CODE  BLEEP  HEX
  6   E1 C, \ POP HL
  7   D1 C, \ POP DE
  8   C5 C, \ PUSH BC
  9   DD C, E5 C, \ PUSH IX
 10   CD C, 03B5 , \ CALL 03B5
 11   DD C, E1 C, \ POP IX
 12   C1 C, \ POP BC
 13   DD C, E9 C, ( NEXT )
 14 SMUDGE DECIMAL
 15 -->

Scr# 51 
  0 ( BLEEP )
  1 : BLEEP-CALC  ( ms Hz -- n1 n2 )
  2   >R R 1000 */
  3   3500.000 R> UM/MOD
  4   241 - 8 /
  5   SWAP DROP ;
  6 : BEEP-PITCH  ( BEEP pitch -- freq )
  7   69 SWAP -
  8   12 /MOD 14080
  9   SWAP 0 ?DO 2/ LOOP
 10   SWAP 0 ?DO 269 286 */ LOOP
 11 ;
 12 
 13 
 14 
 15 

Scr# 52 
  0 ( Pitch bend )
  1 CODE PITCH-BEND
  2   PUSH  BC|
  3   LDX   HL|  500  NN,
  4   LDN   B'|  250   N,
  5   HERE
  6     LDX   DE|    1  NN,
  7     PUSH  BC|  PUSH  HL|  PUSH  IX|
  8     CALL  949 AA,
  9     POP   IX|  POP   HL|  POP   BC|
 10     INCX  HL|
 11   DJNZ  BACK,
 12   POP   BC|
 13   NEXT C;
 14 
 15 

Scr# 53 
  0 ( KEYBOARD-TEST )
  1 : KEYBOARD-TEST
  2   BEGIN
  3     40 0 DO
  4       I KEYBOARD?
  5       IF I . CR THEN
  6     LOOP
  7     ?TERMINAL
  8   UNTIL
  9 ;
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 54 
  0 ( ?ESCAPE experiment       )
  1 CODE  ?ESCAPE
  2   HEX
  3   3E C, FE C, DB C, FE C,
  4   2F C, 5F C,
  5   3E C, F7 C, DB C, FE C,
  6   2F C,
  7   A3 C, E6 C, 01 C,
  8   26 C, 00 C, 6F C,
  9   E5 C, E9DD , ( PSH1 )
 10 SMUDGE DECIMAL ;S
 11 : ESCAPE-TEST
 12   1000 0 DO 2E EMIT
 13     ?ESCAPE IF LEAVE THEN
 14   LOOP ;
 15 DECIMAL

Scr# 55 
  0 ( MS delay )
  1 \ at 3.5MHz n ms delay
  2 DECIMAL
  3 CODE ms ( n -- )
  4   POP DE|
  5   LD  D'|  B|
  6   LDN H'|  205  N,
  7   HERE   \ BEGIN,
  8     LD  B'|  H|
  9     HERE
 10       NOP
 11     DJNZ BACK,
 12     DEC  E'|
 13   JRF NZ'| BACK,
 14   LD  B'| D|
 15   NEXT C;

Scr# 56 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 57 
  0 ( FRAMES )
  1 : FRAMES ( n -- )  \ equivalent to Basic PAUSE n
  2   0 ?DO
  3     [ HEX ] 5C78 @
  4     BEGIN
  5       DUP [ HEX ] 5C78 @ -
  6     UNTIL
  7     DROP
  8   LOOP ;
  9 \
 10 : FRAMES@
 11   [ HEX ] 5C78 DUP CELL+ C@ >R @ R> ;
 12 \
 13 DECIMAL
 14 
 15 

Scr# 58 
  0 ( FRAMES 2 )
  1 : T FRAMES@ D. ;
  2 : TT 1FRAME 1FRAME
  3   FRAMES@ ROT MS FRAMES@
  4   2SWAP DMINUS D+ . . ;
  5 : TEST ( frames -- )
  6   400 18 DO
  7   I DUP . TT
  8   I 1+ DUP . TT
  9   I 2+ DUP . TT
 10   I 3 + DUP . TT
 11   CR 100 +LOOP
 12 ;
 13 
 14 
 15 

Scr# 59 
  0 ( TEST )
  1 HEX 5800
  2 CONSTANT ADDRESS
  3 20 VARIABLE DELAY
  4 : WAIT
  5   DELAY @ 0 DO 1FRAME LOOP
  6 ;
  7 : TEST1
  8   87 ADDRESS 2+ C!
  9   BEGIN
 10   00 ADDRESS C! WAIT
 11   3F ADDRESS C! WAIT
 12   ?TERMINAL
 13   UNTIL
 14 ;
 15 DECIMAL

Scr# 60 
  0 ( Interrupt Handler )
  1 HEX ;S
  2 CODE  INT-EI
  3   FB C,
  4   DD C, E9 C, ( NEXT ) SMUDGE
  5 CODE  INT-DI
  6   F3 C,
  7   DD C, E9 C, ( NEXT ) SMUDGE
  8 CODE  INT-IM1
  9   56ED , ( IM 1 )
 10   DD C, E9 C, ( NEXT ) SMUDGE
 11 CODE  INT-IM2
 12   5EED , ( IM 2 )
 13   DD C, E9 C, ( NEXT ) SMUDGE
 14 -->
 15 

Scr# 61 
  0 ( Interrupt Handler )
  1 HEX
  2 CODE  SETIREG
  3   E1 C, ( POP HL )
  4   7D C, ( LD A,L )
  5   47ED , ( LD I,A )
  6   DD C, E9 C, ( NEXT ) SMUDGE
  7 \
  8 : INT-OFF
  9   INT-DI
 10   3F SETIREG INT-IM1
 11   INT-EI
 12 ;
 13 \
 14 0 VARIABLE INT-SAVE
 15 -->

Scr# 62 
  0 ( Interrupt Handler )
  1 HEX
  2 CODE  INT-RET
  3   ED C, 7B C, INT-SAVE ,
  4   E1 C, \ POP HL
  5   22 C, (NEXT) 4 - ,
  6   C1 C, D1 C, E1 C, \ BCDEHL
  7   D9 C, \ EXX
  8   C1 C, D1 C, E1 C, \ BCDEHL
  9   F1 C, 08 C, F1 C, \ AF
 10   DD C, E1 C, \ POP IX
 11 \
 12   C3 C, 0038 , \ CALL 38
 13   FB C, C9 C, \ EI RET
 14 SMUDGE
 15 -->

Scr# 63 
  0 ( Interrupt Handler )
  1 ' NOOP VARIABLE INT-W
  2 ' INT-RET ,
  3 -->
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 64 
  0 ( Interrupt Handler )
  1 HEX
  2 CODE  INT-SUB
  3   DD C, E5 C, \ PUSH IX
  4   F5 C, 08 C, F5 C, \ AF
  5   E5 C, D5 C, C5 C, \ HLDEBC
  6   D9 C, \ EXX
  7   E5 C, D5 C, C5 C, \ HLDEBC
  8   \ RP
  9   2A C, (NEXT) 4 - ,
 10   E5 C,
 11   \
 12   11 C, -10 ,
 13   19 C, ( ADD HL,DE )
 14   22 C, (NEXT) 4 - ,
 15 -->

Scr# 65 
  0 ( Interrupt Handler )
  1   \ SP
  2   ED C, 73 C, INT-SAVE ,
  3   \
  4   21 C, -10 ,
  5   39 C, ( ADD HL,SP )
  6   F9 C, ( LD  SP,HL  )
  7   \
  8   01 C, INT-W ,
  9        ( LD BC, INT-W )
 10   DD C, E9 C, ( NEXT )
 11 SMUDGE
 12 -->
 13 
 14 
 15 

Scr# 66 
  0 ( Interrupt Handler )
  1 -->
  2 
  3 HEX
  4 : INT-ON
  5   [ ' INT-SUB 2+ ] LITERAL
  6   \ 63FF !
  7   0 +ORIGIN 1- !
  8   \ 63 LDIA
  9   0 + ORIGIN 1- 100 /
 10   SETIREG
 11   IM2
 12   EI
 13 ;
 14 DECIMAL
 15 

Scr# 67 
  0 ( Interrupt Handler )
  1 HEX
  2 : INT-ON
  3   [ ' INT-SUB 2+ ] LITERAL
  4   DUP INT-DI
  5   18 FFFF C!
  6   C3 FFF4 C!
  7      FFF5 !
  8   C3 FFE2 C!
  9      FFE3 !
 10   39 SETIREG \ last ROM page
 11   INT-IM2
 12   INT-EI
 13 ;
 14 
 15 

Scr# 68 
  0 ( INTERRUPT - TEST )
  1 HEX
  2 : TEST
  3   55 4700 C!
  4   4700 4701 FF CMOVE
  5   4700 4F00 100 CMOVE
  6   4700 5700 100 CMOVE
  7 ;
  8 DECIMAL
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 69 
  0 ( INTERRUPT )
  1 INT-OFF
  2 ' TEST INT-W !
  3 INT-ON
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 70 
  0 .( Compare Utility. ) CR
  1 \ Compare two strings and return  0 if they're equal
  2 \ or  1 if s1 > s2  or  -1 if s1 < s2
  3 : COMPARE  ( a1 c1 a2 c2 -- -1|0|1 )
  4   ROT 2DUP SWAP - >R              \ a1 a2 c2 c1      \ c1-c2
  5   MIN                             \ a1 a2 min(c2,c1) \ c1-c2
  6   (COMPARE)                       \ b                \ c1-c2
  7   R> SWAP ?DUP                    \ c1-c2 b b<>0
  8   IF                              \ c1-c2 b that is not zero
  9     SWAP DROP                     \ b that is 1 or -1
 10   ELSE                            \ c1-c2
 11     1 SWAP *                      \ sign(c1-c2) or zero
 12   THEN ;                          \ n
 13 -->
 14 CREATE S1 ," Hello world!"
 15 CREATE S2 ," Hello world?"

Scr# 71 
  0 .( Search utility. ) CR
  1 : SEARCH.TRC  BLK @ 6 .R  >IN @ 6 .R ;
  2 : SEARCH.SHOW
  3   BLK @ B/SCR /MOD  DUP >R   6 .R  B/BUF * >IN @ +
  4   C/L /MOD  DUP >R           6 .R  PAD C@ 1+ -  6 .R
  5   R> R> 6 SPACES (LINE) 2/  TYPE   CR ;
  6 : SEARCH.SCR ( -- f )
  7   BL WORD COUNT
  8   PAD COUNT COMPARE ;
  9 \
 10 : LOCATE.SCR ( -- f )
 11   BL WORD @ 14849 =
 12   IF SEARCH.SCR
 13   ELSE 1 THEN ;
 14 -->
 15 : TESTX NOOP ;

Scr# 72 
  0 ( SEARCH )
  1 : SEARCH.BLK   ( b -- )
  2   BLK @ >R >IN @ >R
  3   0 >IN ! BLK !
  4   BEGIN
  5     SEARCH.SCR
  6     0= IF SEARCH.SHOW ENDIF
  7     HERE 1+ C@ 0=
  8   UNTIL
  9   R> >IN ! R> BLK !
 10 ;
 11 -->
 12 
 13 
 14 
 15 

Scr# 73 
  0 ( BSEARCH SEARCH-ALL )
  1 \ Search the following word and show result
  2 NEEDS SHOW-PROGRESS NEEDS TEXT
  3 : BSEARCH ( n m -- cccc )
  4   BL TEXT    ." ...Searching for "
  5   PAD COUNT TYPE CR
  6   ." Screen  Line  Char" CR
  7   1+ B/SCR *  SWAP B/SCR *
  8   DO
  9     I SHOW-PROGRESS
 10     I  SEARCH.BLK
 11     ?TERMINAL IF ." Stop at " I B/SCR / . LEAVE ENDIF
 12   LOOP
 13 ;
 14 : GREP       1 1000 BSEARCH ;
 15 -->

Scr# 74 
  0 ( LOCATE )
  1 : LOCATE.BLK   ( b -- )
  2   BLK @ >R >IN @ >R
  3   0 >IN !  BLK !
  4   BEGIN
  5     LOCATE.SCR
  6     0= IF CLS
  7       BLK @ B/SCR / LIST QUIT ENDIF
  8     ?TERMINAL \ ?ESCAPE
  9     IF ." Stop at " BLK ? QUIT THEN
 10     HERE 1+ C@ 0=
 11   UNTIL
 12   R> >IN ! R> BLK !
 13 ;
 14 -->
 15 

Scr# 75 
  0 ( LOCATE )
  1 NEEDS SHOW-PROGRESS
  2 : LOCATE ( -- cccc )
  3   BL TEXT
  4   2001 1 DO
  5     I SHOW-PROGRESS
  6     I LOCATE.BLK
  7   LOOP
  8   ." Not found. " ;
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 76 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 77 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 78 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 79 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 80 
  0 .( Heap Memory Management ) CR
  1 \ Convert an heap-pointer address into a real address
  2 \ between E000h and FFFFh and fit the 8K page on MMU7
  3 \ An "ha" uses 3 msb as page-number and lower bits as offset
  4 NEEDS >FAR
  5 : FAR  ( ha -- a )
  6   >FAR MMU7! ;
  7 \
  8 \ Get current Heap Pointer
  9 : HP@ ( -- ha )
 10   HP @ ;
 11 \
 12 \ like CONSTANT but return a Heap-Pointer-Address
 13 : POINTER ( ha -- ccc )
 14   <BUILDS , DOES> @ FAR ;
 15 -->

Scr# 81 
  0 ( Heap Memory Management )
  1 \ check if n bytes are available in this 8K-page in Heap
  2 \ otherwise skip HP to the beginning of next 8K-page
  3 HEX
  4 : SKIP-PAGE ( n -- )
  5   CELL+                         \ always needs 2 bytes more
  6   HP@ >FAR DROP 1FFF  AND       \ take offset only
  7   +  1FFF >                     \ check greater than a page
  8   IF
  9     [ 1FFF 1 >FAR DROP 0 >FAR DROP - / ]
 10     LITERAL HP@ OR 1+ HP !      \ HP goes to the next page
 11   THEN
 12   HP@ 0= [ DECIMAL ] 12 ?ERROR  \ out of memory
 13 ;
 14 \
 15 -->

Scr# 82 
  0 ( Heap Memory Management )
  1 \ Reserve n bytes of Heap, return heap-pointer address
  2 \ Heap is a linked-list starting from P:0002=$40:$E002
  3 \
  4 : HEAP ( n -- ha )
  5   DUP SKIP-PAGE     \ n         check 8k page boundary
  6   HP@ SWAP          \ ha  n
  7   CELL+             \ ha n+2    room for link to previous HP
  8   HP +!             \ ha        advance HP by n+2
  9   HP@ SWAP          \ hp ha
 10   TUCK              \ ha hp ha
 11   FAR !             \ ha        store previous HP
 12   CELL+             \ ha        final heap-address
 13 ;
 14 \
 15 -->

Scr# 83 
  0 ( Heap Memory Management )
  1 \ Accept a string and store it to Heap, return a
  2 \ heap-address pointer (to a counted string)
  3 \
  4 : H" ( -- ha )
  5   HP@ CELL+              \ ha
  6   [CHAR] "  WORD         \ ha a1       accept string from strm
  7   DUP C@ 1+              \ ha a1 u
  8   TUCK HEAP >FAR DROP    \ ha  u a1 a2
  9   DUP >R >FAR            \ ha  u a2
 10   ROT                    \ ha a1 a2 u
 11   CMOVE                  \ ha
 12 ;
 13 \ : C" H" DROP ;
 14 -->
 15 

Scr# 84 
  0 ( Heap Memory Management )
  1 \ immutable  string on heap
  2 : (S") R @ FAR COUNT R> CELL+ >R ;
  3 : S"  ( -- a n )
  4   STATE @
  5   IF
  6     COMPILE (S") H" ,
  7   ELSE
  8     H" FAR COUNT
  9   ENDIF
 10 ; IMMEDIATE
 11 \
 12 -->
 13 \
 14 : TEST_S"  S" HELLO WORLD" NOOP ;
 15 CR TEST_S" TYPE CR S" HELLO WORLD" TYPE

Scr# 85 
  0 ( S" Counted Strings in Heap )
  1 \ consume  c  and append to the string being created
  2 \ in Heap at ha
  3 \ return the same Heap-Pointe to the counted string
  4 \
  5 : +C ( ha c -- ha )
  6   OVER FAR                 \ ha c  a
  7   1 OVER CELL- +!          \ fix linked list pointer
  8   DUP C@ 1+ SWAP 2DUP      \ ha c  n  a  n  a
  9   C!                       \ ha c  n  a   :  fix length
 10   + C!                     \ ha           : store c
 11   1 HP +!                  \ ha
 12 ;
 13 -->
 14 
 15 

Scr# 86 
  0 ( S" Counted Strings in Heap )
  1 \ accept a string and store it to the being created on Heap
  2 \ appending to the existing string at "ha"
  3 \ return the same Heap-Pointer to the counted string on Heap
  4 \
  5 : +" ( ha -- ha )
  6   DUP FAR C@
  7   [CHAR] " WORD
  8   DUP C@ >R 1+
  9   HP@ FAR R CMOVE
 10   R HP +!
 11   R> +
 12   OVER FAR C!
 13   DUP FAR HP@ SWAP !
 14 ;
 15 -->

Scr# 87 
  0 ( Allocate RAM banks $40-$47 for string heap )
  1 : HEAP-DOS ( n -- )
  2   [ HEX ] 48 40 DO
  3     DUP  I  0  0  01BD  M_P3DOS
  4     2C ?ERROR  2DROP 2DROP
  5   LOOP DROP ;
  6 \
  7 : HEAP-INIT  2 HEAP-DOS ;
  8 : HEAP-DONE  3 HEAP-DOS ;
  9 HEAP-DONE HEAP-INIT
 10 WARNING @ 0 WARNING !
 11 : COLD HEAP-DONE COLD ; \ so COLD frees RAM first
 12 WARNING !
 13 DECIMAL
 14 
 15 

Scr# 88 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 89 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 90 
  0 .( Line editor. )         CR
  1 NEEDS INVV NEEDS TRUV -->
  2 \ See .pdf documentation.
  3 \
  4 \ Inverse/True Video
  5 : INVV ( -- )
  6   [ HEX 14 ] LITERAL EMITC
  7   1 EMITC
  8 ;
  9 : TRUV ( -- )
 10   [ HEX 14 ] LITERAL EMITC
 11   0 EMITC
 12 ;
 13 DECIMAL
 14 --> \ Continue LOADing
 15     \ on next Screen.

Scr# 91 
  0 ( Line Editor          2/6 )
  1 : TEXT ( c -- )     \ accept following text to PAD
  2   HERE C/L 1+ BLANKS WORD PAD C/L 1+ CMOVE ;
  3 : LINE ( n -- a )   \ leave address of current screen line n
  4   DUP 0 <        3 ?ERROR  \ error 3: No such line.
  5   DUP L/SCR < 0= 3 ?ERROR
  6   SCR @ (LINE) DROP ;
  7 : -MOVE ( a -- n )  \ move from a to current screen line n
  8   LINE C/L CMOVE UPDATE ;
  9 \
 10 --> \ continues to next
 11 \ Quick reference
 12 \ [ TIB ]  <->  [ PAD ]  <->   [BLOCK]
 13 \          TEXT        H  E  RE
 14 \                      D  S  INS
 15 

Scr# 92 
  0 ( Line Editor          3/6 )
  1 : H ( n -- )        \ hold line n to PAD
  2   LINE PAD 1+ C/L DUP PAD C! CMOVE ;
  3 : E ( n -- )        \ blank line n of current screen
  4   LINE C/L BLANKS UPDATE ;
  5 : RE ( n -- )       \ replace line n using PAD content
  6   PAD 1+ SWAP -MOVE ;
  7 : D ( n -- )        \ remove line n from current screen
  8   DUP H L/SCR 1- DUP ROT ?DO I 1+ LINE I -MOVE LOOP E ;
  9 : S ( n -- )        \ shift lines >= n down by one
 10   DUP  L/SCR 1- DO  I 1- LINE  I -MOVE  -1 +LOOP E ;
 11 : INS ( n -- )      \ insert line n from PAD
 12   DUP S RE ;
 13 -->
 14 \ 14
 15 

Scr# 93 
  0 ( Line Editor          4/6 )
  1 : P ( n -- ) \ put line n
  2   126 TEXT RE ;
  3 : L ( -- ) \ list current
  4   SCR @ LIST ;
  5 : N ( -- ) \ next screen
  6   1 SCR +! L ;
  7 : B ( -- ) \ back screen
  8   -1 SCR +! L ;
  9 : BCOPY ( n1 n2 -- ) \ copy screen n1 to n2, overvriting it
 10   DUP SCR ! B/SCR * SWAP B/SCR *
 11   B/SCR 0 DO 2DUP
 12   BLOCK SWAP BLOCK B/BUF CMOVE UPDATE
 13   SWAP 1+ SWAP 1+
 14   LOOP 2DROP ;
 15 -->

Scr# 94 
  0 ( Line Editor          5/6 )
  1 \ usually used after an error during LOAD:
  2 : WHERE ( n1 n2 -- ) \ display offending row after an error
  3   DUP B/SCR /MOD DUP SCR ! ." Screen# " DECIMAL . CR
  4   B/BUF * ROT + C/L /MOD DUP 3 .R SPACE
  5   ROT B/SCR / (LINE) -TRAILING TYPE
  6   CR 2+ SPACES [CHAR] ^ EMIT SPACE
  7 ;
  8 \
  9 -->
 10 \
 11 \ quick reference
 12 [TIB] <> [PAD]  <>  [BLOCK]
 13               H E RE
 14      TEXT     D S INS
 15 

Scr# 95 
  0 ( Line Editor          6/6 )
  1 : .PAD ( -- ) \ show PAD content
  2   PAD C/L -TRAILING TYPE ;
  3 : SAVE ( -- ) \ save all modified screens flushing to disk
  4   UPDATE FLUSH ;
  5 : UNUSED ( -- n ) \ return free dictionary space
  6   SP@ PAD - ;
  7 : ROOM ( -- ) \ display room available in dictionary
  8   UNUSED U. ." bytes free." CR ;
  9 ;S
 10 \
 11 \ omitted:
 12 : BMOVE OVER SWAP BCOPY
 13   BCLEAR ;
 14 ;S
 15 

Scr# 96 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 97 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 98 
  0 ( Editor utility           )
  1 \ multiple BCOPY
  2 : MBCOPY ( b1 b2 n --- )
  3   FLUSH
  4   >R 2DUP > IF
  5     R> 0 DO 2DUP BCOPY
  6     1 + SWAP 1 + SWAP
  7     46 EMIT LOOP
  8   ELSE
  9     R + 1 - SWAP R + 1 - SWAP
 10     0 R> DO 2DUP BCOPY
 11     1 - SWAP 1 - SWAP
 12     46 EMIT -1 +LOOP
 13   THEN
 14   2DROP ;
 15 

Scr# 99 
  0 .( Call utility. )        CR
  1 \ CALL# ( n1 a -- n2 )
  2 \ must save BC and IX
  3 HEX
  4 CODE  CALL#  ( n1 -- n2 )
  5   E1 C, D1 C,         \ pop hl   pop de
  6   C5 C, DD C, E5 C,   \ push bc  push ix
  7   4B C, 42 C, 7B C,   \ ld a,e   ld bc,de
  8   CD C,  (NEXT) 0A + ,   \ call hl
  9   69 C, 60 C,         \ ld hl,bc
 10   DD C, E1 C, C1 C,   \ pop ix   pop bc
 11   E5 C,               \ push hl
 12   DD C, E9 C,         \ jp ix
 13   SMUDGE
 14 DECIMAL
 15 

Scr# 100 
  0 ." Assembler. "           CR
  1 \ Loads ASSEMBLER vocabulary
  2 FORTH  DEFINITIONS   MARKER FORGET-ASSEMBLER \ MARKER-ASM
  3 VOCABULARY TOOLS-ASM IMMEDIATE
  4 VOCABULARY FORTH-ASM
  5 \
  6 \ DECIMAL 118 LOAD \ MMU allocation ( Seems bugged )
  7 : ASSEMBLER FORTH-ASM 1 MMU7! ; IMMEDIATE
  8 DECIMAL 101 LOAD \ tools
  9 DECIMAL 120 LOAD \ Z80
 10 DECIMAL 140 LOAD \ structure
 11 DECIMAL 160 LOAD \ Z80N
 12 DECIMAL 117 LOAD \ final CODE patch
 13 ." Done " CR
 14 ;S
 15 

Scr# 101 
  0 .( Z80 Assembler. ) CR
  1 ASSEMBLER TOOLS-ASM DEFINITIONS
  2   DP @ LP ! HEX E080 DP !
  3 : INVERT -1 XOR ;
  4 : @+ >R R CELL+ R> @ ;
  5 : !+ >R R ! R> CELL+ ;
  6 : @- 0 CELL+ - >R R @ R> ;
  7 1 VARIABLE TABL1 1 ,
  8 : ROTLEFT  TABL1 + @
  9   UM* \ U*
 10   OR ;
 11 \
 12 CHAR - CONSTANT &-
 13 CHAR ~ CONSTANT &~
 14 -->
 15 

Scr# 102 
  0 ( Z80 Utility - Sys depend )
  1 : % COMPILE ' <NAME ;
  2 \ : % POSTPONE ' <NAME ;
  3 : %ID. ID. ;
  4 : %>BODY PFA CELL+ ;
  5 : %BODY> 0 CELL+ - NFA ;
  6 : %>CODE PFA CFA CELL+ ;
  7 : IGNORE? 1+ C@ &~ = ;
  8 : (>NEXT%) PFA LFA @ ;
  9 : VOCEND?
 10   @ FFFF AND A081 = ;
 11 : >NEXT% BEGIN (>NEXT%)
 12   DUP 1+ C@ &- - UNTIL ;
 13 -->
 14 
 15 

Scr# 103 
  0 ( Z80 Utility - Sys depend )
  1 : STARTVOC ' ASSEMBLER 2 +
  2   CELL+ @ ;
  3 : IS-A <BUILDS
  4   0 ,
  5   DOES>
  6   @ SWAP %>CODE @ = ;
  7 : REMEMBER HERE LATEST
  8   (>NEXT%) %>BODY ! ;
  9   IMMEDIATE
 10 : CONTAINED-IN OVER AND = ;
 11 -->
 12 
 13 
 14 
 15 

Scr# 104 
  0 ( Z80 System independ. )
  1 \ 0 VARIABLE TABLE FF ,
  2 \ FFFF , FFFFFF , FFFFFFFF ,
  3 \ : FIRSTBYTES CELLS TABLE
  4 \   + @ AND ;
  5 0 VARIABLE TALLY-BI
  6 0 VARIABLE TALLY-BY
  7 0 VARIABLE TALLY-BA
  8 0 VARIABLE ISS
  9 0 VARIABLE ISL
 10 0 VARIABLE PREVIOUS
 11 : !TALLY 0 TALLY-BY !
 12  0 TALLY-BI ! 0 TALLY-BA !
 13  0 PREVIOUS ! ;
 14 -->
 15 

Scr# 105 
  0 ( Z80 System independ. )
  1 : AT-REST? TALLY-BI @ 0=
  2  TALLY-BY @ 0= AND ;
  3 : BADPAIRS? DUP 2 * AND
  4  AAAAAAAA AND ;
  5 : BAD?
  6  TALLY-BA @ BADPAIRS? ;
  7 : COMPATIBLE?
  8  TALLY-BA @ OR BADPAIRS?
  9  0= ;
 10 DECIMAL
 11 -->
 12 
 13 
 14 
 15 

Scr# 106 
  0 ( Z80 Generate errors )
  1 : CHECK26 AT-REST? 0=
  2   26 ?ERROR ;
  3 : CHECK27 BAD? 27 ?ERROR ;
  4 : CHECK31 2DUP SWAP
  5   CONTAINED-IN 0= 31 ?ERROR ;
  6 : CHECK33 2DUP SWAP INVERT
  7   CONTAINED-IN 0= 33 ?ERROR ;
  8 : CHECK28 2DUP AND 28 ?ERROR ;
  9 : CHECK29 2DUP OR -1 -
 10   29 ?ERROR ;
 11 : CHECK30 DUP PREVIOUS @ <
 12   30 ?ERROR DUP PREVIOUS ! ;
 13 HEX
 14 -->
 15 

Scr# 107 
  0 ( Assembler Z80 )
  1 : OR!
  2   >R R @ CHECK28 OR R> ! ;
  3 : OR!U >R R @ OR R> ! ;
  4 : AND! >R INVERT R @
  5   CHECK29 AND R> ! ;
  6 -->
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 108 
  0 ( Assembler Z80 )
  1 : >DATA %>BODY ;
  2 : >BI %>BODY CELL+ ;
  3 : >BY %>BODY 2 CELLS + ;
  4 : >BA %>BODY 3 CELLS + ;
  5 : >CNT %>BODY 4 CELLS + ;
  6 : >DIS %>BODY 5 CELLS ;
  7 : CORRECT,-
  8   ISL @ 1 CELLS - ALLOT ;
  9 : !POSTIT
 10   HERE ISS ! 0 PREVIOUS ! ;
 11 : TALLY:, @+ TALLY-BI !
 12   @+ TALLY-BY ! @+ TALLY-BA !
 13   @ ISL ! ;
 14 -->
 15 

Scr# 109 
  0 ( Assembler Z80 )
  1 : POSTIT CHECK26 !POSTIT
  2   HERE ISS ! @+ , TALLY:,
  3   CORRECT,- ;
  4 IS-A IS-CBPI : CBPI CHECK33
  5 <BUILDS , , , , 1 , DOES>
  6 REMEMBER CB C, POSTIT ;
  7 IS-A IS-EDPI : EDPI CHECK33
  8 <BUILDS , , , , 1 , DOES>
  9 REMEMBER ED C, POSTIT ;
 10 IS-A IS-DDPI : DDPI CHECK33
 11 <BUILDS , , , , 1 , DOES>
 12 REMEMBER DD C, POSTIT ;
 13 IS-A IS-FDPI : FDPI CHECK33
 14 <BUILDS , , , , 1 , DOES>
 15 REMEMBER FD C, POSTIT ; -->

Scr# 110 
  0 ( Assembler Z80 )
  1 IS-A IS-1PI : 1PI CHECK33
  2 <BUILDS , , , , 1 , DOES>
  3 REMEMBER POSTIT ;
  4 IS-A IS-2PI : 2PI CHECK33
  5 <BUILDS , , , , 2 , DOES>
  6 REMEMBER POSTIT ;
  7 IS-A IS-3PI : 3PI CHECK33
  8 <BUILDS , , , , 3 , DOES>
  9 REMEMBER POSTIT ;
 10 : IS-PI >R R IS-1PI
 11  R IS-2PI R IS-3PI OR OR
 12  R IS-CBPI R IS-EDPI OR OR
 13  R IS-DDPI R IS-FDPI OR OR
 14  R> DROP ;
 15 -->

Scr# 111 
  0 ( Assembler Z80 )
  1 : TALLY:|
  2   @+ TALLY-BI AND!
  3   @+ TALLY-BY OR!
  4   @  TALLY-BA OR!U ;
  5 : FIXUP> @+ ISS @ OR!
  6   TALLY:| CHECK27 ;
  7 IS-A IS-XFI : XFI CHECK31
  8 <BUILDS , , , , DOES>
  9 REMEMBER FIXUP> ;
 10 : CORRECT-R 0 CELL+ ISL @
 11 - ROTLEFT ;
 12 -->
 13 
 14 
 15 

Scr# 112 
  0 ( Assembler Z80 )
  1 : TALLY:|R @+ CORRECT-R
  2  TALLY-BI AND! @+ TALLY-BY OR!
  3  @ TALLY-BA OR!U ;
  4 : FIXUP< @+ CORRECT-R ISS
  5  @ OR! TALLY:|R CHECK27 ;
  6 IS-A IS-XFIR : XFIR CHECK31
  7 <BUILDS , , , , DOES>
  8 REMEMBER FIXUP< ;
  9 : TALLY:,, CELL+ @+ CHECK30
 10 TALLY-BY AND! @ TALLY-BA
 11 OR!U ;
 12 : COMMA @+ >R TALLY:,,
 13  CHECK27 R> EXECUTE ;
 14 -->
 15 

Scr# 113 
  0 ( Assembler Z80 )
  1 IS-A IS-COMMA
  2 : COMMAER
  3 <BUILDS , 0 , , , , , DOES>
  4 REMEMBER COMMA ;
  5 0 VARIABLE PRO-TALLY
  6   2 CELLS ALLOT
  7 : T! PRO-TALLY !+ !+ !+ DROP ;
  8 : T@ PRO-TALLY 3 CELLS +
  9   @- @- @- DROP ;
 10 -->
 11 
 12 
 13 
 14 
 15 

Scr# 114 
  0 ( Assembler Z80 )
  1 : 1FAMILY, 0 DO DUP >R T@
  2   R> 1PI OVER + LOOP
  3   DROP DROP ;
  4 : 2FAMILY, 0 DO DUP >R T@
  5   R> 2PI OVER + LOOP
  6   DROP DROP ;
  7 : 3FAMILY, 0 DO DUP >R T@
  8   R> 3PI OVER + LOOP
  9   DROP DROP ;
 10 : XFAMILY| 0 DO DUP >R T@
 11   R> XFI OVER + LOOP
 12   DROP DROP ;
 13 : XFAMILY|R 0 DO DUP >R T@
 14   R> XFIR OVER + LOOP
 15   DROP DROP ; -->

Scr# 115 
  0 ( Assembler Z80 )
  1 : CBFAMILY, 0 DO DUP >R T@
  2   R> CBPI OVER + LOOP
  3   DROP DROP ;
  4 : EDFAMILY, 0 DO DUP >R T@
  5   R> EDPI OVER + LOOP
  6   DROP DROP ;
  7 -->
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 116 
  0 ( Assembler Z80 )
  1 : DDFAMILY, 0 DO DUP >R T@
  2   R> DDPI OVER + LOOP
  3   DROP DROP ;
  4 : FDFAMILY, 0 DO DUP >R T@
  5   R> FDPI OVER + LOOP
  6   DROP DROP ;
  7 \
  8 ;S
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 117 
  0 ( Assembler z80 )
  1 FORTH DEFINITIONS RENAME CODE MCOD
  2 : CODE ?EXEC MCOD \ previous def of CODE
  3   [COMPILE] ASSEMBLER
  4   TOOLS-ASM
  5   !TALLY !CSP ; IMMEDIATE
  6 : C;  \ Ends a CODE definitions
  7   CURRENT @ CONTEXT !  ?EXEC
  8   TOOLS-ASM  CHECK26  CHECK27
  9   SMUDGE ; IMMEDIATE
 10 \
 11 ' ASSEMBLER ' ;CODE >BODY 4 CELLS + ! ( patch to ;CODE )
 12 \
 13 FORTH DEFINITIONS
 14 \
 15 ." Done" CR

Scr# 118 
  0 ( Assembler MMU config ) ;S seems bugged: don't use
  1 HEX 3F CONSTANT ASM-PAGE
  2 : ASM-MMU  ( n -- )
  3   DUP 1 - IF  ASM-PAGE 0 0 01BD M_P3DOS THEN
  4   DROP 2DROP 2DROP ;
  5 : ASM-MMU-DONE 3 ASM-MMU ;
  6 : FORGET-ASSEMBLER
  7   3 ASM-MMU \ free  8K-page
  8   [ ' CODE <NAME 1+ HEX ] LITERAL
  9   4F43 OVER ! C544 SWAP CELL+ ! \ Rename CODE
 10   MARKER-ASM ;
 11 : ASSEMBLER FORTH-ASM  ASM-PAGE MMU7! ; IMMEDIATE
 12 \
 13 3 ASM-MMU
 14 2 ASM-MMU   \ Allocate MMU page 3F
 15 

Scr# 119 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 120 
  0 .( Z80 definitions. ) CR
  1 ASSEMBLER DEFINITIONS HEX
  2 TOOLS-ASM
  3 \
  4 0 1 0 800 ' C,
  5   COMMAER N,
  6 0 0 CELL+ 0 200 ' ,
  7   COMMAER NN,
  8 0 0 CELL+ 0 400 ' ,
  9   COMMAER AA,
 10 0 1 0 100 ' C,
 11   COMMAER P,
 12 0 1 0 1000 ' C,
 13   COMMAER D,
 14 -->
 15 

Scr# 121 
  0 ( Z80 ) HEX
  1 00 00 00 T!
  2 08 07 8 1FAMILY,
  3   RLCA RRCA RLA  RRA  DAA  CPL  SCF  CCF
  4 \
  5 08 00 2 1FAMILY,   NOP       EXAFAF
  6 \
  7 08 E3 4 1FAMILY,   EX(SP)HL  EXDEHL  DI  EI
  8 \
  9 00 00 238 T!
 10 08 00 8 XFAMILY|
 11    00| 08| 10| 18|
 12    20| 28| 30| 38|
 13 00 00 238 C7 1PI    RST
 14 -->
 15 \ RST 38|  DAA

Scr# 122 
  0 ( Z80 ) HEX
  1 00 00 07 T!
  2 01 00 8 XFAMILY|
  3   B|  C|    D|  E|
  4   H|  L| (HL)|  A|
  5 08 80 8 1FAMILY,
  6  ADDA ADCA SUBA SBCA
  7  ANDA XORA ORA  CPA
  8 \
  9 00 00 00 76 1PI HALT
 10 -->
 11 \ ADDA B|
 12 \ HALT
 13 
 14 
 15 

Scr# 123 
  0 ( Z80 ) HEX
  1 00 00 30 T!
  2 10 00 4 XFAMILY|
  3   BC| DE| HL| SP|
  4 01 02 2 1FAMILY,
  5   LD(X)A INCX
  6 01 09 3 1FAMILY,
  7   ADDHL  LDA(X)  DECX
  8 00 0200 30 01 1PI LDX
  9 00 00 30 30 XFI AF|
 10 00 00 30 T!
 11 04 C1 2 1FAMILY,
 12   POP PUSH
 13 -->
 14 \ LD(X)A BC|
 15 \ LDX BC| nn NN,

Scr# 124 
  0 ( Z80 immediate data )
  1 00 0100 00 T!
  2 08 D3 2 1FAMILY,
  3   OUTA  INA
  4 00 0800 00 T!
  5 08 C6 8 1FAMILY,
  6   ADDN ADCN SUBN SBCN
  7   ANDN XORN ORN  CPN
  8 00 00 00 T!
  9 10 C9 4 1FAMILY,
 10   RET EXX JPHL LDSPHL
 11 -->
 12 \ OUTA n P,   INA n P,
 13 \ ADDN n N,
 14 
 15 

Scr# 125 
  0 ( Z80 address )
  1 00 0400 00 T!
  2 08 22 4 1FAMILY,
  3   LD()HL LDHL() LD()A LDA()
  4 0A C3 2 1FAMILY,
  5   JP CALL
  6 00 00 38 T!
  7 \ LD B'| C| LD()A nn AA,
  8 08 00 8 XFAMILY|
  9   B'| C'| D'| E'|
 10   H'| L'| (HL)'| A'|
 11 01 04 2 1FAMILY,
 12   INC DEC
 13 00 00 3F 40 1PI LD
 14 00 0800 38 06 1PI LDN
 15 -->

Scr# 126 
  0 ( Z80 ) HEX
  1 00 00 138 T!
  2 08 00 8 XFAMILY|
  3   NZ|  Z|  NC|  CY|
  4   PO| PE|   P|   M|
  5 00 00 138 C0 1PI  RETF
  6 00 0400 138 T!
  7 \
  8 02 C2 2 1FAMILY,
  9  JPF CALLF
 10 -->
 11 \ JPF Z| aa AA,
 12 \ CALLF PO| aa AA,
 13 \ RETF NC|
 14 \ and CY| instead of C|
 15 

Scr# 127 
  0 ( Z80 relative jump )
  1 HEX
  2 00 1000 00 T!
  3 08 10 2 1FAMILY,
  4   DJNZ JR
  5 00 00 218 T!
  6 \
  7 \
  8 08 00 4 XFAMILY|
  9   NZ'| Z'| NC'| CY'|
 10 00 1000 218 20 1PI JRF
 11 -->
 12 \ JRF Z'| d D,
 13 \ JR d D,
 14 \ DJNZ d D,
 15 

Scr# 128 
  0 ( ED prefix )
  1 00 00 30 T!
  2 08 42 2 EDFAMILY,
  3  SBCHL  ADCHL
  4 00 0400 30 T!
  5 08 43 2 EDFAMILY,
  6   LD()X  LDX()
  7 00 00 38 T!
  8 01 40 2 EDFAMILY,
  9   IN(C)  OUT(C)
 10 -->
 11 \ SBCHL BC| ADCHL SP|
 12 \ LDX() BC| nn AA,
 13 \ LD()X SP| nn AA,
 14 \ IN(C) L'|
 15 \ OUT(C) H'|

Scr# 129 
  0 ( ED )
  1 00 00 00 T!
  2 01 44 4 EDFAMILY,
  3   NEG RETN IM0 LDIA
  4 02 4D 2 EDFAMILY,
  5   RETI LDRA
  6 01 56 2 EDFAMILY,
  7   IM1 LDAI
  8 01 5E 2 EDFAMILY,
  9   IM2 LDAR
 10 08 67 2 EDFAMILY,
 11   RRD RLD
 12 -->
 13 
 14 
 15 

Scr# 130 
  0 ( ED )
  1 00 00 00 T!
  2 01 A0 4 EDFAMILY,
  3   LDI  CPI  INI  OUTI
  4 01 A8 4 EDFAMILY,
  5   LDD  CPD  IND  OUTD
  6 01 B0 4 EDFAMILY,
  7   LDIR CPIR INIR OTIR
  8 01 B8 4 EDFAMILY,
  9   LDDR CPDR INDR OTDR
 10 -->
 11 
 12 
 13 
 14 
 15 

Scr# 131 
  0 ( CB )
  1 00 00 07 T!
  2 08 00 8 CBFAMILY,
  3   RLC  RRC  RL  RR
  4   SLA  SRA  SLL SRL
  5 00 00 43F T!
  6 40 40 3 CBFAMILY,
  7   BIT  RES  SET
  8 00 00 438 T!
  9 08 00 8 XFAMILY|
 10   0| 1| 2| 3| 4| 5| 6| 7|
 11 -->
 12 \ RLC B|
 13 \ BIT 3| B|
 14 \ RES 3| B|
 15 \ SET 3| B|

Scr# 132 
  0 ( IX IY )
  1 HEX
  2 00 00 00 T!
  3 02 E3 1 DDFAMILY,
  4   EX(SP)IX
  5 02 E3 1 FDFAMILY,
  6   EX(SP)IY
  7 \
  8 10 E9 2 DDFAMILY,
  9   JPIX  LDSPIX
 10 10 E9 2 FDFAMILY,
 11   JPIY  LDSPIY
 12 \
 13 -->
 14 \
 15 

Scr# 133 
  0 ( IX IY )
  1 HEX
  2 00 00 30 T!
  3 00 09 1 DDFAMILY, ADDIX
  4 00 09 1 FDFAMILY, ADDIY
  5 \
  6 00 0400 00 T!
  7 \
  8 08 22 2 DDFAMILY,
  9   LD()IX LDIX()
 10 08 22 2 FDFAMILY,
 11   LD()IY  LDIY()
 12 -->
 13 \ ADDIX IX|  ADDIX SP|
 14 \ LD()IY aa AA,
 15 \ LDIY() aa AA,

Scr# 134 
  0 ( IX IY )
  1 : I)
  2 HERE 1 - C@
  3 HERE 2 - C@ [ HEX ] CB - IF
  4 -1 ALLOT SWAP C, C,
  5 ELSE
  6 -2 ALLOT SWAP C, CB C, C,
  7 ENDIF ;
  8 TOOLS-ASM
  9 00 00 07 T!
 10 00 06 1 XFAMILY| (I
 11 : (IX+  (I  DD I) ;
 12 : (IY+  (I  FD I) ;
 13 TOOLS-ASM
 14 -->
 15 \ LD B'| (IY+ d )|    ADCA (IY+ d )|   SRA (IY+ d )|

Scr# 135 
  0 ( IX IY )
  1 HEX
  2 : )|
  3   HERE 1 - C@
  4   HERE 2 - C@
  5   CB = IF SWAP ENDIF
  6   HERE 1 - C! C, ;
  7 \
  8 : IXY| ( n -- )
  9  DUP HERE 2 - C@ - IF
 10   HERE 1- C@
 11   -1 ALLOT SWAP C, C,
 12  ENDIF ;
 13 TOOLS-ASM
 14 -->
 15 

Scr# 136 
  0 ( IX IY )
  1 \ INC DEC  (IX'+ d )|
  2 \ LDN  (IX'+ d )|  n N,
  3 00 00 38 T!
  4 00 30 1 XFAMILY|   (I'
  5 : (IX'+ (I' DD I) ;
  6 : (IY'+ (I' FD I) ;
  7 TOOLS-ASM
  8 \ LD(IX+ d )|  r|
  9 00 00 07 T!
 10 00 70 1 DDFAMILY, LD(IX+
 11 00 70 1 FDFAMILY, LD(IY+
 12 : )'| ' EXECUTE )| ;
 13 TOOLS-ASM
 14 -->
 15 

Scr# 137 
  0 ( IX IY )
  1 \ LDIXL A|
  2 00 00 07 T!
  3 08 60 2
  4    DDFAMILY, LDIXH LDIXL
  5 08 60 2
  6    FDFAMILY, LDIYH LDIYL
  7 -->
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 138 
  0 ( IX IY )
  1 HEX
  2 : IX| HL| DD IXY| ;
  3 : IY| HL| FD IXY| ;
  4 : IXL| L| DD IXY| ;
  5 : IXH| H| DD IXY| ;
  6 : IYL| L| FD IXY| ;
  7 : IYH| H| FD IXY| ;
  8 TOOLS-ASM
  9 \ LDX IY| nn NN,
 10 \ POP IY|  LD A'| IXL|
 11 \ DP @ U. KEY \ verify...
 12 \
 13 DECIMAL
 14 
 15 

Scr# 139 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 140 
  0 .( Z80 near structure )   CR
  1 ASSEMBLER DEFINITIONS HEX
  2 \
  3 : NEXT                     JPIX ;
  4 : PSH1           PUSH HL|  JPIX ;
  5 : PSH2 PUSH DE|  PUSH HL|  JPIX ;
  6 \
  7 : HOLDPLACE HERE 0 D, ;
  8 : DISP, OVER -
  9   1 - SWAP C! ;
 10 : BACK,
 11  HOLDPLACE SWAP DISP, ;
 12 \
 13 : | ;
 14 -->
 15 

Scr# 141 
  0 ( Z80 Near struct. )
  1 : THEN, HERE DISP, ;
  2 : ELSE, JR HOLDPLACE
  3   SWAP THEN, ;
  4 \
  5 DECIMAL
  6 ;S
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 142 
  0 ( Z80 Near struct. )
  1 ;S
  2 \
  3 : IF, JRF Z'|
  4   HOLDPLACE ;
  5 : -IF, JRF NZ'|
  6   HOLDPLACE ;
  7 : <IF, JRF CY'|
  8   HOLDPLACE ;
  9 : -<IF, JRF NC'|
 10   HOLDPLACE ;
 11 
 12 
 13 
 14 
 15 

Scr# 143 
  0 ( Z80 Near struct. )
  1 ;S
  2 : BEGIN, HERE ;
  3 : UNTIL, IF, SWAP DISP, ;
  4 : -UNTIL, -IF, SWAP DISP, ;
  5 : <UNTIL, <IF, SWAP DISP, ;
  6 : -<UNTIL, -<IF, SWAP DISP, ;
  7 : WHILE, IF, ;
  8 : -WHILE, -IF, ;
  9 : <WHILE, <IF, ;
 10 : -<WHILE, -<IF, ;
 11 : REPEAT, JR HOLDPLACE
 12   ROT DISP, THEN, ;
 13 -->
 14 
 15 

Scr# 144 
  0 ( Z80 Near struct. )
  1 ;S
  2 : DJNZ,
  3   DJNZ HOLDPLACE
  4   SWAP DISP, ;
  5 FORTH DEFINITIONS
  6 DECIMAL
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 145 
  0 ." Z80 far struct "
  1 : THEN' HERE SWAP ! ;
  2 : HOLDPLACE' HERE 0 AA, ;
  3 : IF' JPF Z| HOLDPLACE' ;
  4 : ELSE' JP HOLDPLACE
  5         SWAP THEN' ;
  6 : BEGIN' HERE ;
  7 : UNTIL' IF' DROP THEN' ;
  8 : WHILE' IF' ;
  9 : REPEAT' ELSE' DROP THEN' ;
 10 DECIMAL
 11 FORTH DEFINITIONS
 12 
 13 
 14 
 15 

Scr# 146 
  0 ( TESTING )
  1 : T?
  2  TALLY-BY ?
  3  TALLY-BI ?
  4  TALLY-BA ?
  5 ;
  6 : H?
  7  HEX
  8  HERE 8 - DUMP
  9 ;
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 147 
  0 ( 128K memory BANK! TEST )
  1 HEX
  2 \ BANKM : 5B5C
  3 : ?BANK BASE @
  4   5B5C C@ 2 BASE ! .
  5   BASE ! ;
  6 : TEST
  7   BANK!
  8   C000 @ U.
  9   10 BANK!
 10 ;
 11 
 12 
 13 
 14 
 15 

Scr# 148 
  0 ( 128K memory BANK! TEST )
  1 \ between 0 and 7
  2 \ set bank n at C000
  3 CODE BANK! ( n -- )
  4  LDAR
  5  DI
  6  EXAFAF
  7  LD   D'|   B|
  8  LD   E'|   C|
  9  POP  BC|
 10  LDX  HL|  HEX  5B5C NN,
 11  LD   A'| (HL)|
 12  ANDN HEX  F8  N,
 13  ORA   C|
 14  LDX  BC|  HEX  7FFD NN,
 15 -->

Scr# 149 
  0 ( 128K memory BANK! TEST )
  1  OUT(C) A'|
  2  LD  (HL)'|   A|
  3  LD     B'|   D|
  4  LD     C'|   E|
  5  EXAFAF
  6  JPF    PO|  HERE 3 + A,
  7  EI
  8  NEXT
  9 C;
 10 \
 11 HEX
 12 : BANK@
 13  5B5C @ 7 AND
 14 ;
 15 

Scr# 150 
  0 ( TEST )
  1 CODE TEST
  2  RLCA RRCA RLA RRA
  3  DAA CPL SCF CCF
  4  NOP EXAFAF EX(SP)HL EXDEHL
  5  DI EI HALT RET EXX
  6  JPHL LDSPHL
  7  RST 00| RST 38|
  8  ADDA B| ADCA C| SUBA D|
  9  SBCA E| ANDA H| XORA L|
 10  ORA (HL)| CPA A|
 11  LD(X)A BC| LDA(X) DE|
 12  INCX HL| DECX SP|
 13  ADDHL BC| ADDHL SP|
 14 C;
 15 -->

Scr# 151 
  0 ( TEST1 )
  1 CODE TEST1
  2  LDX  BC| 1234 NN,
  3  LDX  SP| 5678 NN,
  4  PUSH AF| POP HL|
  5  OUTA 254 P, INA 254 P,
  6  ADDN 1 N, ADCN 2 N,
  7  SUBN 3 N, SBCN 4 N,
  8  ANDN 5 N, XORN 6 N,
  9  ORN  7 N, CPN  8 N,
 10  LD()HL 1234 AA,
 11  LDHL() 1234 AA,
 12  LD()A  1234 AA,
 13  LDA()  1234 AA,
 14 C;
 15 -->

Scr# 152 
  0 ( TEST2 )
  1 CODE TEST2
  2  JP 1234 AA, CALL 1234 AA,
  3  INC B'| DEC A'|
  4  LD D'| E|  LD (HL)'| A|
  5  LDN B'| 1 N, LDN A'| 8 N,
  6  JPF Z| 1234 AA,
  7  CALLF M| 1234 AA,
  8  RETF PE|
  9  DJNZ -10 D, JR +10 D,
 10  JRF NZ'| +10 D,
 11  JRF CY'| -10 D,
 12  SBCHL DE| ADCHL SP|
 13  LDX() BC| 1234 AA,
 14  LD()X SP| 1234 AA,
 15 C; -->

Scr# 153 
  0 ( TEST3 )
  1 CODE TEST3
  2  IN(C) D'|  OUT(C) E'|
  3  NEG RETN IM0 LDIA RETI LDRA
  4  IM1 LDAI IM2 LDAR RRD RLD
  5  LDI   CPI   INI   OUTI
  6  LDD   CPD   IND   OUTD
  7  LDIR  CPIR  INIR  OTIR
  8  LDDR  CPDR  INDR  OTDR
  9  RLC B| RRC C| RL D| RR E|
 10  SLA H| SRA L| SRL (HL)|
 11  BIT 2| D|  BIT 3| E|
 12  RES 4| H|  RES 5| L|
 13  SET 6| (HL)| SET 7| A|
 14 C;
 15 ;S

Scr# 154 
  0 ( TEST IF, THEN, )
  1 CODE TEST4
  2 BEGIN,
  3 NOP NOP NOP
  4 END,
  5 NEXT
  6 C;
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 155 
  0 \ TEST
  1 CODE TEST5
  2 INCX IX|  DECX IY|
  3 PUSH IX|  POP  IY|
  4 EX(SP)IX  JPIY
  5 LDSPIX    LDSPIY
  6 ADDIX BC| ADDIX DE|
  7 ADDIX IX| ADDIX SP|
  8 ADDIY BC| ADDIY DE|
  9 ADDIY IY| ADDIY SP|
 10 LD()IX 4 AA, LDIX() 3 AA,
 11 LD()IY 5 AA, LDIY() 6 AA,
 12 LDX IX| 7 NN,
 13 LDX IY| 8 NN,
 14 C;
 15 

Scr# 156 
  0 \ TEST6
  1 CODE TEST6
  2  ADCA (HL)|
  3  ADCA (IY+ 9 )|
  4  INC (HL)'|
  5  INC (IY'+ 9 )|
  6  LDN (HL)'|      5 N,
  7  LDN (IY'+ 9 )|  5 N,
  8  SRA  (HL)|
  9  SRA (IY+  9 )|
 10  SET 0| (HL)|
 11  SET 0| (IY+ 9 )|
 12  LDIX() 1234 AA,
 13 C;
 14 ;S
 15 

Scr# 157 
  0 \ TEST7
  1 CODE TEST7
  2     LDX HL| 0 NN,
  3     BIT 5| (IY+ 1 )|
  4     IF, INC L'| THEN,
  5 PSH1 C;
  6 \
  7 : KEYIN
  8   BEGIN
  9   TEST7
 10   ?ESCAPE
 11   UNTIL ;
 12 
 13 
 14 
 15 

Scr# 158 
  0 \ TEST Z80N
  1 HEX CODE TEST8
  2  TESTN FF N,
  3  SWAPNIB MIRRORA
  4  LDIX LDDX LDIRX LDDRX
  5  LDWS LDPIRX
  6  OUTINB JP(C)
  7  PIXELDN PIXELAD SETAE
  8  BSLADE,B BSRADE,B BSRLDE,B
  9  BSRFDE,B BRLCDE,B
 10  MUL
 11  ADDHL,A ADDDE,A ADDBC,A
 12  ADDBC, 07654 NN,
 13  NEXTREGA 3 P,
 14  NEXTREG  3 P, 4 N,
 15  PUSHN 07654 LH,  NEXT C;

Scr# 159 
  0 \ TEST Z80N
  1 HEX CODE TEST9
  2  DECIMAL
  3  NEXTREG 87 P, 1 N,
  4  NEXTREGA 87 P,
  5 NEXT C;
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 160 
  0 .( Z80N Next extensions )
  1 ASSEMBLER DEFINITIONS HEX
  2 : <, 100 /MOD C, C, ;
  3 TOOLS-ASM
  4 0 1 0 4000 ' <, COMMAER LH,
  5 \
  6 00 0900 00 91 EDPI NEXTREG
  7 \ NEXTREG reg P, n N,
  8 00 0100 00 92 EDPI NEXTREGA
  9 \  NEXTREGA r P,
 10 00 4000 00 8A EDPI PUSHN
 11 \   PUSHN nn LH,
 12 00 0800 00 27 EDPI TESTN
 13 \  TESTN n N,
 14 -->
 15 

Scr# 161 
  0 ( Z80N Next extension )
  1 \
  2 00 00 00 T!
  3 01 23 2 EDFAMILY,
  4  SWAPNIB MIRRORA
  5 08 A4 4 EDFAMILY,
  6  LDIX LDDX LDIRX LDDRX
  7 \
  8 12 A5 2 EDFAMILY,
  9  LDWS LDPIRX
 10 08 90 2 EDFAMILY,
 11  OUTINB JP(C)
 12 01 93 3 EDFAMILY,
 13  PIXELDN PIXELAD SETAE
 14 -->
 15 

Scr# 162 
  0 ( Z80N Next extension )
  1 01 28 5 EDFAMILY,
  2  BSLADE,B BSRADE,B BSRLDE,B
  3  BSRFDE,B BRLCDE,B
  4 01 30 4 EDFAMILY,
  5  MUL
  6  ADDHL,A ADDDE,A ADDBC,A
  7 00 0200 00 T!
  8 01 34 3 EDFAMILY,
  9  ADDHL, ADDDE, ADDBC,
 10 \ ADDBC, nn NN,
 11 \
 12 FORTH DEFINITIONS DECIMAL
 13 \
 14  DP @ LP @ DP !  LP !
 15 \

Scr# 163 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 164 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 165 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 166 
  0 ( White noise Egghead 3 )
  1 CODE WHITE-NOISE
  2  DI  PUSH BC|
  3 HERE CALL HERE AA,
  4  EI  POP  BC|  NEXT
  5 HERE SWAP 1+ !
  6 HERE LDN  E'|  250  N,
  7      LDX  HL|    0 NN,
  8 HERE PUSH DE|
  9      LDN  B'|   32  N,
 10 HERE PUSH BC|
 11      LD   A'| (HL)|
 12      INCX HL|
 13      ANDN 248 N,
 14      OUTA 254 P,
 15      LD   A'|   E|  -->

Scr# 167 
  0 ( White noise Egghead 3 )
  1      CPL
  2 HERE DEC  A'|
  3      JRF NZ'| BACK,
  4      POP  BC|
  5      DJNZ     BACK,
  6      POP  DE|
  7      LD   A'|    E|
  8      SUBN 24 N,
  9      CPN  30 N,
 10      RETF  Z|
 11      RETF CY|
 12      LD   E'|    A|
 13 -->
 14 
 15 

Scr# 168 
  0 ( White noise Egghead 3 )
  1      CPL
  2 \
  3 HERE LDN  B'| 40 N,
  4 HERE DJNZ BACK,
  5      DEC  A'|
  6      JRF NZ'| BACK,
  7      JR       BACK,
  8 C;
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 169 
  0 ( Checksum of a RAM chunk )
  1 CODE CHECKSUM ( a n -- n2 )
  2  HEX D1 C,       \   POP    DE|
  3      E1 C,       \   POP    HL|
  4      AF C,       \   XORA    A|
  5      14 C,       \   INC    D'|
  6      AE C,       \   XORA (HL)|
  7      23 C,       \   INCX   HL|
  8      1D C,       \   DEC    E'|
  9      20 C, FB C, \   JRF   NZ'|  BACK,
 10      15 C,       \   DEC    D'|
 11      20 C, F8 C, \   JRF   NZ'|  BACK,
 12      5F C,       \   LD     E'|  A|
 13      D5 C,       \   PUSH  DE|
 14      DD C, E9 C, \   NEXT  C;
 15 SMUDGE DECIMAL

Scr# 170 
  0 \ BURP
  1 \ Example
  2 : BURP
  3 [ HEX ] 7999 6000
  4 DO
  5  I HEX . I DECIMAL . CR
  6  ?TERMINAL IF QUIT THEN
  7 [ HEX ] 100
  8 +LOOP
  9 ;
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 171 
  0 ( Dump many pages )
  1 \ Dumps from a1 to a2
  2 DECIMAL
  3 : MDUMP ( a1 a2 -- )
  4  SWAP DO
  5   I DUMP
  6  64 +LOOP
  7 ;
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 172 
  0 ( NEEDS )
  1 \ check for cccc exists in vocabulary
  2 \ if it doesn't then  INCLUDE  inc/cccc.F
  3 DECIMAL
  4 \ temp filename cccc.f as counted string zero-padded
  5 CREATE   NEEDS-W     35 ALLOT   \ 32 + .F + 0x00 = len 35
  6 \ temp complete path+filename
  7 CREATE   NEEDS-FN    40 ALLOT
  8 \ constant path
  9 CREATE   NEEDS-INC   ," inc/"
 10 CREATE   NEEDS-LIB   ," lib/"
 11 -->
 12 
 13 
 14 
 15 

Scr# 173 
  0 ( NEEDS )
  1 \ Concatenate path at a and filename and include it
  2 \ No error is issued if filename doesn't exist.
  3 : NEEDS/  ( a -- )             \ a       \ has  path/
  4   COUNT TUCK                   \ n a n
  5   NEEDS-FN SWAP CMOVE          \ n       \ Path
  6   NEEDS-FN +                   \ a1+n    \ concat
  7   NEEDS-W 1+ SWAP 35 CMOVE     \         \ Filename
  8   NEEDS-FN                     \ a3
  9   PAD 1 F_OPEN                 \ fh f
 10   IF 43 MESSAGE DROP  \ just message, no fatal error
 11   ELSE F_INCLUDE      \ using filehandle
 12   ENDIF
 13 ;
 14 -->
 15 

Scr# 174 
  0 ( NEEDS )
  1 \ replace illegal characters in name with tilde ~
  2 : NEEDS-CHECK ( -- )
  3   NEEDS-W COUNT OVER + SWAP
  4   DO
  5 \   I C@ EMIT
  6     I C@ [CHAR] " =
  7     IF [CHAR] ~ I C! THEN
  8   LOOP ;
  9 -->
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 175 
  0 ( NEEDS )
  1 \ include  "path/cccc.f" if cccc is not defined
  2 \ filename cccc.f is temporary stored at NEEDS-W
  3 : NEEDS-PATH  ( a -- )
  4   -FIND 0= IF                     \ a
  5     NEEDS-W    35 ERASE           \ a
  6     HERE C@ 1+ HERE OVER          \ a n here n
  7     NEEDS-W    SWAP CMOVE         \ a n
  8     NEEDS-CHECK                   \ a n
  9     NEEDS-W  +                    \ a a1+n
 10     [ HEX 662E DECIMAL ] LITERAL  \ a a1+n ".F"
 11     SWAP !                        \ a
 12     NEEDS/                        \   (uses path passed)
 13   ELSE                            \ a cfa b
 14     DROP 2DROP                    \
 15   ENDIF ; -->

Scr# 176 
  0 ( NEEDS )
  1 \ check for cccc exists in vocabulary
  2 \ if it doesn't then  INCLUDE  inc/cccc.F
  3 \ search in inc subdirectory
  4 : NEEDS
  5   NEEDS-INC NEEDS-PATH     \ search in "inc/"
  6 \ NEEDS-W C@ MINUS >IN +!  \ re-feed cccc
  7 \ NEEDS-LIB NEEDS-PATH     \ 2nd chance at "lib/"
  8 ;
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 177 
  0 ( INCLUDE ) \ study and test
  1 0 VARIABLE SOURCE-ID
  2 : INCLUDE ( -- )
  3   PAD 96 ERASE
  4   BL WORD COUNT PAD SWAP CMOVE
  5   PAD  PAD 96 +  1  F_OPEN
  6   43 ?ERROR
  7   SOURCE-ID @ >R  BLK @ >R
  8   SOURCE-ID !
  9   R> R> ;S
 10   SOURCE-ID @ F_CLOSE DROP
 11   R> BLK ! R> SOURCE-ID !
 12 ;
 13 
 14 
 15 

Scr# 178 
  0 ( DEFER IS - EXIT UNLOOP )
  1 : EXIT COMPILE ;S ; IMMEDIATE
  2 : UNLOOP R> R> 2DROP ;
  3 : ['] COMPILE LIT ' , ; IMMEDIATE
  4 : DEFER
  5   <BUILDS [ ' NOOP ] LITERAL ,
  6   DOES> @ EXECUTE ; IMMEDIATE
  7 : IS
  8   ' >BODY 2+
  9   STATE @ IF
 10    COMPILE LIT ,
 11    COMPILE !
 12   ELSE  !  THEN  ;  IMMEDIATE
 13 
 14 
 15 

Scr# 179 
  0 ( CHECK NULL               )
  1 : J RP@ 6 + @ ;
  2 : CHECKNULL
  3 #SEC 1 DO
  4 I .
  5 I BLOCK @ 2020 = IF
  6 ." WRONG " ENDIF
  7 CR
  8 ?ESCAPE IF QUIT ENDIF
  9 LOOP
 10 ;
 11 
 12 
 13 
 14 
 15 

Scr# 180 
  0 ( Fibonacci )
  1 ( n -- d )
  2 \ n must be between 0 and 46
  3 : FIBO ( n -- d )
  4  0. ROT
  5  ?DUP IF
  6   1- 1. ROT
  7   0 DO
  8    2SWAP 2OVER
  9    D+
 10   LOOP
 11   2SWAP 2DROP
 12  ENDIF
 13 ;
 14 
 15 

Scr# 181 
  0 ( DSQRT )
  1 \ Extract square root of d
  2 \ between 0 and 268435455
  3 : DSQRT ( d -- r q )
  4  2DUP D+ 2DUP D+
  5  0 [ HEX ] 8000
  6  0E 0 DO
  7   SWAP DROP
  8   >R 2DUP R UM/MOD
  9   R> + 1 RSHIFT
 10  LOOP 1 RSHIFT
 11  >R DROP 2DROP R>
 12 ;
 13 
 14 
 15 

Scr# 182 
  0 ( Primality Test )
  1 : ?PRIME ( d -- f )
  2  2DUP DSQRT 1+
  3  2 DO
  4   2DUP I UM/MOD DROP
  5   0= IF
  6    2DROP 0. LEAVE
  7   THEN
  8  LOOP
  9  OR 0= 0= ;
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 183 
  0 ( MARKER )
  1 : MARKER ( -- cccc )
  2   <BUILDS
  3    VOC-LINK @ , CURRENT @ , CONTEXT @ ,
  4    LATEST           , \ value for DP
  5    LATEST PFA LFA @ , \ value for LATEST
  6   DOES>
  7    DUP @ VOC-LINK !   CELL+
  8    DUP @ CURRENT  !   CELL+
  9    DUP @ CONTEXT  !   CELL+
 10    DUP @ DP       !   CELL+  @ CURRENT @ !
 11 ; IMMEDIATE
 12 HERE LATEST HEX .S
 13 MARKER TEST
 14 SEE TEST
 15 

Scr# 184 
  0 ( TEST )
  1 \ Given an address, compute the relative address from $2000
  2 : DOT-RELATIVE ( a1 -- a2 )
  3   HERE SWAP - [ HEX ] 2000 + \
  4 ; DECIMAL
  5 0 VARIABLE FH
  6 \ accept volatile filename at PAD
  7 : FILENAME" ( -- )  \
  8   [CHAR] " WORD COUNT    \ a+1 n
  9   TUCK OVER + 0          \ n a+1 a+n+1 0
 10   SWAP !                 \ n a+1
 11   PAD ROT 1+             \ a+1 pad n+1
 12   CMOVE ;
 13 -->
 14 
 15 

Scr# 185 
  0 ( TEST )
  1 \ save bytes to filename held in PAD
  2 \ create new file, error if it already exists
  3 \ PAD is volatile
  4 : SAVE-BYTES ( a n -- )
  5   PAD DUP 10 - 06 F_OPEN          \ a n u f
  6   41 ?ERROR                       \ a n u
  7   DUP FH ! F_WRITE                \ m f
  8   47 ?ERROR                       \ m
  9   DROP FH @ F_CLOSE               \ f
 10   42 ?ERROR
 11 ;
 12 \ filename" prova.txt"
 13 \ PAD 64 save-bytes
 14 
 15 

Scr# 186 
  0 ( DOT example  .helloworld )
  1 create Org Assembler
  2         ldx   hl|   Here   0  NN,
  3   Here  ld    a'|   (hl)|
  4         anda   a|
  5         retf   z|
  6         rst   10|
  7         incx  hl|
  8         jr    Back,  \ to the closest Here
  9 \
 10   Org dot-relative  ," Hello, World!"  1+ swap !
 11 \
 12 Org   Here Org -    \  start-addres & length
 13 Filename" /dot/helloworld" save-bytes
 14 \
 15 

Scr# 187 
  0 ( search for AT position )
  1 : save-page [ hex ] E000 2000 save-bytes ;
  2 : print1 [ decimal ] 11 13 at. ;
  3 : print2 [ decimal ] 13 11 at. ;
  4 filename" L2_10_0000.bin" hex 10 mmu7! 00 00 AT. save-page
  5 filename" L2_10_0101.bin" hex 10 mmu7! 01 01 AT. save-page
  6 filename" L2_10_0202.bin" hex 10 mmu7! 02 02 AT. save-page
  7 filename" L2_10_0031.bin" hex 10 mmu7! 00 31 AT. save-page
  8 filename" L2_10_0032.bin" hex 10 mmu7! 00 32 AT. save-page
  9 filename" L2_10_0033.bin" hex 10 mmu7! 00 33 AT. save-page
 10 filename" L2_10_0063.bin" hex 10 mmu7! 00 63 AT. save-page
 11 filename" L2_10_0064.bin" hex 10 mmu7! 00 64 AT. save-page
 12 
 13 
 14 
 15 

Scr# 188 
  0 ( TEST )
  1 : AT. 22 EMITC SWAP EMITC EMITC ;
  2 hex
  3 : T
  4   AT.
  5   10 mmu7!
  6   FB00 PAD  100 CMOVE
  7   CLS  PAD  DUMP
  8 ;
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 189 
  0 ( TEST )
  1  123
  2  456
  3    789
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 190 
  0 .( Full Screen Editor. ) CR
  1 DECIMAL   0 VARIABLE NROW               \ current row
  2           0 VARIABLE NCOL               \ current columns
  3 : HOMEC   0 NROW ! 0 NCOL ! ;           \ cursor at home
  4 : ADDRC   ( -- a )                      \ calc cursor addr
  5   NROW @ LINE NCOL @ + ;
  6 : TO-SCR  ( row1 col1 -- col2 row2 )    \ translate xy
  7   0 + SWAP 2 + ;
  8 : AT-XY   ( col row -- )                \ set print position
  9   22 EMITC  EMITC EMITC ;               \ using standard AT
 10 : HOME 0 0 AT-XY ;                      \ cursor at home
 11 : BUZZ    7 EMIT ;                      \ sound BEL
 12 : CURC! ( c -- )    \ store chr to current screen position
 13   ADDRC  C! UPDATE ;
 14 : CURC@ ( -- c )    \ fetch chr from current screen position
 15   ADDRC  C@ ; -->

Scr# 191 
  0 ( Full Screen Editor   2/7 )
  1 : RULER 6 0 DO ." +----.----" LOOP ." +--" ;
  2 : UPC     NROW @  0 > IF -1  NROW +!  ELSE  BUZZ  THEN ;
  3 : DOWNC   NROW @ 15 < IF  1  NROW +!  ELSE  BUZZ  THEN ;
  4 : LEFTC   NCOL @  0 > IF -1  ELSE  UPC    63 THEN NCOL +! ;
  5 : RIGHTC  NCOL @ 63 < IF  1  ELSE  DOWNC -63 THEN NCOL +! ;
  6 : PUTPAGE ." Screen # " SCR @ . CR RULER CR
  7           L/SCR 0 DO I SCR @ (LINE) TYPE CR LOOP RULER ;
  8 : REFRESH                             \ refresh current line
  9   NROW @ SCR @  OVER 0 TO-SCR AT-XY  (LINE) TYPE ;
 10 -->
 11 
 12 
 13 
 14 
 15 

Scr# 192 
  0 ( Full Screen Editor   3/7 )
  1 : EDIT-FRAME
  2   0 19 AT-XY
  3   INVV ."  row:" TRUV 5 SPACES INVV ."  col:" TRUV 5 SPACES
  4   INVV ."  hex:" TRUV 5 SPACES INVV ."  dec:" TRUV 6 SPACES
  5   INVV ."  chr:" TRUV
  6   CR INVV ."  pad:" TRUV PAD COUNT 59 MIN TYPE
  7   0 21 AT-XY  INVV ."  cmd:" TRUV
  8   CR ." U-ndo    B-ack    D-el     I-nsert   H-old"
  9   CR ." Q-uit    N-ext    S-hift   R-eplace  P-ut hex byte"
 10   56 0 AT-XY  INVV ."   edit  " TRUV ;
 11 : EDIT-STAT CURC@
 12   25 19 AT-XY  HEX DUP 3 .R  36 19 AT-XY  DECIMAL DUP 3 .R
 13   47 19 AT-XY  32 MAX EMIT
 14   15 19 AT-XY  NCOL @  3 .R  05 19 AT-XY  NROW @      3 .R ;
 15 -->

Scr# 193 
  0 ( Full Screen Editor   4/7 )
  1 : BYTE ( -- b ) \ accept two hex digit as a byte
  2   KEY DUP EMIT 10 DIGIT DROP 4 LSHIFT
  3   KEY DUP EMIT 10 DIGIT DROP + ;
  4 : UNDO  ( -- ) \ discard changes on current Screen
  5   B/SCR 0 DO
  6     SCR @ B/SCR * I +
  7     BLOCK CELL-
  8     0 SWAP !
  9   LOOP ;
 10 HEX
 11 : DONEC             8F 26 +ORIGIN C!    \ reset cursor face
 12                     5F 28 +ORIGIN C! ;  \ reset cursor face
 13 : INITC   CURC@ BL MAX 26 +ORIGIN C!    \ change cursor face
 14                     8F 28 +ORIGIN C! ;
 15 DECIMAL -->

Scr# 194 
  0 ( Full Screen Editor   5/7 )
  1 : CMD    ( c -- )   \ handle EDIT key options
  2   6 21 AT-XY DONEC KEY UPPER BL MAX DUP EMIT
  3   CASE
  4   [CHAR] P OF BYTE CURC! ENDOF  \ put a byte at cursor
  5   [CHAR] H OF NROW @ H   ENDOF  \ copy to PAD
  6   [CHAR] S OF NROW @ S   ENDOF  \ shift down one row
  7   [CHAR] R OF NROW @ RE  ENDOF  \ replace row from PAD
  8   [CHAR] I OF NROW @ INS ENDOF  \ insert row from PAD
  9   [CHAR] D OF NROW @ D   ENDOF  \ delete row + copy to PAD
 10   [CHAR] N OF  1 SCR +! HOMEC ENDOF  \ next screen
 11   [CHAR] B OF -1 SCR +! HOMEC ENDOF  \ prev screen
 12   [CHAR] U OF UNDO BUZZ  ENDOF
 13   [CHAR] Q OF ."  ok" CR C/L 2 * SPACES
 14               0 21 AT-XY QUIT ENDOF
 15   ENDCASE 0 0 AT-XY PUTPAGE EDIT-FRAME ; -->

Scr# 195 
  0 ( Full Screen Editor   6/7 )
  1 : DELC    ( -- )    \ back-space
  2   NCOL @  0 > IF -1 NCOL +! THEN
  3   ADDRC DUP 1+ SWAP C/L NCOL @ - 1- CMOVE UPDATE
  4   BL NROW @ LINE C/L + 1- C! ;
  5 : INSC    ( -- )    \ insert blank at cursor and shift the rest
  6   ADDRC DUP 1+      C/L NCOL @ - 1- CMOVE>
  7   BL ADDRC  C!  UPDATE ;
  8 : CTRLC  ( c -- )   \ manage control keys
  9   CASE 08 OF LEFTC  ENDOF      09 OF RIGHTC ENDOF
 10        10 OF DOWNC  ENDOF      11 OF UPC    ENDOF
 11        12 OF DELC   REFRESH ENDOF
 12        13 OF DOWNC 0 NCOL ! ENDOF
 13        07 OF CMD            ENDOF
 14   ENDCASE ;
 15 -->

Scr# 196 
  0 ( Full Screen Editor   7/7 )
  1 : EDIT     ( -- )
  2   CLS HOMEC PUTPAGE EDIT-FRAME
  3   BEGIN
  4     EDIT-STAT  INITC
  5     CURC@ NROW @ NCOL @ TO-SCR  2DUP AT-XY
  6     KEY  ?TERMINAL IF DROP 0 INSC   REFRESH THEN
  7     DUP BL < IF
  8       >R AT-XY EMIT R>  CTRLC
  9     ELSE
 10       CURC! AT-XY DROP CURC@ EMIT RIGHTC
 11     THEN
 12   AGAIN  \ quit using EDIT-key + Q
 13   ;
 14 
 15 

Scr# 197 
  0 \ TEST
  1 : SRC?
  2   ." S/B/I: "
  3   SOURCE-ID ?
  4   BLK ?
  5   >IN ?  ;
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 198 
  0 ( \ comment )
  1 : \
  2   BLK @
  3   IF
  4     BLK @ 1 >
  5     IF
  6       >IN @ C/L MOD C/L SWAP - >IN +!
  7     ELSE
  8       B/BUF CELL- >IN !
  9     ENDIF
 10   ELSE
 11     80 >IN !
 12   ENDIF
 13 ; IMMEDIATE
 14 
 15 

Scr# 199 
  0 ( MARKER )
  1 : MARKER ( -- cccc )
  2   <BUILDS
  3    VOC-LINK @ , CURRENT @ , CONTEXT @ ,
  4    LATEST           , \ value for DP
  5    LATEST PFA LFA @ , \ value for LATEST
  6   DOES>
  7    DUP @ VOC-LINK !   CELL+
  8    DUP @ CURRENT  !   CELL+
  9    DUP @ CONTEXT  !   CELL+
 10    DUP @ DP       !   CELL+  @ CURRENT @ !
 11 ; IMMEDIATE
 12 HERE LATEST HEX .S
 13 MARKER TEST
 14 SEE TEST
 15 

Scr# 200 
  0 .( .RESET & CPU SPEED )  CR
  1 HEX
  2 : SPEED!
  3      7 243B P!
  4  3 AND 253B P!
  5 ;
  6 \
  7 \ ;S
  8 \
  9 : .RESET
 10  2 253B P!
 11  2 243B P!
 12 ;
 13 
 14 
 15 

Scr# 201 
  0 ( DAA )
  1 HEX
  2 CODE TEST-DAA
  3  POP HL|
  4  LD A'| L|
  5  CPN 10 N,
  6  SBCN 69 N,
  7  DAA
  8  LD L'| A|
  9  PSH1
 10  C;
 11 
 12 
 13 
 14 
 15 

Scr# 202 
  0 ( PICK )
  1 CODE PICK ( n -- v-nth )
  2  POP   HL|
  3  ADDHL HL|
  4  ADDHL SP|
  5  LD    A'|  (HL)|
  6  INCX  HL|
  7  LD    H'|  (HL)|
  8  LD    L'|     A|
  9  PSH1
 10 C;
 11 
 12 
 13 
 14 
 15 

Scr# 203 
  0 ( U* )
  1 CODE U*
  2  POP DE|
  3  POP HL|
  4  PUSH BC|
  5 \
  6  LD  C'|  L|
  7  LD  B'|  H|
  8  LDX HL| 0 NN,
  9  LDN A'| DECIMAL 16 N,
 10  HERE \ BEGIN,
 11   ADDHL HL|
 12   RL E|
 13   RL D|
 14   JRF NC'| HOLDPLACE
 15 -->

Scr# 204 
  0 ( U* )
  1    ADDHL BC|
  2    JRF NC'| HOLDPLACE
  3     INCX DE|
  4    HERE DISP, \ THEN,
  5   HERE DISP, \ THEN,
  6   DEC A'|
  7  JRF NZ'| HOLDPLACE
  8  SWAP DISP, \ -UNTIL,
  9  EXDEHL
 10 \
 11  POP BC|
 12  PSH2
 13  C;
 14 
 15 

Scr# 205 
  0 ( U/   dn n -- r dq )
  1 CODE U/
  2  POP  DE| \ Divisor
  3  POP  HL| \ High
  4  EX(SP)IX \ Low
  5  PUSH BC|
  6  LD   A'|    H|
  7  LD   C'|    L|
  8  LDX  HL|    0  NN,
  9  LDN  B'| DECIMAL 32 N,
 10  HERE DUP \ BEGIN,
 11   ADDIX IX|
 12   RL     C|
 13   RLA
 14   ADCHL HL|
 15 -->

Scr# 206 
  0 ( U/ )
  1   JRF CY'| HOLDPLACE
  2    SBCHL DE|
  3    JRF NC'| HOLDPLACE
  4     ADDHL DE|
  5     ROT DJNZ HOLDPLACE
  6     SWAP DISP,
  7    SWAP ELSE,
  8     ORA A|  SBCHL DE|
  9    SWAP THEN,
 10    INC IX|
 11   THEN,
 12  DNJZ BACK,
 13 -->
 14 
 15 

Scr# 207 
  0 ( U/ )
  1  LD   D'|  A|
  2  LD   E'|  C|
  3  POP  BC|
  4  POP  IX|
  5  PUSH HL|
  6  PUSH IX|
  7  PUSH DE|
  8  NEXT
  9 C;
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 208 
  0 ( UPPER )
  1 CODE UPPER ( c1 -- c2 )
  2 POP   HL|
  3 LD A'| L|
  4 CPN HEX 61 N,
  5 JRF CY'| HOLDPLACE
  6  CPN HEX 7B N,
  7  JRF NC'| HOLDPLACE
  8   SUBN HEX 20 N,
  9  HERE DISP,
 10 HERE DISP,
 11 LD L'| A|
 12 PSH1
 13 C;
 14 DECIMAL
 15 

Scr# 209 
  0 ( "NUL" )
  1 \
  2 : X
  3   BLK @ 1 > IF
  4     1 BLK +!
  5     0 >IN  !
  6     BLK @ B/SCR 1 - AND 0=
  7     IF ?EXEC   R> DROP   ENDIF
  8   ELSE
  9      R> DROP
 10   ENDIF
 11 ; IMMEDIATE
 12 \
 13 DECIMAL 128  ' X <NAME 1+ C! \ patch
 14 \
 15 

Scr# 210 
  0 \ 1. F_GETLINE from handle( via F_READ and F_SEEK ) DECIMAL
  1 marker TASK
  2 : F_GETLINE ( a fh -- a n )
  3   DUP >R F_FGETPOS 44 ?ERROR            \ a d       \ fh
  4   ROT DUP 1+ B/BUF CELL-                \ d a a 510
  5   1- R  F_READ 46 ?ERROR                \ d a n
  6   IF \ at least 1 chr was read          \ d a
  7     10 ENCLOSE DROP NIP SWAP            \ d b a
  8     13 ENCLOSE DROP NIP ROT MIN         \ d a m
  9   \ 0 \ 2dup + @ 2573 = if 1 else 0 then >r \ d a m f
 10     DUP >R 2SWAP R> 0 D+ R> F_SEEK ?ERROR \ a m
 11     2DUP + 0 SWAP C!
 12   ELSE
 13     R> 2SWAP 2DROP DROP 0
 14   ENDIF ; -->
 15 

Scr# 211 
  0 \ 2. include from handle
  1 : F_INCLUDE  ( fh -- )
  2   BLK @ >R  >IN @ >R  SOURCE-ID @ >R
  3   R IF R F_FGETPOS 44 ?ERROR ELSE 0 0 THEN >R >R
  4   SOURCE-ID !
  5   BEGIN
  6     1 BLOCK
  7     DUP B/BUF BLANKS
  8     1+ SOURCE-ID @ F_GETLINE       \ a n
  9     TUCK                           \ n a n
 10     2DUP +                         \ n a n a+n
 11     OVER B/BUF SWAP 2+ -           \ n a n a+n b-n-1
 12     BLANKS                         \ n a n
 13     + 1+ 0 SWAP C!                 \ n
 14 -->
 15 

Scr# 212 
  0 \ 2. include from handle
  1 \
  2   WHILE
  3     1 BLK ! 0 >IN !  INTERPRET
  4   REPEAT
  5   SOURCE-ID @  0 SOURCE-ID !  F_CLOSE 42 ?ERROR
  6   R> R> R>   DUP SOURCE-ID !
  7   IF SOURCE-ID @ F_SEEK 43 ?ERROR ELSE 2DROP THEN
  8   R> >IN !  R> BLK ! ;
  9  -->
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 213 
  0 \ 3. an INCLUDE wrapper
  1 : OPEN#    ( -- fh )  \ used in the form OPEN FFFF
  2   [CHAR] "  WORD COUNT OVER + 0 SWAP !
  3   PAD 1 F_OPEN 43 ?ERROR ;
  4 : INCLUDE
  5   OPEN# DUP F_INCLUDE F_CLOSE DROP ;
  6 ;S
  7 \
  8 \ 5 VALUE FH
  9 \ CREATE FILENAME ," Test.f"
 10 \ FILENAME 1+ PAD 1 F_OPEN 43 ?ERROR TO FH
 11 \ FILENAME COUNT TYPE
 12 \ : G 1 BLOCK FH F_GETLINE ;
 13 \ FH F_CLOSE . CR
 14 
 15 

Scr# 214 
  0 ( NEW UM* using MUL new OP-code )
  1 CASEOFF
  2 CODE U* ( n1 n2 -- d ) \ unsigned multiply
  3  pop de|  pop hl|  push bc|
  4  ld   c'|   e|
  5  ld   b'|   d|
  6  ld   d'|   l|
  7  mul
  8  ld   a'|   e|
  9  exafaf
 10  ld   a'|   h|
 11  ld   e'|   c|
 12  ld   c'|   d|
 13 -->
 14 
 15 

Scr# 215 
  0 ( NEW UM* using MUL new OP-code )
  1  ld   d'|   h|
  2  ld   h'|   b|
  3  mul
  4  exdehl
  5  mul
  6  addhl de|
  7  ld   e'|   c|
  8  ldn  d'|   00 n,
  9  exafaf  \ saves carry flag
 10  ld   c'|   a|
 11  addhl de|
 12  exafaf \ restore carry flag
 13  ld   e'|   a|
 14  ld   d'|   b|
 15 -->

Scr# 216 
  0 ( NEW UM* using MUL new OP-code )
  1  mul
  2  ldn  a'|  00  n,
  3  adca  d|
  4  ld   d'|   a|
  5  ld   b'|   l|
  6  ld   l'|   h|
  7  ldn  h'|  00  n,
  8  addhl de|
  9  ld   d'|   b|
 10  ld   e'|   c|
 11  pop  bc|
 12  PSH2
 13 c;
 14 
 15 

Scr# 217 
  0 ( TEST )
  1 HEX
  2 : TEST
  3  FFFF 0 DO
  4   I I 1- U*
  5   I I 1- UM*
  6   DMINUS D+ AND IF I . CR QUIT THEN
  7  LOOP
  8 ;
  9 DECIMAL
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 218 
  0 ( NEW UM* using MUL new OP-code )
  1 code u* ( n1 n2 -- d )
  2  pop de|  pop hl|  push bc|
  3  ld   b'|   l|
  4  ld   c'|   e|
  5  ld   e'|   l|
  6  ld   l'|   d|
  7  push hl|
  8  ld   l'|   c|
  9  mul
 10  exdehl
 11  mul
 12  xora  a|
 13  addhl de|
 14  adca  a|
 15 -->

Scr# 219 
  0 ( NEW UM* using MUL new OP-code )
  1  ld   e'|   c|
  2  ld   d'|   b|
  3  mul
  4  ld   b'|   a|
  5  ld   c'|   h|
  6  ld   a'|   d|
  7  adda  l|
  8  ld   h'|   a|
  9  ld   l'|   e|
 10  pop  de|
 11  mul
 12  exdehl
 13  adchl bc|
 14  pop bc|  psh2  c;
 15 

Scr# 220 
  0 ( MOVE SP )
  1 ." Moving utility." CR
  2 \ Use: HEX D900 MOVE-SP
  3 \ or   HEX F840 MOVE-SP
  4 HEX
  5 : MOVE-SP ( a -- )
  6   DUP 16 +ORIGIN !
  7   DUP 12 +ORIGIN !
  8   DUP        S0  !
  9   DUP        TIB !
 10   S0 @ SP!
 11 ;
 12 DECIMAL
 13 -->
 14 
 15 

Scr# 221 
  0 ( MOVE RP )
  1 \ Use: HEX D9A0 MOVE-RP
  2 \ or   HEX F8E0 MOVE-RP
  3 HEX
  4 : MOVE-RP ( a -- )
  5   DUP R0 @ 80 -
  6   SWAP 80 - C0 CMOVE
  7   DUP 14 +ORIGIN !
  8   DUP 2E +ORIGIN !
  9   DUP         R0 !
 10 ;
 11 \
 12 DECIMAL
 13 -->
 14 
 15 

Scr# 222 
  0 ( MOVE LIMIT )
  1 \ Use: HEX E000 MOVE-LIMIT
  2 \ or   HEX FF58 MOVE-LIMIT
  3 HEX
  4 : MOVE-LIMIT ( a -- )
  5   DUP LIMIT !
  6   DUP 24 +ORIGIN !
  7   204 #BUFF * - DUP FIRST !
  8   DUP USE !
  9   DUP PREV !
 10   22 +ORIGIN !
 11 ;
 12 DECIMAL
 13 -->
 14 7 TO #BUFF
 15 

Scr# 223 
  0 ( UP AND DOWN )
  1 HEX
  2 : UP ( -- ) \ Move SP, RP, User's, Buffers to high memory
  3   FF58 MOVE-LIMIT
  4   F0E0 MOVE-RP
  5   F040 MOVE-SP
  6   EMPTY-BUFFERS ;
  7 \
  8 : DOWN ( -- ) \ Move SP, RP, User's, Buffers to low memory
  9   D0E8 MOVE-SP
 10   D188 MOVE-RP
 11   E000 MOVE-LIMIT
 12   EMPTY-BUFFERS ;
 13 DECIMAL
 14 
 15 

Scr# 224 
  0 ( 128K BANK! TEST )
  1 HEX
  2 \ BANKM : 5B5C
  3 : ?BANK BASE @
  4   5B5C C@ 2 BASE ! .
  5   BASE ! ;
  6 : TEST
  7   BANK!
  8   C000 @ U.
  9   10 BANK!
 10 ;
 11 
 12 
 13 
 14 
 15 

Scr# 225 
  0 ( ?DO LOOP )
  1 : BACK-
  2  BACK
  3  SP@ CSP @ -
  4  IF 2+ [COMPILE] THEN
  5  ENDIF
  6  ?CSP CSP !
  7 ;
  8 -->
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 226 
  0 ( ?DO LOOP )
  1 : ?DO
  2  COMPILE (?DO)
  3  CSP @ !CSP
  4  HERE 0 , 0
  5  HERE 3
  6 ; IMMEDIATE
  7 \
  8 : DO
  9  COMPILE (DO)
 10  CSP @ !CSP
 11  HERE 3
 12 ; IMMEDIATE
 13 -->
 14 
 15 

Scr# 227 
  0 ( ?DO LOOP )
  1 : LOOP
  2  3 ?PAIRS
  3  COMPILE (LOOP)
  4  BACK-
  5 ; IMMEDIATE
  6 \
  7 : +LOOP
  8  3 ?PAIRS
  9  COMPILE (+LOOP)
 10  BACK-
 11 ; IMMEDIATE
 12 
 13 
 14 
 15 

Scr# 228 
  0 ( ?DO LOOP )
  1 : TYPE
  2  OVER + SWAP
  3  ?DO
  4   I C@ EMIT
  5  LOOP
  6 ;
  7 : TEST
  8  0 0
  9  ?DO I . CR LOOP
 10 ;
 11 
 12 
 13 
 14 
 15 

Scr# 229 
  0 ( POSTPONE )
  1 DECIMAL
  2 : POSTPONE
  3  ?COMP -FIND \ xt b f
  4  0= 0 ?ERROR
  5  192 < IF
  6   COMPILE COMPILE
  7  ENDIF
  8  ,
  9 ; IMMEDIATE
 10 ;S
 11 \ test
 12 : TIF
 13  POSTPONE 0BRANCH HERE 0 ,
 14  2 ; IMMEDIATE
 15 

Scr# 230 
  0 \ 1. F_GETLINE from handle( F_READ and F_SEEK ) DECIMAL
  1 MARKER TASK DECIMAL
  2 : F_GETLINE ( a m fh -- a n )
  3   DUP >R F_FGETPOS 44 ?ERROR            \ a m  d     \ fh
  4   2SWAP OVER 1+ SWAP                    \ d a a m
  5   R  F_READ 46 ?ERROR                   \ d a n
  6   IF    \ at least 1 chr was read       \ d a
  7     10 ENCLOSE DROP NIP   SWAP          \ d b a
  8     13 ENCLOSE DROP NIP   ROT MIN       \ d a n
  9     2dup + @ 2573 = if 1 else 0 then >r \ d a n     \ fh f
 10     DUP >R 2SWAP R>  r> +  0 D+         \ a n d+n+f \ fh
 11     R> F_SEEK 45 ?ERROR                 \ a n
 12   ELSE
 13     R> 2SWAP 2DROP DROP 0               \ a 0
 14   ENDIF
 15 ; -->

Scr# 231 
  0 \ 2. include from handle
  1 : F_INCLUDE  ( fh -- )
  2   BLK @ >R  >IN @ >R  SOURCE-ID @ >R
  3   R IF R F_FGETPOS 44 ?ERROR ELSE 0 0 THEN >R >R
  4   SOURCE-ID !
  5   BEGIN
  6     1 BLOCK
  7     DUP B/BUF BLANKS
  8     1+  500   SOURCE-ID @ F_GETLINE       \ a n
  9   \ CR 1 BLOCK OVER TYPE
 10     2DUP + OVER B/BUF SWAP 2+ - BLANKS
 11     NIP
 12 -->
 13 
 14 
 15 

Scr# 232 
  0 \ 2. include from handle
  1 \
  2   WHILE
  3   \ UPDATE
  4     1 BLK ! 0 >IN !  INTERPRET
  5   REPEAT
  6   SOURCE-ID @  0 SOURCE-ID !  F_CLOSE 42 ?ERROR
  7   R> R> R>   DUP SOURCE-ID !
  8   IF SOURCE-ID @ F_SEEK 43 ?ERROR ELSE 2DROP THEN
  9   R> >IN !  R> BLK ! ;
 10  -->
 11 
 12 
 13 
 14 
 15 

Scr# 233 
  0 \ 3. an INCLUDE wrapper
  1 : OPEN<    ( -- fh )  \ used in the form OPEN FFFF
  2   BL        WORD COUNT OVER + 0 SWAP !
  3   PAD 1 F_OPEN 43 ?ERROR ;
  4 : INCLUDE
  5   OPEN< DUP F_INCLUDE F_CLOSE DROP ;
  6 ;S
  7 \
  8 \ 5 VALUE FH
  9 \ CREATE FILENAME ," Test.f"
 10 \ FILENAME 1+ PAD 1 F_OPEN 43 ?ERROR TO FH
 11 \ FILENAME COUNT TYPE
 12 \ : G 1 BLOCK FH F_GETLINE ;
 13 \ FH F_CLOSE . CR
 14 
 15 

Scr# 234 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 235 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 236 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 237 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 238 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 239 
  0 ( Rainbow effects )
  1 HEX  CODE  SYNC
  2  76 C,       \ halt i.e. sync with interrupt
  3  DD C, E9 C, ( NEXT ) SMUDGE
  4 : RAINBOW
  5 BEGIN
  6  SYNC
  7  40 0 DO
  8   8 0 DO
  9    I FFFE P!
 10   LOOP
 11  LOOP
 12  ?TERMINAL
 13 UNTIL
 14 ;
 15 DECIMAL

Scr# 240 
  0 \ LARGE LETTER F
  1 : STAR   42 EMIT ;
  2 : STARS   0 DO STAR LOOP ;
  3 : MARGIN CR 15 SPACES ;
  4 : BLIP   MARGIN STAR ;
  5 : BAR    MARGIN 5 STARS ;
  6 : F      BAR BLIP BAR
  7          BLIP BLIP CR ;
  8 F
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 241 
  0 ( Square example )
  1 0 variable board 7 allot
  2 : square ( square# -- addr ) board + ;
  3 : clear  board 9 erase ; clear
  4 : bar    ." | " ;
  5 : dashes cr 9 0 do [char] - emit loop cr ;
  6 : .box ( square# -- )
  7   square c@  dup 0= if 2 spaces
  8     else dup 1 = if ." X " else ." O "
  9     then then drop ;
 10 : display ( -- )
 11   cr 9 0 do i if i 3 mod 0 = if dashes else bar then then
 12   i .box loop cr quit ;
 13 : play  1- 0 max 8 min square c! ;
 14 : x! ( square# -- )  1 swap play display ;
 15 : o! ( square# -- ) -1 swap play display ;

Scr# 242 
  0 ( CUBES )
  1 : CUBE ( n  -- d  )
  2   >R R ABS DUP UM*       \ u1 u2
  3   R ABS UM* DROP 0 SWAP  \ u1 ud2
  4   ROT R ABS UM*          \ ud2 ud1
  5   D+ R> D+-  ;           \ d
  6 0 VARIABLE %CUBE 145 4 * 2+ ALLOT
  7 : %CUBE# 2* 2* %CUBE + ; \ address of cube
  8 : BUILD%CUBE 144 0 DO I CUBE I %CUBE# 2! LOOP ; BUILD%CUBE
  9 NEEDS J
 10 NEEDS K
 11 -->
 12 : J RP@ 6 + @ ;
 13 : K RP@ 10 + @ ;
 14 -->
 15 

Scr# 243 
  0 ( CUBES )
  1 : ISCUBE? ( d -- n tf | ff )
  2   ABS DMINUS
  3   144 0 DO
  4     I %CUBE# 2@ 2OVER D+ OR 0=
  5     IF 2DROP 0 I  LEAVE THEN
  6   LOOP NIP
  7   DUP 0< IF DROP 0 ELSE 1 THEN
  8 ;
  9 -->
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 244 
  0 ( CUBES )
  1 : CUBES
  2   100 1 DO
  3     100 I DO
  4       100 I DO
  5         I %CUBE# 2@    J %CUBE# 2@ D+ K %CUBE# 2@ D+
  6         ISCUBE? IF
  7           CR K . J . I . SPACE .
  8         THEN
  9       LOOP
 10     LOOP
 11   LOOP
 12 ;
 13 
 14 
 15 

Scr# 245 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 246 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 247 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 248 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 249 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 250 
  0 \ BLOCK-SHIFT
  1 \ change line 3
  2 : BLOCK-SHIFT
  3   99 118
  4  DO
  5  I . ." TO " I 1+ . CR
  6  I I 1+ BCOPY
  7  ?TERMINAL IF LEAVE THEN
  8  -1
  9  +LOOP
 10 ;
 11 
 12 
 13 
 14 
 15 

Scr# 251 
  0 ( block move reorder )
  1 \ Utility used while
  2 \ reordering all screens
  3 DECIMAL  3 LOAD
  4 DECIMAL 41 LOAD
  5 : BLOCK-SHIFT
  6  CLS
  7  350 1 DO
  8   0. AT. I . SPACE
  9   I I 10000 +
 10   BCOPY
 11   ?TERMINAL IF LEAVE THEN
 12  LOOP
 13 ;
 14 
 15 

Scr# 252 
  0 \ Print all blocsks to #13
  1 \ The "blocks2txt.pl" Perl script does the same faster
  2 : >OUTPUT 13
  3   DUP DEVICE ! SELECT ;
  4 : PRINT-ALL-BLOCKS
  5   >OUTPUT
  6   ." This list is produced via Scr# 252 " CR CR
  7   1 1000 INDEX CR CR
  8   1001 1 DO
  9     VIDEO I 5 .R
 10     I BLOCK >OUTPUT I LIST CR
 11     VIDEO 5 0 DO 8 EMITC LOOP
 12     ?TERMINAL IF LEAVE THEN
 13   LOOP
 14   VIDEO CR ;
 15 

Scr# 253 
  0 ( INITIALIZE-MMC )
  1 \ this erases blocks from
  2 \ # 302 up
  3 ;S STOP STOP
  4 : INITIALIZE-MMC
  5 #SEC
  6 302
  7 DO I . I BCLEAR
  8 ?TERMINAL IF LEAVE THEN
  9 LOOP
 10 ;
 11 
 12 
 13 
 14 
 15 

Scr# 254 
  0 ( MICRODRIVE CARTRIDGE )
  1 ( LAST BLOCK )
  2 \ At least one block should
  3 \ be unusable due to the
  4 \ ring-junction on the tape
  5 \ so this block shouldn't be
  6 \ available.
  7 \ More: Real cartridges can
  8 \ have up to 85-90 K
  9 \ This means 170-180 blocks.
 10 
 11 
 12 
 13 
 14 
 15 \ TEST

Scr# 255 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 256 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 257 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 258 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 259 
  0 \ Forth Application Tecniques - 5.1.1
  1 MARKER THAT
  2 : I'M
  3   BL WORD
  4   COUNT TYPE CR
  5 ;
  6 : MEET
  7   ." HI " I'M ;
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 260 
  0 ( TRACE )
  1 \
  2 \ tracer word
  3 \
  4 ' NOOP   VARIABLE TRACER
  5 ' NOOP , \ patched to TR-EXIT  on scr# 262
  6 \
  7 \ saved Instruction Pointer (BC register)
  8 \
  9 ' QUIT >BODY VARIABLE TR-IP
 10 RP@          VARIABLE TR-RP
 11 SP@          VARIABLE TR-SP
 12 0            VARIABLE TR-X
 13 0            VARIABLE TR-Y
 14 1            VARIABLE TR-MMU
 15 -->

Scr# 261 
  0 ( TRACE )
  1 HEX CODE TROFF
  2   ldx   ix|  (NEXT)     nn,   \ disable tracing
  3   jpix
  4   c;
  5 \
  6 : AT@ ( -- col row )
  7   MMU7@ 10 MMU7! FB24 C@ FB22 C@
  8   ROT MMU7! ;
  9 \
 10 : AT! ( col row -- )
 11   MMU7@ 10 MMU7! FB24 C! FB22 C!
 12   MMU7! ;
 13 -->
 14 
 15 

Scr# 262 
  0 ( TRACE )
  1 HEX CODE TR-ENTER
  2   ld()x sp|   TR-SP     aa,   \ save SP
  3   ld()x bc|   TR-IP     aa,   \ save BC (IP)
  4   ldhl()      06430     aa,   \ save RP
  5   ld()hl      TR-RP     aa,
  6 \
  7   ldx   bc|  TRACER     nn,   \ goto tracer
  8   ldx   ix|  (NEXT)     nn,   \ disable tracing
  9   jpix
 10   c;
 11 -->
 12 
 13 
 14 
 15 

Scr# 263 
  0 ( TRACE )
  1 HEX CODE TR-EXIT
  2   ldx() sp|   TR-SP     aa,       \ restore SP
  3   ldx() bc|   TR-IP     aa,       \ restore BC (IP)
  4   ldhl()      TR-RP     aa,
  5   ld()hl      06430     aa,       \ restore RP
  6 \
  7   ldx   ix| ' TR-ENTER  >BODY nn, \ restore tracing
  8   jp (NEXT) aa,
  9   c;
 10   ' TR-EXIT   TRACER CELL+ !      \ patch to TRACER
 11 \
 12 -->
 13 
 14 
 15 

Scr# 264 
  0 ( TRACE )
  1 HEX CODE TRON
  2   ldx   ix| ' TR-ENTER  >BODY nn, \ restore tracing
  3   jp (NEXT) aa,
  4   c;
  5 \
  6 : -SPACES
  7   1F AND
  8   0 DO 8 EMITC LOOP ;
  9 \
 10 -->
 11 
 12 
 13 
 14 
 15 

Scr# 265 
  0 ( TRACE )
  1 TROFF HEX
  2 : TRACE INVV
  3   TR-IP @ @  .WORD
  4   TR-RP @ @ CELL- @  (deload)
  5 \ R0 @ TR-RP @ ?DO I @ CELL- @ .WORD LOOP
  6   TR-RP @ @ CELL- C@ -SPACES
  7   TR-IP @    C@ -SPACES
  8 TRUV ;
  9 ' TRACE TRACER !
 10 \ ' NOOP  TRACER !
 11 \
 12 DECIMAL
 13 \
 14 
 15 

Scr# 266 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 267 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 268 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 269 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 270 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 271 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 272 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 273 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 274 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 275 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 276 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 277 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 278 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 279 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 280 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 281 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 282 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 283 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 284 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 285 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 286 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 287 
  0 ( GREY-SCREEN example )
  1 HEX
  2 CODE GREY-SCREEN
  3  PUSH BC|
  4  LDX  HL|  4000  NN,
  5  LDX  DE|  AA55  NN,
  6  LDX  BC|  000C  NN,
  7 HERE HERE
  8  LD   A'|  (HL)|
  9  XORA  E|
 10  LD (HL)'|    A|
 11  INCX HL|
 12  DJNZ BACK,
 13 -->
 14 
 15 

Scr# 288 
  0 ( GREY-SCREEN example )
  1 HERE
  2  LD   A'|  (HL)|
  3  XORA  D|
  4  LD (HL)'|    A|
  5  INCX HL|
  6  DJNZ BACK,
  7  DEC  C'|
  8  JRF NZ'| BACK,
  9  POP BC|
 10 NEXT C;
 11 DECIMAL
 12 
 13 
 14 
 15 

Scr# 289 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 290 
  0 ( map - character replacing )
  1 \ translate c using mapping a1 -> a2. n is mapping length
  2 code (map) ( a2 a1 n c1 -- c2 )
  3   exx
  4   pop   hl|               \ c
  5   ld    a'|   l|          \ character to map
  6   pop   bc|               \ n length of a1 map-string
  7   pop   hl|               \ a1 map-string
  8   ld    d'|   b|
  9   ld    e'|   c|          \ length in de too
 10   cpir
 11 -->
 12 
 13 
 14 
 15 

Scr# 291 
  0 ( map - character replacing )
  1   pop   hl|               \ a2 map-string
  2   jrf  nz'|  holdplace
  3     addhl de|
  4     decx  hl|
  5     sbchl bc|
  6     ld    a'| (hl)|
  7   here disp,
  8   ld    l'|   a|
  9   ldn   h'|   0  N,
 10   push  hl|
 11   exx
 12   jpix
 13 c;
 14 -->
 15 

Scr# 292 
  0 ( map - character replacing )
  1 create ncdm  \  ^`%&$_{}~
  2 hex 5E C, 60 C, 25 C, 26 C, 24 C, 5F C, 7B C, 7D C, 7E C,
  3 create ndom  \  :?/*|\<>"
  4 hex 3A C, 3F C, 2F C, 2A C, 7C C, 5C C, 3C C, 3E C, 22 C,
  5 \
  6 : needs-check
  7   needs-w count over + swap
  8   Do
  9     ncdm ndom 9 i c@ (map) i c!
 10   Loop
 11 ;
 12 
 13 
 14 
 15 

Scr# 293 
  0 ( map - character replacing )
  1 : t
  2   >r cod  count  dom  count rot min
  3   r . r emit space r> (map) dup . emit cr ;
  4 \
  5  char \ t
  6  char / t
  7  char : t
  8  char | t
  9  char " t
 10  char < t
 11  char > t
 12  char ? t
 13  char * t
 14 
 15 

Scr# 294 
  0 ( GREY-SCREEN example )
  1 HERE
  2  LD   A'|  (HL)|
  3  XORA  D|
  4  LD (HL)'|    A|
  5  INCX HL|
  6  DJNZ BACK,
  7  DEC  C'|
  8  JRF NZ'| BACK,
  9  POP BC|
 10 NEXT C;
 11 DECIMAL
 12 
 13 
 14 
 15 

Scr# 295 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 296 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 297 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 298 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 299 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 300 
  0 ( Study:  MMU7 / set or get bank )
  1 \ set MMU7 to 8K-page given between 0 and 233
  2 \ to fit *ANY* page
  3 DECIMAL
  4 CODE MMU7! ( n -- )
  5  POP   HL|
  6  LD    A'|  L|
  7  NEXTREGA 87 P,
  8  NEXT
  9 C;
 10 \ query current page in MMU7
 11 : MMU7@ ( -- n )
 12   87 REG@
 13 ;
 14 
 15 

Scr# 301 
  0 ( Study: MMU7 / simplest )
  1 \ decode bits 765 of H as 8K-page 64-71
  2 \ lower bits of H and L are offset from E000h
  3 \
  4 \ heap pointer:                pppb bbbb  bbbb bbbb
  5 \ page:offset:     0100 0ppp : 111b bbbb  bbbb bbbb
  6 \
  7 CODE >FAR ( ha -- a n )
  8  POP   DE|
  9  LD    A'|  D|
 10  ANDN  HEX  E0 N,
 11  RLCA
 12  RLCA
 13  RLCA
 14 -->
 15 

Scr# 302 
  0 ( Study: MMU7 / simplest )
  1 \
  2  ORN   HEX  40 N,
  3 \
  4  LD    L'|  A|
  5  LDN   H'|  00 N,
  6  LD    A'|  D|
  7  ORN   HEX  E0 N,
  8  LD    D'|  A|
  9  PSH2
 10 C;
 11 -->
 12 
 13 
 14 
 15 

Scr# 303 
  0 ( Study: MMU7 / simplest )
  1 \ reverse of >FAR: encodes a FAR address 8K-page in bits 765
  2 \ of H, lower bits of HL are offset at E000h
  3 \
  4 CODE <FAR ( a n -- ha )
  5  POP   DE|
  6  POP   HL|
  7  LD    A'|  E|
  8  ANDN  HEX  07 N,    \ page number is betwen 0 and 7
  9  RRCA
 10  RRCA
 11  RRCA
 12 -->
 13 
 14 
 15 

Scr# 304 
  0 ( Study: MMU7 / simplest )
  1 \
  2  LD    D'|  A|
  3  LD    A'|  H|
  4  ANDN  HEX  1F N,
  5  ORA    D|
  6  LD    H'|  A|
  7  PSH1
  8 C;
  9 DECIMAL
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 305 
  0 ( Study: MMU7 / 16th byte )
  1 \ decode 7 top bits of H as 8K-page 72-199
  2 \ lsb of H and all L are offset rounded at 16th byte
  3 \
  4 \ heap pointer              pppp pppb   bbbb bbbb
  5 \ page:offset   xppp pppp : 111b bbbb   bbbb 0000
  6 \
  7 CODE >FAR ( a1 -- a2 n )
  8  POP   HL|
  9  LD    A'|   H|
 10  SRL    A|
 11  ADDN  HEX  48  N,
 12  LD    E'|   A|        \ page
 13  LDN   D'|   0  N,
 14 -->
 15 

Scr# 306 
  0 ( Study: MMU7 / 16th byte )
  1 \
  2  ADDHL HL|
  3  ADDHL HL|
  4  ADDHL HL|
  5  ADDHL HL|               \ shift hl 4 bits left
  6  LD    A'|   H|
  7  ORN   HEX  E0  N,
  8  LD    H'|   A|          \ E000 offset
  9  PUSH  HL|
 10  PUSH  DE|
 11  NEXT C;
 12 -->
 13 
 14 
 15 

Scr# 307 
  0 ( Study: MMU7 / 16th byte )
  1 \ reverse of >FAR, encodes 8K-page in bits 7-1 of H
  2 \ bit 1 of H and L are the address rounded at 16 byte
  3 \
  4 CODE <FAR ( a2 b -- a1 )
  5  POP   DE|          \ page 72-199
  6  POP   HL|          \ offset at E000
  7  LD    A'|   E|
  8  SUBN  HEX  48  N,
  9  ADDHL HL|
 10  ADDHL HL|
 11  ADDHL HL|
 12  ADDHL HL|
 13  -->
 14 
 15 

Scr# 308 
  0 ( Study: MMU7 / 16th byte )
  1 \
  2  RLA                     \ A receives HL msb
  3  LD    L'|   H|
  4  LD    H'|   A|
  5  PUSH  HL|
  6  NEXT C;
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 309 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 310 
  0 ( LED - Large EDitor )
  1 \ Large file EDitor: each line can be 85 characters long
  2 \ then maximum line number is 14.592
  3 decimal  marker TASK
  4 85 CONSTANT COLS/ROW
  5 96 CONSTANT ROWS/PAGE
  6 0  VARIABLE LED-LN              \ line number
  7 0  VARIABLE LED-MAX             \ max line number
  8 0  VARIABLE LED-ROW
  9 0  VARIABLE LED-COL
 10 0  VARIABLE LED-HOME            \ first line to display
 11 CREATE LED-FN DECIMAL  80 ALLOT \ filename
 12 0 variable LED-FH               \ filehandle of open file
 13 \
 14 -->
 15 

Scr# 311 
  0 ( LED - Large EDitor )
  1 : >>FAR ( row -- n a ) \ given a row-number ret page+offset
  2   rows/page /mod
  3   [ decimal ] 72 +
  4   dup 223 > if 40 error then
  5   swap 85 * [ HEX ] E000 OR swap ;
  6 \
  7 : LED-RAD  ( row -- a )
  8   >>FAR MMU7! ;
  9 \
 10 : LED-CLOSE
 11   led-fh @ f_close [ decimal ] 42 ?error ;
 12 -->
 13 
 14 
 15 

Scr# 312 
  0 ( LED - Large EDitor )
  1 \ assume to read page np.
  2 \ returns the characters read. 0 means EOF
  3 \ row is stored in 8K-pages RAM 72-223
  4 decimal needs SHOW-PROGRESS
  5 : LED-RD1  ( np -- nc )
  6   dup show-progress
  7   led-rad
  8   dup COLS/ROW blanks
  9   led-fh @ f_getline nip
 10 ;
 11 -->
 12 
 13 
 14 
 15 

Scr# 313 
  0 ( LED - Large EDitor )
  1 \ load filename specified in LED-FN
  2 decimal
  3 : LED-LOAD
  4   led-fn 1+ pad 1 f_open 43 ?error
  5   led-fh !
  6   0 led-ln !
  7   begin
  8     led-ln @ show-progress
  9     1 led-ln +!
 10     led-ln @ led-rd1
 11   ?terminal if quit then
 12   0= until
 13   led-ln @ led-max !
 14   led-close ;
 15 -->

Scr# 314 
  0 ( LED - Large EDitor )
  1 \ accept a filename and kep it in LED-FN
  2 decimal
  3 : LED-FILE
  4   led-fn 80 erase
  5   bl word led-fn over c@ 1+   \ a1 a2 n
  6   cmove
  7 ;
  8 \
  9 : LED-OPEN
 10   led-file
 11   led-load
 12 ;
 13 -->
 14 
 15 

Scr# 315 
  0 ( LED - Large EDitor )
  1 \ assume to read page np.
  2 \ returns the characters read. 0 means EOF
  3 \ row is stored in 8K-pages RAM 72-223
  4 decimal
  5 : LED-WR1  ( np -- )
  6   led-rad COLS/ROW -TRAILING
  7   2DUP + [ HEX ] 0A  SWAP 1- C!
  8   LED-FH @ F_WRITE [ decimal ] 47 ?ERROR
  9   DROP
 10 ;
 11 -->
 12 
 13 
 14 
 15 

Scr# 316 
  0 ( LED - Large EDitor )
  1 : LED-SAVE
  2   led-fn 1+ pad  14  f_open 43 ?error
  3   led-fh  !
  4   LED-MAX @ 1+ 1 DO
  5     I show-progress
  6     I LED-WR1
  7     ?terminal if leave then
  8   LOOP
  9   led-fh @ f_close
 10 ;
 11 -->
 12 
 13 
 14 
 15 

Scr# 317 
  0 ( LED - Large EDitor )
  1 DECIMAL
  2 : LED-DISPLAY
  3   16 0 DO
  4     I LED-HOME @ + LED-RAD
  5     COLS/ROW -TRAILING TYPE CR
  6   LOOP
  7 ;
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 318 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 319 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 320 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 321 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 322 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 323 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 324 
  0 ( MMU7 / simplest )
  1 \ visual test
  2 : .PG-OFFS
  3   <# # # # # [CHAR] . HOLD # # #> TYPE CR
  4 ;
  5 \ visual test
  6 : T
  7   HEX CR
  8   DUP S->D .PG-OFFS
  9   >FAR 2DUP .PG-OFFS
 10   <FAR S->D .PG-OFFS
 11 ;
 12 
 13 
 14 
 15 

Scr# 325 
  0 ( MMU Heap Management )
  1 \ DECIMAL 303 LOAD
  2 \
  3 \ Heap Pointer
  4 \ 70 USER HP
  5 \
  6 : HP@ HP @ ;
  7 : HP+! HP +! ;
  8 : FAR >FAR MMU7! ;
  9 \
 10 
 11 -->
 12 
 13 
 14 
 15 

Scr# 326 
  0 ( MMU7 HEAP )
  1 \ check for page boundary
  2 : HP@ HP @ ;
  3 hex
  4 : ?PAGE ( n -- ha )
  5   1fff >r
  6   hp@ cell+  r  and +  r  >
  7   if
  8    hp@  r>  or 1+  hp !
  9   else
 10    r> drop
 11   then
 12   hp@ 0= 12 ?error
 13 ;
 14 
 15 

Scr# 327 
  0 ( MMU7 HEAP )
  1 \ reserve n bytes on heap, retunrs heap-pointer to them
  2 : HEAP ( n -- ha )
  3   dup ?page
  4   hp@ swap
  5   cell+
  6   hp +!
  7   hp@ swap
  8   tuck   far !
  9 ;
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 328 
  0 ( MMU7 HEAP STRING )
  1 \ accepts a string and stores it to Heap,
  2 \ returns a Pointer to a counted string
  3 : +" ( ha -- ha )
  4  DUP FAR C@
  5  [CHAR] " WORD
  6  DUP C@ >R 1+
  7  HP@ FAR R CMOVE
  8  R HP+!
  9  R> +
 10  OVER FAR C!
 11 ;
 12 -->
 13 
 14 
 15 

Scr# 329 
  0 ( MMU7 HEAP STRING )
  1 \ accepts a string and store it to Heap, returns a
  2 \ pointer to a counted string
  3 : H" ( -- ha )
  4  HP @
  5  [CHAR] " WORD  DUP C@ 1+ >R
  6  OVER FAR  TUCK CELL+  R CMOVE
  7  R> CELL+ HP +!
  8  HP @ [ HEX ] 1FFF AND 1EFF >
  9  IF 1FFF OR 1+ HP ! THEN
 10  HP @ OVER !
 11 ;
 12 DECIMAL
 13 
 14 
 15 

Scr# 330 
  0 ( MMU7 HEAP STRING )
  1 \ given a pointer, prints the counted string
  2 \
  3 : .H
  4   FAR
  5   COUNT TYPE
  6 ;
  7 -->
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 331 
  0 ( MMU7 HEAP POINTER )
  1 \ like CONSTANT but it returns a FAR-resolved pointer
  2 : POINTER ( a -- cccc )
  3  <BUILDS
  4   ,
  5  DOES>
  6   @ FAR
  7 ;
  8 -->
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 332 
  0 ( S" Counted Strings in Heap )
  1 : (S")   R R> CELL+ >R  @ FAR COUNT ;
  2 \
  3 : S"  ( -- a n )
  4   STATE @ IF
  5    COMPILE (S") H" ,
  6   ELSE
  7    H" FAR COUNT
  8   ENDIF
  9 ; IMMEDIATE
 10 \
 11 : TEST_S"  S" HELLO WORLD" NOOP ;
 12 ;S
 13 CR TEST_S" TYPE
 14 CR S" HELLO WORLD" TYPE
 15 

Scr# 333 
  0 \ TEST
  1 : Q CR
  2  ." HP  " HP@ U. CR
  3  ." P   " CURPAGE ? CR
  4 ;
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 334 
  0 ( Testing where $6000 is paged )
  1 HEX
  2 : T
  3   MMU7
  4   E000 DUMP
  5   FD38 DUMP
  6 ;
  7 DECIMAL
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 335 
  0 ( Testing where $6000 is paged )
  1 DECIMAL 14 EMITC
  2 HEX 8F EMITC 8F EMITC
  3 DECIMAL
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 336 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 337 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 338 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 339 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 340 
  0 ( R/W : BLK-FH )
  1 1 variable blk-fh
  2 \ seek block n  within blocks!.bin  file
  3 : blk-seek  ( n -- )
  4   b/buf m*
  5   blk-fh @
  6   f_seek
  7   [ hex ] 2D ?error
  8 ;
  9 -->
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 341 
  0 ( R/W : BLK-READ )
  1 \ read block n to address a
  2 : blk-read  ( a n -- )
  3   blk-seek
  4   b/buf
  5   blk-fh @
  6   f_read
  7   [ hex ] 2E ?error
  8   drop
  9 ;
 10 -->
 11 
 12 
 13 
 14 
 15 

Scr# 342 
  0 ( R/W : BLK-WRITE )
  1 \ write block n from address a
  2 : blk-write  ( a n -- )
  3   blk-seek
  4   b/buf
  5   blk-fh @
  6   f_write
  7   [ hex ] 2E ?error
  8   drop
  9 ;
 10 -->
 11 
 12 
 13 
 14 
 15 

Scr# 343 
  0 ( R/W : BLK-INIT )
  1 : blk-init
  2  blk-fh @ f_close drop   \ ignore error
  3  filename
  4  here 3 f_open
  5  44 ?error
  6  blk-fh !
  7 ;
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 344 
  0 ( blk-fname )
  1 : STRING"
  2   [CHAR] " WORD   COUNT 1+ ALLOT ;
  3 create blk-fname
  4   STRING" !Block-64.bin" 0 c,
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 345 
  0 ( r/w patch )
  1 ' r/w 32 + @ .word
  2 ' r/w 38 + @ .word
  3 ' nxtrd ' r/w 32 + !
  4 ' nxtwr ' r/w 38 + !
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 346 
  0 ( r/w patch )
  1 ' r/w 32 + @ .word
  2 ' r/w 38 + @ .word
  3 ' blk-read ' r/w 32 + !
  4 ' blk-write ' r/w 38 + !
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 347 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 348 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 349 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 350 
  0 ( Matt Davies'  .helloworld )
  1 CODE .helloworld
  2         ldx  hl|   here  0  NN,
  3   here  ld   a'|   (hl)|
  4         anda  a|
  5         retf  z|
  6         rst  10|
  7         incx hl|
  8         jr   BACK,
  9         c;
 10   here  ," Hello, World!"  1+ swap !
 11 \
 12 \
 13 
 14 
 15 

Scr# 351 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 352 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 353 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 354 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 355 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 356 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 357 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 358 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 359 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 360 
  0 ( F_STAT via RST 8 hook code )
  1 CASEOFF
  2 code F_STAT ( fspec buff -- f )
  3   pop   de|      \ 11-byte buffer
  4   ex(sp)ix       \ filespec nul-terminated
  5   push  bc|
  6   ldn   a'|   char  *  n,
  7   rst   08|   hex  AC  c,
  8   pop   bc|
  9   pop   ix|
 10   sbchl hl|
 11   push  hl|
 12   jpix
 13 c;
 14 -->
 15 

Scr# 361 
  0 ( F_FGETPOS via RST 08 hook code )
  1 code F_FGETPOS ( n -- d f )
  2   pop   hl|
  3   ld    a'|   l|
  4   push  ix|
  5   push  bc|
  6   rst  08|   hex  9F  c,
  7   ld    h'|   b|
  8   ld    l'|   c|
  9   pop   bc|
 10   pop   ix|
 11   push  de|
 12   push  hl|
 13   sbchl hl|
 14   push  hl|
 15   jpix    c;  -->

Scr# 362 
  0 ( F_SEEK via RST 08 hook code )
  1 code F_SEEK ( d n -- f )
  2   pop   hl|     ld   a'|  l|
  3   ld    h'|   b|
  4   ld    l'|   c|
  5   pop   bc|
  6   pop   de|
  7   push  ix|
  8   push  hl|
  9   ldx   ix| 0 nn,
 10   rst  08|   hex  9F  c,
 11   pop   bc|
 12   pop   ix|
 13   sbchl hl|
 14   push  hl|
 15   jpix    c;  -->

Scr# 363 
  0 ( F_WRITE via RST 8 hook code )
  1 code F_WRITE ( addr bytes n -- actual f )
  2   ld    d'|   b|
  3   ld    e'|   c|
  4   pop   hl|     \ file handle number
  5   ld    a'|   l|
  6   pop   bc|     \ bytes to read
  7   ex(sp)ix
  8   push  de|
  9   rst   08|   hex  9E  c,
 10   pop   bc|
 11   pop   ix|
 12   push  de|
 13   sbchl hl|
 14   push  hl|
 15   jpix    c;  -->

Scr# 364 
  0 ( F_READ via RST 8 hook code )
  1 code F_READ ( addr bytes n -- actual f )
  2   ld    d'|   b|
  3   ld    e'|   c|
  4   pop   hl|     \ file handle number
  5   ld    a'|   l|
  6   pop   bc|     \ bytes to read
  7   ex(sp)ix
  8   push  de|
  9   rst   08|   hex  9D  c,
 10   pop   bc|
 11   pop   ix|
 12   push  de|
 13   sbchl hl|
 14   push  hl|
 15   jpix    c;  -->

Scr# 365 
  0 ( F_CLOSE via RST 8 hook code )
  1 code F_CLOSE ( n -- f )
  2   pop   hl|
  3   ld    a'|   l|
  4   push  ix|
  5   push  bc|
  6   rst   08|   hex  9B  c,
  7   pop   bc|
  8   pop   ix|
  9   sbchl hl|
 10   push  hl|
 11   jpix
 12 c;
 13 -->
 14 
 15 

Scr# 366 
  0 ( F_OPEN via RST 8 hook code )
  1 code F_OPEN ( fspec buff mode -- n f )
  2   ld    h'|   b|
  3   ld    l'|   c|
  4   pop   bc|      \ mode
  5   ld    b'|   c|
  6   pop   de|      \ 8-byte buffer if any
  7   ex(sp)ix       \ filespec nul-terminated
  8   push  hl|      \ this push bc
  9   ldn   a'|   char  *  n,
 10   rst   08|   hex  9A  c,
 11   pop   bc|
 12   pop   ix|
 13 -->
 14 
 15 

Scr# 367 
  0 ( F_OPEN via RST 8 hook code )
  1   sbchl hl|
  2   ld    e'|   a|
  3   ldn   d'|   0  n,
  4   push  de|
  5   push  hl|
  6   jpix
  7 c;
  8 -->
  9 \ CREATE FILENAME 30 ALLOT
 10 \ FILENAME 30 ERASE
 11 \ S" test.txt"   \ new Counted String
 12 \ FILENAME SWAP CMOVE
 13 \ FILENAME PAD 1 F_OPEN
 14 \ DROP
 15 \ F_CLOSE

Scr# 368 
  0 ( F_FSTAT via RST 8 hook code )
  1 code F_FSTAT ( addr n -- f )
  2   pop   de|       \ file handle number
  3   ex(sp)ix        \ 11-byte buffer
  4   push  bc|
  5   ld    a'|   e|
  6   rst   08|   hex  A1  c,
  7   pop   bc|
  8   pop   ix|
  9   sbchl hl|
 10   push  hl|
 11   jpix
 12 c;
 13 -->
 14 \ 2 PAD F_FSTAT
 15 

Scr# 369 
  0 code F_SYNC  ( n -- f )
  1   pop   hl|
  2   push  ix|
  3   push  bc|
  4   ld    a'|   l|
  5   rst   08|   hex  9C  c,
  6   pop   bc|
  7   pop   ix|
  8   sbchl hl|
  9   push  hl|
 10   jpix
 11 c;
 12 -->
 13 \ 2 F_SYNC works
 14 
 15 

Scr# 370 
  0 ( M_DOSVERSION via RST 8 hook code )
  1 \ Get API version/mode information
  2 \ Entry: none
  3 \ Exit: Fc=1, error; A=14 "no such device"
  4 \ Fc=0, success. BC="NX"; DE=maj.min in BCD format
  5 \   HL="en" or "es" for English/Spanish
  6 code M_DOSVERSION ( -- n )
  7   push  ix|
  8   push  bc|
  9   rst   08|   hex  88  c,
 10   pop   bc|
 11   pop   ix|
 12   push  de|
 13   jpix
 14 c;
 15 DECIMAL

Scr# 371 
  0 ( F_GETFREE via RST 08 hook code test )
  1 code f_getfree ( drive -- d )
  2   pop   hl|
  3   push  ix|
  4   push  bc|
  5   ld    a'|   l|
  6   rst   08|   hex  B1  c,
  7   ld    h'|   b|
  8   ld    l'|   c|
  9   pop   bc|
 10   pop   ix|
 11   push  de|
 12   push  hl|
 13   jpix
 14 c;
 15 

Scr# 372 
  0 ( M_P3DOS )
  1 CASEOFF
  2 \ n1 n2 n3 n4 a -- n5 n6 n7 n8
  3 \ hl de bc  a   -- hl de bc  a  flag
  4 code M_P3DOS
  5   pop   de|   \ call ID
  6   pop   hl|
  7   ld    a'|    l|
  8   exx
  9   pop   bc|
 10   pop   de|
 11   pop   hl|
 12   exx
 13   push  bc|
 14   push  ix|
 15 -->

Scr# 373 
  0 ( M_P3DOS )
  1   ld()x sp|   hex 02C +origin  aa,
  2   ldx   sp|  hex  -2 +origin  nn,
  3 \
  4 \  use page 7 RAM bank
  5   ldn   c'|   7   n,
  6 \ nop nop
  7   rst   08|    hex  94  c,
  8 \
  9   ldx() sp|   hex 02C +origin  aa,
 10   push  ix|
 11   pop   hl|
 12   ld()x hl|  hex 02a +origin  aa,
 13 -->
 14 
 15 

Scr# 374 
  0 ( M_P3DOS )
  1   pop   ix|
  2   ex(sp)hl    \ retrieve BC
  3   push  de|
  4   push  bc|
  5   ld    c'|    l|
  6   ld    b'|    h|
  7   ldn   h'|    0   n,
  8   ld    l'|    a|
  9   push  hl|
 10   sbchl  hl|
 11   push   hl|
 12   jpix
 13 c;
 14 decimal
 15 

Scr# 375 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 376 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 377 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 378 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 379 
  0 ( IDE_BANK )
  1 HEX
  2 : IDE_BANK_ALLOC
  3   0002 SWAP 0 0 01BD M_P3DOS
  4   44 ?ERROR
  5   2DROP SWAP DROP ;
  6 DECIMAL
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 380 
  0 ( NextZXOS - IDE_CAPACITY $01b4 )
  1 \ M_P3DOS expects hl, de, bc, a, address
  2 \         returns hl, de, bc, a as error code
  3 : IDE_CAPACITY ( n -- d )
  4 \ n: unit (0 or 1)
  5 \ d: total card capacity in sectors.
  6  >R  0 ( hl )   0 ( de )  R> 1 AND ( bc )  0 ( a )
  7  [ HEX ] 01B4 M_P3DOS [ DECIMAL ]
  8  44 ?ERROR
  9  2DROP ( bc a ) SWAP ( hl,de )
 10  ;
 11 ;S
 12 > TEST <
 13 0 IDE_CAPACITY D.
 14 
 15 

Scr# 381 
  0 ( NextZXOS - DOS_FREE_SPACE $0121 )
  1 \ c: drive letter UpperCase
  2 \ d: total card capacity in sectors.
  3 : DOS_FREE_SPACE ( c -- d )
  4  >R  0  0  0  R>
  5  [ HEX ] 0121 M_P3DOS [ DECIMAL ]
  6  44 ?ERROR
  7  DROP ( a ) ROT ( de bc hl ) DROP SWAP
  8 \
  9 ;
 10 ;S
 11 > TEST <
 12 CHAR C DOS_FREE_SPACE D.
 13 
 14 
 15 

Scr# 382 
  0 ( NextZXOS IDE_MODE 01d5 )
  1 \ Set current NextBasic display mode
  2 : IDE_MODE! ( hl de bc a -- )
  3  >R 0 0 R> 1
  4  [ HEX ] 01D5 M_P3DOS [ DECIMAL ]
  5  44 ?ERROR 2DROP 2DROP VIDEO
  6 ;
  7 HEX
  8 : LAYER0  0000 IDE_MODE!  ;
  9 : LAYER10 0100 IDE_MODE!  1E EMITC 4 EMITC ; \ Lo-Res
 10 : LAYER11 0101 IDE_MODE!  1E EMITC 4 EMITC ; \ ULA
 11 : LAYER12 0102 IDE_MODE!  1E EMITC 8 EMITC ; \ Hi-Res
 12 : LAYER13 0103 IDE_MODE!  1E EMITC 4 EMITC ; \ Hi-Col
 13 : LAYER2  0200 IDE_MODE!  1E EMITC 4 EMITC ;
 14 
 15 

Scr# 383 
  0 ( NextZXOS IDE_MODE 01d5 )
  1 \ Query current NextBasic display mode information
  2 : IDE_MODE@ ( -- hl de bc a )
  3  0 0 0 0
  4  [ HEX ] 01D5 M_P3DOS [ DECIMAL ]
  5  44 ?ERROR
  6 ;
  7 \
  8 \ hex 1840 0 800 9
  9 \ hex 1820 7 800 5
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 384 
  0 ( DOS_FLUSH $0142 )
  1 \ Flush any pending write to SD
  2 : DOS_FLUSH ( c -- )
  3 >R 0 0 0 R>
  4  [ HEX ] 0142 M_P3DOS [ DECIMAL ]
  5  44 ?ERROR
  6  DROP 2DROP
  7 ;
  8 \ CHAR C DOS_FLUSH
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 385 
  0 ( DOS_VERSION / IDE_VERSION )
  1 \ TO BE TESTED YET !
  2 : DOS_VERSION ( -- n )
  3  0 0 0 0
  4  [ HEX ] 0103 DOSCALL [ DECIMAL ]
  5  44 ?ERROR
  6  DROP NIP
  7 ;
  8 : IDE_VERSION ( -- n )
  9  0 0 0 0
 10  [ HEX ] 00A0 DOSCALL [ DECIMAL ]
 11  44 ?ERROR
 12  DROP NIP
 13 ;
 14 
 15 

Scr# 386 
  0 ( IDE_BASIC 1/3 )
  1 \ NOT VERIFIED YET !
  2 CODE IDE_BASIC
  3  POP    HL|
  4  LD()X  SP|  HEX 02C +ORIGIN AA, \ save Forth SP
  5  LDX()  SP|  HEX 008 +ORIGIN AA, \ use Basic's SP
  6  LDAR   DI   EXAFAF   EXX
  7  LDX    HL|  HEX 5B2C NN, \ BANKM
  8  LD     A'| (HL)|
  9  RES     4|    A|  \ ROM switch 3 to 2
 10  LD  (HL)'|    A|
 11  LDX    BC|  HEX 7FFD NN,
 12  OUT(C) A'|
 13  EXX    EXAFAF
 14  JPF    PO| HERE 3 + AA, \ skip EI
 15  EI -->

Scr# 387 
  0 ( IDE_BASIC 2/3 )
  1 \ NOT VERIFIED YET !
  2  PUSH   IX|    PUSH   BC|
  3  CALL   HEX  01C0 AA,
  4  POP    BC|    POP    IX|
  5  PUSH   AF|
  6  LDAR   DI   EXAFAF   EXX
  7  LDX    HL|  HEX 5B2C NN, \ BANKM
  8  LD     A'| (HL)|
  9  SET     4|    A|  \ ROM switch 2 to 3 (48K)
 10  LD  (HL)'|    A|
 11  LDX    BC|  HEX 7FFD NN,
 12  OUT(C) A'|
 13  EXX    EXAFAF
 14  JPF    PO| HERE 3 + AA, \ skip EI
 15  EI -->

Scr# 388 
  0 ( IDE_BASIC 3/3 )
  1 \ NOT VERIFIED YET !
  2  POP    AF|
  3  LDX()  SP|  HEX 02C +ORIGIN AA, \ restore Forth SP
  4 \
  5  LDX    HL|  0 NN,
  6  JRF   CY'|  HOLDPLACE
  7   INC   L'|
  8  HERE  DISP,
  9  PSH1
 10 C;
 11 \ PROG 23635
 12 \ 23635 @ 4 + DUMP
 13 
 14 
 15 

Scr# 389 
  0 ( IDE_BASIC test )
  1 \ NOT VERIFIED YET !
  2 0 VARIABLE PROGR
  3 80 ALLOT
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 390 
  0 ( looking for AT position in LAYERs )
  1 \ search memory for a specific xt for debug purposes
  2 DECIMAL
  3 : AT.
  4 22 EMITC 31 AND SWAP 21 MIN EMITC EMITC ;
  5 HEX
  6 : LOOK-FOR
  7   0F MMU7!
  8   FFFF  E000  DO
  9     0D 11 AT.
 10     0D11 I @ = IF I U. THEN
 11     100D I @ = IF I U. THEN
 12   LOOP
 13   1 MMU7! ;
 14 
 15 

Scr# 391 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 392 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 393 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 394 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 395 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 396 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 397 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 398 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 399 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 400 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 401 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 402 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 403 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 404 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 405 
  0 ( .HEX and .BIN utility )
  1 DECIMAL
  2 : .HEX ( n -- ) \ print n in hexadecimal
  3   BASE @        \ save current base
  4   16 BASE !     \ set to hexadecimal
  5   SWAP U.       \ print number
  6   BASE !
  7 ;
  8 : .BIN ( n -- ) \ print n in binary
  9   BASE @        \ save current base
 10   2 BASE !      \ set to binary
 11   SWAP U.       \ print number
 12   BASE !
 13 ;
 14 
 15 

Scr# 406 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 407 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 408 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 409 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 410 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 411 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 412 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 413 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 414 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 415 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 416 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 417 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 418 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 419 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 420 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 421 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 422 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 423 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 424 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 425 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 426 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 427 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 428 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 429 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 430 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 431 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 432 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 433 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 434 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 435 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 436 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 437 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 438 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 439 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 440 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 441 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 442 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 443 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 444 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 445 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 446 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 447 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 448 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 449 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 450 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 451 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 452 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 453 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 454 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 455 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 456 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 457 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 458 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 459 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 460 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 461 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 462 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 463 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 464 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 465 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 466 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 467 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 468 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 469 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 470 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 471 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 472 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 473 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 474 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 475 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 476 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 477 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 478 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 479 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 480 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 481 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 482 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 483 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 484 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 485 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 486 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 487 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 488 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 489 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 490 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 491 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 492 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 493 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 494 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 495 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 496 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 497 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 498 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 499 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 500 
  0 ( Next Registers )
  1 HEX 253B CONSTANT REG-DATA
  2 HEX 243B CONSTANT REG-SELECT
  3 : REG-RD ( p -- v ) REG-SELECT P! REG-DATA P@ ;
  4 : REG-WR ( v p -- ) REG-SELECT P! REG-DATA P! ;
  5 \
  6 : B.  ( n -- ) \ display a number in binary
  7  BASE @ >R  S->D  2DUP HEX <# # # #> TYPE SPACE
  8  2 BASE ! <# 8 0 DO # LOOP #> TYPE  R> BASE ! ;
  9 \
 10 CR ." Machine ID    " 00 REG-RD B.
 11 CR ." Core Version  " 01 REG-RD B.
 12 CR ." Machine type  " 03 REG-RD B.
 13 CR ." CPU Speed     " 07 REG-RD 7 AND DUP .
 14 DECIMAL 35 SWAP LSHIFT S->D <# # CHAR . HOLD #S #>
 15 SPACE TYPE SPACE ." MHz" CR

Scr# 501 
  0 ( Next Registers )
  1 HEX
  2 CR ." Reset         " 02 REG-RD B.
  3 CR ." Peripheal 1   " 05 REG-RD B.
  4 CR ." Peripheal 2   " 06 REG-RD B.
  5 CR ." Peripheal 3   " 08 REG-RD B.
  6 CR ." Peripheal 4   " 09 REG-RD B.
  7 CR ." Core Boot     " 10 REG-RD B.
  8 CR ." Video Timing  " 11 REG-RD B.
  9 CR ." Layer 2 Active RAM Bank " 12 REG-RD B.
 10 CR ." Layer 2 Shadow RAM Bank " 13 REG-RD B.
 11 CR ." Global Transparency Colour " 14 REG-RD B.
 12 CR ." Sprite and Layer System Setup " 15 REG-RD B.
 13 CR ." Layer 2 Horizontal Scroll Control " 16 REG-RD B.
 14 CR ." Layer 2 Vertical Scroll Control   " 17 REG-RD B.
 15 -->

Scr# 502 
  0 ( Next Registers )
  1 HEX
  2 CR ." Layer 2 Clip Window Definition    " 18 REG-RD B.
  3 CR ." Sprites Clip Window Definition    " 19 REG-RD B.
  4 CR ." Layer 0 Clip Window Definition    " 1A REG-RD B.
  5 CR ." Layer 3 Clip Window Definition    " 1B REG-RD B.
  6 CR ." Clip Window Control               " 1C REG-RD B.
  7 CR ." Active Video Line " 1E REG-RD 100 * 1F REG-RD + .
  8 CR ." Line Interrupt Control      " 22 REG-RD .
  9 CR ." Line Interrupt Value        " 23 REG-RD .
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 503 
  0 ( Next Registers )
  1 HEX
  2 CR ." ULA Horizontal Scroll Control " 26 REG-RD .
  3 CR ." ULA Vertical   Scroll Control " 27 REG-RD .
  4 CR ." Stored Palette Value  " 28 REG-RD .
  5 CR ." Layer 3 Horizontal Scroll Control "
  6                           2F REG-RD 100 * 30 REG-RD + .
  7 CR ." Layer 3 Vetical Scroll Control " 31 REG-RD .
  8 CR ." Layer 1,0 Horizontal Scroll Control " 32 REG-RD .
  9 CR ." Layer 1,0 Vertical   Scroll Control " 33 REG-RD .
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 504 
  0 ( Next Registers )
  1 HEX
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 505 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 506 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 507 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 508 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 509 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 510 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 511 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 512 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 513 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 514 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 515 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 516 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 517 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 518 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 519 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 520 
  0 ( LAYER 2 palette picker )
  1 DECIMAL \ 41 LOAD
  2 : BGR ( b g r -- n )
  3   8 * + 4 * + ; \ compose BGR color
  4 0 0 5 BGR constant KRED
  5 0 5 0 BGR constant KGRN
  6 2 0 0 BGR constant KBLU
  7 2 5 5 BGR constant KWHT
  8 0 value RED 0 value GRN 0 value BLU
  9 0 value dy  0 value dx  0 value COL
 10 0 value x   0 value y
 11 -->
 12 
 13 
 14 
 15 

Scr# 521 
  0 ( LAYER 2 palette picker )
  1 decimal
  2 : INK       16 emitc   emitc ;
  3 : PAPER     17 emitc   emitc ;
  4 : CONDENSED 30 emitc 4 emitc ;
  5 : LARGE     30 emitc 8 emitc ;
  6 create ARY 22 22 * allot
  7 : store ( c -- )
  8   x 22 * y + c! ;
  9 : fetch ( -- c )
 10   x 22 * y + c@ ;
 11 -->
 12 
 13 
 14 
 15 

Scr# 522 
  0 ( LAYER 2 palette picker )
  1 create h-bar ,"  --- "   create v-bar ," |    |"
  2 : scr-init
  3   LARGE CLS  7 border. 0 INK KWHT PAPER
  4   22  0 at. ." Use CURSOR KEYS"
  5    3 22 at. KRED INK ." 32 x RED"
  6    4 22 at. KGRN INK ."  4 x GREEN"
  7    5 22 at. KBLU INK ."  1 x BLUE"     0 INK
  8    8 24 at. h-bar count type
  9   13 9 do i 24 at. v-bar count type loop
 10   13 24 at. h-bar count type
 11 ;
 12 -->
 13 
 14 
 15 

Scr# 523 
  0 ( LAYER 2 palette picker )
  1 : set-block ( q -- )
  2   dup 0 = if    red      grn   endif
  3   dup 1 = if 15 red -    grn   endif
  4   dup 2 = if 15 red - 15 grn - endif
  5       3 = if    red   15 grn - endif 3 + to y 3 + to x
  6 ;
  7 : draw-frame
  8   GRN 0= if KRED INK
  9     03 RED + 1 AT. RED .  03 RED + 20 AT. RED .
 10     18 RED - 1 AT. RED .  18 RED - 20 AT. RED . endif
 11   RED 0= if KGRN INK
 12     20 y AT. GRN .  1 y AT. GRN . endif
 13 ; -->
 14 -->
 15 

Scr# 524 
  0 ( LAYER 2 palette picker )
  1 : draw-corner ( q -- )
  2   KBLU INK
  3   dup 0 = if 01 01 endif
  4   dup 1 = if 20 01 endif
  5   dup 2 = if 01 20 endif
  6       3 = if 20 20 endif
  7   AT. BLU .
  8 ;
  9 : draw-block
 10   BLU GRN RED BGR  TO COL  COL store
 11   dup set-block draw-corner
 12   draw-frame
 13 ;
 14 -->
 15 

Scr# 525 
  0 ( LAYER 2 palette picker )
  1 : draw-grid
  2   8 0 do
  3     I TO RED
  4     8 0 do
  5       I TO GRN
  6       0 TO BLU 0 DRAW-BLOCK
  7       1 TO BLU 1 DRAW-BLOCK
  8       2 TO BLU 3 DRAW-BLOCK
  9       3 TO BLU 2 DRAW-BLOCK
 10     LOOP
 11   LOOP
 12 ;
 13 
 14 
 15 

Scr# 526 
  0 ( LAYER 2 palette picker )
  1 : draw-corner ( q -- )
  2   KBLU INK
  3   dup 0 = if 01 01 AT. endif
  4   dup 1 = if 20 01 AT. endif
  5   dup 2 = if 01 20 AT. endif
  6       3 = if 20 20 AT. endif
  7   BLU .
  8 ;
  9 -->
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 527 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 528 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 529 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 530 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 531 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 532 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 533 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 534 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 535 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 536 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 537 
  0 ( VALUE TO )
  1 : VALUE ( x ccc -- )
  2         ( -- n )
  3  [COMPILE] CONSTANT
  4 ; IMMEDIATE
  5 \
  6 : TO ( n -- ccc )
  7  ' >BODY
  8  STATE @ IF
  9   COMPILE LIT
 10   , COMPILE !
 11  ELSE
 12             !
 13  ENDIF
 14 ; IMMEDIATE
 15 

Scr# 538 
  0 \ test
  1 123 VALUE XXX
  2 456 VALUE YYY
  3 789 VALUE ZZZ
  4 XXX    TO ZZZ
  5 : TEST
  6  ZZZ TO YYY
  7 ;
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 539 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 540 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 541 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 542 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 543 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 544 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 545 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 546 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 547 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 548 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 549 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 550 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 551 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 552 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 553 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 554 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 555 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 556 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 557 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 558 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 559 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 560 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 561 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 562 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 563 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 564 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 565 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 566 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 567 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 568 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 569 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 570 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 571 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 572 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 573 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 574 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 575 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 576 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 577 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 578 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 579 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 580 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 581 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 582 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 583 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 584 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 585 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 586 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 587 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 588 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 589 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 590 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 591 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 592 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 593 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 594 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 595 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 596 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 597 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 598 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 599 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 600 
  0 .( Chomp.f )
  1 MARKER TASK
  2 FORTH DEFINITIONS CASEOFF
  3 FLUSH EMPTY-BUFFERS
  4 NEEDS VALUE  NEEDS TO  NEEDS CASE
  5 NEEDS LAYERS
  6 NEEDS SPEED!
  7 NEEDS CHOOSE     \ random numbers
  8 decimal  50 load \ bleep
  9 decimal  41 load \ attributes
 10 decimal 601 load
 11 decimal 610 load
 12 decimal 630 load
 13 decimal 650 load
 14 decimal 660 load
 15 \

Scr# 601 
  0 ( Chomp.f )
  1 CODE sync-vid HEX
  2  76 C,       \ halt
  3  DD C, E9 C, \ jp (ix)
  4  smudge
  5 \
  6 : c+! ( n a )
  7   tuck c@ + swap c! ;
  8 \
  9 : d+! ( n a )
 10   tuck 2@      \ a n d
 11   rot s->d d+  \ a d+n
 12   rot 2! ;
 13 decimal
 14 -->
 15 

Scr# 602 
  0 ( Chomp.f )
  1 : bin ( n -- )
  2   base @ swap 2 base !
  3   8 .r  base ! ;
  4 \ double equals
  5 : D= ( d1 d2 -- f )
  6   rot =      \ l1 l2 h2=h1
  7   swap rot   \ h1=h2 l2 l1
  8   = and ;
  9 \ true if n between a and b
 10 : between ( n a b -- f )
 11   rot tuck < 0= \ a n b>n
 12   swap rot < 0= \ b>n n>a
 13   and ;
 14 -->
 15 

Scr# 603 
  0 ( Chomp.f )
  1 : six-emitc
  2   emitc emitc emitc
  3   emitc emitc emitc ;
  4 \
  5 : sync-emit
  6   sync-vid
  7   emitc emitc emitc emitc
  8   emitc emitc emitc emitc
  9   emitc emitc emitc emitc ;
 10 \
 11 -->
 12 
 13 
 14 
 15 

Scr# 604 
  0 ( Chomp.f )
  1 decimal 23560 constant LASTK
  2  0 variable total 0 ,
  3  0 variable score 0 ,
  4  0 variable high-score 0 ,
  5 30 variable counting
  6  3 variable lives
  7  1 variable hunt
  8 -->
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 605 
  0 ( Chomp.f )
  1 : pill-on
  2   -1 hunt !
  3   10  total d+!
  4   0 counting ! ;
  5 \
  6 : bip ( n1 n2 -- n3 n4 )
  7   beep-pitch
  8   bleep-calc
  9   swap ;
 10 \
 11 : 2lit ( n1 n2 -- )
 12   [compile] literal
 13   [compile] literal
 14 ; immediate -->
 15 

Scr# 606 
  0 ( Chomp.f )
  1   char 8  value    key-right
  2   char 5  value    key-left
  3   char 7  value    key-up
  4   char 6  value    key-down
  5        9  value    key+right
  6        8  value    key+left
  7       11  value    key+up
  8       10  value    key+down
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 607 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 608 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 609 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 610 
  0 .( Chomp.f - UDG )
  1 decimal
  2 : UDG+ ( c1 -- c2 )
  3  upper 79 + ;
  4 \ compile and UDG literal
  5 : [UDG] ( -- )
  6  char UDG+ [compile] literal ;
  7  IMMEDIATE
  8 \ given c return UDG address
  9 : UDG@ ( c -- a )
 10  upper 65 - 8 * 23675 @ + ;
 11 \ given c print binary repres.
 12 : .UDG ( c -- )
 13  cr UDG@ dup 8 + swap do
 14   i c@ bin cr
 15  loop ; -->

Scr# 611 
  0 ( Chomp.f - UDG )
  1 : UDGize ( a -- )
  2  count over + swap do
  3   i c@ upper [char] A [char] U
  4   between if
  5    i c@ upper UDG+ i c!
  6   endif
  7  loop ;
  8 \
  9 : Gtype ( a c -- )
 10  over + swap ?do
 11   i c@ emitc loop ;
 12 : UDGs
 13   [char] V [char] A do
 14    i UDG+ emitc loop ;
 15 -->

Scr# 612 
  0 ( Chomp.f - UDG )
  1 create UDG_1
  2 hex
  3 FF00 , 0000 , 0000 , 0000 , \ A
  4 0000 , 0000 , 0000 , 00FF , \ B
  5 FF00 , 0000 , 0000 , 00FF , \ C
  6 F800 , 0204 , 0202 , 0202 , \ D
  7 1F00 , 4020 , 4040 , 4040 , \ E
  8 3F00 , 8040 , 4080 , 003F , \ F
  9 FC00 , 0102 , 0201 , 00FC , \ G
 10 0202 , 0202 , 0402 , 00F8 , \ H
 11 4040 , 4040 , 2040 , 001F , \ I
 12 0202 , 0202 , 0202 , 0202 , \ J
 13 -->
 14 
 15 

Scr# 613 
  0 ( Chomp.f - UDG )
  1 hex
  2 1800 , 4224 , 4242 , 4242 , \ K
  3 4242 , 4242 , 2442 , 0018 , \ L
  4 4040 , 4040 , 4040 , 4040 , \ M
  5 4242 , 4242 , 4242 , 4242 , \ N
  6 0000 , 7C38 , 7C7C , 0038 , \ O
  7 3E1C , 0F1F , 3E1F , 001C , \ P
  8 2200 , 7F77 , 3E7F , 001C , \ Q
  9 1C00 , 7C3E , 7C78 , 1C3E , \ R
 10 3800 , FE7C , EEFE , 0044 , \ S
 11 7E38 , DB5A , FFFF , 93FF , \ T
 12 0602 , 140A , EE24 , 66EE , \ U
 13 UDG_1 5C7B ! \ UDG
 14 -->
 15 

Scr# 614 
  0 .( Chomp.f - maze )
  1 decimal
  2 21 constant maze-h
  3 21 constant maze-w
  4 create maze-run
  5 24 21 * allot
  6 create maze-base
  7 -->
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 615 
  0 ( Chomp.f - maze )
  1 ," EAAAAAAAAANAAAAAAAAAD "
  2 ," M.........N.........J "
  3 ," M.EAD.EAD.N.EAD.EAD.J "
  4 ," MOM J.M J.N.M J M JOJ "
  5 ," M.IBH.IBH.L.IBH.IBH.J "
  6 ," M...................J "
  7 ," M.FCG.K.FCACG.K.FCG.J "
  8 ," M.....N...N...N.....J "
  9 ," IBBBB.MCG.L.FCJ.BBBBH "
 10 ,"     J.N.......N.M     "
 11 ," BBBBH.L.E---D.L.IBBBB "
 12 -->
 13 
 14 
 15 

Scr# 616 
  0 ( Chomp.f - maze )
  1 ," /.......M   J.......\ "
  2 ," AAAAD.K.I---H.K.EAAAA "
  3 ,"     J.N.... ..N.N     "
  4 ," BBBBH.L.FCACG.L.IBBBB "
  5 ," M.........N.........J "
  6 ," MOFCD.FCG.L.FCG.ECGOJ "
  7 ," M...N...........N...J "
  8 ," AAD.L.FCCCCCCCG.L.EAA "
  9 ,"   J...............M   "
 10 ,"    AAAAAAAAAAAAAAA    "
 11 -->
 12 
 13 
 14 
 15 

Scr# 617 
  0 ( Chomp.f - maze )
  1 decimal
  2 : maze-copy ( a1 a2 -- )
  3  maze-h 0 do
  4   2dup 24 cmove
  5   dup udgize
  6   swap 24 + swap 24 +
  7  loop
  8  2drop ;
  9 \
 10 : set-maze-run
 11   maze-base
 12   maze-run
 13   maze-copy ;
 14 set-maze-run
 15 -->

Scr# 618 
  0 ( Chomp.f - maze )
  1 : maze^ ( x y -- a )
  2  maze-run + swap 1-
  3  24 * + ;
  4 \
  5 : maze@ ( x y -- c )
  6  maze^ c@ ;
  7 \
  8 : maze! ( c x y -- )
  9  maze^ c! ;
 10 \
 11 -->
 12 
 13 
 14 
 15 

Scr# 619 
  0 ( Chomp.f - maze )
  1 : maze.
  2  0 0 at.
  3  1 22 do
  4   025 i 16 +
  5   beep-pitch bleep-calc
  6  -1 +loop
  7  maze-run
  8  22 1 do
  9   cr space
 10   dup count gtype 24 +
 11  >R bleep R>
 12  loop
 13  drop
 14 ;
 15 -->

Scr# 620 
  0 .( Chomp.f - Sprite )
  1 create Array   6 08 * allot
  2 0 variable Sprite^
  3 0 value    Sprite-no
  4 : sprite# ( n -- )
  5   dup 3 lshift array +
  6   sprite^ ! to sprite-no ;
  7 \
  8 : sprite ( -- a )
  9   sprite^ @ ;
 10 \
 11 : all-ghost  ( v i -- )
 12   32 Array  + swap Array  +
 13   do dup i c! 08 +loop
 14   drop ;
 15 -->

Scr# 621 
  0 ( Chomp.f - Sprite )
  1 \ creates an index of Ghost
  2 : index-of ( n -- )
  3   <builds c, does> c@ + ;
  4 \ creates a ghost pointer
  5 : name-of  ( n -- creates )
  6   <builds c, does> c@ dup
  7   3 lshift Array + sprite^ !
  8   to sprite-no ;
  9 -->
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 622 
  0 ( Chomp.f - Sprite )
  1 \ array index by name
  2 0 name-of Inky
  3 1 name-of Pinky
  4 2 name-of Blinky
  5 3 name-of Ted
  6 \
  7 0 index-of face
  8 1 index-of color
  9 2 index-of x-pos
 10 3 index-of y-pos
 11 4 index-of dir
 12 5 index-of x-pre
 13 6 index-of y-pre
 14 7 index-of maze
 15 -->

Scr# 623 
  0 ( chomp.f - Sprite )
  1 \ shorthand for x-pos,y-pos
  2 : xy-pos@  ( -- x y )
  3   sprite
  4   dup    x-pos c@
  5   swap   y-pos c@ ;
  6 : xy-pre@  ( -- x y )
  7   sprite
  8   dup    x-pre c@
  9   swap   y-pre c@ ;
 10 : xy-pre! ( x y -- )
 11   >R sprite x-pre c!
 12   R> sprite y-pre c! ;
 13 \
 14 -->
 15 

Scr# 624 
  0 ( Chomp.f - Sprite )
  1 : Ghost-color ( -- )
  2  Inky   1 sprite color c!
  3  Pinky  3 sprite color c!
  4  Blinky 5 sprite color c!
  5  Ted    2 sprite color c!
  6 ;
  7 : Ghost-white ( -- )
  8  7  0 color  all-ghost
  9 ;
 10 ghost-color
 11 -->
 12 
 13 
 14 
 15 

Scr# 625 
  0 ( Chomp.f - Sprite )
  1 : Ghost-init  ( -- )
  2  12 0 x-pos  all-ghost
  3  11 0 y-pos  all-ghost
  4  55 0 dir    all-ghost
  5  bl 0 maze   all-ghost
  6  Inky   10 sprite y-pos c!
  7  Inky   xy-pos@ xy-pre!
  8  Pinky  12 sprite y-pos c!
  9  Pinky  xy-pos@ xy-pre!
 10  Ted    11 sprite x-pos c!
 11  Ted    xy-pos@ xy-pre!
 12  Blinky xy-pos@ xy-pre!
 13  [char] T udg+
 14  0 face all-ghost
 15 ; -->

Scr# 626 
  0 ( Chomp.f - Sprite )
  1 4 name-of Pacman
  2 : pacman-init
  3   Pacman [char] R UDG+
  4      sprite face  c!
  5   14 sprite x-pos c!
  6   12 sprite y-pos c!
  7   14 sprite x-pre c!
  8   12 sprite y-pre c!
  9    6 sprite color c!
 10   56 sprite dir   c!
 11   bl sprite maze  c!
 12 ;
 13 ghost-init
 14 pacman-init
 15 -->

Scr# 627 
  0 ( Chomp.f - Sprite )
  1 5 name-of Cherry
  2 : cherry-init
  3   Cherry [char] U UDG+
  4      sprite face  c!
  5   14 sprite x-pos c!
  6   12 sprite y-pos c!
  7   14 sprite x-pre c!
  8   12 sprite y-pre c!
  9    2 sprite color c!
 10   00 sprite dir   c!
 11   bl sprite maze  c!
 12 ;
 13 cherry-init -->
 14 
 15 

Scr# 628 
  0 ( Chomp.f - Sprite )
  1 \ draw current sprite
  2 : sprite-put ( -- )
  3   sprite face  c@
  4   sprite color c@   16
  5   xy-pos@ swap      22
  6   sprite maze  c@
  7   xy-pre@ swap      22
  8   4 16
  9   sync-emit
 10 ;
 11 \ usage:
 12 \ Blinky  sprite-put
 13 -->
 14 
 15 

Scr# 629 
  0 ( Chomp.f )
  1 : init-all
  2   ghost-init
  3   pacman-init
  4   cherry-init
  5   00 counting !
  6   key-right LASTK c!
  7 ;
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 630 
  0 .( Chomp.f - trail )
  1 : ?pac-trail  ( c -- )
  2  case
  3   bl       of 1 endof
  4   [char] . of 1 endof
  5   [udg]  U of 1 endof
  6   [udg]  O of 1 endof
  7   [char] / of 1 endof
  8   [char] \ of 1 endof
  9   0 swap
 10  endcase ;
 11 -->
 12 
 13 
 14 
 15 

Scr# 631 
  0 ( Chomp.f - trail )
  1 : ?ghost-trail  ( c -- )
  2  case
  3   bl       of 1 endof
  4   [char] . of 1 endof
  5   [udg]  U of 1 endof
  6   [udg]  O of 1 endof
  7   [char] - of 1 endof
  8   0 swap
  9  endcase ;
 10 -->
 11 
 12 
 13 
 14 
 15 

Scr# 632 
  0 ( Chomp.f - trail )
  1 : go-right
  2   Pacman
  3   xy-pos@      1+      maze@
  4   dup [char] \ = if
  5    1 sprite y-pos c!
  6   endif
  7   ?pac-trail if
  8    [char] R UDG+
  9    sprite face  c!
 10    1  sprite y-pos c+!
 11 \ else 2 choose if key-up
 12 \  else key-down then
 13 \  sprite dir c!
 14   endif ;
 15 -->

Scr# 633 
  0 ( Chomp.f - trail )
  1 : go-left
  2   Pacman
  3   xy-pos@      1-      maze@
  4   dup [char] / = if
  5    21 sprite y-pos c!
  6   endif
  7   ?pac-trail if
  8    [char] P UDG+
  9     sprite face  c!
 10    -1 sprite y-pos c+!
 11 \ else 2 choose if key-up
 12 \  else key-down then
 13 \  sprite dir c!
 14   endif ;
 15 -->

Scr# 634 
  0 ( Chomp.f - trail )
  1 : go-up
  2   Pacman
  3   xy-pos@ swap 1- swap maze@
  4   ?pac-trail if
  5    [char] Q UDG+
  6    sprite face  c!
  7    -1 sprite x-pos c+!
  8 \ else 2 choose if
  9 \  key-right else key-left then
 10 \  sprite dir c!
 11   endif ;
 12 -->
 13 
 14 
 15 

Scr# 635 
  0 ( Chomp.f - trail )
  1 : go-down
  2   Pacman
  3   xy-pos@ swap 1+ swap maze@
  4   ?pac-trail if
  5    [char] S UDG+
  6    sprite face  c!
  7    1  sprite x-pos c+!
  8 \ else 2 choose if
  9 \  key-left else key-right then
 10 \  sprite dir c!
 11   endif ;
 12 -->
 13 
 14 
 15 

Scr# 636 
  0 ( Chomp.f - trail )
  1 : pacman-move ( c -- )
  2  case
  3  key-right of go-right endof
  4  key-left  of go-left  endof
  5  key-up    of go-up    endof
  6  key-down  of go-down  endof
  7  endcase ;
  8 \
  9 : pacman-eat-dot ( c -- )
 10   [char] . = if
 11    1  score d+!
 12 \  [ 12 -12 bip ] 2lit
 13 \  bleep
 14   endif ;
 15 -->

Scr# 637 
  0 ( Chomp.f - trail )
  1 : pacman-eat-pill ( c -- )
  2   [udg] O = if
  3    -1 hunt !
  4    10 score d+!
  5    10 total d+!
  6    [ 50 25 bip ] 2lit bleep
  7    [ 50 39 bip ] 2lit bleep
  8    0 counting !
  9    ghost-white
 10   endif ;
 11 \
 12 -->
 13 
 14 
 15 

Scr# 638 
  0 ( Chomp.f - trail )
  1 : pacman-walk ( c -- )
  2   >r r  [udg]  O =
  3      r  [char] . = or
  4      r> [udg]  U = or
  5   0= if
  6    pacman
  7    xy-pos@ xy-pre@ d=
  8    0= if
  9 \   [ 12 -14 bip ] 2lit
 10 \   bleep
 11    endif
 12   endif
 13 ;
 14 -->
 15 

Scr# 639 
  0 ( Chomp.f - trail )
  1 : pacman-eat-cherry ( c -- )
  2   [udg] U = if
  3    10 score d+!
  4    10 total d+!
  5    [ 50 29 bip ] 2lit bleep
  6    [ 50 36 bip ] 2lit bleep
  7   endif ; -->
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 640 
  0 ( Chomp.f - ghost )
  1 : ghost-right ( c -- )
  2   xy-pos@ 1+ maze@
  3   ?ghost-trail if
  4      1  sprite y-pos c+!
  5   else
  6    2 choose if
  7     key-down
  8    else
  9     key-up
 10    endif
 11    sprite dir c!
 12   endif
 13 ;
 14 -->
 15 

Scr# 641 
  0 ( Chomp.f - ghost )
  1 : ghost-left  ( c -- )
  2   xy-pos@ 1- maze@
  3   ?ghost-trail if
  4     -1  sprite y-pos c+!
  5   else
  6    2 choose if
  7     key-up
  8    else
  9     key-down
 10    endif
 11    sprite dir c!
 12   endif
 13 ;
 14 -->
 15 

Scr# 642 
  0 ( Chomp.f - ghost )
  1 : ghost-down  ( c -- )
  2   xy-pos@ swap 1+ swap maze@
  3   ?ghost-trail if
  4      1  sprite x-pos c+!
  5   else
  6    2 choose if
  7     key-right
  8    else
  9     key-left
 10    endif
 11    sprite dir c!
 12   endif
 13 ;
 14 -->
 15 

Scr# 643 
  0 ( Chomp.f - ghost )
  1 : ghost-up    ( c -- )
  2   xy-pos@ swap 1- swap maze@
  3   ?ghost-trail if
  4     -1  sprite x-pos c+!
  5   else
  6    2 choose if
  7     key-left
  8    else
  9     key-right
 10    endif
 11    sprite dir c!
 12   endif
 13 ;
 14 -->
 15 

Scr# 644 
  0 ( Chomp.f - ghost )
  1 : ghost-move ( c -- )
  2  case
  3   key-right of
  4    ghost-right endof
  5   key-left  of
  6    ghost-left  endof
  7   key-up    of
  8    ghost-up    endof
  9   key-down  of
 10    ghost-down  endof
 11  endcase ;
 12 \
 13 -->
 14 
 15 

Scr# 645 
  0 ( Chomp.f - ghost )
  1 : ghost-decision ( -- )
  2   xy-pos@ xy-pre@ d= if
  3    4 choose
  4    case
  5    0 of key-left  endof
  6    1 of key-down  endof
  7    2 of key-up    endof
  8    3 of key-right endof
  9    endcase
 10   endif
 11   sprite dir c!
 12 ;
 13 
 14 
 15 

Scr# 646 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 647 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 648 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 649 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 650 
  0 ( Chomp.f )
  1 : init-display
  2  0 paper. 0 border. 4 ink.
  3  cls maze.
  4  0 20 at. ." high "
  5  high-score 2@
  6  <# # # # # # # #> type
  7  5 0 do
  8   i  sprite#
  9   sprite-put
 10  loop
 11 ;
 12 -->
 13 
 14 
 15 

Scr# 651 
  0 ( Chomp.f )
  1 : inter-hunt
  2   0 27 do
  3    10 i at. sync-vid
  4    7 16 bl emit emitc emitc
  5    [udg] T emitc sync-vid
  6    bl bl emitc emitc
  7    6 16 emitc emitc
  8    [udg] P emitc
  9    bl emit sync-vid
 10    bleep
 11    ?terminal if quit then
 12   -1 +loop ;
 13  -->
 14 
 15 

Scr# 652 
  0 ( Chomp.f )
  1 : inter-flee
  2   28 1 do
  3    10 i at. sync-vid
  4    3 16 bl emit emitc emitc
  5    [udg] T emitc sync-vid
  6    bl bl emitc emitc
  7    6 16 emitc emitc
  8    [udg] R emitc
  9    sync-vid
 10    bleep
 11    ?terminal if quit then
 12   1 +loop ;
 13  -->
 14 
 15 

Scr# 653 
  0 ( Chomp.f - Interlude )
  1 : inter-sound
  2   27 0 do
  3    012 i bip swap
  4   01 +loop
  5   1 28 do
  6    012 i bip swap
  7   -1 +loop ;
  8 \
  9 : interlude
 10   inter-sound cls
 11   10 30 at.
 12   [udg]  O  emitc
 13   inter-flee
 14   inter-hunt ;
 15 -->

Scr# 654 
  0 ( Chomp.f )
  1 : catch? ( -- f )
  2   pacman xy-pos@
  3   inky   xy-pos@ d=
  4   pacman xy-pos@
  5   pinky  xy-pos@ d=
  6   pacman xy-pos@
  7   blinky xy-pos@ d=
  8   pacman xy-pos@
  9   ted    xy-pos@ d=
 10   or or or ;
 11 -->
 12 
 13 
 14 
 15 

Scr# 655 
  0 ( Chomp.f )
  1 : ghost-eaten ( n -- )
  2   sprite#
  3   12 sprite x-pos c!
  4   12 sprite y-pos c!
  5   bl sprite maze  c!
  6   10 score d+!
  7   10 total d+!
  8   [  5 20 bip ] 2lit bleep
  9   [  5 10 bip ] 2lit bleep
 10   [ 10 10 bip ] 2lit bleep
 11 ;
 12 -->
 13 
 14 
 15 

Scr# 656 
  0 ( Chomp.f )
  1 : ghost-catch
  2   -1 lives +!
  3   lives @ 0= if
  4    high-score 2@ score 2@
  5    dminus d+ 0< if
  6      score 2@ high-score 2!
  7    endif
  8    0. score 2!
  9    179. total 2!
 10   endif
 11   init-all
 12   interlude
 13   init-display ;
 14 -->
 15 

Scr# 657 
  0 ( Chomp.f )
  1 : catch!
  2   hunt @ 1 = if
  3    ghost-catch
  4   else
  5    4 0 do
  6     i sprite# xy-pos@
  7     pacman    xy-pos@ d= if
  8      i ghost-eaten
  9     endif
 10    loop
 11   endif ;
 12 -->
 13 
 14 
 15 

Scr# 658 
  0 ( Chomp.f )
  1 : count-down
  2   hunt @ -1 = if 1 counting +!
  3    56 counting @ < if
  4     ghost-color endif
  5    57 counting @ < if
  6     ghost-white endif
  7    58 counting @ < if
  8     ghost-color endif
  9    59 counting @ < if
 10     ghost-white endif
 11    60 counting @ < if
 12     ghost-color
 13     1 hunt ! endif
 14   endif
 15 ; -->

Scr# 659 
  0 ( Chomp.f )
  1 : put-cherry
  2   100 choose 0= if
  3    cherry sprite-put
  4    [udg] U xy-pos@ maze!
  5   endif ;
  6 \
  7 : key-decode ( c1 -- c2 )
  8   case
  9   key+up of key-up endof
 10   key+down of key-down endof
 11   key+left of key-left endof
 12   key+right of key-right endof
 13   dup
 14   endcase ;
 15 

Scr# 660 
  0 ( Chomp.f )
  1 : move-pacman
  2   pacman xy-pos@ xy-pre!
  3   LASTK key-decode c@
  4 \ sprite dir c@
  5   pacman-move sprite-put
  6   xy-pos@ maze@
  7   bl xy-pos@ maze!
  8   catch? if catch! then
  9   dup pacman-eat-dot
 10   dup pacman-eat-pill
 11   dup pacman-eat-cherry
 12       pacman-walk
 13 ;
 14 -->
 15 

Scr# 661 
  0 ( Chomp.f )
  1 : move-four-ghosts
  2   4 0 do
  3    i sprite# xy-pos@ xy-pre!
  4 \  ghost-decision
  5    sprite dir c@ ghost-move
  6 \  LASTK c@      ghost-move
  7    sprite-put
  8    xy-pos@ maze@
  9    sprite maze c!
 10    catch? if catch! then
 11   loop
 12 ; -->
 13 
 14 
 15 

Scr# 662 
  0 ( Chomp.f )
  1 : dashboard
  2   0  1 at.
  3   6 16 emitc emitc \ yellow
  4   [udg] P emitc
  5   7 16 emitc emitc \ white
  6   bl emitc lives ?
  7   0  6 at. ." score "
  8   score 2@
  9   <# # # # # # # #> type
 10 ;
 11 -->
 12 
 13 
 14 
 15 

Scr# 663 
  0 ( Chomp.f )
  1 needs .s
  2 : debug
  3   2 24 at. 6 16 emitc emitc
  4   pacman xy-pos@ swap . .
  5   3 24 at. LASTK c@ .
  6 \ 22 1 at. hex sprite 8 +
  7 \ sprite (dump) decimal
  8   5 24 at. total 2@ D.
  9   7 24 at. counting @ .
 10   9 24 at.
 11   sprite maze c@ emitc
 12   0 0 at. .s
 13   11 24 at. hunt @ .
 14 \ 22 22 at. ." KEY" key drop
 15 ; -->

Scr# 664 
  0 ( Chomp.f )
  1 : heart-beat
  2   move-pacman
  3   move-four-ghosts
  4   put-cherry
  5   count-down
  6   dashboard
  7 \ debug
  8 ;
  9 : T heart-beat ;
 10 : C catch? . ;
 11 : M init-display ;
 12 -->
 13 
 14 
 15 

Scr# 665 
  0 ( Chomp.f )
  1 : phase-complete
  2   score 2@ total 2@ d= if
  3    179  total D+!
  4    init-all
  5    set-maze-run
  6    interlude
  7    init-display
  8    key-right LASTK c!
  9   endif ;
 10 -->
 11 
 12 
 13 
 14 
 15 

Scr# 666 
  0 ( Chomp.f )
  1 : run-game
  2   begin
  3    lives @
  4   while
  5    heart-beat
  6    phase-complete
  7    ?terminal if quit then
  8   repeat
  9 ;
 10 -->
 11 
 12 
 13 
 14 
 15 

Scr# 667 
  0 ( Ghost.f )
  1 : game
  2   LAYER11 1 SPEED! 30 emitc 8 emitc
  3   3 lives !
  4   0 paper. 0 border. 4 ink.
  5   1 bright. perm
  6   interlude
  7   179. total 2!
  8   0.   score 2!
  9   init-all
 10   set-maze-run
 11   init-display
 12   run-game
 13   22 0 at.
 14   LAYER12 3 SPEED!
 15 ; -->

Scr# 668 
  0 ( Ghost.f )
  1 CR CR
  2 .( Use GAME to start game. ) CR
  3 .( Arrorw keys to move. ) CR
  4 .( Cursor Joystick should work. ) CR
  5 .( BREAK stops: give LAYER12 to pass to 64 columns. ) CR
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 669 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 670 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 671 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 672 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 673 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 674 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 675 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 676 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 677 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 678 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 679 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 680 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 681 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 682 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 683 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 684 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 685 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 686 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 687 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 688 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 689 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 690 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 691 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 692 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 693 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 694 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 695 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 696 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 697 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 698 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 699 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 700 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 701 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 702 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 703 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 704 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 705 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 706 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 707 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 708 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 709 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 710 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 711 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 712 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 713 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 714 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 715 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 716 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 717 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 718 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 719 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 720 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 721 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 722 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 723 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 724 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 725 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 726 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 727 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 728 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 729 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 730 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 731 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 732 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 733 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 734 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 735 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 736 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 737 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 738 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 739 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 740 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 741 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 742 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 743 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 744 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 745 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 746 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 747 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 748 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 749 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 750 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 751 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 752 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 753 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 754 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 755 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 756 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 757 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 758 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 759 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 

Scr# 760 
  0 
  1 
  2 
  3 
  4 
  5 
  6 
  7 
  8 
  9 
 10 
 11 
 12 
 13 
 14 
 15 
