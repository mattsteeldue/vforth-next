ect\Projects\vForth15_DIRECT/source/main.asm
//  ______________________________________________________________________
//
//  main.asm
//  ______________________________________________________________________
//
//  v-Forth 1.52 NextZXOS version
//  build 20230108
//
//  Direct-Thread version.
//
//  NextZXOS version
//  ______________________________________________________________________
//
//  This work is available as-is with no whatsoever warranty.
//  Copying, modifying and distributing this software is allowed
//  provided that the copyright notice is kept.
//  ______________________________________________________________________
//
//  by Matteo Vitturi, 1990-2023
//
//  https://sites.google.com/view/vforth/vforth15-next
//  https://www.oocities.org/matteo_vitturi/english/index.htm
//
//  This is the complete compiler for v.Forth for SINCLAIR ZX Spectrum Next.
//  Each line of this source list mustn't exceed 80 bytes.
//  Z80N (ZX Spectrum Next) extension is available.
//
//  This list has been tested using the following configuration:
//      - CSpect emulator V.2.12.30
//  ______________________________________________________________________
//
//  Z80 Registers usage map
//
//  AF
//  BC - Instruction Pointer: should be preserved during ROM/OS calls
//  DE - Working
//  HL - Working
//
//  AF'- Sometime used for backup purpose
//  BC'- Not used
//  DE'- Not used
//  HL'- Not used: (saved at startup)
//
//  SP - Calculator Stack Pointer
//  IX - Inner interpreter "next" address pointer. This way jp (ix) is 2T-state faster than JP next
//  IY - (ZX System: must be preserved to interact with standard ROM)
//
//  ______________________________________________________________________
//
//  _________________
//
//  FORTH DEFINITIONS
//  _________________

                OPT     --zxnext
//  ______________________________________________________________________
//
// this controls some debugging code in L0.asm
//  0 for final binary release.
//  1 for debugging with Visual Studio Code and DeZog
// -1 for for binary comparison with Forth generated code.
DEBUGGING       equ     -1
//
//  ______________________________________________________________________

                if ( -1 == DEBUGGING )
ORIGIN          equ     $62E6                   // for binary comparison
//ORIGIN          equ     $8CC1                   // for binary comparison
                endif
//  ______________________________________________________________________

                if (  0 == DEBUGGING )
ORIGIN          equ     $6366                   // binary and Tape
                endif
//  ______________________________________________________________________

                if (  1 == DEBUGGING )
ORIGIN          equ     $8080                   // for DeZog
                endif
//  ______________________________________________________________________

                DEVICE  ZXSPECTRUMNEXT

                ORG     ORIGIN

                if ( -1 == DEBUGGING )
                ds 128                            // for binary comparison
                endif

//  ______________________________________________________________________
//
//  Naming convention for Label vs Forth correspondance
//  Forth words are named as they are named for real with some exception to avoid assembler syntax errors.
//    - Leading "0" is converted into "Z_"
//    - Leading "(" is converted into "C_", closing bracket is omitted
//    - Leading numbers are converted in letters: ONE_  TWO_ etc.
//    - Question mark "?" is converted into "Q" or omitted if needed / useful.
//    - Plus sign "+" is converted in _PLUS or ADD_ depending.
//    - Minus sign "-" in L (for Line), MINUS or SUBTRACT depending
//    - Greater-Than sign ">" in _GREATER or TO_ depending
//    - Equal sign "=" is converted in EQUAL
//    - Less-Than sign "<" in _LESS or FROM_ (or TO_ again) depending
//    - Asterisk sign "*" is converted in _MUL or STAR
//    - Slash "/" is converted in _DIV or omitted if it is clear what it means
//    - Exclamation mark "!" is converted in STORE
//    - At-Sign "@" is converted in FETCH
//    - Words that collide with Assembler are normally suffixed with "_OP"

                include "system.asm"
ect\Projects\vForth15_DIRECT/source/system.asm
//  ______________________________________________________________________
//
//  system.asm
//  ______________________________________________________________________

// Registers:
//
//      BC: Instruction Pointer
//      DE:
//      HL: W register
//      SP: Calc stack Pointer
//      IX: Inner-Interpreter Address

//  ______________________________________________________________________
//
// ZX-Spectrum standard system variables
SCR_CT          equ     $5C8C                   // SCR-CT system variable
LASTK           equ     $5C08                   // LASTK system variable
BORDCR          equ     $5C48                   // BORDCR system variable
FLAGS2          equ     $5C6A                   // for caps-lock

//  ______________________________________________________________________
//
// Flag constants
TRUE_FLAG       equ     $FFFF
FALSE_FLAG      equ     $0000

//  ______________________________________________________________________
//
// Ascii char constants
NUL_CHAR        equ     $00
COMMA_CHAR      equ     $06
BACKSPACE_CHAR  equ     $08
CR_CHAR         equ     $0D
BLANK_CHAR      equ     $20
QUOTE_CHAR      equ     "'"
DQUOTE_CHAR     equ     '"'
UNDERSCORE_CHAR equ     $5F
SOLIDBLOCK_CHAR equ     $8F
HALFBLOCK_CHAR  equ     $8C
LC_A_CHAR       equ     $61                 // lower-case "a"
LC_Z_CHAR       equ     $7A                 // lower-case "z"


//  ______________________________________________________________________
//

                // emulate something like:  ld hl,rp
ldhlrp          macro
                ld      hl,(RP_Pointer)
                endm

                // emulate something like:  ld rp,hl
ldrphl          macro
                ld      (RP_Pointer),hl
                endm

//  ______________________________________________________________________
//
//  Inner interpreter next-address pointer. This is 2T-state faster than "jp address"
next            macro
                jp      (ix)
                endm

psh1            macro
                push    hl
                jp      (ix)
                endm

psh2            macro
                push    de
                push    hl
                jp      (ix)
                endm

//  ______________________________________________________________________
//
// Bit constants in length-byte

SMUDGE_BIT      equ     %00100000               // $20
IMMEDIATE_BIT   equ     %01000000               // $40
END_BIT         equ     %10000000               // $80


//  ______________________________________________________________________
//
//  To create Forth words using this (nice) Assembler, we have to use the two following
//  pointers
temp_NFA        defl    0
last_NFA        defl    0
len_NFA         defl    0

is_code         equ     0                   // so the direct machine-code starts at CFA
is_normal       equ     0                   // so the direct machine-code starts at CFA
is_immediate    equ     IMMEDIATE_BIT       // $40 - the definition is IMMEDIATE.

//  ______________________________________________________________________
//
//  Create a new "low-level" definition
//  This macro is used in the form  Create FORTH_NAME,n,"forth_name"
//  to create a new Forth Dictionary entry the same way Forth itself would do.
//  A word begins with a Length-Byte in range 1-31. Top 3 msb are used as flags
//  see SMUDGE_BIT and IMMEDIATE_BIT constant above.
//  It is followed by the Name of the word, i.e. a string expressed in 7-bit Ascii.
//  The last character of the Name must have the msb set to signal the end of it (END_BIT)
//  This macro acts much like the standard Forth definition CREATE

New_Def         macro   label, namec, runcode, bits
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      namec
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | bits  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      namec               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
label:          if runcode != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                endm

//  ______________________________________________________________________
//
// Create a "constant"
// The constant value is compiled in first PFA cell
Constant_Def    macro   label, namec, constant_value
                New_Def  label, namec, Constant_Ptr, is_normal
                dw      constant_value
                endm

//  ______________________________________________________________________
//
// Create a "variable"
// The when invoked, a variable returns a pointer, the address of first PFA cell
// this allow creation of "variables" which content is  of any length
Variable_Def    macro   label, namec, initial_value
                New_Def  label, namec, Variable_Ptr, is_normal
                dw      initial_value
                endm

//  ______________________________________________________________________
//
// Create a "user"
// It uses a single byte as offset to calculate the address of the variable
User_Def        macro   label, namec, offset_value
                New_Def  label, namec, User_Ptr, is_normal
                db      offset_value
                endm

//  ______________________________________________________________________
//
// Create a "colon-definition"
// The CFA contains a small routine i.e. "call Enter_Ptr".
// The PFA, three bytes later, contains the actual Forth definition
Colon_Def       macro   label, namec, bits
                New_Def  label, namec, Enter_Ptr, bits ; ok
                endm

//  ______________________________________________________________________
//

S0_system:      equ     $D0E8               // Address of top of Calc Stack
TIB_system      equ     $D0E8               // TIB grows upwards, Return-Stack downward.
R0_system:      equ     $D188               // Address of top of Return Stack. This is S0 + $00A0
USER_system:    equ     $D188               // User variables zone.
FIRST_system:   equ     $D1E4               // Address of first BUFFER
LIMIT_system:   equ     $E000               // Address of first byte beyond last BUFFER

ect\Projects\vForth15_DIRECT/source/system.asm
                include "L0.asm"
ect\Projects\vForth15_DIRECT/source/L0.asm
//  ______________________________________________________________________
//
//  L0.asm
//
//  Origin-Area and Level-0 definitions
//  ______________________________________________________________________


Cold_origin:
                and     a
                jp      ColdRoutine
Warm_origin:
                scf
                jp      WarmRoutine

// +008
SP_Basic:       dw      $D0E6               // These are bits with some "standard" meaning... 0101

// +00A
                dw      $0E00

// +00C
Latest_origin:  dw      Latest_Definition   // Latest word (used in Cold_Start)

// +00E
DEL_Char_Ptr:   dw      $000C               // This is the characther used as "Back-Space"

// +010
CPU_Id          dw      $B250               // Z80 expressed in base 36

// +012
S0_origin:      dw      S0_system
R0_origin:      dw      R0_system
TIB_origin:     dw      TIB_system
WIDTH_origin:   dw      31
WARNING_origin: dw      1
FENCE_origin:   dw      Fence_Word
DP_origin       dw      Fence_Word
VOCLINK_origin: dw      Voclink_Ptr
                dw      FIRST_system
                dw      LIMIT_system

// +026
Block_Face:     db      SOLIDBLOCK_CHAR     // Caps-Lock   Cursor face
Half_Face:      db      HALFBLOCK_CHAR      // Caps-unlock Cursor face
Underscore_Face:db      UNDERSCORE_CHAR     // Underscore  Cursor face
                db      0

// +02A
IX_Echo:        dw      $0000               // Echo IX after NextOS call

// +02C
SP_Saved:       dw      $0000               // Saved SP dufing NextOS call

// +02E
USER_Pointer:   dw      USER_system

// +030
RP_Pointer:     dw      $d188 // R0_system

// +32
// SP_Basic        dw      0


//  ______________________________________________________________________

// from this point we can use LDHLRP and LDRPHL Assembler macros
// instead of their equivalent long sequences.

//  ______________________________________________________________________

// address for "next" - inner interpreter
// This address must always be pointed by IX
// "next" macro simply does a  jp(ix)  instruction

// Psh2_Ptr:       push    de
// Psh1_Ptr:       push    hl

Next_Ptr:       // This address must always be kept in IX: "next" relies on that

                if ( 1 == DEBUGGING )
                ld      hl, Next_Breakpoint_1
                and     a
                sbc     hl, bc
                jr      nz, Next_Continue
                nop // This is where you have to put a real breakpoint to intercept BC values...
                endif

Next_Continue:
                ld      a, (bc)
                inc     bc
                ld      l, a
                ld      a, (bc)
                inc     bc
                ld      h, a                // hl contains a CFA (xt) of word being executed

// Execute xt i.e. CFA held in HL
Exec_Ptr:




                jp      (hl)                // and jump to it
                                            // there you'll find the real code or a CALL to a ;code part

//  ______________________________________________________________________
//
// lit          -- x
// puts on top of stack the value of the following word.
// it is compiled in colon definition before a literal number

                New_Def  LIT, "LIT", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "LIT"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "LIT"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
LIT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

                ld      a, (bc)
                inc     bc
                ld      l, a
                ld      a, (bc)
                inc     bc
                ld      h, a
                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// execute      i*x xt -- j*x
// execution token. usually xt is given by CFA

                New_Def  EXECUTE, "EXECUTE", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "EXECUTE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "EXECUTE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
EXECUTE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                ret
//              pop     hl
//              jp      (hl)
//              jr      Exec_Ptr


//  ______________________________________________________________________
//
// (+loop)       --
// compiled by +LOOP. it uses the top two values of return-stack to
// keep track of index and limit, they are accessed via I and I'
                New_Def C_PLOOP, "(+LOOP)", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "(+LOOP)"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "(+LOOP)"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
C_PLOOP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

Loop_Ptr:
                exx
                ldhlrp                      // ld hl,rp macro 30h +Origin
                ld      hl,(RP_Pointer)

                pop     bc                  // bc is increment

                ld      e, (hl)             // hl points to loop-index, add increment to it.
                ld      a, e                // de keeps index before increment.
                add     c
                ld      (hl), a
                inc     hl
                ld      d, (hl)
                ld      a, d
                adc     b
                ld      (hl),a
                inc     hl

                ld      a, e
                sub     (hl)
                ld      e, a
                inc     hl
                ld      a, d
                sbc     (hl)
                ld      d, a                // DE is index - limit : limit is the "new zero"

                ex      de, hl
                add     hl, bc
                bit     7, b                // keep increment-sign just before overwriting d
                jr      z, Loop_NegativeIncrement
                    ccf
Loop_NegativeIncrement:

                jr      c, Loop_Endif
                    exx
                    jr      Branch_Ptr      // perform branch consuming following cell
Loop_Endif:
                ex      de, hl
                inc     hl
                ldrphl                      // ld rp,hl macro 30h +Origin
                ld      (RP_Pointer),hl
                exx
                inc     bc                  // skip branch-style offset
                inc     bc
                next
                jp      (ix)

//  ______________________________________________________________________
//
// (loop)       n --
// same as (LOOP) but index is incremented by 1
// compiled by LOOP.
                New_Def C_LOOP, "(LOOP)", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "(LOOP)"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "(LOOP)"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
C_LOOP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                push    1
                jr      Loop_Ptr

//  ______________________________________________________________________
//
// branch       --
// unconditional branch in colon definition using the following cell as an offset from current IP value
// compiled by ELSE, AGAIN and some other immediate words

                New_Def BRANCH, "BRANCH", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "BRANCH"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "BRANCH"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
BRANCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
Branch_Ptr:
                ld      h, b
                ld      l, c
                ld      e, (hl)
                inc     hl
                ld      d, (hl)
                dec     hl                  // offset is calculated from current IP
                add     hl, de
                ld      c, l
                ld      b, h
                next
                jp      (ix)


//  ______________________________________________________________________
//
// 0branch      f --
// conditional branch if the top-of-stack is ZERO or FALSE.
// compiled by IF, UNTIL and some other immediate words

                New_Def ZBRANCH, "0BRANCH", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "0BRANCH"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "0BRANCH"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
ZBRANCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
ZBranch_Ptr:
                pop     hl
                ld      a, l
                or      h
                jr      z, Branch_Ptr
                inc     bc                  // if not branch, skip offset cell.
                inc     bc
                next
                jp      (ix)

//  ______________________________________________________________________
//
// (leave)        --
// compiled by LEAVE
// this forces to exit from loop and jump past
                New_Def C_LEAVE, "(LEAVE)", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "(LEAVE)"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "(LEAVE)"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
C_LEAVE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

                ldhlrp
                ld      hl,(RP_Pointer)
                ld      a, 4
                add     hl, a
                ldrphl
                ld      (RP_Pointer),hl

                jr      Branch_Ptr       // perform branch consuming following cell
                next
                jp      (ix)

//  ______________________________________________________________________
//
// (?do)        lim ind --
// compiled by ?DO to make a loop checking for lim == ind first
// at run-time (?DO) must be followed by a BRANCH offset
// used to skip the loop if lim == ind
                New_Def C_Q_DO, "(?DO)", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "(?DO)"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "(?DO)"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
C_Q_DO:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     de                  // de has the index
                pop     hl                  // hl has the limit
                push    hl
                push    de
                and     a                   // reset carry flag
                sbc     hl, de              // compute limit - index
                jr      nz, Do_Ptr          // if zero then don't even begin loop
                    pop     de
                    pop     hl

                    jr      Branch_Ptr          // perform branch consuming following cell
Do_Ptr:
                ldhlrp                      // prepare RP
                ld      hl,(RP_Pointer)
                dec     hl
                dec     hl
                dec     hl
                dec     hl
                ldrphl
                ld      (RP_Pointer),hl

                // store index as top RP
                pop     de
                ld      (hl), e
                inc     hl
                ld      (hl), d
                inc     hl
                // stores lim as second from top RP
                pop     de
                ld      (hl), e
                inc     hl
                ld      (hl), d

                // skip branch-style offseet
                inc     bc
                inc     bc
                next
                jp      (ix)

//  ______________________________________________________________________
//
// (do)        lim ind --
// compiled by DO to make a loop checking for lim == ind first
// this is a simpler version of (?DO)
                New_Def C_DO, "(DO)", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "(DO)"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "(DO)"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
C_DO:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dec     bc                  // prepare IP beforehand
                dec     bc                  // to balance the two final inc bc in (?do)
                jr      Do_Ptr

//  ______________________________________________________________________
//
// i            -- n
// used between DO and LOOP or between DO e +LOOP to copy on top of stack
// the current value of the index-loop
                New_Def I, "I", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "I"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "I"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
I:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
I_Ptr:

                ldhlrp
                ld      hl,(RP_Pointer)
I_Ptr_prime
                ld      e, (hl)
                inc     hl
                ld      d, (hl)
                push    de
                next
                jp      (ix)


//  ______________________________________________________________________
//
// i'            -- n
// used between DO and LOOP or between DO e +LOOP to copy on top of stack
// the limit of the index-loop

                New_Def II, "I'", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "I'"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "I'"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
II:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                ldhlrp
                ld      hl,(RP_Pointer)
                inc     hl
                inc     hl
                jr      I_Ptr_prime


//  ______________________________________________________________________
//
// digit        c n -- u 1  |  0
// convert a character c using base n
// returns a unsigned number and a true flag
// or just a false flag if the conversion fails
                New_Def DIGIT, "DIGIT", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "DIGIT"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "DIGIT"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DIGIT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl                  // l has the base
                pop     de                  // e has the digit
                ld      a, e
                cp      $60                 // check if lowercase
                jr      c, Digit_Uppercase
                    sub     $20                 // quick'n'dirty uppercase
Digit_Uppercase:
                sub     $30
                jr      c, Digit_Fail       // fail when character < "0"
                    cp      $0A
                    jr      c, Digit_Decimal    // perhaps is not decimal
                        sub     7                   // try hex and subtract 7
                        cp      $0A
                        jr      c,  Digit_Fail      // it is not hex !

Digit_Decimal:
                // compare digit
                cp      l                   // compare with base

                jr      nc, Digit_Fail      // fail when greater than base
                    ld      e, a                // digit is returned as second from TOS
                    ld      hl, 1

                    psh2
                push    de
                push    hl
                jp      (ix)
Digit_Fail:
                ld      hl, 0
                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
//  parametric uppercase routine
//  depending on the following op-code the routine can be by-passed
//  changing the behaviour of some callers.
//  If it is "ret" then the system is Case-Sensitive
//  If it is "Nop" then the system is Case-Insensitive
//  Only A register is touched.
Case_Sensitive: nop                         // Default is case-insensitive.
Case_Upper:
                cp      LC_A_CHAR           // lower-case "a"
                ret     c                   // no change if A < "a"
                cp      LC_Z_CHAR + 1       // lower-case "z" + 1
                ret     nc                  // no change if A > "z"
                sub     $20                 // Make uppercase if A in ["a".."z"]
                ret

//  ______________________________________________________________________
//
//  caseon      --
// set system case-sensitivity on
// it patches a RET/NOP at the beginning of the uppercase-routine
                New_Def CASEON, "CASEON", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "CASEON"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "CASEON"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CASEON:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                ld      a, $C9              // "ret"
                ld      (Case_Sensitive), a
                next
                jp      (ix)

//  ______________________________________________________________________
//
//  caseoff     --
// set system case-sensitivity on
// it patches a RET/NOP at the beginning of the uppercase-routine
                New_Def CASEOFF, "CASEOFF", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "CASEOFF"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "CASEOFF"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CASEOFF:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                ld      a, $00              // "nop"
                ld      (Case_Sensitive), a
                next
                jp      (ix)

//  ______________________________________________________________________
//
//  upper       c1 -- c1 | c2
// character on top of stack is forced to Uppercase.
                New_Def UPPER, "UPPER", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "UPPER"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "UPPER"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
UPPER:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl
                ld      a, l
                call    Case_Upper
                ld      l, a

                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// (find)       addr voc -- 0 | cfa b 1
// vocabulary search,
// - voc is starting word's NFA
// - addr is the string to be searched for
// On success, it returns the CFA of found word, the first NFA byte
// (which contains length and some flags) and a true flag.
// On fail, a false flag  (no more: leaves addr unchanged)
                New_Def C_FIND, "(FIND)", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "(FIND)"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "(FIND)"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
C_FIND:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                exx
                pop     de                      // de has dictionary pointer
Find_VocabularyLoop:
                    pop     hl                  // string pointer to search for
                    push    hl                  // keep it on stack too for the end.
                    ld      a, (de)             // save NFA length byte
                    ex      af,af'              // for later use (!)
                    ld      a, (de)             // reload NFA length byte
                    xor     (hl)                // check if same length
                    and     $3F                 // by resetting 3 high bits (flags)
                    // word and text haven't the same length, skip to next vocabulary entry
                    jr      nz, Find_DifferentLenght

Find_ThisWord:      // begin loop
                        inc     hl
                        inc     de
                        ld      a, (de)
                        // case insensitive option - begin
                        // push    bc
                        and     $80                 // split A in msb and the rest
                        ld      b, a
                        ld      a, (de)
                        and     $7F                 // ... the rest (lower 7 bits)
                        call    Case_Sensitive      // uppercase routine
                        ld      c, a
                        ld      a, (hl)
                        call    Case_Sensitive      // uppercase routine
                        xor     c
                        xor     b
                        // pop     bc
                        // case insensitive option - end
                        add     a                   // ignore msb during compare
                        jr      nz, Find_DidntMatch  // jump if doesn't match (*)

                    // loop back until last byte msb is found set
                    // that bit marks the ending char of this word
                    jr      nc, Find_ThisWord

                    // match found !
                    ld      hl, 3               // 3 bytes for CFA offset to skip LFA
                    add     hl, de
                    ex      (sp), hl            // CFA on stack and drop addr
                    ex      af, af'             // retrieve NFA byte (!)
                    ld      e, a
                    ld      d, 0


                    ld      hl, -1
                    push    de
                    push    hl
                    exx
                    next
                jp      (ix)

Find_DidntMatch: // didn't match (*)
                    jr      c,  Find_WordEnd   // jump if not end of word (**)

Find_DifferentLenght:
                    // consume chars until the end of the word
                    // that is last byte msb is found set
                        inc     de
                        ld      a, (de)
                        add     a, a
                    jr      nc, Find_DifferentLenght

Find_WordEnd:   // word-end  found (**)
                    // take LFA and use it
                    inc     de
                    ex      de, hl
                    ld      e, (hl)
                    inc     hl
                    ld      d, (hl)
                    ld      a, d
                    or      e

                // loop until end of vocabulary
                jr      nz, Find_VocabularyLoop

                pop     hl              // without this, leaves addr unchanged
                ld      hl, FALSE_FLAG
                push    hl
                exx
                next
                jp      (ix)

//  ______________________________________________________________________
//
// enclose      a c -- a  n1 n2 n3
// starting from a, using delimiter c, determines the offsets:
//   n1   the first character non-delimiter
//   n2   the first delimiter after the text
//   n3   the first character non enclosed.
// This procedure does not go beyond a 'nul' ASCII (0x00) that represents
// an uncoditional delimiter.
// Examples:
//   i:	c  c  x  x  x  c  x	 -- 2  5  6
//  ii:	c  c  x  x  x  'nul' -- 2  5  5
// iii:	c  c  'nul'          -- 2  3  2
                New_Def ENCLOSE, "ENCLOSE", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "ENCLOSE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "ENCLOSE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
ENCLOSE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                exx
                pop     de                  //  e has the character
                pop     hl                  // hl has the string address
                push    hl
                ld      a, e
                ld      de, -1              // let's start from -1
                dec     hl
Enclose_NonDelimiter:
                // find first non delimiter
                    inc     hl
                    inc     de
                    cp      (hl)
                jr      z, Enclose_NonDelimiter
                push    de

                // push    bc                  // save Instruction Pointer

                ld      c, a                // save char
                ld      a, (hl)
                and     a                   // stop if 0x00
                jr      nz, Enclose_NextChar

                /// case iii. no more character in string
                    // pop     bc                  // restore Instruction Pointer
                    inc     de
                    push    de
                    dec     de
                    push    de
                    exx
                    next
                jp      (ix)
Enclose_NextChar:
                    ld      a, c
                    inc     hl
                    inc     de
                    cp      (hl)
                    jr      nz, Enclose_NonSeparator

                        // case i. first non enclosed
                        // pop     bc                  // restore Instruction Pointer
                        push    de
                        inc     de
                        push    de
                        exx
                        next
                jp      (ix)
Enclose_NonSeparator:
                    ld      a, (hl)
                    and     a
                jr      nz, Enclose_NextChar

                // case ii. separator & terminator
                // pop     bc                  // restore Instruction Pointer
                push    de
                push    de
                exx
                next
                jp      (ix)

//  ______________________________________________________________________
//
// (map)        a2 a1 n c1 -- c2
// translate character c1 using mapping string a2 and a2
// if c1 is not present within string a1 then
// c2 = c2 if it is not translated. n is the length of both a1 and a2.
                New_Def C_MAP, "(MAP)", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "(MAP)"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "(MAP)"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
C_MAP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                exx
                pop     hl
                ld      a, l
                pop     bc
                pop     hl
                ld      d, b
                ld      e, c
                cpir
                pop     hl
                jr      nz, C_Map_Then

                    add     hl, de
                    dec     hl
                    sbc     hl, bc
                    ld      a, (hl)
C_Map_Then:
                ld      l, a
                ld      h, 0
                push    hl
                exx
                next
                jp      (ix)

//  ______________________________________________________________________
//
// (compare)    a1 a2 n -- b
// this word performs a lexicographic compare of n bytes of text at address a1
// with n bytes of text at address a2. It returns numeric a value:
//  0 : if strings are equal
// +1 : if string at a1 greater than string at a2
// -1 : if string at a1 less than string at a2
// strings can be 256 bytes in length at most.
                New_Def C_COMPARE, "(COMPARE)", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "(COMPARE)"


len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "(COMPARE)"               // name string in 7-bit ascii, but


                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
C_COMPARE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                exx
                pop     hl                  // Number of bytes
                ld      a, l
                pop     hl                  // hl points string a2
                pop     de                  // hl points string a1
//              push    bc                  // Instruction pointer on stack
                ld      b, a
C_Compare_Loop:
                    ld      a, (hl)
                    call    Case_Sensitive
                    ld      c, a
                    ld      a, (de)
                    call    Case_Sensitive
                    cp      c
                    inc     de
                    inc     hl
                    jr      z, C_Compare_Equal
                        jr      c, C_Compare_NotLessThan  // If LessThan
                            ld      hl, 1               // a1 gt a2
                        jr      C_Compare_Then      // Else
C_Compare_NotLessThan:
                            ld      hl, -1              // a1 lt a2
C_Compare_Then:                                 // Endif
//                      pop     bc              // restore Instruction Pointer
                        push    hl
                        exx

                        next
                jp      (ix)

C_Compare_Equal:
                djnz    C_Compare_Loop
                ld      hl, 0               // a1 eq a2
//              pop     bc                  // restore Instruction Pointer
                push    hl
                exx

                next
                jp      (ix)

//  ______________________________________________________________________
//
// emitc        c --
// low level emit, calls ROM routine at #10 to send a character to
// the the current channel (see SELECT to change stream-channel)
                New_Def EMITC, "EMITC", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "EMITC"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "EMITC"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
EMITC:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl
                ld      a, l
Emitc_Ptr:
                push    bc
                push    ix
                rst     $10
                pop     ix
                pop     bc
                ld      a, 255            // max possible
                ld      (SCR_CT), a

                next
                jp      (ix)

//  ______________________________________________________________________
//
// cr           --
// send a CR via EMITC
                New_Def CR, "CR", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "CR"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "CR"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CR:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

                ld      a, CR_CHAR
                jr      Emitc_Ptr

Emitc_Vec:
                dw      C_Emit_Printable  // comma
                dw      C_Emit_Bel        // bel
                dw      C_Emit_Printable  // bs
                dw      C_Emit_Tab        // tab
                dw      C_Emit_Printable  // cr
                dw      C_Emit_NL         // lf (unix newline)
                dw      C_Emit_Printable  // blank
                dw      C_Emit_Printable  // blank

Emit_Selector_Start:
                db      $06                 // comma
                db      $07                 // bel
                db      $08                 // bs
                db      $09                 // tab
                db      $0D                 // cr
                db      $0A                 // lf (unix newline)
                db      $20
Emit_Selector_End:
                db      $20

//  ______________________________________________________________________
//
// (?emit)      c1 -- c2 | c1
// decode a character to be sent via EMIT
// search first the Emit_Selector table, if found jump to the corresponding routine in Emit_Vector
// the routine should resolve anything and convert the character anyway.
                New_Def C_EMIT, "(?EMIT)", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "(?EMIT)"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "(?EMIT)"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
C_EMIT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                exx
                pop     de
                ld      a, e                //  de has c1
                and     $7F                 // 7-bit ascii only
                // push    bc                  // save Instruction Pointer
                ld      bc, Emit_Selector_End - Emit_Selector_Start + 1
                ld      hl, Emit_Selector_End
                cpdr                        // search for c1 in Emit_Selector table, backward
                jr      nz, C_Emit_Not_Found
                    // Found then decode it
                    ld      hl, Emitc_Vec
                    add     hl, bc
                    add     hl, bc
                    ld      e, (hl)
                    inc     hl
                    ld      d, (hl)
                    ex      de, hl
                    // pop     bc                  // restore Instruction Pointer
                    jp      (hl)                // one of the following labels
C_Emit_Not_Found:
                // pop     bc                  // restore Instruction Pointer
                cp      BLANK_CHAR          // cp $20 non-printable check
                jr      nc, C_Emit_Printable
                    ld      a, NUL_CHAR         // NUL is never "printed"
C_Emit_Printable:
                ld      l, a
                ld      h, 0
                push    hl
                exx
                next
                jp      (ix)

C_Emit_Bel:
                exx
                push    bc                  // save Instruction Pointer
                ld      de, $0100
                ld      hl, $0200
                push    ix                  // save Next Pointer
                call    $03B6               // bleep Standard-ROM routine
                pop     ix                  // restore Next Pointer
                pop     bc                  // restore Instruction Pointer
                ld      hl, NUL_CHAR
                push    hl
                next
                jp      (ix)

C_Emit_Tab:     ld      hl, COMMA_CHAR
                push    hl
                exx
                next
                jp      (ix)

C_Emit_NL       ld      hl, CR_CHAR           // 0x0A --> 0x0D  à la Spectrum
                push    hl
                exx
                next
                jp      (ix)

//  ______________________________________________________________________

Key_Table:
                db      $E2                 //  0: STOP  --> SYMBOL+A : ~
                db      $C3                 //  1: NOT   --> SYMBOL+S : |
                db      $CD                 //  2: STEP  --> SYMBOl+D : //
                db      $CC                 //  3: TO    --> SYMBOL+F : {
                db      $CB                 //  4: THEN  --> SYMBOL+G : }
                db      $C6                 //  5: AND   --> SYMBOL+Y : [
                db      $C5                 //  6: OR    --> SYMBOL+U : ]
                db      $AC                 //  7: AT    --> SYMBOL+I : (C) copyright symbol
                db      $C7                 //  8: <=    --> same as SHIFT-1 [EDIT]
                db      $C8                 //  9: >=    --> same as SHIFT-0 [BACKSPACE]
                db      $C9                 // 10: <>    --> SYMBOL+W is the same as CAPS (toggle) SHIFT+2
Key_MapTo:
                db      $06                 // 10: SYMBOL+W is the same as CAPS (toggle) SHIFT+2
                db      $0C                 //  9: same as SHIFT-0 [BACKSPACE]
                db      $07                 //  8: same as SHIFT-1 [EDIT]
                db      $7F                 //  7: SYMBOL+I : (C) copyright symbol
                db      $5D                 //  6: SYMBOL+U : ]
                db      $5B                 //  5: SYMBOL+Y : [
                db      $7D                 //  4: SYMBOL+G : }
                db      $7B                 //  3: SYMBOL+F : {
                db      $5C                 //  2: SYMBOl+D : //
                db      $7C                 //  1: SYMBOL+S : |
                db      $7E                 //  0: SYMBOL+A : ~

//  ______________________________________________________________________
//
// curs         -- c
// wait for a keypress
// This definition need Standard ROM Interrupt to be served

                New_Def CUR, "CURS", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "CURS"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "CURS"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CUR:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

                push    bc                  // save Instruction Pointer
                push    ix

                ld      (SP_Saved), sp      // be sure to not to be paged out.
                ld      sp, Cold_origin - 5 // maybe $4000 in the future...
                res     5, (iy + 1)         // FLAGS (5C3A+1)

Cur_Wait:
                    halt
                    ld      a, 2                // selec channel #2 (Upper Video)
                    call    $1601               // SELECT Standard-ROM Routine

                    // software-flash: flips face every 320 ms
                    ld      a, $10              // Timing based
                    and     (iy + $3E)          // FRAMES (5C3A+3E)

                    ld      a, (Block_Face)     // see origin.asm
                    jr      nz, Cur_Cursor
                        ld      a, (Half_Face)      // see origin.asm
                        bit     3, (iy + $30)       // FLAGS2 (5C3A+$30) that is CAPS-LOCK
                        jr      z, Cur_Cursor
                            ld      a, (Underscore_Face) // see origin
Cur_Cursor:
                    rst     $10
                    ld      a, BACKSPACE_CHAR    // backspace
                    rst     $10

                    bit     5, (iy + 1)         // FLAGS (5C3A+1)
                jr      z, Cur_Wait

                halt    // this is to sync flashing cursor.

                ld      a, BLANK_CHAR       // space to blank cursor
                rst     $10
                ld      a, BACKSPACE_CHAR   // backspace
                rst     $10

                ld      sp, (SP_Saved)

                pop     ix
                pop     bc                  // Restore Instruction Pointer

                next
                jp      (ix)


//  ______________________________________________________________________
//
// key          -- c
// This definition need Standard ROM Interrupt to be served

                New_Def KEY, "KEY", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "KEY"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "KEY"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
KEY:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

                push    bc

Key_Wait:
                    bit     5, (iy + 1)         // FLAGS (5C3A+1)
                jr      z, Key_Wait

                ld      a, (LASTK)          // get typed character (5C08)

                // decode character from above table
                ld      hl, Key_Table
                ld      bc, $000B
                cpir
                jr      nz, Key_DontMap
                    ld      hl, Key_MapTo
                    add     hl, bc
                    ld      a, (hl)
Key_DontMap:    cp      $06                 // CAPS-LOCK management
                jr      nz, Key_NoCapsLock
                    ld      hl, $5C6A           // FLAGS2
                    ld      a, (hl)
                    xor     $08
                    ld      (hl), a
                    ld      a, NUL_CHAR
Key_NoCapsLock: ld      l, a
                ld      h, 0                // Prepare TOS

                res     5, (iy + 1)         // FLAGS (5C3A+1)

                pop     bc                  // Restore Instruction Pointer

                psh1
                push    hl
                jp      (ix)


//  ______________________________________________________________________
//
// click        --
// This definition need Standard ROM Interrupt to be served
//
//              New_Def CLICK, "CLICK", is_code, is_normal
//
//                push    bc
//              ld      a, ($5C48)          // BORDCR system variable
//              rra
//              rra
//              rra
//              or      $18                 // quick'n'dirty click
//              out     ($fe), a
//              ld      b, 0
//              djnz    $                   // wait loop
//              xor     $18
//              out     ($fe), a
//                pop     bc

//              next

//  ______________________________________________________________________
//
// key?         -- f
// key available
//
//              New_Def KEY_Q, "KEY?", is_code, is_normal
//
//              ld      hl, 0000
//              bit     5, (iy + 1)         // FLAGS (5C3A+1)
//              jr      z, Key_Q
//                  dec     hl
// Key_Q:
//                psh1
//              next

//  ______________________________________________________________________
//
// ?terminal    -- FALSE | TRUE
// test for BREAK keypress
                New_Def QTERMINAL, "?TERMINAL", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "?TERMINAL"


len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "?TERMINAL"               // name string in 7-bit ascii, but


                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
QTERMINAL:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                exx
                ld      bc, $7ffe
                in      d, (c)
                ld      b, c
                in      a, (c)
                or       d
                rra
                ccf
                sbc     hl, hl
                push    hl
                exx
                next
                jp      (ix)


//  ______________________________________________________________________
//
// inkey        -- c | 0
// call ROM inkey$ routine, returns c or "zero".

                New_Def INKEY, "INKEY", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "INKEY"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "INKEY"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
INKEY:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

                push    bc
                ld      (SP_Saved), sp
                ld      sp, Cold_origin - 5
                push    ix
                call    $15E6                   // instead of 15E9
                pop     ix
                ld      sp, (SP_Saved)
                ld      l, a
                ld      h, 0
                pop     bc
                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// select      n --
// selects the given channel number

                New_Def SELECT, "SELECT", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "SELECT"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "SELECT"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
SELECT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl
                push    bc
                ld      a, l
                ld      (SP_Saved), sp
                ld      sp, Cold_origin - 5
                push    ix
                call    $1601
                pop     ix
                ld      sp, (SP_Saved)
                pop     bc

                next
                jp      (ix)

//  ______________________________________________________________________
//
// ZX Spectrum Next - Low Level disk primitives.
// this include is "here" for backward compatibility

                include "next-opt0.asm"
ect\Projects\vForth15_DIRECT/source/next-opt0.asm
//  ______________________________________________________________________
//
//  next-opt.asm
//
//  ZX Spectrum Next - peculiar definitions
//  ______________________________________________________________________

//  ______________________________________________________________________
//
// f_seek       d u -- f
// Seek to position d in file-handle u.
// Return a false-flag 0 on success, True flag on error
                New_Def F_SEEK, "F_SEEK", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "F_SEEK"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "F_SEEK"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
F_SEEK:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl                  // file-handle
                ld      a, l                // file-handle
                ld      h, b                // save Intruction Pointer
                ld      l, c
                pop     bc                  // bc has high-word of d
                pop     de
                push    ix
                push    hl                  // save Instruction Pointer
                ld      ix, 0
                rst     $08
                db      $9F
F_Seek_Exit:
                pop     bc                  // restore Instruction Pointer
                pop     ix
                sbc     hl, hl              // to get 0 or -1

                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// f_close      u -- f
// Close file-handle u.
// Return 0 on success, True flag on error

                New_Def F_CLOSE, "F_CLOSE", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "F_CLOSE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "F_CLOSE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
F_CLOSE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

                pop     hl
                ld      a, l                // file-handle
                push    ix
                push    bc                  // Save Instruction pointer
                rst     $08
                db      $9B
                jr      F_Seek_Exit
//              pop     bc
//              pop     ix
//              sbc     hl, hl
//              psh1

//  ______________________________________________________________________
//
// f_sync      u -- f
// Close file-handle u.
// Return 0 on success, True flag on error

                New_Def F_SYNC, "F_SYNC", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "F_SYNC"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "F_SYNC"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
F_SYNC:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl
                ld      a, l                // file-handle
                push    ix
                push    bc
                rst     $08
                db      $9C
                jr      F_Seek_Exit
//              pop     bc
//              pop     ix
//              sbc     hl, hl
//              psh1

//  ______________________________________________________________________
//
// f_fgetpos    u -- d f
// Seek to position d in file-handle u.
// Return a false-flag 0 on success, True flag on error
                New_Def F_FGETPOS, "F_FGETPOS", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "F_FGETPOS"


len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "F_FGETPOS"               // name string in 7-bit ascii, but


                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
F_FGETPOS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl
                ld      a, l                // file-handle
                push    ix
                push    bc
                rst     $08
                db      $A0
                pop     hl                  // restore Instruction Pointer
                pop     ix
                push    de
                push    bc
                ld      b, h                // restore Instruction Pointer
                ld      c, l
                sbc     hl, hl

                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// f_read       a b u -- n f
// Read b bytes from file-handle u to address a
// Return the actual number n of bytes read
// Return 0 on success, True flag on error
                New_Def F_READ, "F_READ", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "F_READ"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "F_READ"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
F_READ:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

                ld      d, b
                ld      e, c
                pop     hl
                ld      a, l                // file-handle
                pop     bc                  // bc has bytes to read
                ex      (sp), ix            // ix has address
                push    de                  // Save Instruction pointer
                rst     $08
                db      $9D
F_Read_Exit:
                pop     bc                  // Restore Instruction pointer
                pop     ix                  // Restore ix
                push    de                  // bytes written
                sbc     hl, hl

                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// f_write      a b u -- n f
// Write bytes currently stored at address a to file-handle u.
// Return the actual n bytes written and 0 on success, True flag on error.
                New_Def F_WRITE, "F_WRITE", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "F_WRITE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "F_WRITE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
F_WRITE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

                ld      d, b
                ld      e, c
                pop     hl
                ld      a, l                // file-handle
                pop     bc                  // bc has bytes to read
                ex      (sp), ix            // ix has address
                push    de                  // Save Instruction pointer
                rst     $08
                db      $9E
                jr F_Read_Exit
//              pop     bc                  // Restore Instruction pointer
//              pop     ix                  // Restore ix
//              push    de                  // bytes written
//              sbc     hl, hl
//
//              psh1

//  ______________________________________________________________________
//
// f_open       a1 a2 b -- u f
// open a file
// a1 (filespec) is a null-terminated string, such as produced by ," definition
// a2 is address to an 8-byte header data used in some cases.
// b is access mode-byte, that is a combination of:
// any/all of:
//   esx_mode_read          $01 request read access
//   esx_mode_write         $02 request write access
//   esx_mode_use_header    $40 read/write +3DOS header
// plus one of:
//   esx_mode_open_exist    $00 only open existing file
//   esx_mode_open_creat    $08 open existing or create file
//   esx_mode_creat_noexist $04 create new file, error if exists
//   esx_mode_creat_trunc   $0c create new file, delete existing
// Return file-handle u and 0 on success, True flag on error
                New_Def F_OPEN, "F_OPEN", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "F_OPEN"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "F_OPEN"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
F_OPEN:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                ld      h, b                // Save Instruction pointer
                ld      l, c
                pop     bc                  // file-mode
                ld      b, c                // file-mode
                pop     de                  // 8-bytes buffer if any
                ex      (sp), ix            // filespec nul-terminated
                push    hl                  // Save Instruction pointer
                ld      a, "*"
                rst     $08
                db      $9A
F_Open_Exit:
                ld      e, a
                ld      d, 0
                jr F_Read_Exit

//   \ CREATE FILENAME ," test.txt"   \ new Counted String
//   \ FILENAME 1+ PAD 1 F_OPEN
//   \ DROP
//   \ F_CLOSE


//  ______________________________________________________________________
//
// f_opendir    a1 a2 b -- u f
// open a file
                New_Def F_OPENDIR, "F_OPENDIR", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "F_OPENDIR"


len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "F_OPENDIR"               // name string in 7-bit ascii, but


                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
F_OPENDIR:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                ex      (sp), ix            // filespec nul-terminated
                push    de
                push    bc                  // Save Instruction pointer
                ld      b, $10              // file-mode
                ld      a, "C"
                rst     $08
                db      $A3
                jr      F_Open_Exit


//  ______________________________________________________________________
//
// f_readdir    a1 a2 b -- u f
// open a file
                New_Def F_READDIR, "F_READDIR", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "F_READDIR"


len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "F_READDIR"               // name string in 7-bit ascii, but


                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
F_READDIR:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                 exx
                 pop     hl
                 ld      a, l
                 pop     de
                 ex      (sp), ix            // filespec nul-terminated
                exx
                push    de
                push    bc                  // Save Instruction pointer
                 exx
                 rst     $08
                 db      $A4
                 jr      F_Open_Exit

ect\Projects\vForth15_DIRECT/source/next-opt0.asm


//  ______________________________________________________________________
//
// cmove    a1 a2 u --
// If u > 0, moves memory content starting at address a1 for n bytes long
// storing then starting at address addr2.
// The content of a1 is moved first. See CMOVE> also.
                New_Def CMOVE, "CMOVE", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "CMOVE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "CMOVE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CMOVE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                exx

                pop     bc                  // bc has counter
                pop     de                  // de now has dest
                pop     hl                 // hl has source, save Instruction Pointer
                ld      a, b
                or      c
                jr      z, Cmove_NoMove
                    ldir
Cmove_NoMove:
                exx

                next
                jp      (ix)

//  ______________________________________________________________________
//
// cmove>    a1 a2 u --
// If u > 0, moves memory content starting at address a1 for n bytes long
// storing then starting at address addr2.
// The content of a1 is moved last. See cmove.
                New_Def CMOVE_TO, "CMOVE>", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "CMOVE>"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "CMOVE>"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CMOVE_TO:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                exx

                pop     bc                  // bc has counter
                pop     de                  // de has dest
                pop     hl                  // hl has source, save Instruction Pointer
                ld      a, b
                or      c
                jr      z, CmoveV_NoMove
                    ex      de, hl              // compute address to
                    add     hl, bc              // operate backward
                    dec     hl
                    ex      de, hl
                    add     hl, bc
                    dec     hl
                    lddr                        // backward
CmoveV_NoMove:
                exx

                next
                jp      (ix)

//  ______________________________________________________________________
//
// um*      u1 u2 -- ud
// Unsigned multiplication
// A double-integer is kept in CPU registers as DEHL then pushed on stack.
// On the stack a double number is treated as two single numbers
// where DE is on the top of the stack and HL is the second from top,
// Instead, in 2VARIABLE a double number is stored as EDLH.
// this definition could use "MUL" Z80N new op-code.
                New_Def UM_MUL, "UM*", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "UM*"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "UM*"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
UM_MUL:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                exx
                pop     de                    // de has u2 operand
                pop     hl                    // hl has u1 operand
                ld      b, l
                ld      c, e
                ld      e, l
                ld      l, d
                push    hl
                ld      l, c
                mul
                ex      de, hl
                mul
                xor     a
                add     hl, de
                adc     a
                ld      e, c
                ld      d, b
                mul
                ld      b, a
                ld      c, h
                ld      a, d
                add     l
                ld      h, a
                ld      l, e
                pop     de
                mul
                ex      de, hl
                adc     hl, bc
                push    de
                push    hl
                exx
                next
                jp      (ix)

//  ______________________________________________________________________
//
// um/mod      ud u1 -- q r
// divides ud into u1 giving quotient q and remainder r
// algorithm takes 16 bit at a time starting from msb
// DE grows from lsb upward with quotient result
// HL keeps the remainder at each stage of division
// each loop 'lowers' the next binary digit to form the current dividend
                New_Def UMDIVMOD, "UM/MOD", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "UM/MOD"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "UM/MOD"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
UMDIVMOD:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                exx
                pop     bc                      // divisor

                pop     hl                      // < high part
                pop     de                      // < low part and

                ld      a, l                    // check without changing arguments
                sub     c                       // if divisor is greater than high part
                ld      a, h                    // so quotient will be in range
                sbc     a, b
                jr      nc, Um_DivMod_OutOfRange
                    ld      a, 16
Um_DivMod_Loop:
                        sla     e
                        rl      d
                        adc     hl, hl
                        jr      nc, Um_DivMod_Carry
                            and     a
                            sbc     hl, bc
                        jr      Um_DivMod_Endif    // else
Um_DivMod_Carry:
                            and     a
                            sbc     hl, bc
                            jr      nc, Um_DivMod_Endif
                                add     hl, bc
                                dec     de
Um_DivMod_Endif:                                   // endif
                        inc     de
                        dec     a
                    jr      nz, Um_DivMod_Loop
                    ex      de, hl
Um_DivMod_Bailout:
                    push    de                  // de := remanider
                    push    hl                  // hl := quotient
                    exx
                    next
                jp      (ix)

Um_DivMod_OutOfRange:
                ld      hl, -1
                ld      d, h
                ld      e, l
                jr      Um_DivMod_Bailout

//  ______________________________________________________________________
//
// and          n1 n2 -- n3
// bit logical AND. Returns n3 as n1 & n2
                New_Def AND_OP, "AND", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "AND"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "AND"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
AND_OP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     de
                pop     hl
                ld      a, e
                and     l
                ld      l, a
                ld      a, d
                and     h
                ld      h, a

                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// or           n1 n2 -- n3
// bit logical OR. Returns n3 as n1 | n2
                New_Def OR_OP, "OR", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "OR"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "OR"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
OR_OP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     de
                pop     hl
                ld      a, e
                or      l
                ld      l, a
                ld      a, d
                or      h
                ld      h, a

                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// xor          n1 n2 -- n3
// bit logical OR. Returns n3 as n1 ^ n2
                New_Def XOR_OP, "XOR", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "XOR"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "XOR"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
XOR_OP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     de
                pop     hl
                ld      a, e
                xor     l
                ld      l, a
                ld      a, d
                xor     h
                ld      h, a

                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// sp@      -- a
// returns on top of stack the value of SP before execution
                New_Def SPFETCH, "SP@", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "SP@"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "SP@"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
SPFETCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

                ld      hl, 0
                add     hl, sp

                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// sp!      a --
// restore SP to the initial value passed
// normally it is S0, i.e. the word at offset 6 and 7 of user variabiles area.
                New_Def SPSTORE, "SP!", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "SP!"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "SP!"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
SPSTORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl
                ld      sp, hl

                next
                jp      (ix)

//  ______________________________________________________________________
//
// rp@      -- a
// returns on top of stack the value of Return-Pointer
                New_Def RPFETCH, "RP@", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "RP@"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "RP@"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
RPFETCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

                ldhlrp
                ld      hl,(RP_Pointer)

                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// rp!      a --
// restore RP to the initial value passed
// normally it is R0 @, i.e. the word at offset 8 of user variabiles area.
                New_Def RPSTORE, "RP!", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "RP!"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "RP!"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
RPSTORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl
                ldrphl
                ld      (RP_Pointer),hl

                next
                jp      (ix)

//  ______________________________________________________________________
//
// exit       --
// exits back to the caller word
                New_Def EXIT, "EXIT", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "EXIT"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "EXIT"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
EXIT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                ldhlrp                      // Get Return Stack Pointer
                ld      hl,(RP_Pointer)
                ld      c, (hl)             // pop Instruction Pointer
                inc     hl                  // from Return Stack
                ld      b, (hl)
                inc     hl
                ldrphl                      // Set Return Stack Pointer
                ld      (RP_Pointer),hl
                next
                jp      (ix)

//  ______________________________________________________________________
//
// lastl      --
// exits back to the caller word
//              New_Def EXIT, "LASTL", is_code, is_normal
//              ldhlrp                      // Get Return Stack Pointer
//              ld      e, (hl)             // pop Instruction Pointer
//              inc     hl                  // from Return Stack
//              ld      d, (hl)
//              inc     hl
//              ld      (hl), e
//              inc     hl
//              ld      (hl), d
//              next

//  ______________________________________________________________________
//
// >r      n --
// pop from calculator-stack and push into return-stack
                New_Def TO_R, ">R", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      ">R"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      ">R"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
TO_R:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     de
                ldhlrp
                ld      hl,(RP_Pointer)
                dec     hl
                ld      (hl), d             // store current TOS
                dec     hl                  // to Return Stack
                ld      (hl), e
                ldrphl
                ld      (RP_Pointer),hl

                next
                jp      (ix)

//  ______________________________________________________________________
//
// r>      -- n
// pop from return-stack and push into calculator-stack
                New_Def R_TO, "R>", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "R>"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "R>"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
R_TO:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

                ldhlrp
                ld      hl,(RP_Pointer)
                ld      e, (hl)             // retrieve from Return Stack
                inc     hl
                ld      d, (hl)
                inc     hl
                ldrphl
                ld      (RP_Pointer),hl
                push    de
                next
                jp      (ix)

//  ______________________________________________________________________
//
// r@           -- n
// return on top of stack the value of top of return-stack
// Since this is the same as I, we alter R's CFA to jump there
                New_Def R_OP, "R@", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "R@"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "R@"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
R_OP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                jp      I_Ptr

//  ______________________________________________________________________
//
// r            -- n
// return on top of stack the value of top of return-stack
// Since this is the same as I, we alter R's CFA to jump there
//              New_Def R_OLD, "R", is_code, is_normal
//              jp      I_Ptr

//  ______________________________________________________________________
//
// 0=           n -- f
// true (non zero) if n is zero, false (0) elsewere
                New_Def ZEQUAL, "0=", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "0="
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "0="               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
ZEQUAL:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
Zero_Equal:
                pop     hl
                ld      a, l
                or      h
                ld      hl, FALSE_FLAG
                jr      nz, ZEqual_Skip
                    dec     hl
ZEqual_Skip:
                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// not         a1 -- a2
// increment by 2 top of stack
                New_Def NOT_OP, "NOT", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "NOT"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "NOT"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
NOT_OP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                jp      Zero_Equal

//  ______________________________________________________________________
//
// 0<           n -- f
// true (non zero) if n is less than zero, false (0) elsewere
                New_Def ZLESS, "0<", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "0<"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "0<"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
ZLESS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl
                add     hl, hl
                sbc     hl, hl
                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// 0>           n -- f
// true (non zero) if n is less than zero, false (0) elsewere
                New_Def ZGREATER, "0>", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "0>"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "0>"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
ZGREATER:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl
                ld      a, l
                or      h
                add     hl, hl
                ld      hl, FALSE_FLAG
                jr      c, ZGreater_Skip
                    and     a
                    jr      z, ZGreater_Skip
                        dec     hl
ZGreater_Skip:
                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// +            n1 n2 -- n3
// returns the unsigned sum of two top values
                New_Def PLUS, "+", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "+"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "+"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
PLUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl
                pop     de
                add     hl, de

                psh1
                push    hl
                jp      (ix)


//  ______________________________________________________________________
//
// d+           d1 d2 -- d3
// returns the unsigned sum of two top double-numbers
//      d2  d1
//      h l h l
// SP   LHEDLHED
// SP  +01234567
                New_Def DPLUS, "D+", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "D+"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "D+"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DPLUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

                exx
                pop     bc                  // bc := d2.H
                pop     de                  // hl := d2.L
                pop     hl                  // d1.H
                ex      (sp), hl            // d1.L
                add     hl, de              // hl := d2.L + d1.L
                ex      (sp), hl            // d1.H
                adc     hl, bc              // d1.H + d2.H
                push    hl
                exx
                next
                jp      (ix)

//  ______________________________________________________________________
//
// 1+           n1 -- n2
// increment by 1 top of stack
                New_Def ONE_PLUS, "1+", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "1+"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "1+"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
ONE_PLUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl
                inc     hl

                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// 1-           n1 -- n2
// decrement by 1 top of stack
                New_Def ONE_SUBTRACT, "1-", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "1-"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "1-"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
ONE_SUBTRACT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl
                dec     hl

                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// 2+           n1 -- n2
// increment by 2 top of stack
                New_Def TWO_PLUS, "2+", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "2+"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "2+"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
TWO_PLUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
Two_Plus:
                pop     hl
                inc     hl
                inc     hl

                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// cell+        a1 -- a2
// increment by 2 top of stack
                New_Def CELL_PLUS, "CELL+", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "CELL+"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "CELL+"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CELL_PLUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                jp      Two_Plus

//  ______________________________________________________________________
//
// align        a1 -- a2
// align memory : not used
//              New_Def ALIGN_ADDR, "ALIGN", is_code, is_normal
//            next

//  ______________________________________________________________________
//
// cell-        a1 -- a2
// decrement by 2 top of stack
                New_Def CELL_MINUS, "CELL-", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "CELL-"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "CELL-"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CELL_MINUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
CellMinus:
                pop     hl
                dec     hl
                dec     hl

                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// 2-           a1 -- a2
// decrement by 2 top of stack
                New_Def TWO_MINUS, "2-", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "2-"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "2-"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
TWO_MINUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                jp      CellMinus

//  ______________________________________________________________________
//
// negate       n1 -- n2
// change the sign of number
                New_Def MINUS, "NEGATE", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "NEGATE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "NEGATE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
MINUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                ld      hl, 0               // subtract from 0
                pop     de
                or      a
                sbc     hl, de

                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// dnegate      d1 -- d2
// change the sign of a double number
                New_Def DMINUS, "DNEGATE", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "DNEGATE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "DNEGATE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DMINUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                exx
                pop     bc                  // d1.H
                pop     de                  // d1.L
                xor     a
                ld      h, a
                ld      l, a
                sbc     hl, de              // subtact from zero
                push    hl                  // > d2-L
                ld      h, a
                ld      l, a
                sbc     hl, bc              // subtract from zero with carry
                                            // > d2-H
                push    hl
                exx
                next
                jp      (ix)

//  ______________________________________________________________________
//
// over         n1 n2 -- n1 n2 n1
// copy the second value of stack and put it on top.
                New_Def OVER, "OVER", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "OVER"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "OVER"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
OVER:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     af                  //   n2
                pop     hl                  // < n1
                push    hl                  // > n1
                push    af                  // > n2
                push    hl                  // > n1
                next
                jp      (ix)

//  ______________________________________________________________________
//
// drop         n1 --
// drops the top of stack
                New_Def DROP, "DROP", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "DROP"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "DROP"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DROP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl                  // < n1 and discard previous TOS
                next
                jp      (ix)

//  ______________________________________________________________________
//
// nip          n1 n2 -- n2
// drops the second elemento on the stack
                New_Def NIP, "NIP", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "NIP"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "NIP"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
NIP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

                pop     hl                  // < n1 discarded
                ex      (sp), hl
                next
                jp      (ix)

//  ______________________________________________________________________
//
// tuck         n1 n2 -- n2 n1 n2
// copy the top element after the second.
                New_Def TUCK, "TUCK", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "TUCK"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "TUCK"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
TUCK:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl
                pop     af                  // < n1
                push    hl                  // > n2  and TOS
                push    af                  // > n1
                push    hl
                next
                jp      (ix)

//  ______________________________________________________________________
//
// swap         n1 n2 -- n2 n1
// swaps the two values on top of stack
                New_Def SWAP, "SWAP", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "SWAP"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "SWAP"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
SWAP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl                  // < n1
                ex      (sp),hl             // > n2
                push    hl                  // copy n1 to TOS
                next
                jp      (ix)

//  ______________________________________________________________________
//
// dup         n -- n n
// duplicates the top value of stack
                New_Def DUP, "DUP", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "DUP"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "DUP"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DUP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl
                push    hl                  // > n duplicate TOS
                push    hl
                next
                jp      (ix)

//  ______________________________________________________________________
//
// rot         n1 n2 n3 -- n2 n3 n1
// Rotates the 3 top values of stack by picking the 3rd in access-order
// and putting it on top. The other two are shifted down one place.
                New_Def ROT, "ROT", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "ROT"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "ROT"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
ROT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     de                  // < n3
                pop     hl                  // < n2
                ex      (sp),hl             // > n2 < n1
                push    de                  // > n3
                push    hl                  // copy n1 to TOS
                next
                jp      (ix)

//  ______________________________________________________________________
//
// -rot         n1 n2 n3 -- n3 n1 n2
// Rotates the 3 top values of stack by picking the 1st in access-order
// and putting back to 3rd place. The other two are shifted down one place.
                New_Def DASH_ROT, "-ROT", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "-ROT"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "-ROT"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DASH_ROT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl                  // < n3
                pop     de                  // < n2
                ex      (sp),hl             // > n3 < n1
                push    hl                  // > n1
                push    de                  // copy n3 to TOS
                next
                jp      (ix)

//  ______________________________________________________________________
//
// pick        n1 -- nx
// picks the nth element from TOS
                New_Def PICK, "PICK", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "PICK"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "PICK"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
PICK:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl                  // take TOS as index
                add     hl, hl              // as cells
                add     hl, sp              // from Stack Pointer
                ld      a, (hl)             // replace TOS
                inc     hl
                ld      h, (hl)
                ld      l, a

                psh1
                push    hl
                jp      (ix)


//  ______________________________________________________________________
//
// roll        n1 n2 n3 ... n -- n2 n3 ... n1
// picks the nth element from TOS
//              New_Def ROLL, "ROLL", is_code, is_normal
//              exx                     // we need all registers free
//              pop     hl              // number of cells to roll
//              ld      a, h
//              or       l
//              jr      z, Roll_Zero
//                  add     hl, hl              // number of bytes to move
//                  ld      b, h
//                  ld      c, l
//                  add     hl, sp          // address of n1
//                  ld      a, (hl)         // take n1 into a and a,
//                  inc     hl
//                  ex      af, af'
//                  ld      a, (hl)         // take n1 into a and a,
//                  ld      d, h
//                  ld      e, l
//                  dec     hl
//                  dec     hl
//                  lddr
//                  ex      de, hl
//                  ld      (hl), a
//                  dec     hl
//                  ex      af, af'
//                  ld      (hl), a
//Roll_Zero:
//              exx
//              next


//  ______________________________________________________________________
//
// 2over        d1 d2 -- d1 d2 d1
//              n1 n2 n3 n4 -- n1 n2 n3 n4 n1 n2
// copy the second double of stack and put on top.
//              New_Def TWO_OVER, "2OVER", is_code, is_normal
//
//              ld      hl, 7
//              add     hl, sp
//              ld      d, (hl)
//              dec     hl
//              ld      e, (hl)             // d1-L
//              push    de
//              dec     hl
//              ld      d, (hl)
//              dec     hl
//              ld      e, (hl)             // d1-H
//              push    de
//              next

//  ______________________________________________________________________
//
// 2drop        d --
//              n1 n2 --
// drops the top double from stack
                New_Def TWO_DROP, "2DROP", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "2DROP"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "2DROP"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
TWO_DROP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl
                pop     hl
                next
                jp      (ix)

//  ______________________________________________________________________
//
// 2nip         d1 d2 -- d2
//              n1 n2 n3 n4 -- n3 n4
// drops the second double on the stack
//              New_Def TWO_NIP, 4, "2nip"
//              ...

//  ______________________________________________________________________
//
// 2tuck         d1 d2 -- d2 d1 d2
// copy the top element after the second.
//              New_Def TWO_TUCK, 5, "2tuck"
//              ...

//  ______________________________________________________________________
//
// 2swap         d1 d2 -- d2 d1
//               n1 n2 n3 n4 -- n3 n4 n1 n2
// swaps the two doubles on top of stack
                New_Def TWO_SWAP, "2SWAP", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "2SWAP"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "2SWAP"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
TWO_SWAP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     af                  //   d2-H
                pop     hl                  // < d2-L
                pop     de                  // < d1-H
                ex      (sp), hl            // < d1-L > d2-L
                push    af                  // > d2-H
                push    hl                  // > d1-L
                push    de

                next
                jp      (ix)

//  ______________________________________________________________________
//
// 2dup         d -- d d
//              n1 n2 -- n1 n2 n1 n2
// duplicates the top double of stack
                New_Def TWO_DUP, "2DUP", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "2DUP"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "2DUP"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
TWO_DUP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl                  // < d-H
                pop     af                  // < d-L
                push    af                  // < d-L
                push    hl                  // > d-H
                push    af                  // > d-L
                push    hl                  // > d-H
                next
                jp      (ix)

//  ______________________________________________________________________
//
// 2rot         d1 d2 d3 -- d2 d3 d1
//              n1 n2 n3 n4 n5 n6 -- n3 n4 n5 n6 n1 n2
// Rotates the 3 top doubles of stack by picking the 3rd in access-order
// and putting it on top. The other two are shifted down one place.
//              New_Def TWO?ROT, 4, "2rot"
//              ...
//              New_Def TWO_ROT, "2ROT", is_code, is_normal
//
//      d3  |d2  |d1  |
//      h l |h l |h l |
// SP   LHED|LHED|LHED|
// SP  +0123|4567|89ab|
//              ld      hl, $000B
//              add     hl, sp
//              ld      d, (hl)
//              dec     hl
//              ld      e, (hl)
//              dec     hl
//              push    de
//              ld      d, (hl)
//              dec     hl
//              ld      e, (hl)
//              dec     hl
//              push    de

//      d1  |d3  |d2  |d1  |
//      h l |h l |h l |h l |
// SP   LHED|LHED|LHED|LHED|
// SP       +0123|4567|89ab|

//              ld      d, h
//              ld      e, l
//              inc     de
//              inc     de
//              inc     de
//              inc     de
//              push    bc
//              ld      bc, $000C
//              lddr
//              pop     bc
//              pop     de
//              pop     de
//
//              next


//  ______________________________________________________________________
//
// +!           n a --
// Sums to the content of address a the number n.
// It is the same of  a @ n + a !
                New_Def PLUSSTORE, "+!", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "+!"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "+!"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
PLUSSTORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl                  // hl is the address
                pop     de                  // de is the number
                ld      a, (hl)
                add     e
                ld      (hl), a
                inc     hl
                ld      a, (hl)
                adc     d
                ld      (hl), a

                next
                jp      (ix)

//  ______________________________________________________________________
//
// toggle       a n --
// Complements (xor) the byte at addrress  a  with the model n.
                New_Def TOGGLE, "TOGGLE", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "TOGGLE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "TOGGLE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
TOGGLE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     de
                pop     hl
                ld      a, (hl)
                xor     e
                ld      (hl), a

                next
                jp      (ix)

//  ______________________________________________________________________
//
// @            a -- n
// fetch 16 bit number n from address a. Z80 keeps high byte is in high memory
                New_Def FETCH, "@", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "@"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "@"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
FETCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl
                ld      e, (hl)             // low-byte
                inc     hl
                ld      d, (hl)             // high-byte
                push    de
                next
                jp      (ix)

//  ______________________________________________________________________
//
// !            n a --
// store 16 bit number n from address a. Z80 keeps high byte is in high memory
                New_Def STORE, "!", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "!"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "!"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
STORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl                  // address
                pop     de                  // < n
                ld      (hl), e             // low-byte
                inc     hl
                ld      (hl), d             // high-byte

                next
                jp      (ix)

//  ______________________________________________________________________
//
// c@           a -- c
// fetch a character n from address a
                New_Def CFETCH, "C@", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "C@"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "C@"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CFETCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl
                ld      l, (hl)             // low-byte
                ld      h, 0

                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// c!           c a --
// fetch 16 bit number n from address a. Z80 keeps high byte is in high memory
                New_Def CSTORE, "C!", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "C!"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "C!"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CSTORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl                  // < address
                pop     de
                ld      (hl), e             // low-byte

                next
                jp      (ix)

//  ______________________________________________________________________
//
// 2@           a -- d
// fetch a 32 bits number d from address a and leaves it on top of the
// stack as two single numbers, high part as top of the stack.
// A double number is normally kept in CPU registers as HLDE.
// On stack a double number is treated as two single numbers
// where BC is on the top of the stack and HL is the second from top,
// so the sign of the number can be checked on top of stack
// and in the stack memory it appears as LHED.
                New_Def TWO_FETCH, "2@", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "2@"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "2@"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
TWO_FETCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl                  // address
                ld      e, (hl)             // low-byte
                inc     hl
                ld      d, (hl)             // high-byte
                inc     hl
                ld      a, (hl)             // low-byte
                inc     hl
                ld      h, (hl)             // high-byte
                ld      l, a
                push    hl
                push    de
                next
                jp      (ix)

//  ______________________________________________________________________
//
// 2!           d a --
// stores a 32 bits number d from address a and leaves it on top of the
// stack as two single numbers, high part as top of the stack.
// A double number is normally kept in CPU registers as HLDE.
// On stack a double number is treated as two single numbers
// where BC is on the top of the stack and HL is the second from top,
// so the sign of the number can be checked on top of stack
// and in the stack memory it appears as LHED.
                New_Def TWO_STORE, "2!", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "2!"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "2!"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
TWO_STORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                exx
                pop     hl                  // address
                pop     bc                  // < high-part
                pop     de                  // < low-part > Instruction Pointer
                ld      (hl), c
                inc     hl
                ld      (hl), b
                inc     hl
                ld      (hl), e
                inc     hl
                ld      (hl), d
                exx
                next
                jp      (ix)

//  ______________________________________________________________________
//
// p@           a -- c
// Read one byte from port a and leave the result on top of stack
                New_Def PFETCH, "P@", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "P@"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "P@"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
PFETCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                exx
                pop     bc
                ld      h, 0
                in      l, (c)
                push    hl
                exx
                next
                jp      (ix)

//  ______________________________________________________________________
//
// p!           c a --
// Send one byte (top of stack) to port a
                New_Def PSTORE, "P!", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "P!"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "P!"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
PSTORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                exx
                pop     bc
                pop     hl                  // < c
                out     (c), l              // low-byte
                exx
                next
                jp      (ix)


//  ______________________________________________________________________
//
// 2*           n1 -- n2
// doubles the number at top of stack
                New_Def TWO_MUL, "2*", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "2*"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "2*"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
TWO_MUL:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
Two_Mul_Ptr:
                pop     hl
                add     hl, hl

                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// 2/           n1 -- n2
// halves the top of stack, sign is unchanged
                New_Def TWO_DIV, "2/", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "2/"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "2/"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
TWO_DIV:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl
                sra     h
                rr      l

                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// lshift       n1 u -- n2
// bit left shift of u bits
                New_Def LSHIFT, "LSHIFT", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "LSHIFT"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "LSHIFT"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
LSHIFT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                exx
                pop     bc
                ld      b, c
                pop     de
                bsla    de, b
                push    de
                exx
                next
                jp      (ix)

//  ______________________________________________________________________
//
// rshift       n1 u -- n2
// bit right shift of u bits
                New_Def RSHIFT, "RSHIFT", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "RSHIFT"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "RSHIFT"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
RSHIFT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                exx
                pop     bc
                ld      b, c
                pop     de
                bsrl    de, b
                push    de
                exx
                next
                jp      (ix)

//  ______________________________________________________________________
//
// cells        n1 -- n2
// decrement by 2 top of stack
                New_Def CELLS, "CELLS", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "CELLS"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "CELLS"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CELLS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                jp      Two_Mul_Ptr


//  ______________________________________________________________________

ect\Projects\vForth15_DIRECT/source/L0.asm
                include "L1.asm"
ect\Projects\vForth15_DIRECT/source/L1.asm
//  ______________________________________________________________________
//
//  L1.asm
//
//  Level-1 definitions and derivate
//  ______________________________________________________________________

//  ______________________________________________________________________
//
// :            -- cccc     ( compile time )
//              i*x -- j*x  ( run time )
// Colon Definition
                Colon_Def COLON, ":", is_normal      // has forward-ref
                New_Def  COLON, ":", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      ":"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      ":"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
COLON:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

                dw      QEXEC                   // ?exec
                dw      STORE_CSP               // !csp
                dw      CURRENT, FETCH          // current @
                dw      CONTEXT, STORE          // context !
                dw      CREATE                  // create  ( forward )
                dw      SMUDGE                  // dmudge
                dw      SQUARED_CLOSE           // ]
                dw      C_SEMICOLON_CODE        // ;code ( change the 3-bytes CFA of defining word to call Enter_Ptr )
                                                // ... immediate
Enter_Ptr:
                // via call coded in CFA
                ldhlrp
                ld      hl,(RP_Pointer)
                dec     hl                  // push on Return-Stack current Instruction-Pointer
                ld      (hl), b
                dec     hl
                ld      (hl), c
                ldrphl
                ld      (RP_Pointer),hl


                pop     bc                  // points to PFA of "this" word
                next
                jp      (ix)

//  ______________________________________________________________________
//
// ;            --
// Semicolon. End of Colon-Definition. Stack must be balanced.
                Colon_Def SEMICOLON, ";", is_immediate   // has forward-ref
                New_Def  SEMICOLON, ";", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      ";"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      ";"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
SEMICOLON:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

                dw      QCSP                    // ?csp
                dw      COMPILE, EXIT           // [compile] ;s
                dw      SMUDGE                  // smudge
                dw      SQUARED_OPEN            // [
                dw      EXIT                    // ; immediate

//  ______________________________________________________________________
//
// noop         --

                New_Def NOOP, "NOOP", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "NOOP"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "NOOP"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
NOOP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                next
                jp      (ix)

//  ______________________________________________________________________
//
// constant     n -- cccc     ( compile time )
//              -- n          ( run time )
// Constant definition.
                Colon_Def CONSTANT, "CONSTANT", is_normal   // has forward-ref
                New_Def  CONSTANT, "CONSTANT", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "CONSTANT"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "CONSTANT"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CONSTANT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

                dw      CREATE                  // create
                dw      COMMA                   // ,    ( at PFA then, store the value )
                dw      C_SEMICOLON_CODE        // ;code (  changes the 3-bytes CFA to call Constant_Ptr )
Constant_Ptr:


                pop     hl

                ld      e, (hl)
                inc     hl
                ld      d, (hl)

                push    de
                next
                jp      (ix)

//  ______________________________________________________________________
//
// variable     n -- cccc     ( compile time )
//              -- a          ( run time )
// Variable definition, n is the initial value.
                Colon_Def VARIABLE, "VARIABLE", is_normal   // has forward-ref
                New_Def  VARIABLE, "VARIABLE", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "VARIABLE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "VARIABLE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
VARIABLE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

                dw      ZERO
                dw      CONSTANT                // constant
                dw      C_SEMICOLON_CODE        // ;code ( changes the 3-bytes CFA to call Variable_Ptr )
Variable_Ptr:




                next
                jp      (ix)

//  ______________________________________________________________________
//
// user         b -- cccc     ( compile time )
//              -- a          ( run time )
// User variable definition
                Colon_Def USER, "USER", is_normal
                New_Def  USER, "USER", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "USER"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "USER"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
USER:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

                dw      CREATE                  // create
                dw      CCOMMA                  // c,
                dw      C_SEMICOLON_CODE        // ;code () changes the 3-bytes CFA to call User_Ptr )


User_Ptr:
                // via call coded in CFA
                pop     hl
                ld      a, (hl)
                ld      hl, (USER_Pointer)
                add     hl, a
                push    hl
                next
                jp      (ix)

//  ______________________________________________________________________
//
                Constant_Def ZERO       ,   "0"     ,   0
                New_Def  ZERO, "0", Constant_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "0"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "0"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
ZERO:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Constant_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      0
                Constant_Def ONE        ,   "1"     ,   1
                New_Def  ONE, "1", Constant_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "1"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "1"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
ONE:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Constant_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      1
                Constant_Def TWO        ,   "2"     ,   2
                New_Def  TWO, "2", Constant_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "2"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "2"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
TWO:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Constant_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      2
                Constant_Def THREE      ,   "3"     ,   3
                New_Def  THREE, "3", Constant_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "3"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "3"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
THREE:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Constant_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      3
                Constant_Def NEG_ONE    ,   "-1"    ,  -1
                New_Def  NEG_ONE, "-1", Constant_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "-1"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "-1"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
NEG_ONE:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Constant_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      -1
                Constant_Def BL         ,   "BL"    , $20
                New_Def  BL, "BL", Constant_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "BL"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "BL"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
BL:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Constant_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      $20
                Constant_Def CL         ,   "C/L"   ,  64
                New_Def  CL, "C/L", Constant_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "C/L"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "C/L"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CL:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Constant_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      64
                Constant_Def BBUF       ,   "B/BUF" , 512
                New_Def  BBUF, "B/BUF", Constant_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "B/BUF"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "B/BUF"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
BBUF:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Constant_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      512
                Constant_Def BSCR       ,   "B/SCR" ,   2
                New_Def  BSCR, "B/SCR", Constant_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "B/SCR"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "B/SCR"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
BSCR:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Constant_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      2
                Constant_Def LSCR       ,   "L/SCR" ,  16
                New_Def  LSCR, "L/SCR", Constant_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "L/SCR"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "L/SCR"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
LSCR:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Constant_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      16

//  ______________________________________________________________________
//
// +origin         --
//              Colon_Def PLUS_ORIGIN, "+ORIGIN", is_normal
//              dw      LIT, Cold_origin        // [ hex 6366 ] literal
//              dw      PLUS                    // +
//              dw      EXIT                    // ;
                New_Def  PLUS_ORIGIN, "+ORIGIN", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "+ORIGIN"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "+ORIGIN"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
PLUS_ORIGIN:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

                pop     hl
                ld      de, Cold_origin
                add     hl, de
                push    hl

                next
                jp      (ix)


//  ______________________________________________________________________
//
                Constant_Def CNEXT      ,   "(NEXT)", Next_Ptr
                New_Def  CNEXT, "(NEXT)", Constant_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "(NEXT)"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "(NEXT)"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CNEXT:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Constant_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      Next_Ptr

//  ______________________________________________________________________
//

                User_Def S0         , "S0"        , 06 // starting value of Stack-Pointer
                New_Def  S0, "S0", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "S0"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "S0"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
S0:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      06
                User_Def R0         , "R0"        , 08 // starting value of Return-Pointer
                New_Def  R0, "R0", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "R0"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "R0"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
R0:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      08
                User_Def TIB        , "TIB"       , 10 // input terminal buffer address
                New_Def  TIB, "TIB", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "TIB"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "TIB"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
TIB:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      10
                User_Def WIDTH      , "WIDTH"     , 12 // maximum number of characters for a word name
                New_Def  WIDTH, "WIDTH", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "WIDTH"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "WIDTH"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
WIDTH:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      12
                User_Def WARNING    , "WARNING"   , 14 // error reporting method: 0 base, 1 verbose
                New_Def  WARNING, "WARNING", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "WARNING"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "WARNING"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
WARNING:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      14
                User_Def FENCE      , "FENCE"     , 16 // minimum address where FORGET can work
                New_Def  FENCE, "FENCE", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "FENCE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "FENCE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
FENCE:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      16
                User_Def DP         , "DP"        , 18 // Dictionary Pointer
                New_Def  DP, "DP", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "DP"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "DP"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DP:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      18
                User_Def VOC_LINK   , "VOC-LINK"  , 20 // pointer to the latest vocabulary
                New_Def  VOC_LINK, "VOC-LINK", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "VOC-LINK"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "VOC-LINK"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
VOC_LINK:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      20
                User_Def FIRST      , "FIRST"     , 22 // address of first buffer
                New_Def  FIRST, "FIRST", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "FIRST"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "FIRST"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
FIRST:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      22
                User_Def LIMIT      , "LIMIT"     , 24 // address of last buffer
                New_Def  LIMIT, "LIMIT", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "LIMIT"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "LIMIT"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
LIMIT:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      24
                User_Def EXP        , "EXP"       , 26 // keeps the exponent in number conversion
                New_Def  EXP, "EXP", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "EXP"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "EXP"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
EXP:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      26
                User_Def NMODE      , "NMODE"     , 28 // number mode: 0 integer, 1 floating point
                New_Def  NMODE, "NMODE", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "NMODE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "NMODE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
NMODE:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      28
                User_Def BLK        , "BLK"       , 30 // block number to be interpreted. 0 for terminal
                New_Def  BLK, "BLK", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "BLK"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "BLK"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
BLK:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      30
                User_Def TO_IN      , ">IN"       , 32 // incremented when consuming input buffer
                New_Def  TO_IN, ">IN", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      ">IN"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      ">IN"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
TO_IN:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      32
                User_Def OUT        , "OUT"       , 34 // incremented when sending to output
                New_Def  OUT, "OUT", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "OUT"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "OUT"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
OUT:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      34
                User_Def SCR        , "SCR"       , 36 // latest screen retreieved by LIST
                New_Def  SCR, "SCR", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "SCR"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "SCR"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
SCR:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      36
                User_Def OFFSET     , "OFFSET"    , 38 //
                New_Def  OFFSET, "OFFSET", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "OFFSET"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "OFFSET"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
OFFSET:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      38
                User_Def CONTEXT    , "CONTEXT"   , 40 // pointer to the vocabulary where search begins
                New_Def  CONTEXT, "CONTEXT", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "CONTEXT"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "CONTEXT"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CONTEXT:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      40
                User_Def CURRENT    , "CURRENT"   , 42 // pointer to the vocabulary where search continues
                New_Def  CURRENT, "CURRENT", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "CURRENT"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "CURRENT"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CURRENT:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      42
                User_Def STATE      , "STATE"     , 44 // compilation status. 0 interpreting.
                New_Def  STATE, "STATE", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "STATE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "STATE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
STATE:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      44
                User_Def BASE       , "BASE"      , 46 //
                New_Def  BASE, "BASE", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "BASE"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "BASE"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
BASE:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      46
                User_Def DPL        , "DPL"       , 48 // number of digits after decimal point in conversion
                New_Def  DPL, "DPL", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "DPL"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "DPL"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DPL:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      48
                User_Def FLD        , "FLD"       , 50 // output field width
                New_Def  FLD, "FLD", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "FLD"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "FLD"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
FLD:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      50
                User_Def CSP        , "CSP"       , 52 // used to temporary store Stack-Pointer value
                New_Def  CSP, "CSP", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "CSP"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "CSP"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CSP:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      52
                User_Def RSHARP     , "R#"        , 54 // location of editing cursor
                New_Def  RSHARP, "R#", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "R#"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "R#"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
RSHARP:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      54
                User_Def HLD        , "HLD"       , 56 // last character during a number conversion output
                New_Def  HLD, "HLD", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "HLD"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "HLD"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
HLD:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      56
                User_Def USE        , "USE"       , 58 // address of last used block
                New_Def  USE, "USE", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "USE"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "USE"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
USE:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      58
                User_Def PREV       , "PREV"      , 60 // address of previous used block
                New_Def  PREV, "PREV", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "PREV"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "PREV"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
PREV:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      60
                User_Def LP         , "LP"        , 62 // line printer (not used)
                New_Def  LP, "LP", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "LP"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "LP"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
LP:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      62
                User_Def PLACE      , "PLACE"     , 64 // number of digits after decimal point in output
                New_Def  PLACE, "PLACE", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "PLACE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "PLACE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
PLACE:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      64
                User_Def SOURCE_ID  , "SOURCE-ID" , 66 // data-stream number in INCLUDE and LOAD-
                New_Def  SOURCE_ID, "SOURCE-ID", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "SOURCE-ID"


len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "SOURCE-ID"               // name string in 7-bit ascii, but


                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
SOURCE_ID:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      66
                User_Def SPAN       , "SPAN"      , 68 // number of character of last EXPECT
                New_Def  SPAN, "SPAN", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "SPAN"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "SPAN"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
SPAN:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      68
                User_Def HANDLER    , "HANDLER"   , 70 // Used by THROW-CATCH
                New_Def  HANDLER, "HANDLER", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "HANDLER"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "HANDLER"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
HANDLER:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      70
                User_Def HP         , "HP"        , 72 // heap-pointer address
                New_Def  HP, "HP", User_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "HP"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "HP"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
HP:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    User_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      72

//  ______________________________________________________________________
//
// here         -- a
                Colon_Def HERE, "HERE", is_normal
                New_Def  HERE, "HERE", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "HERE"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "HERE"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
HERE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      DP, FETCH               // dp @
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// allot        n --
                Colon_Def ALLOT, "ALLOT", is_normal
                New_Def  ALLOT, "ALLOT", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "ALLOT"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "ALLOT"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
ALLOT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      DP,  PLUSSTORE          // dp +!
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// comma        n --
                Colon_Def COMMA, ",", is_normal
                New_Def  COMMA, ",", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      ","
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      ","               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
COMMA:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      HERE, STORE             // here !
                dw      TWO, ALLOT              // 2 allot
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// ccomma       c --
                Colon_Def CCOMMA, "C,", is_normal
                New_Def  CCOMMA, "C,", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "C,"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "C,"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CCOMMA:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      HERE, CSTORE            // here c!
                dw      ONE, ALLOT              // 1 allot
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// s>d          n -- d
// converts a single precision integer in a double precision
                New_Def S_TO_D, "S>D", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "S>D"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "S>D"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
S_TO_D:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl
                ld      a, h
                push    hl
                rla
                sbc     hl, hl
                push    hl
                next
                jp      (ix)

//  ______________________________________________________________________
//
// -            n1 n2 -- n3
// subtraction
                New_Def SUBTRACT, "-", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "-"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "-"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
SUBTRACT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     de
                pop     hl
                and     a
                sbc     hl, de

                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// =            n1 n2 -- n3
// equals
                Colon_Def EQUALS, "=", is_normal
                New_Def  EQUALS, "=", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "="
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "="               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
EQUALS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      SUBTRACT, ZEQUAL        // - 0=
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// u<           u1 u2 -- u3
// unsigned less-than
                New_Def ULESS, "U<", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "U<"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "U<"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
ULESS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     de
                pop     hl
                and     a
                sbc     hl, de
                sbc     hl, hl
                push    hl
                next
                jp      (ix)


//  ______________________________________________________________________
//
// <           n1 n2 -- n3
// less-than
                New_Def LESS, "<", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "<"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "<"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
LESS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     de
                pop     hl
                ld      a, h
                xor     $80
                ld      h, a
                ld      a, d
                xor     $80
                ld      d, a
//              and     a
                sbc     hl, de
                sbc     hl, hl
                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// >            n1 n2 -- n3
// greater than
                Colon_Def GREATER, ">", is_normal
                New_Def  GREATER, ">", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      ">"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      ">"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
GREATER:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      SWAP, LESS              // swap <
                dw      EXIT                    // ;
//  ______________________________________________________________________
//
// min          n1 n2 -- n3
// minimum between n1 and n2
                Colon_Def MIN, "MIN" , is_normal
                New_Def  MIN, "MIN", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "MIN"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "MIN"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
MIN:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      TWO_DUP                 // 2dup
                dw      GREATER                 // >
                dw      ZBRANCH
                dw      Min_Skip - $   // if
                dw          SWAP                //      swap
Min_Skip:                                       // endif
                dw      DROP                    // drop
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// max          n1 n2 -- n3
// maximum between n1 and n2
                Colon_Def MAX, "MAX", is_normal
                New_Def  MAX, "MAX", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "MAX"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "MAX"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
MAX:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      TWO_DUP                 // 2dup
                dw      LESS                    // <
                dw      ZBRANCH
                dw      Max_Skip - $   // if
                dw          SWAP                //      swap
Max_Skip:                                       // endif
                dw      DROP                    // drop
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// ?dup         n -- 0 | n n
// duplicate if not zero
                New_Def QDUP, "?DUP", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "?DUP"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "?DUP"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
QDUP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
QDup_Ptr:
                pop     hl
                ld      a, h
                or      l
                jr      z, QDup_Skip
                    push    hl
QDup_Skip:
                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// -dup         n -- 0 | n n
// duplicate if not zero
                New_Def LDUP, "-DUP", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "-DUP"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "-DUP"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
LDUP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                jp      QDup_Ptr

//  ______________________________________________________________________
//
// emit         c --
                Colon_Def EMIT, "EMIT", is_normal
                New_Def  EMIT, "EMIT", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "EMIT"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "EMIT"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
EMIT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      C_EMIT                      // (?emit)
                dw      QDUP                        // ?dup
                                                    // if
                dw      ZBRANCH
                dw      Emit_Skip - $
                dw          EMITC                   //      emitc
                dw          ONE                     //      1
                dw          OUT, PLUSSTORE        //      out +!
Emit_Skip:                                          // endif
                dw      EXIT                        // ;

//  ______________________________________________________________________
//
// space        --
                Colon_Def SPACE, "SPACE", is_normal
                New_Def  SPACE, "SPACE", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "SPACE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "SPACE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
SPACE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      BL, EMIT                // bl emit
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// traverse     a n -- a
// A dictionary entry is structured as follows
// NFA: +0   one byte of word-length (n<32) | some flags (immediate, smudge) | $80
//      +1   word name, last character is toggled with $80
// LFA: +1+n link to NFA ofprevious  dictionary entry.
// CFA: +3+n routine address. Colon definitions here have a CALL aa
// PFA: +6+n "is_code", definitions have no PFA. // +5
//
                Colon_Def TRAVERSE, "TRAVERSE", is_normal
                New_Def  TRAVERSE, "TRAVERSE", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "TRAVERSE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "TRAVERSE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
TRAVERSE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      SWAP                    // swap
Traverse_Begin:                                 // begin
                dw          OVER, PLUS          //      over +
                dw          LIT, 127            //      127
                dw          OVER, CFETCH        //      over @
                dw          LESS                //      <
                                                // until
                dw      ZBRANCH
                dw      Traverse_Begin - $
                dw      NIP                     //  nip
                dw      EXIT                    //  ;

//  ______________________________________________________________________
//
// latest       -- nfa
                Colon_Def LATEST, "LATEST", is_normal
                New_Def  LATEST, "LATEST", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "LATEST"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "LATEST"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
LATEST:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      CURRENT                 // current
                dw      FETCH, FETCH            // @ @
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// lfa          pfa -- lfa
                Colon_Def LFA, "LFA", is_normal
                New_Def  LFA, "LFA", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "LFA"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "LFA"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
LFA:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      LIT, 5                  // cell- --> 5
                dw      SUBTRACT                // cell- --> -
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// cfa          pfa -- cfa
                Colon_Def CFA, "CFA", is_normal
                New_Def  CFA, "CFA", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "CFA"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "CFA"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CFA:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
//              dw      CELL_MINUS              // cell-
                dw      THREE, SUBTRACT         // 3 -
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// nfa          pfa -- nfa
                Colon_Def NFA, "NFA", is_normal
                New_Def  NFA, "NFA", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "NFA"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "NFA"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
NFA:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      LIT, 6                  // 5 --> 6
                dw      SUBTRACT                // -
                dw      NEG_ONE                 // -1
                dw      TRAVERSE                // traverse
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// pfa          nfa -- pfa
                Colon_Def PFA, "PFA", is_normal
                New_Def  PFA, "PFA", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "PFA"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "PFA"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
PFA:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      ONE                     // 1
                dw      TRAVERSE                // traverse
                dw      LIT, 6                  // 5 --> 6
                dw      PLUS                    // +
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// >body        cfa -- pfa
                Colon_Def TO_BODY, ">BODY", is_normal
                New_Def  TO_BODY, ">BODY", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      ">BODY"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      ">BODY"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
TO_BODY:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      THREE, PLUS             // cell+ --> 3 +
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// <name        cfa -- nfa
                Colon_Def TO_NAME, "<NAME", is_normal
                New_Def  TO_NAME, "<NAME", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "<NAME"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "<NAME"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
TO_NAME:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      TO_BODY                 // >body
                dw      NFA                     // nfa
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// !csp         --
// store in user variable CSP current value of SP. Used at compile-time for syntax checkng
                Colon_Def STORE_CSP, "!CSP", is_normal
                New_Def  STORE_CSP, "!CSP", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "!CSP"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "!CSP"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
STORE_CSP:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      SPFETCH                 // sp@
                dw      CSP, STORE              // csp !
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// ?error       f n --
// rase error n if flag f it true
                Colon_Def QERROR, "?ERROR", is_normal
                New_Def  QERROR, "?ERROR", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "?ERROR"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "?ERROR"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
QERROR:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      SWAP                    // swap
                                                // if
                dw      ZBRANCH
                dw      QError_Else - $
                dw          ERROR               //      error  ( is a forward-ref )
                                                // else
                dw      BRANCH
                dw      QError_Endif - $
QError_Else:
                dw          DROP                //      drop
QError_Endif:                                   // endif
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// ?comp       --
// raise msg #17 if not compiling
                Colon_Def QCOMP, "?COMP", is_normal
                New_Def  QCOMP, "?COMP", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "?COMP"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "?COMP"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
QCOMP:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      STATE, FETCH            // state @
                dw      ZEQUAL                  // 0=
                dw      LIT, 17                 // 17  ( can't be executed )
                dw      QERROR                  // ?error
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// ?exec       --
// raise msg #18 if compiling
                Colon_Def QEXEC, "?EXEC", is_normal
                New_Def  QEXEC, "?EXEC", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "?EXEC"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "?EXEC"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
QEXEC:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      STATE, FETCH            // state @
                dw      LIT, 18                 // 18  ( can't be compiled )
                dw      QERROR                  // ?error
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// ?pairs       n1 n2 --
// raise msg #19 if n1 != n2. Compiler pushes some placeholder to stack for syntax checking
                Colon_Def QPAIRS, "?PAIRS", is_normal
                New_Def  QPAIRS, "?PAIRS", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "?PAIRS"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "?PAIRS"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
QPAIRS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      SUBTRACT                // -
                dw      LIT, 19                 // 18  ( syntax error )
                dw      QERROR                  // ?error
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// ?csp       --
// raise msg #20 if surrent SP in not what previously saved in CSP.
// Compiler relies on that for  syntax checking of structures
                Colon_Def QCSP, "?CSP", is_normal
                New_Def  QCSP, "?CSP", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "?CSP"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "?CSP"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
QCSP:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      SPFETCH                 // sp@
                dw      CSP, FETCH              // csp @
                dw      SUBTRACT                // -
                dw      LIT, 20                 // 20  ( bad definition end )
                dw      QERROR                  // ?error
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// ?loading      --
// raise msg #22 if not loading
                Colon_Def QLOADING, "?LOADING", is_normal
                New_Def  QLOADING, "?LOADING", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "?LOADING"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "?LOADING"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
QLOADING:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      BLK, FETCH              // blk @
                dw      ZEQUAL                  // 0=
                dw      LIT, 22                 // 22  ( aren't loading now )
                dw      QERROR                  // ?error
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// compile      --
// compiles the following word
                Colon_Def COMPILE, "COMPILE", is_normal
                New_Def  COMPILE, "COMPILE", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "COMPILE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "COMPILE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
COMPILE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      QCOMP                   // ?comp
                dw      R_TO                    // r>
                dw      DUP, CELL_PLUS          // dup, cell+
                dw      TO_R                    // >r
                dw      FETCH, COMMA            // @ ,
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// compile,     --
// compiles the following word
                Colon_Def COMPILE_XT, "COMPILE,", is_normal
                New_Def  COMPILE_XT, "COMPILE,", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "COMPILE,"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "COMPILE,"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
COMPILE_XT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      QCOMP                   // ?comp
                dw      COMMA                   // ,
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// [            --
// stop compilation
                Colon_Def SQUARED_OPEN, "[", is_immediate
                New_Def  SQUARED_OPEN, "[", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "["
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "["               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
SQUARED_OPEN:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      ZERO                    // 0
                dw      STATE, STORE            // state !
                dw      EXIT                    // ; immediate

//  ______________________________________________________________________
//
// ]            --
// start compilation
                Colon_Def SQUARED_CLOSE, "]", is_normal
                New_Def  SQUARED_CLOSE, "]", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "]"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "]"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
SQUARED_CLOSE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      LIT, $C0                // 192
                dw      STATE, STORE            // state !
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// smudge       --
// toggle smudge bit of latest definition
                Colon_Def SMUDGE, "SMUDGE", is_normal
                New_Def  SMUDGE, "SMUDGE", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "SMUDGE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "SMUDGE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
SMUDGE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      LATEST                  // latest
                dw      LIT, SMUDGE_BIT         // 32
                dw      TOGGLE                  // toggle
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// immediate    --
// make immediate the latest definition
                Colon_Def IMMEDIATE, "IMMEDIATE", is_normal
                New_Def  IMMEDIATE, "IMMEDIATE", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "IMMEDIATE"


len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "IMMEDIATE"               // name string in 7-bit ascii, but


                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
IMMEDIATE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      LATEST                  // latest
                dw      LIT, $40                // 64
                dw      TOGGLE                  // toggle
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// hex          --
// change numeration base
                Colon_Def HEX, "HEX", is_normal
                New_Def  HEX, "HEX", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "HEX"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "HEX"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
HEX:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      LIT, 16                 // 16
                dw      BASE, STORE             // base !
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// decimal      --
// change numeration base
                Colon_Def DECIMAL, "DECIMAL", is_normal
                New_Def  DECIMAL, "DECIMAL", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "DECIMAL"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "DECIMAL"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DECIMAL:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      LIT, 10                 // 10
                dw      BASE, STORE             // base !
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// (;code)       --
// patch to CFA to call/jump to the "following code"
                Colon_Def C_SEMICOLON_CODE, "(;CODE)", is_normal
                New_Def  C_SEMICOLON_CODE, "(;CODE)", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "(;CODE)"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "(;CODE)"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
C_SEMICOLON_CODE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      R_TO                    // r>       ( Return Stack has IP to caller's next cell )
                dw      LATEST                  // latest   ( Word being defined in this moment )
                dw      PFA, CFA                // pfa cfa  ( cfa of latest word )

                dw      LIT, $CD                // $CD      ( At Latest CFA put "call" op-code )
                dw      OVER, CSTORE            // over c!  ( why can't use comma? because CFA was already ALLOTted by create? )
                dw      ONE_PLUS                // 1+       ( At Latest CFA+1 put address for call. )

                dw      STORE                   // !
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// ;code        --
                Colon_Def SEMICOLON_CODE, ";CODE", is_immediate
                New_Def  SEMICOLON_CODE, ";CODE", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      ";CODE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      ";CODE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
SEMICOLON_CODE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      QCSP                    // ?csp
                dw      COMPILE                 // compile
                dw      C_SEMICOLON_CODE        // (;code)
                dw      SQUARED_OPEN            // [
                dw      NOOP                    // noop () can be patched later to ASSEMBLER... )
                dw      EXIT                    // ; immediate

//  ______________________________________________________________________
//
// <builds      --
                Colon_Def CBUILDS, "<BUILDS", is_normal
                New_Def  CBUILDS, "<BUILDS", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "<BUILDS"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "<BUILDS"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CBUILDS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      ZERO                    // 0
                dw      CONSTANT                // constant
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// recurse      --
//              Colon_Def RECURSE, "RECURSE", is_immediate
//              dw      QCOMP                   // ?comp
//              dw      LATEST                  // latest
//              dw      PFA, CFA                // pfa cfa
//              dw      COMMA                   // ,
//              dw      EXIT                    // ; immediate

//  ______________________________________________________________________
//
// does>     --
                Colon_Def DOES_TO, "DOES>", is_normal
                New_Def  DOES_TO, "DOES>", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "DOES>"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "DOES>"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DOES_TO:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      R_TO                    // r>
                dw      LATEST                  // latest
                dw      PFA                     // pfa
                dw      STORE                   // !
                dw      C_SEMICOLON_CODE        // ;code
Does_Ptr:
                // via call coded in CFA
                ldhlrp
                ld      hl,(RP_Pointer)
                dec     hl                  // push on Return-Stack current Instruction-Pointer
                ld      (hl), b
                dec     hl
                ld      (hl), c
                ldrphl
                ld      (RP_Pointer),hl
                pop     hl                  // CFA has a call to this, so PFA -> IP

                ld      c, (hl)
                inc     hl
                ld      b, (hl)
                inc     hl

                psh1
                push    hl
                jp      (ix)
                // SMUDGE !

//  ______________________________________________________________________
//
// count        a -- a2 n
// expects a counted string at address a, returns string address and counter
                New_Def COUNT, "COUNT", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "COUNT"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "COUNT"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
COUNT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl
                ld      e, (hl)
                ld      d, 0
                inc     hl
Count_Ptr:
                push    hl
                push    de
                next
                jp      (ix)

//  ______________________________________________________________________
//
// bounds       a n -- a+n n
// given an address and a length ( a n ) calculate the bound addresses
// suitable for DO-LOOP
                New_Def BOUNDS, "BOUNDS", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "BOUNDS"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "BOUNDS"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
BOUNDS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl
                pop     de
                add     hl, de
                jr      Count_Ptr

//  ______________________________________________________________________
//
// leave        --
// Compile (leave) to leave current LOOP and jump just after it
                Colon_Def LEAVE, "LEAVE", is_immediate
                New_Def  LEAVE, "LEAVE", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "LEAVE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "LEAVE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
LEAVE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      COMPILE, C_LEAVE       // compile (leave)     \ unloop and branch
                dw      HERE, TO_R, ZERO, COMMA // here >r 0 ,

                dw      ZERO, ZERO
                dw      SPFETCH, DUP
                dw      CELL_PLUS, CELL_PLUS
                dw      TUCK
                dw      CSP, FETCH
                dw      SWAP, SUBTRACT
                dw      CMOVE
                dw      CSP, FETCH, CELL_MINUS

                dw      R_TO, OVER, STORE

                dw      CELL_MINUS, ZERO
                dw      SWAP, STORE
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// type         a n --
// Sends to current output channel n characters starting at address a.
                Colon_Def TYPE, "TYPE", is_normal
                New_Def  TYPE, "TYPE", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "TYPE"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "TYPE"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
TYPE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      BOUNDS                  // bounds
                dw      C_Q_DO                  // ?do
                dw      Type_Skip - $
Type_Loop:
                dw          I, CFETCH           //      i c@
                dw          EMIT                //      emit
                dw      C_LOOP                  // loop
                dw      Type_Loop - $
Type_Skip:
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// -trailing    a n1 -- a n2
// Assumes that an n1 bytes-long string is stored at address a
// and the string contains a space delimited word,
// Finds n2 as the position of the first character after the word.
                Colon_Def LTRAILING, "-TRAILING", is_normal
                New_Def  LTRAILING, "-TRAILING", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "-TRAILING"


len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "-TRAILING"               // name string in 7-bit ascii, but


                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
LTRAILING:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      DUP, ZERO               // dup 0
                                                // do
                dw      C_Q_DO
                dw      LTrailing_Leave - $
LTrailing_Loop:
                dw          TWO_DUP, PLUS       //      2dup +
                dw          ONE_SUBTRACT        //      1-
                dw          CFETCH              //      c@
                dw          BL, SUBTRACT        //      bl -
                                                //      if
                dw          ZBRANCH
                dw          LTrailing_Else - $
                dw              C_LEAVE         //          leave
                dw              LTrailing_Leave - $
                dw          BRANCH              //      else
                dw          LTrailing_Endif - $
LTrailing_Else:
                dw              ONE_SUBTRACT    //          1-
LTrailing_Endif:                                //      endif
                                                // loop
                dw      C_LOOP
                dw      LTrailing_Loop - $
LTrailing_Leave:
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// accept       a n1 -- n2
// Accepts at most n1 characters from terminal and stores them at address a
// CR stops input. A 'nul' is added as trailer.
// n2 is the string length. n2 is kept in span user variable also.
                Colon_Def ACCEPT, "ACCEPT", is_normal
                New_Def  ACCEPT, "ACCEPT", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "ACCEPT"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "ACCEPT"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
ACCEPT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      OVER, PLUS, OVER        //                      ( a  n1+a  a )

                dw      ZERO, DASH_ROT          //                      ( a  0     a+n1  a )
                                                // do
                dw      C_Q_DO
                dw      Accept_Leave - $
Accept_Loop:
                dw          CUR
                dw          DROP, KEY           //      drop key        ( a  c )
                dw          DUP                 //      dup             ( a  c  c )
                dw          LIT, $0E            //      0E
                dw          PLUS_ORIGIN         //      +origin
                dw          FETCH               //      @               ( a  c  c  del )
                dw          EQUALS              //      =               ( a  c  c==del )
                                                //      if
                dw          ZBRANCH
                dw          Accept_Else_0 - $
                dw              DROP            //          drop        ( a  )
                dw              DUP, I, EQUALS  //          dup i =     ( a  a==i )

                dw              ONE, AND_OP     //          1 and
                dw              DUP             //          dup         ( a  a==i  a==i )
                dw              R_TO            //          r> 2 - + r>
                dw              TWO_MINUS, PLUS //      ( decrement index by 1 or 2 )
                dw              TO_R            //
                                                //          if
                dw              ZBRANCH
                dw              Accept_Else_1 - $
                dw                  LIT, 7      //              7       ( a  7 )
                                                //          else
                dw              BRANCH
                dw              Accept_Endif_1 - $
Accept_Else_1:
                dw                  LIT, 8      //              8       ( a  8 )
Accept_Endif_1:                                 //          endif
                dw          BRANCH
                dw          Accept_Endif_0 - $
Accept_Else_0:                                  //      else
                dw              DUP             //          dup         ( a  c  c )
                dw              LIT, 13         //          13
                dw              EQUALS          //          =           ( a  c  c==CR )
                                                //          if
                dw              ZBRANCH
                dw              Accept_Else_2 - $
                dw                  DROP, BL    //              drop bl ( a  bl )
                dw                  ZERO        //              0       ( a  c  0 )
                                                //          else
                dw              BRANCH
                dw              Accept_Endif_2 - $
Accept_Else_2:
                dw                  DUP         //              dup     ( a  c  c )
                                                //          endif
Accept_Endif_2:
                dw              I, CSTORE       //          i           ( a  c )
                dw              DUP, BL, LESS   //          dup bl <    ( a  c  c<BL )

                                                //          if
                dw              ZBRANCH
                dw              Accept_Endif_3 - $
                dw                  R_TO        //              r>
                dw                  ONE_SUBTRACT//              1-
                dw                  TO_R        //              >r
                                                //          endif
Accept_Endif_3:
Accept_Endif_0:                                 //      endif
                dw          EMIT                //      emit
                dw          ZERO, I, ONE_PLUS   //      0 i 1+ !

                dw          STORE               //          ( zero pad )
                dw          I                   //      i
                dw          I, CFETCH, ZEQUAL   //      i 0= if

                dw          ZBRANCH             //
                dw              Accept_Endif_4 - $
                dw                  C_LEAVE     //              leave
                dw                  Accept_Leave - $
Accept_Endif_4:                                 //      endif
                                                // loop
                dw      C_LOOP
                dw      Accept_Loop - $
Accept_Leave:
                dw      SWAP, SUBTRACT          // swap -
                dw      ONE_PLUS                // 1+
                dw      DUP, SPAN, STORE        // dup span !

                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// expect      a n --
// Accepts at most n1 characters from terminal and stores them at address a
// CR stops input. A 'nul' is added as trailer.
// n2 is the string length. n2 is kept in span user variable also.
//              Colon_Def EXPECT, "EXPECT", is_normal
//              dw      ACCEPT, DROP            // accept drop
//              dw      EXIT                    // ;

//  ______________________________________________________________________
//
// query        --
// Accept at most 80 character from console. CR stops.
// Text is stored in TIB. Variable IN is zeroed.
                Colon_Def QUERY, "QUERY", is_normal
                New_Def  QUERY, "QUERY", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "QUERY"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "QUERY"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
QUERY:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      TIB, FETCH              // tib @
                dw      LIT, 80                 // 80
                dw      ACCEPT, DROP            // accept drop
                dw      ZERO, TO_IN, STORE      // 0 >in !

                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// fill        a n c --
// If n > 0, fills n locations starting from address a with the value c.
                New_Def FILL, "FILL", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "FILL"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "FILL"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
FILL:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                exx
                pop     de                  // de has character
                pop     bc                  // bc has counter
                pop     hl                  // hl has address, save Instruction Pointer
Fill_Loop:
                    ld      a, b
                    or      c
                jr      z, Fill_While_End
                    ld      (hl), e
                    dec     bc
                    inc     hl
                jr      Fill_Loop
Fill_While_End:
                exx
                next
                jp      (ix)

//  ______________________________________________________________________
//
// erase        a n --
// If n > 0, fills n locations starting from address a with 'nul' characters.
                Colon_Def ERASE, "ERASE", is_normal
                New_Def  ERASE, "ERASE", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "ERASE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "ERASE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
ERASE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      ZERO, FILL              // 0 fill
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// blank        a n --
// If n > 0, fills n locations starting from address a with 'nul' characters.
                Colon_Def BLANK, "BLANK", is_normal
                New_Def  BLANK, "BLANK", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "BLANK"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "BLANK"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
BLANK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      BL, FILL                // bl fill
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// hold         c --
// Used between <# and #> to insert a character c in numeric formatting.
                Colon_Def HOLD, "HOLD", is_normal
                New_Def  HOLD, "HOLD", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "HOLD"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "HOLD"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
HOLD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      NEG_ONE                 // -1
                dw      HLD, PLUSSTORE          // hld +!
                dw      HLD, FETCH, CSTORE      // hld @ c!

                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// pad         -- a
// leaves the buffer text address. This is at a fixed distance over HERE.
                Colon_Def PAD, "PAD", is_normal
                New_Def  PAD, "PAD", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "PAD"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "PAD"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
PAD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      HERE                    // here
                dw      LIT, 68                 // 68
                dw      PLUS                    // +
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// word         c -- a
// reads characters from input streams until it encouners a c delimiter.
// Stores that packet so it starts from HERE
// WORD leaves a counter as first byte and ends the packet with two spaces.
// Other occurrences of c are ignored.
// If BLK is zero, text is taken from terminal buffer TIB.
// Otherwise text is taken from the disk-block given by BLK.
// "in" variable is incremented of the number of character read.
// The number of characters read is given by ENCLOSE.
                Colon_Def WORD, "WORD", is_normal
                New_Def  WORD, "WORD", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "WORD"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "WORD"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
WORD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      BLK, FETCH              // blk @
                                                // if
                dw      ZBRANCH
                dw      Word_Else - $
                dw          BLK, FETCH          //      blk @
                dw          BLOCK               //      block ( forward )
                                                // else
                dw      BRANCH
                dw      Word_Endif - $
Word_Else:
                dw         TIB, FETCH           //      tib @
Word_Endif:                                     // endif
                dw      TO_IN, FETCH, PLUS      // >in @ +

                dw      SWAP, ENCLOSE           // swap enclose
                dw      HERE, LIT, 34, BLANK    // here 34 blank

                dw      TO_IN, PLUSSTORE        // >in @ +
                dw      OVER, SUBTRACT, TO_R    // over - >r

                dw      R_OP, HERE, CSTORE      // r here c!

                dw      PLUS                    // +
                dw      HERE, ONE_PLUS, R_TO    // here 1+ r>

                dw      CMOVE                   // cmove
                dw      HERE                    // here
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// (.")         --
// Direct procedure compiled by ." and  .(  It executes TYPE.
                Colon_Def C_DOT_QUOTE, '(.")', is_normal
                New_Def  C_DOT_QUOTE, '(.")', Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      '(.")'
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      '(.")'               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
C_DOT_QUOTE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      R_OP, COUNT             // r count
                dw      DUP, ONE_PLUS           // dup 1+
                dw      R_TO, PLUS, TO_R        // r> + >r  ( advance IP )

                dw      TYPE                    // type
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// char         -- c
// get first character from next input word
                Colon_Def CHAR,  "CHAR", is_normal
                New_Def  CHAR, "CHAR", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "CHAR"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "CHAR"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CHAR:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      BL, WORD                // bl word
                dw      ONE_PLUS, CFETCH        // 1+ c@
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// ,"           --
// compiles a string terminated by " as a counted string from next input stream
                Colon_Def COMMA_QUOTE,  ',"', is_normal
                New_Def  COMMA_QUOTE, ',"', Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      ',"'
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      ',"'               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
COMMA_QUOTE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      LIT, DQUOTE_CHAR        // [char] "
                dw      WORD                    // word
                dw      CFETCH, ONE_PLUS        // c@ 1+
                dw      ALLOT                   // allot
                dw      ZERO, CCOMMA            // 0 c,  ( nul-terminated string - useful anyway )
                dw      EXIT

//  ______________________________________________________________________
//
// .c           c --
// intermediate general purpose string builder, used by ." and .(
                Colon_Def DOT_C,  ".C", is_immediate
                New_Def  DOT_C, ".C", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      ".C"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      ".C"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DOT_C:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      STATE, FETCH            // state @
                                                // if
                dw      ZBRANCH
                dw      Dot_C_Else - $
                dw          COMPILE, C_DOT_QUOTE //     compile (.")
                dw          WORD, CFETCH        //      word c@
                dw          ONE_PLUS, ALLOT     //      1+ allot
                                                // else
                dw      BRANCH
                dw      Dot_C_Endif - $
Dot_C_Else:
                dw          WORD, COUNT, TYPE   //      word count type

Dot_C_Endif:                                    // endif
                dw      EXIT                    ;

//  ______________________________________________________________________
//
// ."           c --
                Colon_Def DOT_QUOTE,  '."', is_immediate
                New_Def  DOT_QUOTE, '."', Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      '."'
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      '."'               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DOT_QUOTE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      LIT, DQUOTE_CHAR        // [char] "
                dw      DOT_C                   // [compile] .c
                dw      EXIT                    // ; immediate

//  ______________________________________________________________________
//
// .(           c --
                Colon_Def DOT_BRACKET,  ".(", is_immediate
                New_Def  DOT_BRACKET, ".(", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      ".("
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      ".("               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DOT_BRACKET:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      LIT, ")"                // [char] )
                dw      DOT_C                   // [compile] .c
                dw      EXIT                    // ; immediate

//  ______________________________________________________________________
//
// (sgn)        a -- a f
// determines if char in addr a is a sign (+ or -), and in that case increments
// a flag. Returns f as the sign, true for negative, false for positive.
// called by NUMBER and (EXP)
                Colon_Def CSGN,  "(SGN)", is_normal
                New_Def  CSGN, "(SGN)", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "(SGN)"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "(SGN)"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CSGN:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      DUP, ONE_PLUS, CFETCH   // dup 1+ c@

                dw      DUP, LIT, "-", EQUALS   // dup [char] - =

                                                // if
                dw      ZBRANCH
                dw      CSgn_Else_0 - $
                dw          DROP                //      drop
                dw          ONE_PLUS            //      1+
                dw          ONE, DPL, PLUSSTORE //      1 dpl +!

                dw          ONE                 //      1
                                                // else
                dw      BRANCH
                dw      CSgn_Endif_0 - $
CSgn_Else_0:
                dw          LIT, "+", EQUALS    //      [char] + =

                                                //      if
                dw          ZBRANCH
                dw          CSgn_Endif_1 - $
                dw              ONE_PLUS        //          1+
                dw              ONE, DPL        //          1 dpl
                dw              PLUSSTORE       //          +!
CSgn_Endif_1                                    //      endif
                dw          ZERO                //      0
CSgn_Endif_0:                                   // endif
                dw      EXIT

//  ______________________________________________________________________
//
// (number)     d a -- d1 a1
// using the current BASE parse characters stored in address a
// accumulating a double precision integer d
// the process stops at the first not-convertible character
// A double-number is kept in CPU registers as HLDE.
// On the stack a double number is treated as two single numbers
// where HL is on the top of the stack and DE is the second from top,
// so in the stack memory it appears as LHED.
// Instead, in 2VARIABLE a double number is stored as EDLH.
                Colon_Def CNUMBER,  "(NUMBER)", is_normal
                New_Def  CNUMBER, "(NUMBER)", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "(NUMBER)"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "(NUMBER)"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CNUMBER:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                                                // begin
CNumber_Begin:
                dw          ONE_PLUS            //      1+
                dw          DUP, TO_R           //      dup >r
                dw          CFETCH              //      @
                dw          BASE, FETCH         //      base @
                dw          DIGIT               //      digit
                                                // while
                dw      ZBRANCH
                dw      CNumber_While_end - $
                dw          SWAP                //      swap
                dw          BASE, FETCH         //      base @
                dw          UM_MUL              //      um*
                dw          DROP, ROT           //      drop rot
                dw          BASE, FETCH         //      base @
                dw          UM_MUL              //      um*
                dw          DPLUS               //      d+
                dw          DPL, FETCH          //      dpl @
                dw          ONE_PLUS            //      1+
                                                //      if
                dw          ZBRANCH
                dw          CNumber_Endif - $
                dw              ONE, DPL        //          1 dpl
                dw              PLUSSTORE       //          +!
CNumber_Endif:                                  //      endif
                dw             R_TO             //      r>  ( balance rp )
                dw      BRANCH
                dw      CNumber_Begin - $
CNumber_While_end:                              // repeat
                dw      R_TO                    // r>  ( balance rp on exit while-repeat )
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// number       a -- d
                Colon_Def NUMBER,  "NUMBER", is_normal
                New_Def  NUMBER, "NUMBER", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "NUMBER"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "NUMBER"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
NUMBER:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      ZERO, ZERO              // 0 0
                dw      ROT                     // rot
                dw      CSGN, TO_R              // (sgn) >r
                dw      NEG_ONE, DPL, STORE     // -1 dpl !

                dw      CNUMBER                 // (number)
                dw      DUP, CFETCH             // dup c@
                dw      LIT, 46, EQUALS         // [char] . =  ( decimal point )

                                                // if
                dw      ZBRANCH
                dw      Number_Endif_1 - $
                dw          ZERO, DPL, STORE    //      0 dpl !

                dw          CNUMBER             //      (number)
Number_Endif_1:                                 // endif
                dw      CFETCH, BL              // c@ bl
                dw      SUBTRACT, ZERO, QERROR  // - 0 ?error

                dw      R_TO                    // r>
                                                // if
                dw      ZBRANCH
                dw      Number_Endif_2 - $
                dw          DMINUS              //      dminus
Number_Endif_2:                                 // endif
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// -find        a -- d
                Colon_Def LFIND,  "-FIND", is_normal
                New_Def  LFIND, "-FIND", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "-FIND"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "-FIND"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
LFIND:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      BL, WORD                // bl word
                dw      CONTEXT, FETCH, FETCH   // context @ @

                dw      C_FIND                  // (find)
                dw      QDUP                    // ?dup
                dw      ZEQUAL                  // 0=
                                                // if
                dw      ZBRANCH
                dw      LFind_Endif - $
                dw          HERE                //      here
                dw          LATEST              //      latest
                dw          C_FIND              //      (find)
LFind_Endif:                                    // endif
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// (abort)      --
                Colon_Def CABORT,  "(ABORT)", is_normal
                New_Def  CABORT, "(ABORT)", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "(ABORT)"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "(ABORT)"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CABORT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      ABORT                   // abort
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// error        n --
// raise an error
// if WARNING is 0, prints "MSG#n".
// if WARNING is 1, prints line n of screen 4.
// if WARNING is -1 does (ABORT) that normally does ABORT
// value can be negative or beyond block 4.
                Colon_Def ERROR,  "ERROR", is_normal
                New_Def  ERROR, "ERROR", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "ERROR"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "ERROR"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
ERROR:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      WARNING, FETCH, ZLESS   // warning @ 0<

                                                // if
                dw      ZBRANCH
                dw      Error_Endif_1 - $
                dw          CABORT              //      (abort)
Error_Endif_1:                                  // endif
                dw      HERE, COUNT, TYPE       // here count type

                dw      C_DOT_QUOTE             // .( ? )
                db      2, "? "
                dw      MESSAGE                 // message  ( forward )
                dw      S0, FETCH, SPSTORE      // s0 @ sp!

                dw      BLK, FETCH, QDUP        // blk @ ?dup

                                                // if
                dw      ZBRANCH
                dw      Error_Endif_2 - $
                dw          TO_IN, FETCH, SWAP  //      >in @ swap

Error_Endif_2:                                  // endif
                dw      QUIT                    // quit ( forward )
                dw      EXIT                    // ;
//  ______________________________________________________________________
//
// id.          nfa --
                Colon_Def ID_DOT,  "ID.", is_normal
                New_Def  ID_DOT, "ID.", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "ID."
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "ID."               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
ID_DOT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      PAD, LIT, 32, LIT, 96   // pad 32 96


                dw      FILL                    // fill
                dw      DUP, PFA, LFA           // dup pfa lfa

                dw      OVER, SUBTRACT          // over -
                dw      PAD, SWAP               // pad swap
                dw      CMOVE                   // cmove
                dw      PAD, COUNT, LIT, $1F    // pad count 01F

                dw      AND_OP                  // and  ( use only lower bits )
                dw      TYPE, SPACE             // type
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// code         -- cccc
                Colon_Def CODE,  "CODE", is_normal
                New_Def  CODE, "CODE", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "CODE"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "CODE"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CODE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      LFIND                   // -find
                                                // if
                dw      ZBRANCH
                dw      Code_Endif - $
                dw          DROP                //      drop
                dw          TO_NAME, ID_DOT     //      >name id.
                dw          LIT, 4, MESSAGE     //      4 message

                dw          SPACE               //      space
Code_Endif:                                     // endif
                dw      HERE                    // here
                                                // ( ---- here begins NFA ---- )
                dw      DUP, CFETCH             // dup c@
                dw      WIDTH, FETCH, MIN       // width @ min  ( max 31 character length )

                dw      ONE_PLUS, ALLOT         // 1+ allot
                dw      DUP                     // dup
                dw      LIT
                dw      SMUDGE_BIT | END_BIT    // 160
                dw      TOGGLE                  // toggle
                dw      HERE, ONE_SUBTRACT      // here 1- ( last character )
                dw      LIT, END_BIT, TOGGLE    // 128 toggle

                                                // ( ---- here is LFA ---- )
                dw      LATEST, COMMA           // latest ,
                dw      CURRENT, FETCH, STORE   // current @ ! ( save this word as the latest )

                                                // ( ---- here is LFA ---- )
//              dw      HERE, CELL_PLUS, COMMA  // ( CFA is empty and PFA yet to exist )
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// create       -- cccc     ( compile time )
//              -- a        ( run time )
                Colon_Def CREATE,  "CREATE", is_normal
                New_Def  CREATE, "CREATE", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "CREATE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "CREATE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CREATE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      CODE, SMUDGE            // code smudge
                dw      LIT, $CD, CCOMMA        // 00CD c,

                dw      LIT, Variable_Ptr, COMMA// Variable_Ptr ,

                dw      C_SEMICOLON_CODE
                // this routine is called from the call coded in CFA
Create_Ptr:



                next
                jp      (ix)

//  ______________________________________________________________________
//
// [compile]    -- cccc     ( compile time )
                Colon_Def COMPILE_IMMEDIATE,  "[COMPILE]", is_immediate
                New_Def  COMPILE_IMMEDIATE, "[COMPILE]", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "[COMPILE]"


len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "[COMPILE]"               // name string in 7-bit ascii, but


                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
COMPILE_IMMEDIATE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      LFIND                   // -find      (  cfa  b  f  )
                dw      ZEQUAL                  // 0=         (  cfa  b  )
                dw      ZERO, QERROR            // 0 ?error
                dw      DROP                    // drop       (  cfa  )
                dw      COMMA                   // ,
                dw      EXIT                    // ; immediate

//  ______________________________________________________________________
//
// literal      n --      ( compile time )
                Colon_Def LITERAL,  "LITERAL", is_immediate
                New_Def  LITERAL, "LITERAL", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "LITERAL"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "LITERAL"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
LITERAL:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      STATE, FETCH            // state @
                                                // if
                dw      ZBRANCH
                dw      Literal_Endif - $
                dw          COMPILE, LIT        //      compile lit
                dw          COMMA               //      ,
Literal_Endif:                                  // endif
                dw      EXIT                    // ; immediate

//  ______________________________________________________________________
//
// dliteral     n --      ( compile time )
                Colon_Def DLITERAL,  "DLITERAL", is_immediate
                New_Def  DLITERAL, "DLITERAL", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "DLITERAL"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "DLITERAL"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DLITERAL:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      STATE, FETCH            // state @
                                                // if
                dw      ZBRANCH
                dw      DLiteral_Endif - $
                dw          SWAP                //      swap
                dw          LITERAL,  LITERAL   //      [compile] literal [compile] literal
DLiteral_Endif:                                 // endif
                dw      EXIT                    // ; immediate

//  ______________________________________________________________________
//
// [char]       n --      ( compile time )
// inside colon definition, gets first character from next input word
// and compiles it as literal.
                Colon_Def COMPILE_CHAR,  "[CHAR]", is_immediate
                New_Def  COMPILE_CHAR, "[CHAR]", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "[CHAR]"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "[CHAR]"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
COMPILE_CHAR:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      CHAR, LITERAL           // char [compile] literal
                dw      EXIT                    // ; immediate

//  ______________________________________________________________________
//
// 0x00         n --      ( compile time )
                Colon_Def NUL_WORD,  $00, is_immediate
                New_Def  NUL_WORD, $00, Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      $00
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      $00               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
NUL_WORD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      BLK, FETCH, ONE         // blk @ 1

                dw      GREATER                 // > if
                                                // if
                dw      ZBRANCH
                dw      Nul_Else_1 - $
                dw          ONE, BLK, PLUSSTORE //      1 blk +!

                dw          ZERO, TO_IN, STORE  //      0 >in !

                dw          BLK, FETCH          //      blk @
                dw          BSCR                //      b/scr
                dw          ONE_SUBTRACT        //      1 -
                dw          AND_OP              //      and  ( this is tricky )
                dw          ZEQUAL              //      0=
                                                //      if
                dw          ZBRANCH
                dw          Nul_Endif_2 - $
                dw              QEXEC           //          ?exec
                dw              R_TO, DROP      //          r> drop
Nul_Endif_2:                                    //      endif
                dw      BRANCH
                dw      Nul_Endif_1 - $
Nul_Else_1:                                     // else
                dw          R_TO, DROP          //      r> drop
Nul_Endif_1:                                    // endif
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// ?stack       --
// Raise error #1 if stack is empty and you pop it
// Raise error #7 if stack is full.
// This means SP must always stay between HERE and FFFF
// For 128K BANK paging purpose SP must be <= BFE0 and 50 words room
// for Next 8K MMU paging this is $DOE8
                Colon_Def QSTACK, "?STACK", is_normal
                New_Def  QSTACK, "?STACK", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "?STACK"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "?STACK"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
QSTACK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      SPFETCH                 // sp@
                dw      S0, FETCH               // s0 @
                dw      SWAP, ULESS             // swap u<
                dw      ONE, QERROR             // 1 ?error
                dw      HERE                    // here
                dw      S0, FETCH, LESS         // s0 @ <

                                                // if
                dw      ZBRANCH
                dw      QStack_Endif - $
                dw          SPFETCH             //      sp@
                dw          HERE, LIT, 128      //      here 128

                dw          PLUS, ULESS         //      plus u<
                dw          LIT, 7, QERROR      //      7 Cerror

QStack_Endif:                                   // endif
                dw      EXIT                    // ;


ect\Projects\vForth15_DIRECT/source/L1.asm
                include "L2.asm"
ect\Projects\vForth15_DIRECT/source/L2.asm
//  ______________________________________________________________________
//
//  L2.asm
//
//  Level-2
//  the Forth interpreter, vocabulary, cold/warm start and quit from Forth.
//  ______________________________________________________________________


//  ______________________________________________________________________
//
// interpret    --
// This is the text interpreter.
// It executes or compiles, depending on STATE, the text coming from
// current input stream.
// If the word search fails after parsing CONTEXT and CURRENT vocabulary,
// the word is interpreted as numeric and converted, using current BASE,
// leaving on top of stack a single or double precision number, depending
// on the presence of a decimal point.
// If the number conversion fails, the terminal is notified with ? followed
// by the offending word.
                Colon_Def INTERPRET, "INTERPRET", is_normal
                New_Def  INTERPRET, "INTERPRET", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "INTERPRET"


len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "INTERPRET"               // name string in 7-bit ascii, but


                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
INTERPRET:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

Interpret_Begin:                                        // begin
                dw          LFIND                       //      -find
                                                        //      if
                dw          ZBRANCH
                dw          Interpret_Else_1 - $
                dw              STATE, FETCH, LESS      //          state @ <

                                                        //          if
                dw              ZBRANCH
                dw              Interpret_Else_2 - $
                dw                  COMPILE_XT          //              compile,
                                                        //          else
                dw              BRANCH
                dw              Interpret_Endif_2 - $
Interpret_Else_2:
                dw                  EXECUTE, NOOP       //              execute nooop
Interpret_Endif_2:                                      //          endif
                                                        //      else
                dw          BRANCH
                dw          Interpret_Endif_1 - $
Interpret_Else_1:
                dw              HERE, NUMBER            //          here number
                dw              DPL, FETCH, ONE_PLUS    //          dpl @ 1+

                                                        //          if
                dw              ZBRANCH
                dw              Interpret_Else_3 - $
//              dw                  NMODE, FETCH        //              nmode @
//                                                      //              if
//              dw                  ZBRANCH
//              dw                  Interpret_Endif_4 - $
//              dw                      ONE, ZERO       //                  1 0
//              dw                      TWO_DROP        //                  2drop
//Interpret_Endif_4:                                      //              endif
                dw                  DLITERAL            //              [compile] dliteral
                                                        //          else
                dw              BRANCH
                dw              Interpret_Endif_3 - $
Interpret_Else_3:
                dw                  DROP                //              drop
                dw                  LITERAL             //              [compile]  literal
Interpret_Endif_3:                                      //          endif
Interpret_Endif_1:                                      //      endif
                dw          QSTACK                      //      ?stack
//              dw          QTERMINAL                   //      ?terminal
//                                                      //      if
//              dw          ZBRANCH
//              dw          Interpret_Endif_5 - $
//              dw              CABORT                  //          (abort)
//Interpret_Endif_5:                                      //      endif
                dw      BRANCH
                dw      Interpret_Begin - $
                dw      EXIT                            // ;

//  ______________________________________________________________________
//
// vocabulary   -- cccc     ( compile time )
// Defining word used in the form   VOCABULARY cccc
// creates the word  cccc  that gives the name to the vocabulary.
// Giving  cccc  makes the vocabulary CONTEXT so its words are executed first
// Giving  cccc DEFINITIONS makes  the vocabulary  CURRENT
// so new definitions can be inserted in that vocabulary.
                Colon_Def VOCABULARY, "VOCABULARY", is_normal
                New_Def  VOCABULARY, "VOCABULARY", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "VOCABULARY"


len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "VOCABULARY"               // name string in 7-bit ascii, but


                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
VOCABULARY:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

                dw      CBUILDS

                dw      LIT, $A081, COMMA       // $81A0 ,

                dw      CURRENT, FETCH          // current @
                dw      CELL_MINUS, COMMA       // cell- ,
                dw      HERE                    // here
                dw      VOC_LINK, FETCH, COMMA  // voc-link @ ,

                dw      VOC_LINK, STORE         // voc-link !

                dw      DOES_TO                 // does>
Vocabulary_Does:
                dw      CELL_PLUS               // cell+
                dw      CONTEXT, STORE          // context !
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// forth        --
// Name of the first vocabulary.
// It makes FORTH the CONTEXT vocabulary.
// Until new user vocabulary are defined, new colon-definitions becomes
// part of FORTH. It is immediate, so it will executed during the creation
// of a colon definition to be able to select the vocabulary.

                New_Def FORTH, "FORTH", Does_Ptr, is_immediate
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "FORTH"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "FORTH"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
FORTH:          if Does_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Does_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      Vocabulary_Does
                db      $81, $A0
Forth_Latest_Ptr:
                dw      Here_Dictionary // Fence_Word // Latest_Definition // Here_Dictionary
Voclink_Ptr:
                dw      0
// Any new vocabulary is structured as follow:
// PFA+0 points to DOES> part of VOCABULARY to perform CELL+ CONTEXT !
// PFA+2 is 81,A0 i.e. a null-word used as LATEST in the new vocabulary
// PFA+4 always contains the LATEST word of this VOCABULARY.
//       at creations it points to the null-word of its parent vocabulary
//       that is normally FORTH, For example ASSEMBLER points FORTH's null-word
// PFA+6 is the pointer that builds up the vocabulary linked list.
//       FORTH has 0 here to signal the end of the list and user's variable
//       VOC-LINK points to PFA+6 of the newest vocabulary created.
//       While FORTH is the only vocabulary, VOC-LINK points to FORTH's PFA+6
//       When ASSEMBLER is created, its PFA+6 points to FORTH's PFA+6, and so on

//  ______________________________________________________________________
//
// definitions  --
// Used in the form  cccc DEFINITIONS
// set the CURRENT vocabulary at CONTEXT to insert new definitions in
// vocabulary cccc.
                Colon_Def DEFINITIONS, "DEFINITIONS", is_normal
                New_Def  DEFINITIONS, "DEFINITIONS", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "DEFINITIONS"


len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "DEFINITIONS"               // name string in 7-bit ascii, but


                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DEFINITIONS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      CONTEXT, FETCH          // context @
                dw      CURRENT, STORE          // current !
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// (            -- cccc )
// the following text is interpreted as a comment until a closing )
                Colon_Def COMMENT_BRAKET, "(", is_immediate
                New_Def  COMMENT_BRAKET, "(", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "("
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "("               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
COMMENT_BRAKET:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      LIT, ")"                // [char] )
                dw      WORD, DROP              // word drop
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// quit         --
// \ Erase the return-stack, stop any compilation and give controlo to the console. No message is issued.
                Colon_Def QUIT, "QUIT", is_normal
                New_Def  QUIT, "QUIT", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "QUIT"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "QUIT"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
QUIT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above

                dw      SOURCE_ID, FETCH        // source-id @
                dw      F_CLOSE, DROP           // f_close drop
                dw      ZERO, SOURCE_ID, STORE  // 0 source-id !

                dw      ZERO, BLK, STORE        // 0 blk !

                dw      SQUARED_OPEN            // [compile] [
                                                // begin
Quit_Begin:
                dw      R0, FETCH, RPSTORE      //      r0 @ rp!

                dw      CR                      //      cr
                dw      QUERY                   //      query
Next_Breakpoint_1:
                dw      INTERPRET               //      interpret
                dw      STATE, FETCH, ZEQUAL    //      state @ 0=

                                                //      if
                dw      ZBRANCH
                dw      Quit_Endif - $
                dw          C_DOT_QUOTE
                db          2, "ok"             //          .( ok)
Quit_Endif:                                     //      else
                                                // again
                dw      BRANCH
                dw      Quit_Begin - $
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// abort        --
                Colon_Def ABORT, "ABORT", is_normal
                New_Def  ABORT, "ABORT", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "ABORT"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "ABORT"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
ABORT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      S0, FETCH, SPSTORE      // s0 @ sp!

                dw      DECIMAL                 // decimal
                dw      FORTH                   // [compile] forth
                dw      DEFINITIONS             // definitions
Autoexec_Ptr:
                dw      AUTOEXEC                // autoexec, patched to noop
                dw      QUIT                    // quit
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// warm         --
                Colon_Def WARM, "WARM", is_normal
                New_Def  WARM, "WARM", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "WARM"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "WARM"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
WARM:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      BLK_INIT                // blk-init
                dw      SPLASH                  // splash
                dw      LIT, 7, EMIT            // 7 emit

                dw      ABORT                   // abort
                dw      EXIT                    // exit

//  ______________________________________________________________________
//
// cold         --
                Colon_Def COLD, "COLD", is_normal
                New_Def  COLD, "COLD", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "COLD"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "COLD"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
COLD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      LIT, S0_origin          // [ hex $12 +origin ] Literal
                dw      LIT, USER_Pointer       // [ hex $3E +origin ] literal
                dw      FETCH                   // @
                dw      LIT, 6, PLUS            // 6 +

                dw      LIT, 20                 // 20
                dw      CMOVE
                dw      LIT, Latest_origin      // [ hex 0C +origin ] literal
                dw      FETCH                   // @
                dw      LIT, Forth_Latest_Ptr   // [ ' forth >body 4 + ] Literal
                dw      STORE                   // !
                dw      ZERO, NMODE, STORE      // 0 nmode !

                dw      FIRST, FETCH, DUP       // first @ dup

                dw      USE, STORE              // use !
                dw      PREV, STORE             // prev !
                dw      LIT, 4, PLACE, STORE    // 4 place !

//              dw      LIT, 8
//              dw      LIT, FLAGS2, CSTORE     // 8 5C6A c!
                dw      TWO, HP, STORE          // 2 hp !

Warm_Start:     dw      WARM
Cold_Start:     dw      COLD
                dw      EXIT

//  ______________________________________________________________________
WarmRoutine:
ColdRoutine:
                ld      ix, Next_Ptr
                exx
                push    hl
                exx

                ld      (SP_Basic), sp
                ld      sp, (S0_origin)
//              nop
                ld      hl, (R0_origin)
//              nop
                ldrphl
                ld      (RP_Pointer),hl
                ld      bc, Warm_Start
                jr      c, Warm_Skip
                inc     bc
                inc     bc
Warm_Skip:
                next
                jp      (ix)

//  ______________________________________________________________________
//
// basic        --
                New_Def BASIC, "BASIC", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "BASIC"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "BASIC"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
BASIC:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     bc
                ld      hl, 0
                add     hl, sp
                ld      sp, (SP_Basic)
//              nop
                ld      (SP_Basic),hl
                exx
                pop     hl
                exx
                ret     // to Basic

//  ______________________________________________________________________
//
// +-           n1 n2 -- n3
// leaves n1 with the sign of n2 as n3.
                Colon_Def PLUS_MINUS, "+-", is_normal
                New_Def  PLUS_MINUS, "+-", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "+-"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "+-"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
PLUS_MINUS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      ZLESS                   // 0<
                                                // if
                dw      ZBRANCH
                dw      Plus_Minus_Endif - $
                dw          MINUS               //      minus
Plus_Minus_Endif:                               // endif
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// d+-          d1 n -- d2
// leaves d1 with the sign of n as d2.
                Colon_Def DPLUS_MINUS, "D+-", is_normal
                New_Def  DPLUS_MINUS, "D+-", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "D+-"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "D+-"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DPLUS_MINUS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      ZLESS                   // 0<
                                                // if
                dw      ZBRANCH
                dw      DPlus_Minus_Endif - $
                dw          DMINUS              //      dminus
DPlus_Minus_Endif:                              // endif
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// abs          n1 -- n2
                Colon_Def ABS_OP, "ABS", is_normal
                New_Def  ABS_OP, "ABS", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "ABS"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "ABS"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
ABS_OP:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      DUP                     // dup
                dw      PLUS_MINUS              // +-
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// dabs         d1 -- d2
                Colon_Def DABS, "DABS", is_normal
                New_Def  DABS, "DABS", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "DABS"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "DABS"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DABS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      DUP                     // dup
                dw      DPLUS_MINUS             // d+-
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// m*           n1 n2 -- d
// multiply two integer giving a double
                Colon_Def MMUL, "M*", is_normal
                New_Def  MMUL, "M*", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "M*"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "M*"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
MMUL:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      TWO_DUP, XOR_OP, TO_R   // 2dup xor >r

                dw      ABS_OP, SWAP            // abs swap
                dw      ABS_OP, UM_MUL          // abs um*
                dw      R_TO, DPLUS_MINUS       // r> d+-
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// sm/rem       d n -- q r
// Symmetric division: divides a double into n giving quotient q and remainder r
// the remainder has the sign of d.
                Colon_Def SMDIVM, "SM/REM", is_normal
                New_Def  SMDIVM, "SM/REM", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "SM/REM"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "SM/REM"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
SMDIVM:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      OVER, TO_R, TO_R        // over >r >r

                dw      DABS, R_OP, ABS_OP      // dabs r abs

                dw      UMDIVMOD                // um/mod
                dw      R_TO                    // r>
                dw      R_OP, XOR_OP            // r xor
                dw      PLUS_MINUS, SWAP        // +- swap
                dw      R_TO                    // r>
                dw      PLUS_MINUS, SWAP        // +- swap
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// fm/mod       d n -- q r
// Floored division: divides a double into n giving quotient q and remainder r
// the remainder has the sign of d.
                Colon_Def FMDIVM, "FM/MOD", is_normal
                New_Def  FMDIVM, "FM/MOD", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "FM/MOD"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "FM/MOD"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
FMDIVM:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      DUP, TO_R               // dup >r
                dw      SMDIVM
                dw      OVER, DUP
                dw      ZEQUAL, ZEQUAL
                dw      SWAP, ZLESS
                dw      R_OP, ZLESS
                dw      XOR_OP, AND_OP
                dw      ZBRANCH
                dw      Fm_Mod_Else - $
                dw          ONE_SUBTRACT
                dw          SWAP, R_TO
                dw          PLUS, SWAP
                dw      BRANCH
                dw      Fm_Mod_Endif - $
Fm_Mod_Else:
                dw          R_TO, DROP
Fm_Mod_Endif:
                dw      EXIT
//              dw      TWO_DUP                 // 2dup
//              dw      XOR_OP, TO_R, TO_R      // xor >r >r
//              dw      DABS, R_OP, ABS_OP      // dabs r abs
//              dw      UMDIVMOD                // um/mod
//              dw      SWAP                    // swap
//              dw      II, ZLESS               // i'
//              dw      ONE, AND_OP, PLUS       // 0< 1 and +
//              dw      R_TO                    // r>
//              dw      PLUS_MINUS, SWAP        // +- swap
//              dw      R_OP                    // r@
//              dw      ZLESS                   // i'
//              dw      ONE, AND_OP, PLUS       // 0< 1 and +
//              dw      R_TO                    // r>
//              dw      PLUS_MINUS              // +- swap
//              dw      EXIT                    // ;

//  ______________________________________________________________________
//
// m/mod        d n -- q r
// multiply two integer giving a double
                Colon_Def MDIVM, "M/MOD", is_normal
                New_Def  MDIVM, "M/MOD", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "M/MOD"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "M/MOD"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
MDIVM:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      SMDIVM
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// m/           d n -- q
// multiply two integer giving a double
                Colon_Def MDIV, "M/", is_normal
                New_Def  MDIV, "M/", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "M/"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "M/"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
MDIV:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      MDIVM, NIP
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// *            n1 n2 -- n3
// multiply two integer
                Colon_Def MUL, "*", is_normal
                New_Def  MUL, "*", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "*"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "*"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
MUL:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      MMUL, DROP              // m* drop
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// /mod         n1 n2 -- n3 n4
// leaves quotient n4 and remainder n3 of the integer division n1 / n2.
// The remainder has the sign of n1
                Colon_Def DIVMOD, "/MOD", is_normal
                New_Def  DIVMOD, "/MOD", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "/MOD"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "/MOD"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DIVMOD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      TO_R, S_TO_D, R_TO      // >r s->d r>

                dw      MDIVM                   // m/mod
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// /            n1 n2 -- n3
// division
                Colon_Def DIV, "/", is_normal
                New_Def  DIV, "/", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "/"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "/"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DIV:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      DIVMOD, NIP             // /mod nip
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// mod          n1 n2 -- n3
                Colon_Def MOD, "MOD", is_normal
                New_Def  MOD, "MOD", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "MOD"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "MOD"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
MOD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      DIVMOD, DROP            // /mod drop
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// */mod        n1 n2 n3 -- n4 n5
// leaves the quotient n5 and the remainder n4 of the operation
// (n1 * n2) / n3. The intermediate passage through a double number
// avoids loss of precision
                Colon_Def MUL_DIV_MOD, "*/MOD", is_normal
                New_Def  MUL_DIV_MOD, "*/MOD", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "*/MOD"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "*/MOD"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
MUL_DIV_MOD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      TO_R, MMUL              // >r  m*
                dw      R_TO, MDIVM             // r>  m/mod
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// */          n1 n2 n3 -- n4
// (n1 * n2) / n3. The intermediate passage through a double number avoids loss of precision
                Colon_Def MUL_DIV, "*/", is_normal
                New_Def  MUL_DIV, "*/", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "*/"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "*/"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
MUL_DIV:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw     MUL_DIV_MOD              // */mod
                dw     NIP                      // nip
                dw     EXIT                     // ;


//  ______________________________________________________________________
//
// m/mod        ud1 u2 -- u3 ud4
// mixed operation: it leaves the remainder u3 and the quotient ud4 of ud1 / u1.
// All terms are unsigned.
//              Colon_Def MDIV_MOD, "M/MOD", is_normal
//              dw      TO_R                    // >r           ( ud1 )
//              dw      ZERO, R_OP, UMDIVMOD    // 0 r um/mod   ( l rem1 h/r )
//              dw      R_TO, SWAP, TO_R        // r> swap >r   ( l rem )
//              dw      UMDIVMOD                // um/mod       ( rem2 l/r )
//              dw      R_TO                    // r>           ( rem2 l/r h/r )
//              dw      EXIT                    // ;

//  ______________________________________________________________________
//
// (line)       n1 n2 -- a b
// sends the line n1 of block n2 to the disk buffer.
// it returns the address a and ca counter b = C/L meaning a whole line.
                Colon_Def CLINE, "(LINE)", is_normal
                New_Def  CLINE, "(LINE)", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "(LINE)"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "(LINE)"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CLINE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      TO_R                    // >r
                dw      NOOP                    // noop
                dw      CL                      // c/l
                dw      BBUF, MUL_DIV_MOD       // */mod
                dw      R_TO                    // r>
                dw      BSCR, MUL, PLUS         // b/scr * +

                dw      BLOCK                   // block   ( forward )
                dw      PLUS                    // +
                dw      NOOP                    // noop
                dw      CL                      // c/l
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// .line        n1 n2 --
// Sends to output line  n1  of screen n2.
                Colon_Def DOT_LINE, ".LINE", is_normal
                New_Def  DOT_LINE, ".LINE", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      ".LINE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      ".LINE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DOT_LINE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      CLINE, LTRAILING, TYPE  // (line) -trailing type

                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// message       n1 n2 --
// prints error message to current channel.
// if WARNING is 0, prints "MSG#n".
// if WARNING is 1, prints line n of screen 4.
// if WARNING is -1, see ERROR
// value can be negative or beyond block 4.
                Colon_Def MESSAGE, "MESSAGE", is_normal
                New_Def  MESSAGE, "MESSAGE", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "MESSAGE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "MESSAGE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
MESSAGE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      WARNING, FETCH          // warning @
                                                // if
                dw      ZBRANCH
                dw      Message_Else - $
                dw          LIT, 4              //      4
                dw          OFFSET, FETCH       //      offset @
                dw          BSCR, DIV, SUBTRACT //      b/scr / -

                dw          DOT_LINE            //      .line
                dw          SPACE               //      space
                                                // else

                dw      BRANCH
                dw      Message_ENdif - $
Message_Else:
                dw          C_DOT_QUOTE         //      .( msg#)
                db          4, "msg#"

                dw          DOT                 //      .  ( forward )
Message_ENdif:                                  // endif
                dw      EXIT                    // ;


//  ______________________________________________________________________
//
// device
                Variable_Def DEVICE,   "DEVICE",   2
                New_Def  DEVICE, "DEVICE", Variable_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "DEVICE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "DEVICE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DEVICE:          if Variable_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Variable_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      2

//  ______________________________________________________________________

ect\Projects\vForth15_DIRECT/source/L2.asm
                include "next-opt1.asm"
ect\Projects\vForth15_DIRECT/source/next-opt1.asm
//  ______________________________________________________________________
//
//  next-opt.asm
//
//  ZX Spectrum Next - peculiar definitions
//  ______________________________________________________________________

//  ______________________________________________________________________
//
// reg@         n -- b
// read Next REGister n giving byte b
//
//              Colon_Def REG_FETCH, "REG@", is_normal
//              dw      LIT, $243B
//              dw      PSTORE
//              dw      LIT, $253B
//              dw      PFETCH
//              dw      EXIT
                New_Def REG_FETCH, "REG@", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "REG@"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "REG@"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
REG_FETCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                exx
                ld      bc, $243B
                pop     hl
                out     (c), l
                inc     b
                in      l, (c)
                push    hl
                exx
                next
                jp      (ix)


//  ______________________________________________________________________
//
// reg!         b n --
// write value b to Next REGister n
//
//              Colon_Def REG_STORE, "REG!", is_normal
//              dw      LIT, $243B
//              dw      PSTORE
//              dw      LIT, $253B
//              dw      PSTORE
//              dw      EXIT
                New_Def REG_STORE, "REG!", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "REG!"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "REG!"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
REG_STORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                exx
                ld      bc, $243B
                pop     hl
                out     (c), l
                inc     b
                pop     hl
                out     (c), l
                exx
                next
                jp      (ix)


//  ______________________________________________________________________
//
// mmu7@        -- n
// query current page in MMU7 8K-RAM : 0 and 223

                Colon_Def MMU7_FETCH, "MMU7@", is_normal
                New_Def  MMU7_FETCH, "MMU7@", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "MMU7@"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "MMU7@"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
MMU7_FETCH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      LIT, 87, REG_FETCH

                dw      EXIT

//  ______________________________________________________________________
//
// mmu7!        n --
// set MMU7 8K-RAM page to n given between 0 and 223
// optimized version that uses NEXTREG n,A Z80n op-code.

                New_Def MMU7_STORE, "MMU7!", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "MMU7!"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "MMU7!"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
MMU7_STORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     hl
                ld      a, l
                nextreg 87, a

                next
                jp      (ix)

//  ______________________________________________________________________
//
// >far         ha -- a n
// decode bits 765 of H as one of the 8K-page between 64 and 71 (40h-47h)
// take lower bits of H and L as an offset from E000h
// then return address  a  between E000h-FFFFh
// and page number n  between 64-71 (40h-47h)
// For example, in hex:
//   0000 >FAR  gives  40.E000
//   1FFF >FAR  gives  40.FFFF
//   2000 >FAR  gives  41.E000
//   3FFF >FAR  gives  41.FFFF
//   EFFF >FAR  gives  47.EFFF
//   FFFF >FAR  gives  47.FFFF
//                New_Def TO_FAR, ">FAR", is_code, is_normal
//                pop     de
//                ld      a, d
//                and     $E0
//                rlca
//                rlca
//                rlca
//                add     $40
//                ld      l, a
//                ld      h, 0
//                ld      a, d
//                or      $E0
//                ld      d, a
//                push    hl
//                push    de
//                next

//  ______________________________________________________________________
//
// <far         a n  -- ha
// given an address E000-FFFF and a page number n (64-71 or 40h-47h)
// reverse of >FAR: encodes a FAR address compressing
// to bits 765 of H, lower bits of HL address offset from E000h
//                New_Def FROM_FAR, "<FAR", is_code, is_normal
//                pop     de                  // page number in e
//                pop     hl                  // address in hl
//                ld      a, e
//                sub     $40                 // reduced to 0-7
//                rrca
//                rrca
//                rrca
//                ld      d, a                // save to d bits 765
//                ld      a, h                // drops
//                and     $1F
//                or      d
//                ld      h, a
//
//                psh1

//  ______________________________________________________________________
//
// m_p3dos      n1 n2 n3 n4 a -- n5 n6 n7 n8  f
// NextZXOS call wrapper.
//  n1 = hl register parameter value
//  n2 = de register parameter value
//  n3 = bc register parameter value
//  n4 =  a register parameter value
//   a = routine address in ROM 3
// ----
//  n5 = hl returned value
//  n6 = de returned value
//  n7 = bc returned value
//  n8 =  a returned value
//   f
                New_Def M_P3DOS, "M_P3DOS", is_code, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "M_P3DOS"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "M_P3DOS"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
M_P3DOS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
                call    runcode ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                pop     de                  // dos call entry address in de
                pop     hl                  // a register
                ld      a, l
                exx
                pop     bc
                pop     de
                pop     hl
                exx

                push    bc
                push    ix

//              ld      (SP_Saved), sp
//              ld      sp, Cold_origin - 5
                ld      c, 7                // use 7 RAM Bank

                rst     08
                db      $94

//              ld      sp, (SP_Saved)
//              push    ix
//              pop     hl
//              ld      (IX_Echo), hl
                ld      (IX_Echo), ix
//              nop
                pop     ix
                ex      (sp), hl            // hl argument and retrieve bc
                push    de
                push    bc
                ld      c, l
                ld      b, h

                ld      h, 0
                ld      l, a
                push    hl
                sbc     hl, hl              // -1 for OK ; 0 for KO but now...
                inc     hl                  //  0 for OK ; 1 for ko

                psh1
                push    hl
                jp      (ix)

//  ______________________________________________________________________
//
// blk-fh
                Variable_Def BLK_FH,   "BLK-FH",   1
                New_Def  BLK_FH, "BLK-FH", Variable_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "BLK-FH"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "BLK-FH"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
BLK_FH:          if Variable_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Variable_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      1

                New_Def BLK_FNAME,   "BLK-FNAME", Create_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "BLK-FNAME"


len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "BLK-FNAME"               // name string in 7-bit ascii, but


                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
BLK_FNAME:          if Create_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Create_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      14, "!Blocks-64.bin", 0



                ds      24

//  ______________________________________________________________________
//
// blk-seek     n --
// seek block n  within blocks!.bin  file
                Colon_Def BLK_SEEK, "BLK-SEEK", is_normal
                New_Def  BLK_SEEK, "BLK-SEEK", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "BLK-SEEK"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "BLK-SEEK"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
BLK_SEEK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw  BBUF, MMUL
                dw  BLK_FH, FETCH
                dw  F_SEEK
                dw  LIT, $2D, QERROR

                dw  EXIT

//  ______________________________________________________________________
//
// blk-read     n --
// seek block n  within blocks!.bin  file
                Colon_Def BLK_READ, "BLK-READ", is_normal
                New_Def  BLK_READ, "BLK-READ", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "BLK-READ"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "BLK-READ"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
BLK_READ:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw  BLK_SEEK
                dw  BBUF
                dw  BLK_FH, FETCH
                dw  F_READ
                dw  LIT, $2E, QERROR

                dw  DROP
                dw  EXIT

//  ______________________________________________________________________
//
// blk-write     n --
// seek block n  within blocks!.bin  file
                Colon_Def BLK_WRITE, "BLK-WRITE", is_normal
                New_Def  BLK_WRITE, "BLK-WRITE", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "BLK-WRITE"


len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "BLK-WRITE"               // name string in 7-bit ascii, but


                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
BLK_WRITE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw  BLK_SEEK
                dw  BBUF
                dw  BLK_FH, FETCH
                dw  F_WRITE
                dw  LIT, $2F, QERROR

                dw  DROP
                dw  EXIT

//  ______________________________________________________________________
//
// blk-init     n --
// seek block n  within blocks!.bin  file
                Colon_Def BLK_INIT, "BLK-INIT", is_normal
                New_Def  BLK_INIT, "BLK-INIT", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "BLK-INIT"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "BLK-INIT"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
BLK_INIT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw  BLK_FH, FETCH, F_CLOSE, DROP

                dw  BLK_FNAME, ONE_PLUS
                dw  HERE, THREE, F_OPEN         // open for update (read+write)

                dw  LIT, $2C, QERROR

                dw  BLK_FH, STORE
                dw  EXIT

//  ______________________________________________________________________
//
// #sec
// number of 512-Byte "sectors" available on thie sysstem.
// it adds up to 16 MByte of data that can be used as source or pool for almost anything.

                Constant_Def NSEC , "#SEC", 32767
                New_Def  NSEC, "#SEC", Constant_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "#SEC"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "#SEC"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
NSEC:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Constant_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      32767

//  ______________________________________________________________________



ect\Projects\vForth15_DIRECT/source/next-opt1.asm
                include "L3.asm"
ect\Projects\vForth15_DIRECT/source/L3.asm
//  ______________________________________________________________________
//
//  L3.asm
//
//  Continuation of L2.asm
//  I/O Block definitions
//  ______________________________________________________________________


//  ______________________________________________________________________
//
// r/w          a n f --
// read/write block n depending on flag f, true-flag means read, false-flag means write.
                Colon_Def READ_WRITE, "R/W", is_normal
                New_Def  READ_WRITE, "R/W", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "R/W"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "R/W"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
READ_WRITE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      TO_R                    // >r
                dw      ONE_SUBTRACT            // 1-
                dw      DUP, ZLESS              // dup 0<
                dw      OVER, NSEC              // over #sec
                dw      ONE_SUBTRACT, GREATER   // 1- >
                dw      OR_OP                   // or
                dw      LIT, 6, QERROR          // 6 ?error

                dw      R_TO                    // r>
                                                // if
                dw      ZBRANCH
                dw      Read_Write_Else - $
                dw          BLK_READ            //      blk-read
                dw      BRANCH
                dw      Read_Write_Endif - $
Read_Write_Else:                                // else
                dw          BLK_WRITE           //      blk-write
Read_Write_Endif:                               // endif
                dw      EXIT                    // ;


//  ______________________________________________________________________
//
// +buf        a1 -- a2 f
// advences to next buffer, cyclically rotating along them
                Colon_Def PBUF, "+BUF", is_normal
                New_Def  PBUF, "+BUF", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "+BUF"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "+BUF"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
PBUF:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      LIT, 516, PLUS          // 516 +

                dw      DUP, LIMIT, FETCH       // dup limit @

                dw      EQUALS                  // =
                                                // if
                dw      ZBRANCH
                dw      PBuf_Endif - $
                dw          DROP                //      drop
                dw          FIRST, FETCH        //      first @
PBuf_Endif:                                     // endif
                dw      DUP, PREV, FETCH        // dup prev @

                dw      SUBTRACT                // -
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// update       --
// mark the last used block to be written to disk
                Colon_Def UPDATE, "UPDATE", is_normal
                New_Def  UPDATE, "UPDATE", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "UPDATE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "UPDATE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
UPDATE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      PREV, FETCH, FETCH      // prev @ @

                dw      LIT, $8000, OR_OP       // $8000, or

                dw      PREV, FETCH, STORE      // prev @ !

                dw      EXIT                    // ;


//  ______________________________________________________________________
//
// empty-buffers --
                Colon_Def EMPTY_BUFFERS, "EMPTY-BUFFERS", is_normal
                New_Def  EMPTY_BUFFERS, "EMPTY-BUFFERS", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "EMPTY-BUFFERS"



len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "EMPTY-BUFFERS"               // name string in 7-bit ascii, but



                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
EMPTY_BUFFERS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      FIRST, FETCH            // first @
                dw      LIMIT, FETCH            // limit @
                dw      OVER, SUBTRACT, ERASE   // over - erase

                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// buffer       n -- a
// read block n and gives the address to a buffer
// any block previously inside the buffer, if modified, is rewritten to
// disk before reading the block n.

                Colon_Def BUFFER, "BUFFER", is_normal
                New_Def  BUFFER, "BUFFER", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "BUFFER"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "BUFFER"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
BUFFER:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      USE, FETCH              // use @
                dw      DUP, TO_R               // dup >r
                                                // begin
Buffer_Begin:
                dw          PBUF                //      +buf
                                                // until
                dw      ZBRANCH
                dw      Buffer_Begin - $
                dw      USE, STORE              // use !
                dw      R_OP, FETCH, ZLESS      // r @ 0<

                                                // if
                dw      ZBRANCH
                dw      Buffer_Endif - $
                dw          R_OP, CELL_PLUS     //      r cell+
                dw          R_OP, FETCH         //      r fetch
                dw          LIT, $7FFF          //      7FFF
                dw          AND_OP              //      and
                dw          ZERO, READ_WRITE    //      0 r/w
Buffer_Endif:                                   // endif
                dw      R_OP, STORE             // r !
                dw      R_OP, PREV, STORE       // r prev !

                dw      R_TO, CELL_PLUS         // r> cell+
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// block        n -- a
// Leaves the buffer address that contains the block n.
// If the block is not already present, it will be loaded from disk
// The block previously inside the buffer, if modified, is rewritten to
// disk before reading the block n.
// See also BUFFER, R/W, UPDATE, FLUSH.

                Colon_Def BLOCK, "BLOCK", is_normal
                New_Def  BLOCK, "BLOCK", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "BLOCK"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "BLOCK"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
BLOCK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      OFFSET, FETCH           // offset @
                dw      PLUS, TO_R              // + >r
                dw      PREV, FETCH             // prev @
                dw      DUP, FETCH              // dup @
                dw      R_OP, SUBTRACT          // r -
                dw      DUP, PLUS               // dup +  ( trick: check equality without most significant bit )
                                                // if
                dw        ZBRANCH
                dw        Block_Endif_1 - $
Block_Begin:                                    //      begin
                dw          PBUF, ZEQUAL        //          +buf 0
                                                //          if
                dw          ZBRANCH
                dw          Block_Endif_2 - $
                dw              DROP            //              drop
                dw              R_OP, BUFFER    //              r buffer
                dw              DUP             //              dup
                dw              R_OP, ONE       //              r 1
                dw              READ_WRITE      //              r/w
                dw              TWO_MINUS       //              2-
Block_Endif_2:                                  //          endif
                dw          DUP, FETCH, R_OP    //          dup @ r

                dw          SUBTRACT, DUP       //          - dup
                dw          PLUS, ZEQUAL        //          + 0=
                                                //      until
                dw        ZBRANCH
                dw        Block_Begin - $
                dw        DUP, PREV, STORE      //      dup prev !

Block_Endif_1:                                  // endif
                dw      R_TO, DROP, CELL_PLUS   // r> drop cell+

                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// #buff        -- n
// number of buffers available. must be the difference between LIMIT and FIRST divided by 516
                Constant_Def NBUFF,   "#BUFF", 7
                New_Def  NBUFF, "#BUFF", Constant_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "#BUFF"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "#BUFF"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
NBUFF:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Constant_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      7

//  ______________________________________________________________________
//
// flush        --
                Colon_Def FLUSH, "FLUSH", is_normal
                New_Def  FLUSH, "FLUSH", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "FLUSH"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "FLUSH"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
FLUSH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      NBUFF, ONE_PLUS, ZERO   // #buff 1+ 0

Flush_Do:                                       // do
                dw      C_DO
                dw      ZERO, BUFFER, DROP      //      0 buffer drop

                                                // loop
                dw      C_LOOP, Flush_Do - $
                dw      BLK_FH, FETCH           // blk-fh @     ( ZX-Next dependance )
                dw      F_SYNC, DROP            // f_sync drop
                dw      EXIT                    // exit

//  ______________________________________________________________________
//
// f_getline    a m fh -- n
// Given an open filehandle read next line (terminated with $0D or $0A)
// Address a is left for subsequent processing
// and n as the actual number of byte read, that is the length of line
                Colon_Def F_GETLINE, "F_GETLINE", is_normal
                New_Def  F_GETLINE, "F_GETLINE", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "F_GETLINE"


len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "F_GETLINE"               // name string in 7-bit ascii, but


                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
F_GETLINE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      TO_R                    // >r               ( a  m  )     \  fh
                dw      TUCK                    // tuck             ( m a m )
                dw      R_OP, F_FGETPOS         // r f_fgetpos      ( m a m d f )
                dw      LIT, 44, QERROR         // 44 ?error        ( m a m d )


                dw      TWO_SWAP, OVER          // 2swap over       ( m d a m )
                dw      ONE_PLUS, SWAP          // 1+ swap          ( m d a a+1 m )

                dw      R_OP, F_READ            // r f_read         ( m d a n f )
                dw      LIT, 46, QERROR         // 46 ?error        ( m d a n )

                                                // if ( at least 1 chr was read )  \  fh
                dw      ZBRANCH
                dw      FGetline_Else - $
                dw          LIT, 10, ENCLOSE    //      10 enclose       ( m d a x b x )

                dw          DROP, NIP           //      drop nip         ( m d a b )
                dw          SWAP                //      drop swap        ( m d b a )
                dw          LIT, 13, ENCLOSE    //      13 enclose       ( m d b a x c x )

                dw          DROP, NIP           //      drop nip         ( m d b a c )
                dw          ROT, MIN            //      rot min          ( m d a n )
                dw          DUP, SPAN, STORE    //      dup span !       ( m d a n )

                dw          DUP, TO_R           //      dup >r           ( m d a n )      \ fh n
                dw          TWO_SWAP, R_TO      //      2swap r>         ( m a n d n )    \ fh
                dw          ZERO, DPLUS         //      0 d+             ( m a n d+n )
                dw          R_TO, F_SEEK        //      r> f_seek        ( m a n f )
                dw          LIT, 45, QERROR     //      45 ?error        ( m a n )

                                                // else
                dw      BRANCH
                dw      FGetline_Endif - $
FGetline_Else:
                dw          R_TO                //      r>              ( m d a fh )
                dw          TWO_SWAP, TWO_DROP  //      2swap 2drop     ( m a fh )
                dw          DROP, ZERO          //      drop, 0         ( m a 0 )
FGetline_Endif:                                 // endif
                dw      TO_R, DUP, DUP          // >r dup dup           ( m a a a )

                dw      ONE_PLUS, SWAP          // 1+ swap              ( m a a+1 a )
                dw      R_OP, CMOVE             // r cmove              ( m a )
                dw      TWO_DUP, PLUS           // 2dup +               ( m a m+a )
                dw      ZERO, SWAP              // 0 swap
                dw      CELL_MINUS,  STORE      // cell-  !             ( m a )
                dw      R_OP, PLUS, ONE_SUBTRACT// r + 1-               ( m a+n1 )

                dw      SWAP, R_OP, SUBTRACT    // swap r -             ( a+n+1 m-n )

                dw      BLANK                   // blank
                dw      R_TO                    // r>                   ( n )
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// f_include    fh --
// Given a filehandle includes the source from file
                Colon_Def F_INCLUDE, "F_INCLUDE", is_normal
                New_Def  F_INCLUDE, "F_INCLUDE", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "F_INCLUDE"


len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "F_INCLUDE"               // name string in 7-bit ascii, but


                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
F_INCLUDE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      BLK, FETCH, TO_R        // blk @ >r

                dw      TO_IN, FETCH, TO_R      // >in @ >r

                dw      SOURCE_ID, FETCH, TO_R  // source-id @ >r

                dw      R_OP                    // r
                                                // if
                dw      ZBRANCH
                dw      FInclude_Else_1 - $
                dw          R_OP, F_FGETPOS     //      r f_getpos
                dw          LIT, 44, QERROR     //      44 ?error

                dw          TO_IN, FETCH        //      >in @ 2-
                dw          TWO_MINUS
                dw          SPAN, FETCH         //      span @ -
                dw          SUBTRACT
                dw          S_TO_D, DPLUS       //      s>d d+
                                                // else
                dw      BRANCH
                dw      FInclude_Endif_1 - $
FInclude_Else_1:
                dw          ZERO, ZERO          //      0 0
                                                // endif
FInclude_Endif_1:
                dw      TO_R, TO_R              // >r >r
                dw      SOURCE_ID, STORE        // source-id !
FInclude_Begin:                                 // begin
                dw          ONE, BLOCK, BBUF    //      1 block b/buf

                dw          TWO_DUP, BLANK      //      2dup blank
                dw          SWAP, ONE_PLUS      //      swap 1+
                dw          SWAP, CELL_MINUS    //      swap cell-
                dw          SOURCE_ID, FETCH    //      source-id @
                dw          F_GETLINE           //      f_getline
                                                // while
                dw      ZBRANCH
                dw      FInclude_Repeat - $
                dw          ONE, BLK, STORE     //      1 blk !

                dw          ZERO, TO_IN, STORE  //      0 >in !

                dw          INTERPRET           //      interpret
                dw      BRANCH
                dw      FInclude_Begin - $
FInclude_Repeat:                                // repeat
                dw      SOURCE_ID, FETCH        // source-id @
                dw      ZERO, SOURCE_ID, STORE  // 0 source-id !

                dw      F_CLOSE                 // f_close
                dw      LIT, 42, QERROR         // 42 ?error

                dw      R_TO, R_TO, R_TO        // r> r> r>

                dw      DUP, SOURCE_ID, STORE   // dup source-id !

                                                // if
                dw      ZBRANCH
                dw      FInclude_Else_2 - $
                dw          SOURCE_ID, FETCH    //      source-id @
                dw          F_SEEK              //      f_seek
                dw          LIT, 43, QERROR     //      43, ?error

                                                // else
                dw      BRANCH
                dw      FInclude_Endif_2 - $
FInclude_Else_2:
                dw          TWO_DROP            //      2drop
FInclude_Endif_2:                               // endif
                dw      R_TO, TO_IN, STORE      // r> >in !

                dw      R_TO, BLK, STORE        // r> blk !

                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// open<         -- fh
// Open the following filename and return it file-handle
// Used in the form OPEN CCCC
                Colon_Def OPEN_FH, "OPEN<", is_normal
                New_Def  OPEN_FH, "OPEN<", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "OPEN<"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "OPEN<"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
OPEN_FH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      BL
                dw      WORD, COUNT, OVER       // bl word count over

                dw      PLUS, ZERO, SWAP, STORE // + 0 swap !

                dw      PAD, ONE, F_OPEN        // pad 1 f_open

                dw      LIT, 43                 // 43
                dw      QERROR                  // ?error
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// include      -- cccc
// Include the following filename
                Colon_Def INCLUDE, "INCLUDE", is_normal
                New_Def  INCLUDE, "INCLUDE", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "INCLUDE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "INCLUDE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
INCLUDE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      OPEN_FH                 // open
                dw      DUP, F_INCLUDE          // dup f_include
                dw      F_CLOSE, DROP           // f_close drop
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// needs
// check for cccc exists in vocabulary
// if it doesn't then  INCLUDE  inc/cccc.F

// temp filename cccc.f as counted string zero-padded
                New_Def NEEDS_W,   "NEEDS-W", Create_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "NEEDS-W"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "NEEDS-W"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
NEEDS_W:          if Create_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Create_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                ds      35                      // 32 + .f + 0x00 = len 35
// temp complete path+filename
                New_Def NEEDS_FN,  "NEEDS-FN", Create_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "NEEDS-FN"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "NEEDS-FN"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
NEEDS_FN:          if Create_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Create_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                ds      40
// constant path
                New_Def NEEDS_INC,  "NEEDS-INC", Create_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "NEEDS-INC"


len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "NEEDS-INC"               // name string in 7-bit ascii, but


                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
NEEDS_INC:          if Create_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Create_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      4, "inc/", 0

                New_Def NEEDS_LIB,  "NEEDS-LIB", Create_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "NEEDS-LIB"


len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "NEEDS-LIB"               // name string in 7-bit ascii, but


                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
NEEDS_LIB:          if Create_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Create_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                db      4, "lib/", 0


// Concatenate path at a and filename and include it
// No error is issued if filename doesn't exist.
                Colon_Def NEEDS_SLASH, "NEEDS/", is_normal
                New_Def  NEEDS_SLASH, "NEEDS/", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "NEEDS/"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "NEEDS/"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
NEEDS_SLASH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      COUNT, TUCK             // n a n
                dw      NEEDS_FN, SWAP, CMOVE   // n        \ Path

                dw      NEEDS_FN, PLUS          // a1+n     \ Concat
                dw      NEEDS_W, ONE_PLUS, SWAP

                dw      LIT, 35
                dw      CMOVE
                dw      NEEDS_FN
                dw      PAD, ONE, F_OPEN

                dw      ZEQUAL
                dw      ZBRANCH
                dw      Needs_1 - $
                dw          F_INCLUDE
                dw      BRANCH
                dw      Needs_2 - $
Needs_1:
//              dw          NEEDS_W, COUNT, TYPE, SPACE
//              dw          LIT, 43, MESSAGE
                dw          DROP
Needs_2:
                dw      EXIT                    // ;


                New_Def NDOM,   "NDOM", Create_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "NDOM"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "NDOM"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
NDOM:          if Create_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Create_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
//              db $3A, $3F, $2F, $2A, $7C, $5C, $3C, $3E, $22
                db ':?/*|\<>"'


                db 0

                New_Def NCDM,   "NCDM", Create_Ptr, is_normal
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "NCDM"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "NCDM"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
NCDM:          if Create_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Create_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
//              db $5F, $5E, $25, $26, $24, $5F, $7B, $7D, $7E
                db '_^%&$_{}~'


                db 0

// Replace illegal character in filename using the map here above
// at the moment we need only  "
                Colon_Def NEEDS_CHECK, "MAP-FN", is_normal
                New_Def  NEEDS_CHECK, "MAP-FN", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "MAP-FN"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "MAP-FN"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
NEEDS_CHECK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      COUNT, BOUNDS
                dw      C_DO
Needs_3:
                dw          NCDM, NDOM, LIT, 10

                dw          I, CFETCH
                dw          C_MAP
                dw          I, CSTORE
Needs_4:
                dw      C_LOOP
                dw      Needs_3 - $
                dw      EXIT


// include  "path/cccc.f" if cccc is not defined
// filename cccc.f is temporary stored at NEEDS-W
                Colon_Def NEEDS_PATH, "NEEDS-F", is_normal
                New_Def  NEEDS_PATH, "NEEDS-F", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "NEEDS-F"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "NEEDS-F"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
NEEDS_PATH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      LFIND
                dw      ZBRANCH
                dw      Needs_5 - $

                dw          DROP, TWO_DROP
                dw      BRANCH
                dw      Needs_6 - $
Needs_5:
                dw          NEEDS_W
                dw          LIT, 35
                dw          ERASE                   // a
                dw          HERE, CFETCH, ONE_PLUS  // a n

                dw          HERE, OVER              // a n here n
                dw          NEEDS_W, SWAP, CMOVE    // a n

                dw          NEEDS_W, NEEDS_CHECK
                dw          NEEDS_W, PLUS           // a a1+1
                dw          LIT, $662E              // a a1+1 ".F"
                dw          SWAP, STORE             // a
                dw          NEEDS_SLASH
Needs_6:
                dw      EXIT


// check for cccc exists in vocabulary
// if it doesn't then  INCLUDE  inc/cccc.F
// search in inc subdirectory
                Colon_Def NEEDS, "NEEDS", is_normal
                New_Def  NEEDS, "NEEDS", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "NEEDS"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "NEEDS"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
NEEDS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      TO_IN, FETCH
                dw      DUP
                dw      NEEDS_INC, NEEDS_PATH
                dw      TO_IN, STORE
                dw      NEEDS_LIB, NEEDS_PATH
                dw      TO_IN, STORE
                dw      LFIND
                dw      ZBRANCH
                dw      Needs_10 - $
                dw          TWO_DROP
                dw      BRANCH
                dw      Needs_11 - $
Needs_10:
                dw      NEEDS_W, COUNT, TYPE, SPACE

                dw      LIT, 43, MESSAGE

Needs_11:
                dw      EXIT


//  ______________________________________________________________________
//
// load+        n --
                Colon_Def LOAD_P, "LOAD+", is_normal
                New_Def  LOAD_P, "LOAD+", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "LOAD+"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "LOAD+"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
LOAD_P:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      BLK, FETCH, TO_R        // blk @ >r

                dw      TO_IN, FETCH, TO_R      // >in @ >r


                dw      ZERO, TO_IN, STORE      // 0 >in !

                dw      BSCR, MUL, BLK, STORE   // b/scr * blk !

                dw      INTERPRET               // interpret

                dw      R_TO, TO_IN, STORE      // r> >in !

                dw      R_TO, BLK, STORE        // r> blk !

                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// -->          --
                Colon_Def LOAD_NEXT, "-->", is_immediate
                New_Def  LOAD_NEXT, "-->", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "-->"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "-->"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
LOAD_NEXT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      QLOADING                // ?loading
                dw      ZERO, TO_IN, STORE      // 0 >in !

                dw      BSCR                    // b/scr
                dw      BLK, FETCH              // blk @
                dw      OVER                    // over
                dw      MOD                     // mod
                dw      SUBTRACT                // -
                dw      BLK, PLUSSTORE          // +!
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// '            -- xt
                Colon_Def TICK, "'", is_normal
                New_Def  TICK, "'", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "'"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "'"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
TICK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      LFIND                   // -find
                dw      ZEQUAL                  // 0=
                dw      ZERO, QERROR            // 0 ?error
                dw      DROP                    // drop
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// forget       -- cccc
                Colon_Def FORGET, "FORGET", is_normal
                New_Def  FORGET, "FORGET", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "FORGET"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "FORGET"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
FORGET:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      CURRENT, FETCH          // current @
                dw      CONTEXT, FETCH          // context @
                dw      SUBTRACT, LIT, 23, QERROR // - 23 ?error

                dw      TICK, TO_BODY           // ' >body
                dw      DUP, FENCE, FETCH       // dup fence @

                dw      ULESS, LIT, 21, QERROR  // u< 21 ?error

                dw      DUP, NFA, DP, STORE     // dup nfa dp !

                dw      LFA, FETCH              // lfa @
                dw      CONTEXT, FETCH, STORE   // context @ !

                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// marker       -- cccc
                Colon_Def MARKER, "MARKER", is_immediate
                New_Def  MARKER, "MARKER", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "MARKER"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "MARKER"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
MARKER:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      CBUILDS
                dw      VOC_LINK, FETCH, COMMA

                dw      CURRENT, FETCH, COMMA

                dw      CONTEXT, FETCH, COMMA

                dw      LATEST, COMMA
                dw      LATEST, PFA, LFA, FETCH, COMMA


                dw      DOES_TO
                dw      DUP, FETCH, VOC_LINK, STORE, CELL_PLUS


                dw      DUP, FETCH, CURRENT, STORE, CELL_PLUS


                dw      DUP, FETCH, CONTEXT, STORE, CELL_PLUS


                dw      DUP, FETCH, DP, STORE, CELL_PLUS


                dw           FETCH, CURRENT, FETCH, STORE

                dw      EXIT

//  ______________________________________________________________________
//
// spaces       n --
                Colon_Def SPACES, "SPACES", is_normal
                New_Def  SPACES, "SPACES", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "SPACES"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "SPACES"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
SPACES:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      ZERO, MAX
                dw      ZERO, C_Q_DO
                dw      Spaces_Leave - $
Spaces_Loop:
                dw          SPACE
                dw      C_LOOP
                dw      Spaces_Loop - $
Spaces_Leave:
                dw      EXIT                    // ;

//  ______________________________________________________________________
//
// <#           --
                Colon_Def BEGIN_DASH, "<#", is_normal
                New_Def  BEGIN_DASH, "<#", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "<#"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "<#"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
BEGIN_DASH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      PAD, HLD, STORE

                dw      EXIT

//  ______________________________________________________________________
//
// #>           --
                Colon_Def DASH_END, "#>", is_normal
                New_Def  DASH_END, "#>", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "#>"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "#>"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DASH_END:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      TWO_DROP
                dw      HLD, FETCH, PAD, OVER, SUBTRACT


                dw      EXIT

//  ______________________________________________________________________
//
// sign         n d -- d
                Colon_Def SIGN, "SIGN", is_normal
                New_Def  SIGN, "SIGN", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "SIGN"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "SIGN"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
SIGN:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      ZLESS
                dw      ZBRANCH
                dw      Sign_Endif - $
                dw          LIT, 45, HOLD

Sign_Endif:
                dw      EXIT

//  ______________________________________________________________________
//
// #           d1 -- d2
                Colon_Def DASH, "#", is_normal
                New_Def  DASH, "#", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "#"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "#"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DASH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      BASE, FETCH

                dw      TO_R                    // >r           ( ud1 )
                dw      ZERO, R_OP, UMDIVMOD    // 0 r um/mod   ( l rem1 h/r )

                dw      R_TO, SWAP, TO_R        // r> swap >r   ( l rem )

                dw      UMDIVMOD                // um/mod       ( rem2 l/r )
                dw      R_TO                    // r>           ( rem2 l/r h/r )

                dw      ROT
                dw      LIT, 9, OVER, LESS

                dw      ZBRANCH
                dw      Dash_Endif - $
                dw          LIT, 7, PLUS

Dash_Endif:

                dw      LIT, 48, PLUS, HOLD

                dw      EXIT

//  ______________________________________________________________________
//
// #s           d1 -- d2
                Colon_Def DASHES, "#S", is_normal
                New_Def  DASHES, "#S", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "#S"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "#S"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DASHES:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
Dashes_Begin:
                dw      DASH, TWO_DUP
                dw          OR_OP, ZEQUAL
                dw      ZBRANCH
                dw      Dashes_Begin - $
                dw      EXIT

//  ______________________________________________________________________
//
// d.r          d n --
                Colon_Def D_DOT_R, "D.R", is_normal
                New_Def  D_DOT_R, "D.R", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "D.R"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "D.R"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
D_DOT_R:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      TO_R
                dw      TUCK, DABS
                dw      BEGIN_DASH, DASHES, ROT, SIGN, DASH_END


                dw      R_TO
                dw      OVER, SUBTRACT, SPACES, TYPE

                dw      EXIT

//  ______________________________________________________________________
//
// .r           n1 n2 --
                Colon_Def DOT_R, ".R", is_normal
                New_Def  DOT_R, ".R", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      ".R"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      ".R"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DOT_R:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      TO_R
                dw      S_TO_D, R_TO
                dw      D_DOT_R
                dw      EXIT

//  ______________________________________________________________________
//
// d.           d --
                Colon_Def D_DOT, "D.", is_normal
                New_Def  D_DOT, "D.", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "D."
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "D."               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
D_DOT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      ZERO, D_DOT_R, SPACE

                dw      EXIT

//  ______________________________________________________________________
//
// .            n --
                Colon_Def DOT, ".", is_normal
                New_Def  DOT, ".", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "."
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "."               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DOT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      S_TO_D, D_DOT
                dw      EXIT

//  ______________________________________________________________________
//
// ?            n --
                Colon_Def QUESTION, "?", is_normal
                New_Def  QUESTION, "?", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "?"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "?"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
QUESTION:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      FETCH, DOT
                dw      EXIT

//  ______________________________________________________________________
//
// u.           u --
                Colon_Def U_DOT, "U.", is_normal
                New_Def  U_DOT, "U.", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "U."
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "U."               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
U_DOT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      ZERO, D_DOT
                dw      EXIT

//  ______________________________________________________________________
//
// words        --
                Colon_Def WORDS, "WORDS", is_normal
                New_Def  WORDS, "WORDS", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "WORDS"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "WORDS"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
WORDS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      LIT, 128, OUT, STORE

                dw      CONTEXT, FETCH, FETCH

Words_Begin:
                dw          DUP, CFETCH, LIT, $1F, AND_OP


                dw          OUT, FETCH, PLUS

                dw          CL, LESS, ZEQUAL

                dw          ZBRANCH
                dw          Words_Endif - $
                dw              CR, ZERO, OUT, STORE

Words_Endif:
                dw          DUP, ID_DOT
                dw          PFA, LFA, FETCH

                dw          DUP, ZEQUAL
                dw          QTERMINAL, OR_OP
                dw      ZBRANCH
                dw      Words_Begin - $
                dw      DROP
                dw      EXIT

//  ______________________________________________________________________
//
// list         n --
                Colon_Def LIST, "LIST", is_normal
                New_Def  LIST, "LIST", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "LIST"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "LIST"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
LIST:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      DECIMAL, CR
                dw      DUP, SCR, STORE

                dw      C_DOT_QUOTE
                db      5, "Scr# "

                dw      DOT
                dw      LSCR, ZERO, C_DO

List_Loop:
                dw          CR
                dw          I, THREE
                dw          DOT_R, SPACE
                dw          I, SCR, FETCH, DOT_LINE

                dw          QTERMINAL
                dw          ZBRANCH
                dw          List_Endif - $
                dw              C_LEAVE
                dw              List_Leave - $
List_Endif:
                dw      C_LOOP
                dw      List_Loop - $
List_Leave:
                dw      CR
                dw      EXIT

//  ______________________________________________________________________
//
// index        n1 n2 --
                Colon_Def INDEX, "INDEX", is_normal
                New_Def  INDEX, "INDEX", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "INDEX"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "INDEX"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
INDEX:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      ONE_PLUS, SWAP, C_DO

Index_Loop:
                dw          CR, I, THREE

                dw          DOT_R, SPACE
                dw          ZERO, I, DOT_LINE

                dw          QTERMINAL
                dw          ZBRANCH
                dw          Index_Endif - $
                dw              C_LEAVE
                dw              Index_Leave - $
Index_Endif:
                dw      C_LOOP
                dw      Index_Loop - $
Index_Leave:
                dw      CR
                dw      EXIT

//  ______________________________________________________________________
//
// cls          --
                Colon_Def CLS, "CLS", is_normal
                New_Def  CLS, "CLS", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "CLS"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "CLS"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
CLS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      LIT, $0E, EMITC

                dw      EXIT

//  ______________________________________________________________________
//
// splash       --
                Colon_Def SPLASH, "SPLASH", is_normal
                New_Def  SPLASH, "SPLASH", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "SPLASH"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "SPLASH"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
SPLASH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      CLS
                dw      C_DOT_QUOTE
                db      88
                db      "v-Forth 1.52 NextZXOS version", 13    // 29







                db      "Direct Threaded - build 20230108", 13  // 31








                db      "1990-2023 Matteo Vitturi", 13        // 25






                dw      EXIT

//  ______________________________________________________________________
//
// video        --
                Colon_Def VIDEO, "VIDEO", is_normal
                New_Def  VIDEO, "VIDEO", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "VIDEO"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "VIDEO"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
VIDEO:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      TWO, DUP, DEVICE, STORE

                dw      SELECT
                dw      EXIT

//  ______________________________________________________________________
//
// accept-      a n1 -- n2
                Colon_Def ACCEPT_N, "ACCEPT-", is_normal
                New_Def  ACCEPT_N, "ACCEPT-", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "ACCEPT-"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "ACCEPT-"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
ACCEPT_N:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      TO_R
                dw      ZERO
                dw      SWAP
                dw      DUP
                dw      R_TO
                dw      PLUS
                dw      SWAP
                dw      C_DO
AcceptN_Loop:
                dw          MMU7_FETCH
                dw          INKEY
                dw          SWAP, MMU7_STORE
                dw          DUP, ZEQUAL
                dw          ZBRANCH
                dw          AcceptN_Endif_1 - $
//              dw              VIDEO, QUIT
                dw              C_LEAVE
                dw              AcceptN_Leave - $

AcceptN_Endif_1:
                dw          DUP, LIT, 13, EQUALS

                dw          ZBRANCH
                dw          AcceptN_Endif_2 - $
                dw              DROP, ZERO
AcceptN_Endif_2:
                dw          DUP, LIT, 10, EQUALS

                dw          ZBRANCH
                dw          AcceptN_Endif_3 - $
                dw              DROP, ZERO
AcceptN_Endif_3:
                dw          I, CSTORE, ONE_PLUS


                dw          I, CFETCH, ZEQUAL   //      i 0= if

                dw          ZBRANCH
                dw              AcceptN_Endif_4 - $
                dw                  C_LEAVE     //              leave
                dw                  AcceptN_Leave - $
AcceptN_Endif_4:                                 //      endif

                dw      C_LOOP
                dw      AcceptN_Loop -$
AcceptN_Leave:
                dw      EXIT

//  ______________________________________________________________________
//
// load-        n --
// Provided that a stream n is OPEN# via the standart BASIC
// it accepts text from stream #n to the normal INTERPRET
// up to now, text-file must end with QUIT
                Colon_Def LOAD_N, "LOAD-", is_normal
                New_Def  LOAD_N, "LOAD-", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "LOAD-"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "LOAD-"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
LOAD_N:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      SOURCE_ID, STORE
Load_N_Begin:
                dw          TIB, FETCH
                dw          DUP, LIT, 80

                dw          TWO_DUP, BLANK
                dw          SOURCE_ID, FETCH
                dw          ABS_OP, DUP, DEVICE, STORE

                dw          SELECT
                dw          ACCEPT_N
                dw          VIDEO
                dw          TWO_DROP
                dw          ZERO, BLK, STORE

                dw          ZERO, TO_IN, STORE

                dw          INTERPRET
                dw          QTERMINAL
                dw      ZBRANCH
                dw      Load_N_Begin - $
                dw      EXIT

//  ______________________________________________________________________
//
// load         n --
// if n is positive, it loads screen #n (as usual)
// if n is negative, it connects stream #n to the normal INTERPRET
// this second way is useful if you want to load any kind of file
// provied that it is OPEN# the usual BASIC way.
                Colon_Def LOAD, "LOAD", is_normal
                New_Def  LOAD, "LOAD", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "LOAD"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "LOAD"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
LOAD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      DUP, ZLESS
                dw      ZBRANCH
                dw      Load_Else - $
                dw          LOAD_N
                dw      BRANCH
                dw      Load_Endif - $
Load_Else:
                dw          LOAD_P
Load_Endif:
                dw      EXIT


//  ______________________________________________________________________
//
// autoexec     --
// this word is called the first time the Forth system boot to
// load Screen# 1. Once called it patches itself to prevent furhter runs.
                Colon_Def AUTOEXEC, "AUTOEXEC", is_normal
                New_Def  AUTOEXEC, "AUTOEXEC", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "AUTOEXEC"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "AUTOEXEC"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
AUTOEXEC:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      LIT, 11
                dw      LIT, NOOP
                dw      LIT, Autoexec_Ptr
                dw      STORE
                dw      LOAD
                dw      QUIT
                dw      EXIT


//  ______________________________________________________________________
//
// bye     --
//
                Colon_Def BYE, "BYE", is_normal
                New_Def  BYE, "BYE", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "BYE"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "BYE"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
BYE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      FLUSH
                dw      EMPTY_BUFFERS
                dw      BLK_FH, FETCH, F_CLOSE, DROP

                dw      ZERO, PLUS_ORIGIN
                dw      BASIC

//  ______________________________________________________________________
//
// invv     --
//
//              Colon_Def INVV, "INVV", is_normal
//              dw      LIT, 20, EMITC, ONE, EMITC
//              dw      EXIT

//  ______________________________________________________________________
//
// truv     --
//
//              Colon_Def TRUV, "TRUV", is_normal
//              dw      LIT, 20, EMITC, ZERO, EMITC
//              dw      EXIT

//  ______________________________________________________________________
//
// mark     --
//
//              Colon_Def MARK, "MARK", is_normal
//              dw      INVV, TYPE, TRUV
//              dw      EXIT

//  ______________________________________________________________________
//
// back     --
//
                Colon_Def BACK, "BACK", is_normal
                New_Def  BACK, "BACK", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "BACK"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "BACK"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
BACK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      HERE, SUBTRACT, COMMA

                dw      EXIT

//  ______________________________________________________________________
//
// if          ( -- a 2 ) \ compile-time
// IF ... THEN
// IF ... ELSE ... ENDIF
                Colon_Def IF, "IF", is_immediate
                New_Def  IF, "IF", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "IF"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "IF"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
IF:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      COMPILE, ZBRANCH
                dw      HERE, ZERO, COMMA

                dw      TWO
                dw      EXIT

//  ______________________________________________________________________
//
// then        ( a 2 -- ) \ compile-time
//
                Colon_Def THEN, "THEN", is_immediate
                New_Def  THEN, "THEN", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "THEN"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "THEN"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
THEN:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      QCOMP
                dw      TWO, QPAIRS
                dw      HERE, OVER, SUBTRACT, SWAP, STORE


                dw      EXIT

//  ______________________________________________________________________
//
// endif       ( a 2 -- ) \ compile-time
//
                Colon_Def ENDIF, "ENDIF", is_immediate
                New_Def  ENDIF, "ENDIF", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "ENDIF"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "ENDIF"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
ENDIF:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      THEN
                dw      EXIT

//  ______________________________________________________________________
//
// else        ( a1 2 -- a2 2 ) \ compile-time
//
                Colon_Def ELSE, "ELSE", is_immediate
                New_Def  ELSE, "ELSE", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "ELSE"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "ELSE"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
ELSE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      QCOMP
                dw      TWO, QPAIRS
                dw      COMPILE, BRANCH
                dw      HERE, ZERO, COMMA

                dw      SWAP, TWO, THEN

                dw      TWO
                dw      EXIT

//  ______________________________________________________________________
//
// begin        ( -- a 1 ) \ compile-time
// BEGIN ... AGAIN
// BEGIN ... f UNTIL
// BEGIN ... f WHILE ... REPEAT
                Colon_Def BEGIN, "BEGIN", is_immediate
                New_Def  BEGIN, "BEGIN", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "BEGIN"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "BEGIN"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
BEGIN:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      QCOMP
                dw      HERE
                dw      TWO
                dw      EXIT

//  ______________________________________________________________________
//
// again        ( a 1 -- ) \ compile-time
                Colon_Def AGAIN, "AGAIN", is_immediate
                New_Def  AGAIN, "AGAIN", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "AGAIN"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "AGAIN"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
AGAIN:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      QCOMP
                dw      TWO, QPAIRS
                dw      COMPILE, BRANCH
                dw      BACK
                dw      EXIT

//  ______________________________________________________________________
//
// until        ( a 1 -- ) \ compile-time
                Colon_Def UNTIL, "UNTIL", is_immediate
                New_Def  UNTIL, "UNTIL", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "UNTIL"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "UNTIL"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
UNTIL:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      QCOMP
                dw      TWO, QPAIRS
                dw      COMPILE, ZBRANCH
                dw      BACK
                dw      EXIT

//  ______________________________________________________________________
//
// end          ( a 1 -- ) \ compile-time
                Colon_Def END, "END", is_immediate
                New_Def  END, "END", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "END"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "END"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
END:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      UNTIL
                dw      EXIT

//  ______________________________________________________________________
//
// while        ( a1 1 -- a1 1 a2 4 ) \ compile-time
                Colon_Def WHILE, "WHILE", is_immediate
                New_Def  WHILE, "WHILE", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "WHILE"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "WHILE"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
WHILE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      IF
//              dw      TWO_PLUS // ( that is 4 )
                dw      TWO_SWAP
                dw      EXIT

//  ______________________________________________________________________
//
// repeat       ( a1 1 a2 4 -- ) \ compile-time
                Colon_Def REPEAT, "REPEAT", is_immediate
                New_Def  REPEAT, "REPEAT", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "REPEAT"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "REPEAT"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
REPEAT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      AGAIN
//              dw      TWO_MINUS
                dw      THEN
                dw      EXIT

//  ______________________________________________________________________
//
// ?do-
// special version of "BACK" used by ?DO and LOOP
                Colon_Def C_DO_BACK, "?DO-", is_normal
                New_Def  C_DO_BACK, "?DO-", Enter_Ptr, is_normal ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "?DO-"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "?DO-"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
C_DO_BACK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      BACK
CDoBack_Begin:
                dw      SPFETCH, CSP, FETCH, SUBTRACT

                dw      ZBRANCH
                dw      CDoBack_While - $
                dw          TWO_PLUS, THEN
                dw      BRANCH
                dw      CDoBack_Begin - $
CDoBack_While:
                dw      QCSP, CSP, STORE

                dw      EXIT

//  ______________________________________________________________________
//
// do
// DO  ... LOOP
// DO  ... n +LOOP
// ?DO ... LOOP
// ?DO ... n +LOOP
                Colon_Def DO, "DO", is_immediate
                New_Def  DO, "DO", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "DO"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "DO"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
DO:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      COMPILE, C_DO
                dw      CSP, FETCH, STORE_CSP

                dw      HERE, THREE
                dw      EXIT

//  ______________________________________________________________________
//
// loop
                Colon_Def LOOP, "LOOP", is_immediate
                New_Def  LOOP, "LOOP", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "LOOP"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "LOOP"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
LOOP:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      THREE, QPAIRS
                dw      COMPILE, C_LOOP
                dw      C_DO_BACK
                dw      EXIT

//  ______________________________________________________________________
//
// +loop
                Colon_Def PLOOP, "+LOOP", is_immediate
                New_Def  PLOOP, "+LOOP", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "+LOOP"

len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "+LOOP"               // name string in 7-bit ascii, but

                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
PLOOP:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      THREE, QPAIRS
                dw      COMPILE, C_PLOOP
                dw      C_DO_BACK
                dw      EXIT

//  ______________________________________________________________________
//
// ?do
                Colon_Def QDO, "?DO", is_immediate
                New_Def  QDO, "?DO", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "?DO"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "?DO"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
QDO:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      COMPILE, C_Q_DO
                dw      CSP, FETCH, STORE_CSP

                dw      HERE, ZERO, COMMA, ZERO

                dw      HERE, THREE
                dw      EXIT

Latest_Definition:
//  ______________________________________________________________________
//
// \
                Colon_Def BACKSLASH, "\\", is_immediate  // this is a single back-slash
                New_Def  BACKSLASH, "\\", Enter_Ptr, is_immediate ; ok
temp_NFA        defl    $                   // save this NFA address to temp_NFA

                // dummy db directives used to calculate length of namec
                db      "\\"
len_NFA         defl    $ - temp_NFA
                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part

                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
                db      "\\"               // name string in 7-bit ascii, but
                org     $-1                 // alter last byte of Name just above to set
                db      {b $} | END_BIT     // msb as name end

                dw      last_NFA            // Link to previous definition Name
BACKSLASH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
                call    Enter_Ptr ; ok        // for primitive definitions  actual code


                endif           ; ok        // for other definitions it "points" the correct handler
                // Use of "; ok" to suppress "warning[fwdref]"

last_NFA        defl    temp_NFA            // keep track of NFA saved above
                dw      BLK, FETCH
                dw      ZBRANCH
                dw      Backslash_Else_1 - $
                dw          BLK, FETCH, ONE, GREATER  // BLOCK 1 is used as temp-line in INCLUDE file

                dw          ZBRANCH
                dw          Backslash_Else_2 - $
                dw              TO_IN, FETCH, CL, MOD, CL


                dw              SWAP, SUBTRACT, TO_IN, PLUSSTORE

                dw          BRANCH
                dw          Backslash_Endif_2 - $
Backslash_Else_2:
                dw              BBUF, CELL_MINUS, TO_IN, STORE

Backslash_Endif_2:
                dw      BRANCH
                dw      Backslash_Endif_1 - $
Backslash_Else_1:
                dw          LIT, 80, TO_IN, STORE

Backslash_Endif_1:
                dw      EXIT

Fence_Word:
//  ______________________________________________________________________
//

Here_Dictionary db      0

ect\Projects\vForth15_DIRECT/source/L3.asm

// now we save the compiled file so we can either run it or debug it
                SAVENEX OPEN "output/main.nex", ORIGIN
                SAVENEX CORE 3, 0, 0                                // Next core 3.0.0 required as minimum
                SAVENEX CFG  0
                SAVENEX BANK 2, 0
                SAVENEX AUTO
                SAVENEX CLOSE

//              PAGE 7 ;set 7 page to current slot
//              SAVEBIN "ram7.bin",$C000,$4000 ;- save 4000h begin from C000h of RAM to file
//              SAVEBIN "output/ram2.bin", $8000, 9800 ;- save 3000h begin from 8000h of RAM to file

                SAVETAP "output/F15f.tap", CODE, "forth15f", ORIGIN, 10000

                SAVEBIN "output/forth15f.bin", ORIGIN, 10000

                END
ect\Projects\vForth15_DIRECT/source/main.asm
