# file opened: C:\Zx\CSpect\Projects\vForth17_MMU7/source/main.asm
   1  0000              //  ______________________________________________________________________
   2  0000              //
   3  0000              //  main.asm
   4  0000              //  ______________________________________________________________________
   5  0000              //
   6  0000              //  v-Forth 1.62 NextZXOS version
   7  0000              //  build 20230321
   8  0000              //
   9  0000              //  Direct-Threaded version.
  10  0000              //
  11  0000              //  NextZXOS version
  12  0000              //  ______________________________________________________________________
  13  0000              //
  14  0000              //  This work is available as-is with no whatsoever warranty.
  15  0000              //  Copying, modifying and distributing this software is allowed
  16  0000              //  provided that the copyright notice is kept.
  17  0000              //  ______________________________________________________________________
  18  0000              //
  19  0000              //  by Matteo Vitturi, 1990-2023
  20  0000              //
  21  0000              //  https://sites.google.com/view/vforth/vforth15-next
  22  0000              //  https://www.oocities.org/matteo_vitturi/english/index.htm
  23  0000              //
  24  0000              //  This is the complete compiler for v.Forth for SINCLAIR ZX Spectrum Next.
  25  0000              //  Each line of this source list mustn't exceed 80 bytes.
  26  0000              //  Z80N (ZX Spectrum Next) extension is available.
  27  0000              //
  28  0000              //  This list has been tested using the following configuration:
  29  0000              //      - CSpect emulator V.2.12.30
  30  0000              //  ______________________________________________________________________
  31  0000              //
  32  0000              //  Z80 Registers usage map
  33  0000              //
  34  0000              //  AF
  35  0000              //  BC - Instruction Pointer: should be preserved during ROM/OS calls
  36  0000              //  DE - Return Stack Pointer: should be preserved during ROM/OS calls
  37  0000              //  HL - Working
  38  0000              //
  39  0000              //  AF'- Sometime used for backup purpose
  40  0000              //  BC'- Not used
  41  0000              //  DE'- Not used
  42  0000              //  HL'- Not used
  43  0000              //
  44  0000              //  SP - Calculator Stack Pointer
  45  0000              //  IX - Inner interpreter "next" address pointer. This way jp (ix) is 2T-state faster than JP next
  46  0000              //  IY - (ZX System: must be preserved to interact with standard ROM)
  47  0000              //
  48  0000              //  ______________________________________________________________________
  49  0000              //
  50  0000              //  _________________
  51  0000              //
  52  0000              //  FORTH DEFINITIONS
  53  0000              //  _________________
  54  0000
  55  0000                              OPT     --zxnext
  56  0000              //  ______________________________________________________________________
  57  0000              //
  58  0000              // this controls some debugging code in L0.asm
  59  0000              //  0 for final binary release.
  60  0000              //  1 for debugging with Visual Studio Code and DeZog
  61  0000              // -1 for for binary comparison with Forth generated code.
  62  0000              DEBUGGING       equ     -1
  63  0000              //
  64  0000              //  ______________________________________________________________________
  65  0000
  66  0000                              if ( -1 == DEBUGGING )
  67  0000              //ORIGIN          equ     $62E6                   // for binary comparison
  68  0000              ORIGIN          equ     39606 - $80               // for binary comparison
  69  0000                              endif
  70  0000              //  ______________________________________________________________________
  71  0000
  72  0000                              if (  0 == DEBUGGING )
  73  0000 ~            ORIGIN          equ     $6366                   // binary and Tape
  74  0000 ~            // ORIGIN          equ     $9A93                // binary and Tape
  75  0000                              endif
  76  0000              //  ______________________________________________________________________
  77  0000
  78  0000                              if (  1 == DEBUGGING )
  79  0000 ~            ORIGIN          equ     $8080                   // for DeZog
  80  0000                              endif
  81  0000              //  ______________________________________________________________________
  82  0000
  83  0000                              DEVICE  ZXSPECTRUMNEXT
  84  0000
  85  0000                              ORG     ORIGIN
  86  9A36
  87  9A36                              if ( -1 == DEBUGGING )
  88  9A36 00 00 00...                  ds 128                            // for binary comparison
  89  9A3A                              endif
  90  9AB6
  91  9AB6              //  ______________________________________________________________________
  92  9AB6              //
  93  9AB6              //  Naming convention for Label vs Forth correspondance
  94  9AB6              //  Forth words are named as they are named for real with some exception to avoid assembler syntax errors.
  95  9AB6              //    - Leading "0" is converted into "Z_"
  96  9AB6              //    - Leading "(" is converted into "C_", closing bracket is omitted
  97  9AB6              //    - Leading numbers are converted in letters: ONE_  TWO_ etc.
  98  9AB6              //    - Question mark "?" is converted into "Q" or omitted if needed / useful.
  99  9AB6              //    - Plus sign "+" is converted in _PLUS or ADD_ depending.
 100  9AB6              //    - Minus sign "-" in L (for Line), MINUS or SUBTRACT depending
 101  9AB6              //    - Greater-Than sign ">" in _GREATER or TO_ depending
 102  9AB6              //    - Equal sign "=" is converted in EQUAL
 103  9AB6              //    - Less-Than sign "<" in _LESS or FROM_ (or TO_ again) depending
 104  9AB6              //    - Asterisk sign "*" is converted in _MUL or STAR
 105  9AB6              //    - Slash "/" is converted in _DIV or omitted if it is clear what it means
 106  9AB6              //    - Exclamation mark "!" is converted in STORE
 107  9AB6              //    - At-Sign "@" is converted in FETCH
 108  9AB6              //    - Words that collide with Assembler are normally suffixed with "_OP"
 109  9AB6
 110  9AB6                              include "system.asm"
# file opened: C:\Zx\CSpect\Projects\vForth17_MMU7/source/system.asm
   1+ 9AB6              //  ______________________________________________________________________
   2+ 9AB6              //
   3+ 9AB6              //  system.asm
   4+ 9AB6              //  ______________________________________________________________________
   5+ 9AB6
   6+ 9AB6              // Registers:
   7+ 9AB6              //
   8+ 9AB6              //      BC: Instruction Pointer
   9+ 9AB6              //      DE:
  10+ 9AB6              //      HL: W register
  11+ 9AB6              //      SP: Calc stack Pointer
  12+ 9AB6              //      IX: Inner-Interpreter Address
  13+ 9AB6
  14+ 9AB6              //  ______________________________________________________________________
  15+ 9AB6              //
  16+ 9AB6              // ZX-Spectrum standard system variables
  17+ 9AB6              SCR_CT          equ     $5C8C                   // SCR-CT system variable
  18+ 9AB6              LASTK           equ     $5C08                   // LASTK system variable
  19+ 9AB6              BORDCR          equ     $5C48                   // BORDCR system variable
  20+ 9AB6              FLAGS2          equ     $5C6A                   // for caps-lock
  21+ 9AB6
  22+ 9AB6              //  ______________________________________________________________________
  23+ 9AB6              //
  24+ 9AB6              // Flag constants
  25+ 9AB6              TRUE_FLAG       equ     $FFFF
  26+ 9AB6              FALSE_FLAG      equ     $0000
  27+ 9AB6
  28+ 9AB6              //  ______________________________________________________________________
  29+ 9AB6              //
  30+ 9AB6              // Ascii char constants
  31+ 9AB6              NUL_CHAR        equ     $00
  32+ 9AB6              COMMA_CHAR      equ     $06
  33+ 9AB6              BACKSPACE_CHAR  equ     $08
  34+ 9AB6              CR_CHAR         equ     $0D
  35+ 9AB6              BLANK_CHAR      equ     $20
  36+ 9AB6              QUOTE_CHAR      equ     "'"
  37+ 9AB6              DQUOTE_CHAR     equ     '"'
  38+ 9AB6              UNDERSCORE_CHAR equ     $5F
  39+ 9AB6              SOLIDBLOCK_CHAR equ     $8F
  40+ 9AB6              HALFBLOCK_CHAR  equ     $8C
  41+ 9AB6              LC_A_CHAR       equ     $61                 // lower-case "a"
  42+ 9AB6              LC_Z_CHAR       equ     $7A                 // lower-case "z"
  43+ 9AB6
  44+ 9AB6
  45+ 9AB6              //  ______________________________________________________________________
  46+ 9AB6              //
  47+ 9AB6
  48+ 9AB6                              // emulate something like:  ld hl,rp
  49+ 9AB6              ldhlrp          macro
  50+ 9AB6 ~                            ld      hl,(RP_Pointer)
  51+ 9AB6                              endm
  52+ 9AB6
  53+ 9AB6                              // emulate something like:  ld rp,hl
  54+ 9AB6              ldrphl          macro
  55+ 9AB6 ~                            ld      (RP_Pointer),hl
  56+ 9AB6                              endm
  57+ 9AB6
  58+ 9AB6              //  ______________________________________________________________________
  59+ 9AB6              //
  60+ 9AB6              //  Inner interpreter next-address pointer. This is 2T-state faster than "jp address"
  61+ 9AB6              next            macro
  62+ 9AB6 ~                            jp      (ix)
  63+ 9AB6                              endm
  64+ 9AB6
  65+ 9AB6              psh1            macro
  66+ 9AB6 ~                            push    hl
  67+ 9AB6 ~                            jp      (ix)
  68+ 9AB6                              endm
  69+ 9AB6
  70+ 9AB6              psh2            macro
  71+ 9AB6 ~                            push    de
  72+ 9AB6 ~                            push    hl
  73+ 9AB6 ~                            jp      (ix)
  74+ 9AB6                              endm
  75+ 9AB6
  76+ 9AB6              //  ______________________________________________________________________
  77+ 9AB6              //
  78+ 9AB6              // Bit constants in length-byte
  79+ 9AB6
  80+ 9AB6              SMUDGE_BIT      equ     %00100000               // $20
  81+ 9AB6              IMMEDIATE_BIT   equ     %01000000               // $40
  82+ 9AB6              END_BIT         equ     %10000000               // $80
  83+ 9AB6
  84+ 9AB6
  85+ 9AB6              //  ______________________________________________________________________
  86+ 9AB6              //
  87+ 9AB6              //  To create Forth words using this (nice) Assembler, we have to use the two following
  88+ 9AB6              //  pointers
  89+ 9AB6              temp_NFA        defl    0
  90+ 9AB6              last_NFA        defl    0
  91+ 9AB6              len_NFA         defl    0
  92+ 9AB6
  93+ 9AB6              Dict_Ptr        defl    0
  94+ 9AB6              Heap_Ptr        defl    $00FA
  95+ 9AB6              Prev_Ptr        defl    0
  96+ 9AB6              mirror_Ptr      defl    0
  97+ 9AB6
  98+ 9AB6              is_code         equ     0                   // so the direct machine-code starts at CFA
  99+ 9AB6              is_normal       equ     0                   // so the direct machine-code starts at CFA
 100+ 9AB6              is_immediate    equ     IMMEDIATE_BIT       // $40 - the definition is IMMEDIATE.
 101+ 9AB6
 102+ 9AB6              //  ______________________________________________________________________
 103+ 9AB6              //
 104+ 9AB6              //  Create a new "low-level" definition
 105+ 9AB6              //  This macro is used in the form  Create FORTH_NAME,n,"forth_name"
 106+ 9AB6              //  to create a new Forth Dictionary entry the same way Forth itself would do.
 107+ 9AB6              //  A word begins with a Length-Byte in range 1-31. Top 3 msb are used as flags
 108+ 9AB6              //  see SMUDGE_BIT and IMMEDIATE_BIT constant above.
 109+ 9AB6              //  It is followed by the Name of the word, i.e. a string expressed in 7-bit Ascii.
 110+ 9AB6              //  The last character of the Name must have the msb set to signal the end of it (END_BIT)
 111+ 9AB6              //  This macro acts much like the standard Forth definition CREATE
 112+ 9AB6
 113+ 9AB6              New_Def         macro   label, namec, runcode, bits
 114+ 9AB6 ~
 115+ 9AB6 ~            Dict_Ptr        defl    $
 116+ 9AB6 ~
 117+ 9AB6 ~            //              ______________________________________________________________________
 118+ 9AB6 ~            //              Heap part
 119+ 9AB6 ~
 120+ 9AB6 ~
 121+ 9AB6 ~                            org     (Heap_Ptr & $1FFF) + $E000
 122+ 9AB6 ~
 123+ 9AB6 ~            temp_NFA        defl    $                   // save this NFA address to temp_NFA
 124+ 9AB6 ~            Latest_Definition defl  Heap_Ptr
 125+ 9AB6 ~
 126+ 9AB6 ~                            // dummy db directives used to calculate length of namec
 127+ 9AB6 ~                            db      namec
 128+ 9AB6 ~            len_NFA         defl    $ - temp_NFA
 129+ 9AB6 ~                            org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 130+ 9AB6 ~
 131+ 9AB6 ~                            db      len_NFA | END_BIT | bits  // The start of NFA must have msb set to signal the beginning of the sounted string
 132+ 9AB6 ~                            db      namec               // name string in 7-bit ascii, but
 133+ 9AB6 ~                            org     $-1                 // alter last byte of Name just above to set
 134+ 9AB6 ~                            db      {b $} | END_BIT     // msb as name end
 135+ 9AB6 ~
 136+ 9AB6 ~                            dw      Prev_Ptr            // Link to previous definition Name
 137+ 9AB6 ~            Prev_Ptr        defl    Heap_Ptr
 138+ 9AB6 ~
 139+ 9AB6 ~            mirror_Ptr      defl    $
 140+ 9AB6 ~
 141+ 9AB6 ~                            dw      Dict_Ptr + 2        // xt
 142+ 9AB6 ~            Heap_Ptr        defl    $ - $E000           // save current HP
 143+ 9AB6 ~
 144+ 9AB6 ~            Current_HP      defl  $ - $E000             // used to set HP once!
 145+ 9AB6 ~
 146+ 9AB6 ~            //              ______________________________________________________________________
 147+ 9AB6 ~            //              Dictionary part
 148+ 9AB6 ~
 149+ 9AB6 ~                            org     Dict_Ptr
 150+ 9AB6 ~
 151+ 9AB6 ~                            dw      mirror_Ptr - $E000 + $1F00
 152+ 9AB6 ~
 153+ 9AB6 ~            label:          if runcode != 0 ; ok        // This is the start address of the direct jp(hl)
 154+ 9AB6 ~                            call    runcode ; ok        // for primitive definitions  actual code
 155+ 9AB6 ~
 156+ 9AB6 ~
 157+ 9AB6 ~                            endif           ; ok        // for other definitions it "points" the correct handler
 158+ 9AB6 ~                            // Use of "; ok" to suppress "warning[fwdref]"
 159+ 9AB6 ~
 160+ 9AB6 ~            last_NFA        defl    temp_NFA            // keep track of NFA saved above
 161+ 9AB6                              endm
 162+ 9AB6
 163+ 9AB6              //  ______________________________________________________________________
 164+ 9AB6              //
 165+ 9AB6              // Create a "constant"
 166+ 9AB6              // The constant value is compiled in first PFA cell
 167+ 9AB6              Constant_Def    macro   label, namec, constant_value
 168+ 9AB6 ~                            New_Def  label, namec, Constant_Ptr, is_normal
 169+ 9AB6 ~                            dw      constant_value
 170+ 9AB6                              endm
 171+ 9AB6
 172+ 9AB6              //  ______________________________________________________________________
 173+ 9AB6              //
 174+ 9AB6              // Create a "variable"
 175+ 9AB6              // The when invoked, a variable returns a pointer, the address of first PFA cell
 176+ 9AB6              // this allow creation of "variables" which content is  of any length
 177+ 9AB6              Variable_Def    macro   label, namec, initial_value
 178+ 9AB6 ~                            New_Def  label, namec, Variable_Ptr, is_normal
 179+ 9AB6 ~                            dw      initial_value
 180+ 9AB6                              endm
 181+ 9AB6
 182+ 9AB6              //  ______________________________________________________________________
 183+ 9AB6              //
 184+ 9AB6              // Create a "user"
 185+ 9AB6              // It uses a single byte as offset to calculate the address of the variable
 186+ 9AB6              User_Def        macro   label, namec, offset_value
 187+ 9AB6 ~                            New_Def  label, namec, User_Ptr, is_normal
 188+ 9AB6 ~                            db      offset_value
 189+ 9AB6                              endm
 190+ 9AB6
 191+ 9AB6              //  ______________________________________________________________________
 192+ 9AB6              //
 193+ 9AB6              // Create a "colon-definition"
 194+ 9AB6              // The CFA contains a small routine i.e. "call Enter_Ptr".
 195+ 9AB6              // The PFA, three bytes later, contains the actual Forth definition
 196+ 9AB6              Colon_Def       macro   label, namec, bits
 197+ 9AB6 ~                            New_Def  label, namec, Enter_Ptr, bits ; ok
 198+ 9AB6                              endm
 199+ 9AB6
 200+ 9AB6              //  ______________________________________________________________________
 201+ 9AB6              //
 202+ 9AB6
 203+ 9AB6              S0_system:      equ     $D0E8               // Address of top of Calc Stack
 204+ 9AB6              TIB_system      equ     $D0E8               // TIB grows upwards, Return-Stack downward.
 205+ 9AB6              R0_system:      equ     $D188               // Address of top of Return Stack. This is S0 + $00A0
 206+ 9AB6              USER_system:    equ     $D188               // User variables zone.
 207+ 9AB6              FIRST_system:   equ     $D1E4               // Address of first BUFFER
 208+ 9AB6              LIMIT_system:   equ     $E000               // Address of first byte beyond last BUFFER
 209+ 9AB6
# file closed: C:\Zx\CSpect\Projects\vForth17_MMU7/source/system.asm
 111  9AB6                              include "L0.asm"
# file opened: C:\Zx\CSpect\Projects\vForth17_MMU7/source/L0.asm
   1+ 9AB6              //  ______________________________________________________________________
   2+ 9AB6              //
   3+ 9AB6              //  L0.asm
   4+ 9AB6              //
   5+ 9AB6              //  Origin-Area and Level-0 definitions
   6+ 9AB6              //  ______________________________________________________________________
   7+ 9AB6
   8+ 9AB6              Cold_origin:
   9+ 9AB6 A7                           and     a
  10+ 9AB7 C3 D8 AC                     jp      ColdRoutine
  11+ 9ABA              Warm_origin:
  12+ 9ABA 37                           scf
  13+ 9ABB C3 D8 AC                     jp      WarmRoutine
  14+ 9ABE
  15+ 9ABE              // +008
  16+ 9ABE E6 D0        SP_Basic:       dw      $D0E6               // These are bits with some "standard" meaning... 0101
  17+ 9AC0
  18+ 9AC0              // +00A
  19+ 9AC0 00 0E                        dw      $0E00
  20+ 9AC2
  21+ 9AC2              // +00C
  22+ 9AC2 69 0D        Latest_origin:  dw      Latest_Definition   // Latest word (used in Cold_Start)
  23+ 9AC4
  24+ 9AC4              // +00E
  25+ 9AC4 0C 00        DEL_Char_Ptr:   dw      $000C               // This is the characther used as "Back-Space"
  26+ 9AC6
  27+ 9AC6              // +010
  28+ 9AC6 50 B2        CPU_Id          dw      $B250               // Z80 expressed in base 36
  29+ 9AC8
  30+ 9AC8              // +012
  31+ 9AC8 E8 D0        S0_origin:      dw      S0_system
  32+ 9ACA 88 D1        R0_origin:      dw      R0_system
  33+ 9ACC E8 D0        TIB_origin:     dw      TIB_system
  34+ 9ACE 1F 00        WIDTH_origin:   dw      31
  35+ 9AD0 01 00        WARNING_origin: dw      1
  36+ 9AD2 73 B8        FENCE_origin:   dw      Fence_Word
  37+ 9AD4 73 B8        DP_origin       dw      Fence_Word
  38+ 9AD6 09 AC        VOCLINK_origin: dw      Voclink_Ptr
  39+ 9AD8 E4 D1                        dw      FIRST_system
  40+ 9ADA 00 E0                        dw      LIMIT_system
  41+ 9ADC 6F 0D        HP_origin:      dw      Current_HP
  42+ 9ADE
  43+ 9ADE              // +028
  44+ 9ADE 8F           Block_Face:     db      SOLIDBLOCK_CHAR     // Caps-Lock   Cursor face
  45+ 9ADF 8C           Half_Face:      db      HALFBLOCK_CHAR      // Caps-unlock Cursor face
  46+ 9AE0 5F           Underscore_Face:db      UNDERSCORE_CHAR     // Underscore  Cursor face
  47+ 9AE1 00                           db      0
  48+ 9AE2
  49+ 9AE2              // +02C
  50+ 9AE2 00 00        SP_Saved:       dw      $0000               // Saved SP dufing NextOS call
  51+ 9AE4
  52+ 9AE4              // +02E
  53+ 9AE4 88 D1        USER_Pointer:   dw      USER_system
  54+ 9AE6
  55+ 9AE6              // +030
  56+ 9AE6 88 D1        RP_Pointer:     dw      $d188 // R0_system
  57+ 9AE8
  58+ 9AE8              // +32
  59+ 9AE8 00 00        IX_Echo:        dw      $0000               // Echo IX after NextOS call
  60+ 9AEA
  61+ 9AEA
  62+ 9AEA
  63+ 9AEA              //  ______________________________________________________________________
  64+ 9AEA
  65+ 9AEA              // from this point we can use LDHLRP and LDRPHL Assembler macros
  66+ 9AEA              // instead of their equivalent long sequences.
  67+ 9AEA
  68+ 9AEA              //  ______________________________________________________________________
  69+ 9AEA
  70+ 9AEA              // address for "next" - inner interpreter
  71+ 9AEA              // This address must always be pointed by IX
  72+ 9AEA              // "next" macro simply does a  jp(ix)  instruction
  73+ 9AEA
  74+ 9AEA              // Psh2_Ptr:       push    de
  75+ 9AEA              // Psh1_Ptr:       push    hl
  76+ 9AEA
  77+ 9AEA              Next_Ptr:       // This address must always be kept in IX: "next" relies on that
  78+ 9AEA
  79+ 9AEA                              if ( 1 == DEBUGGING )
  80+ 9AEA ~                            ld      hl, Next_Breakpoint_1
  81+ 9AEA ~                            and     a
  82+ 9AEA ~                            sbc     hl, bc
  83+ 9AEA ~                            jr      nz, Next_Continue
  84+ 9AEA ~                            nop // This is where you have to put a real breakpoint to intercept BC values...
  85+ 9AEA                              endif
  86+ 9AEA
  87+ 9AEA              Next_Continue:
  88+ 9AEA 0A                           ld      a, (bc)
  89+ 9AEB 03                           inc     bc
  90+ 9AEC 6F                           ld      l, a
  91+ 9AED 0A                           ld      a, (bc)
  92+ 9AEE 03                           inc     bc
  93+ 9AEF 67                           ld      h, a                // hl contains a CFA (xt) of word being executed
  94+ 9AF0
  95+ 9AF0              // Execute xt i.e. CFA held in HL
  96+ 9AF0              Exec_Ptr:
  97+ 9AF0
  98+ 9AF0
  99+ 9AF0
 100+ 9AF0
 101+ 9AF0 E9                           jp      (hl)                // and jump to it
 102+ 9AF1                                                          // there you'll find the real code or a CALL to a ;code part
 103+ 9AF1
 104+ 9AF1              //  ______________________________________________________________________
 105+ 9AF1              //
 106+ 9AF1              // lit          -- x
 107+ 9AF1              // puts on top of stack the value of the following word.
 108+ 9AF1              // it is compiled in colon definition before a literal number
 109+ 9AF1
 110+ 9AF1                              New_Def  LIT, "LIT", is_code, is_normal
 110+ 9AF1             >
 110+ 9AF1             >Dict_Ptr        defl    $
 110+ 9AF1             >
 110+ 9AF1             >//              ______________________________________________________________________
 110+ 9AF1             >//              Heap part
 110+ 9AF1             >
 110+ 9AF1             >
 110+ 9AF1             >                org     (Heap_Ptr & $1FFF) + $E000
 110+ E0FA             >
 110+ E0FA             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 110+ E0FA             >Latest_Definition defl  Heap_Ptr
 110+ E0FA             >
 110+ E0FA             >                // dummy db directives used to calculate length of namec
 110+ E0FA 4C 49 54    >                db      "LIT"
 110+ E0FD             >len_NFA         defl    $ - temp_NFA
 110+ E0FD             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 110+ E0FA             >
 110+ E0FA 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 110+ E0FB 4C 49 54    >                db      "LIT"               // name string in 7-bit ascii, but
 110+ E0FE             >                org     $-1                 // alter last byte of Name just above to set
 110+ E0FD D4          >                db      {b $} | END_BIT     // msb as name end
 110+ E0FE             >
 110+ E0FE 00 00       >                dw      Prev_Ptr            // Link to previous definition Name
 110+ E100             >Prev_Ptr        defl    Heap_Ptr
 110+ E100             >
 110+ E100             >mirror_Ptr      defl    $
 110+ E100             >
 110+ E100 F3 9A       >                dw      Dict_Ptr + 2        // xt
 110+ E102             >Heap_Ptr        defl    $ - $E000           // save current HP
 110+ E102             >
 110+ E102             >Current_HP      defl  $ - $E000             // used to set HP once!
 110+ E102             >
 110+ E102             >//              ______________________________________________________________________
 110+ E102             >//              Dictionary part
 110+ E102             >
 110+ E102             >                org     Dict_Ptr
 110+ 9AF1             >
 110+ 9AF1 00 20       >                dw      mirror_Ptr - $E000 + $1F00
 110+ 9AF3             >
 110+ 9AF3             >LIT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 110+ 9AF3 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 110+ 9AF3 ~           >
 110+ 9AF3 ~           >
 110+ 9AF3             >                endif           ; ok        // for other definitions it "points" the correct handler
 110+ 9AF3             >                // Use of "; ok" to suppress "warning[fwdref]"
 110+ 9AF3             >
 110+ 9AF3             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 111+ 9AF3
 112+ 9AF3 0A                           ld      a, (bc)
 113+ 9AF4 03                           inc     bc
 114+ 9AF5 6F                           ld      l, a
 115+ 9AF6 0A                           ld      a, (bc)
 116+ 9AF7 03                           inc     bc
 117+ 9AF8 67                           ld      h, a
 118+ 9AF9 E5                           push    hl
 119+ 9AFA                              next
 119+ 9AFA DD E9       >                jp      (ix)
 120+ 9AFC
 121+ 9AFC              //  ______________________________________________________________________
 122+ 9AFC              //
 123+ 9AFC              // execute      i*x xt -- j*x
 124+ 9AFC              // execution token. usually xt is given by CFA
 125+ 9AFC
 126+ 9AFC                              New_Def  EXECUTE, "EXECUTE", is_code, is_normal
 126+ 9AFC             >
 126+ 9AFC             >Dict_Ptr        defl    $
 126+ 9AFC             >
 126+ 9AFC             >//              ______________________________________________________________________
 126+ 9AFC             >//              Heap part
 126+ 9AFC             >
 126+ 9AFC             >
 126+ 9AFC             >                org     (Heap_Ptr & $1FFF) + $E000
 126+ E102             >
 126+ E102             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 126+ E102             >Latest_Definition defl  Heap_Ptr
 126+ E102             >
 126+ E102             >                // dummy db directives used to calculate length of namec
 126+ E102 45 58 45 43 >                db      "EXECUTE"
 126+ E106 55 54 45    >
 126+ E109             >len_NFA         defl    $ - temp_NFA
 126+ E109             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 126+ E102             >
 126+ E102 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 126+ E103 45 58 45 43 >                db      "EXECUTE"               // name string in 7-bit ascii, but
 126+ E107 55 54 45    >
 126+ E10A             >                org     $-1                 // alter last byte of Name just above to set
 126+ E109 C5          >                db      {b $} | END_BIT     // msb as name end
 126+ E10A             >
 126+ E10A FA 00       >                dw      Prev_Ptr            // Link to previous definition Name
 126+ E10C             >Prev_Ptr        defl    Heap_Ptr
 126+ E10C             >
 126+ E10C             >mirror_Ptr      defl    $
 126+ E10C             >
 126+ E10C FE 9A       >                dw      Dict_Ptr + 2        // xt
 126+ E10E             >Heap_Ptr        defl    $ - $E000           // save current HP
 126+ E10E             >
 126+ E10E             >Current_HP      defl  $ - $E000             // used to set HP once!
 126+ E10E             >
 126+ E10E             >//              ______________________________________________________________________
 126+ E10E             >//              Dictionary part
 126+ E10E             >
 126+ E10E             >                org     Dict_Ptr
 126+ 9AFC             >
 126+ 9AFC 0C 20       >                dw      mirror_Ptr - $E000 + $1F00
 126+ 9AFE             >
 126+ 9AFE             >EXECUTE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 126+ 9AFE ~           >                call    runcode ; ok        // for primitive definitions  actual code
 126+ 9AFE ~           >
 126+ 9AFE ~           >
 126+ 9AFE             >                endif           ; ok        // for other definitions it "points" the correct handler
 126+ 9AFE             >                // Use of "; ok" to suppress "warning[fwdref]"
 126+ 9AFE             >
 126+ 9AFE             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 127+ 9AFE C9                           ret
 128+ 9AFF
 129+ 9AFF              //  ______________________________________________________________________
 130+ 9AFF              //
 131+ 9AFF              // brk
 132+ 9AFF              //              New_Def  BRK, "BRK", is_code, is_normal
 133+ 9AFF              //              next
 134+ 9AFF
 135+ 9AFF
 136+ 9AFF
 137+ 9AFF              //  ______________________________________________________________________
 138+ 9AFF              //
 139+ 9AFF              // (+loop)      n --
 140+ 9AFF              // compiled by +LOOP. it uses the top two values of return-stack to
 141+ 9AFF              // keep track of index and limit, they are accessed via I and I'
 142+ 9AFF              // Add n to the loop index. If the loop index did not cross the boundary
 143+ 9AFF              // between the loop limit minus one and the loop limit, continue execution
 144+ 9AFF              // at the beginning of the loop. Otherwise, discard the current loop control
 145+ 9AFF              // parameters and continue execution immediately following the loop.
 146+ 9AFF                              New_Def C_PLOOP, "(+LOOP)", is_code, is_normal
 146+ 9AFF             >
 146+ 9AFF             >Dict_Ptr        defl    $
 146+ 9AFF             >
 146+ 9AFF             >//              ______________________________________________________________________
 146+ 9AFF             >//              Heap part
 146+ 9AFF             >
 146+ 9AFF             >
 146+ 9AFF             >                org     (Heap_Ptr & $1FFF) + $E000
 146+ E10E             >
 146+ E10E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 146+ E10E             >Latest_Definition defl  Heap_Ptr
 146+ E10E             >
 146+ E10E             >                // dummy db directives used to calculate length of namec
 146+ E10E 28 2B 4C 4F >                db      "(+LOOP)"
 146+ E112 4F 50 29    >
 146+ E115             >len_NFA         defl    $ - temp_NFA
 146+ E115             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 146+ E10E             >
 146+ E10E 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 146+ E10F 28 2B 4C 4F >                db      "(+LOOP)"               // name string in 7-bit ascii, but
 146+ E113 4F 50 29    >
 146+ E116             >                org     $-1                 // alter last byte of Name just above to set
 146+ E115 A9          >                db      {b $} | END_BIT     // msb as name end
 146+ E116             >
 146+ E116 02 01       >                dw      Prev_Ptr            // Link to previous definition Name
 146+ E118             >Prev_Ptr        defl    Heap_Ptr
 146+ E118             >
 146+ E118             >mirror_Ptr      defl    $
 146+ E118             >
 146+ E118 01 9B       >                dw      Dict_Ptr + 2        // xt
 146+ E11A             >Heap_Ptr        defl    $ - $E000           // save current HP
 146+ E11A             >
 146+ E11A             >Current_HP      defl  $ - $E000             // used to set HP once!
 146+ E11A             >
 146+ E11A             >//              ______________________________________________________________________
 146+ E11A             >//              Dictionary part
 146+ E11A             >
 146+ E11A             >                org     Dict_Ptr
 146+ 9AFF             >
 146+ 9AFF 18 20       >                dw      mirror_Ptr - $E000 + $1F00
 146+ 9B01             >
 146+ 9B01             >C_PLOOP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 146+ 9B01 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 146+ 9B01 ~           >
 146+ 9B01 ~           >
 146+ 9B01             >                endif           ; ok        // for other definitions it "points" the correct handler
 146+ 9B01             >                // Use of "; ok" to suppress "warning[fwdref]"
 146+ 9B01             >
 146+ 9B01             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 147+ 9B01
 148+ 9B01              Loop_Ptr:
 149+ 9B01 E1                           pop     hl                  // get increment
 150+ 9B02 EB                           ex      de, hl
 151+ 9B03                              // *** ldhlrp
 152+ 9B03 C5                           push    bc                  // Save IP
 153+ 9B04 42                           ld      b, d                // bc is increment
 154+ 9B05 4B                           ld      c, e
 155+ 9B06 E5                           push    hl
 156+ 9B07 5E                           ld      e, (hl)             // hl points to loop-index, add increment to it.
 157+ 9B08 7B                           ld      a, e                // de keeps index before increment.
 158+ 9B09 81                           add     c
 159+ 9B0A 77                           ld      (hl), a
 160+ 9B0B 23                           inc     hl
 161+ 9B0C 56                           ld      d, (hl)
 162+ 9B0D 7A                           ld      a, d
 163+ 9B0E 88                           adc     b
 164+ 9B0F 77                           ld      (hl),a
 165+ 9B10 23                           inc     hl
 166+ 9B11
 167+ 9B11 7B                           ld      a, e
 168+ 9B12 96                           sub     (hl)
 169+ 9B13 5F                           ld      e, a
 170+ 9B14 23                           inc     hl
 171+ 9B15 7A                           ld      a, d
 172+ 9B16 9E                           sbc     (hl)
 173+ 9B17 57                           ld      d, a                // DE is index - limit : limit is the "new zero"
 174+ 9B18
 175+ 9B18 EB                           ex      de, hl              // swap HL and DE, so restore DE:=RP+3
 176+ 9B19 09                           add     hl, bc
 177+ 9B1A CB 78                        bit     7, b                // keep increment-sign just before overwriting d
 178+ 9B1C 28 01                        jr      z, Loop_NegativeIncrement
 179+ 9B1E 3F                               ccf                     // carry-flag tracks bonudary limit crossing.
 180+ 9B1F              Loop_NegativeIncrement:
 181+ 9B1F 38 04                        jr      c, Loop_Endif
 182+ 9B21 D1                               pop     de              // Discard RP+3, retrieve original RP
 183+ 9B22 C1                               pop     bc                  // Retrieve IP
 184+ 9B23 18 13                            jr      Branch_Ptr      // perform branch consuming following cell
 185+ 9B25              Loop_Endif:
 186+ 9B25 C1                           pop     bc                  // discard original RP
 187+ 9B26 EB                           ex      de, hl
 188+ 9B27 23                           inc     hl                  // keep    RP+4 (exit from loop)
 189+ 9B28                              // *** ldrphl                      // ld rp,hl macro 30h +Origin
 190+ 9B28 EB                           ex      de, hl
 191+ 9B29 C1                           pop     bc                  // Retrieve IP
 192+ 9B2A 03                           inc     bc                  // skip branch-style offset
 193+ 9B2B 03                           inc     bc
 194+ 9B2C                              next
 194+ 9B2C DD E9       >                jp      (ix)
 195+ 9B2E
 196+ 9B2E              //  ______________________________________________________________________
 197+ 9B2E              //
 198+ 9B2E              // (loop)       n --
 199+ 9B2E              // same as (LOOP) but index is incremented by 1
 200+ 9B2E              // compiled by LOOP.
 201+ 9B2E                              New_Def C_LOOP, "(LOOP)", is_code, is_normal
 201+ 9B2E             >
 201+ 9B2E             >Dict_Ptr        defl    $
 201+ 9B2E             >
 201+ 9B2E             >//              ______________________________________________________________________
 201+ 9B2E             >//              Heap part
 201+ 9B2E             >
 201+ 9B2E             >
 201+ 9B2E             >                org     (Heap_Ptr & $1FFF) + $E000
 201+ E11A             >
 201+ E11A             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 201+ E11A             >Latest_Definition defl  Heap_Ptr
 201+ E11A             >
 201+ E11A             >                // dummy db directives used to calculate length of namec
 201+ E11A 28 4C 4F 4F >                db      "(LOOP)"
 201+ E11E 50 29       >
 201+ E120             >len_NFA         defl    $ - temp_NFA
 201+ E120             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 201+ E11A             >
 201+ E11A 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 201+ E11B 28 4C 4F 4F >                db      "(LOOP)"               // name string in 7-bit ascii, but
 201+ E11F 50 29       >
 201+ E121             >                org     $-1                 // alter last byte of Name just above to set
 201+ E120 A9          >                db      {b $} | END_BIT     // msb as name end
 201+ E121             >
 201+ E121 0E 01       >                dw      Prev_Ptr            // Link to previous definition Name
 201+ E123             >Prev_Ptr        defl    Heap_Ptr
 201+ E123             >
 201+ E123             >mirror_Ptr      defl    $
 201+ E123             >
 201+ E123 30 9B       >                dw      Dict_Ptr + 2        // xt
 201+ E125             >Heap_Ptr        defl    $ - $E000           // save current HP
 201+ E125             >
 201+ E125             >Current_HP      defl  $ - $E000             // used to set HP once!
 201+ E125             >
 201+ E125             >//              ______________________________________________________________________
 201+ E125             >//              Dictionary part
 201+ E125             >
 201+ E125             >                org     Dict_Ptr
 201+ 9B2E             >
 201+ 9B2E 23 20       >                dw      mirror_Ptr - $E000 + $1F00
 201+ 9B30             >
 201+ 9B30             >C_LOOP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 201+ 9B30 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 201+ 9B30 ~           >
 201+ 9B30 ~           >
 201+ 9B30             >                endif           ; ok        // for other definitions it "points" the correct handler
 201+ 9B30             >                // Use of "; ok" to suppress "warning[fwdref]"
 201+ 9B30             >
 201+ 9B30             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 202+ 9B30 ED 8A 00 01                  push    1
 203+ 9B34 18 CB                        jr      Loop_Ptr
 204+ 9B36
 205+ 9B36              //  ______________________________________________________________________
 206+ 9B36              //
 207+ 9B36              // branch       --
 208+ 9B36              // unconditional branch in colon definition using the following cell as an offset from current IP value
 209+ 9B36              // compiled by ELSE, AGAIN and some other immediate words
 210+ 9B36
 211+ 9B36                              New_Def BRANCH, "BRANCH", is_code, is_normal
 211+ 9B36             >
 211+ 9B36             >Dict_Ptr        defl    $
 211+ 9B36             >
 211+ 9B36             >//              ______________________________________________________________________
 211+ 9B36             >//              Heap part
 211+ 9B36             >
 211+ 9B36             >
 211+ 9B36             >                org     (Heap_Ptr & $1FFF) + $E000
 211+ E125             >
 211+ E125             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 211+ E125             >Latest_Definition defl  Heap_Ptr
 211+ E125             >
 211+ E125             >                // dummy db directives used to calculate length of namec
 211+ E125 42 52 41 4E >                db      "BRANCH"
 211+ E129 43 48       >
 211+ E12B             >len_NFA         defl    $ - temp_NFA
 211+ E12B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 211+ E125             >
 211+ E125 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 211+ E126 42 52 41 4E >                db      "BRANCH"               // name string in 7-bit ascii, but
 211+ E12A 43 48       >
 211+ E12C             >                org     $-1                 // alter last byte of Name just above to set
 211+ E12B C8          >                db      {b $} | END_BIT     // msb as name end
 211+ E12C             >
 211+ E12C 1A 01       >                dw      Prev_Ptr            // Link to previous definition Name
 211+ E12E             >Prev_Ptr        defl    Heap_Ptr
 211+ E12E             >
 211+ E12E             >mirror_Ptr      defl    $
 211+ E12E             >
 211+ E12E 38 9B       >                dw      Dict_Ptr + 2        // xt
 211+ E130             >Heap_Ptr        defl    $ - $E000           // save current HP
 211+ E130             >
 211+ E130             >Current_HP      defl  $ - $E000             // used to set HP once!
 211+ E130             >
 211+ E130             >//              ______________________________________________________________________
 211+ E130             >//              Dictionary part
 211+ E130             >
 211+ E130             >                org     Dict_Ptr
 211+ 9B36             >
 211+ 9B36 2E 20       >                dw      mirror_Ptr - $E000 + $1F00
 211+ 9B38             >
 211+ 9B38             >BRANCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 211+ 9B38 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 211+ 9B38 ~           >
 211+ 9B38 ~           >
 211+ 9B38             >                endif           ; ok        // for other definitions it "points" the correct handler
 211+ 9B38             >                // Use of "; ok" to suppress "warning[fwdref]"
 211+ 9B38             >
 211+ 9B38             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 212+ 9B38              Branch_Ptr:
 213+ 9B38 0A                           ld      a, (bc)
 214+ 9B39 6F                           ld      l, a
 215+ 9B3A 03                           inc     bc
 216+ 9B3B 0A                           ld      a, (bc)
 217+ 9B3C 67                           ld      h, a
 218+ 9B3D 0B                           dec     bc
 219+ 9B3E 09                           add     hl, bc
 220+ 9B3F 4D                           ld      c, l
 221+ 9B40 44                           ld      b, h
 222+ 9B41                              next
 222+ 9B41 DD E9       >                jp      (ix)
 223+ 9B43
 224+ 9B43
 225+ 9B43              //  ______________________________________________________________________
 226+ 9B43              //
 227+ 9B43              // 0branch      f --
 228+ 9B43              // conditional branch if the top-of-stack is ZERO or FALSE.
 229+ 9B43              // compiled by IF, UNTIL and some other immediate words
 230+ 9B43
 231+ 9B43                              New_Def ZBRANCH, "0BRANCH", is_code, is_normal
 231+ 9B43             >
 231+ 9B43             >Dict_Ptr        defl    $
 231+ 9B43             >
 231+ 9B43             >//              ______________________________________________________________________
 231+ 9B43             >//              Heap part
 231+ 9B43             >
 231+ 9B43             >
 231+ 9B43             >                org     (Heap_Ptr & $1FFF) + $E000
 231+ E130             >
 231+ E130             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 231+ E130             >Latest_Definition defl  Heap_Ptr
 231+ E130             >
 231+ E130             >                // dummy db directives used to calculate length of namec
 231+ E130 30 42 52 41 >                db      "0BRANCH"
 231+ E134 4E 43 48    >
 231+ E137             >len_NFA         defl    $ - temp_NFA
 231+ E137             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 231+ E130             >
 231+ E130 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 231+ E131 30 42 52 41 >                db      "0BRANCH"               // name string in 7-bit ascii, but
 231+ E135 4E 43 48    >
 231+ E138             >                org     $-1                 // alter last byte of Name just above to set
 231+ E137 C8          >                db      {b $} | END_BIT     // msb as name end
 231+ E138             >
 231+ E138 25 01       >                dw      Prev_Ptr            // Link to previous definition Name
 231+ E13A             >Prev_Ptr        defl    Heap_Ptr
 231+ E13A             >
 231+ E13A             >mirror_Ptr      defl    $
 231+ E13A             >
 231+ E13A 45 9B       >                dw      Dict_Ptr + 2        // xt
 231+ E13C             >Heap_Ptr        defl    $ - $E000           // save current HP
 231+ E13C             >
 231+ E13C             >Current_HP      defl  $ - $E000             // used to set HP once!
 231+ E13C             >
 231+ E13C             >//              ______________________________________________________________________
 231+ E13C             >//              Dictionary part
 231+ E13C             >
 231+ E13C             >                org     Dict_Ptr
 231+ 9B43             >
 231+ 9B43 3A 20       >                dw      mirror_Ptr - $E000 + $1F00
 231+ 9B45             >
 231+ 9B45             >ZBRANCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 231+ 9B45 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 231+ 9B45 ~           >
 231+ 9B45 ~           >
 231+ 9B45             >                endif           ; ok        // for other definitions it "points" the correct handler
 231+ 9B45             >                // Use of "; ok" to suppress "warning[fwdref]"
 231+ 9B45             >
 231+ 9B45             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 232+ 9B45              ZBranch_Ptr:
 233+ 9B45 E1                           pop     hl
 234+ 9B46 7D                           ld      a, l
 235+ 9B47 B4                           or      h
 236+ 9B48 28 EE                        jr      z, Branch_Ptr
 237+ 9B4A 03                           inc     bc                  // if not branch, skip offset cell.
 238+ 9B4B 03                           inc     bc
 239+ 9B4C                              next
 239+ 9B4C DD E9       >                jp      (ix)
 240+ 9B4E
 241+ 9B4E              //  ______________________________________________________________________
 242+ 9B4E              //
 243+ 9B4E              // (leave)        --
 244+ 9B4E              // compiled by LEAVE
 245+ 9B4E              // this forces to exit from loop and jump past
 246+ 9B4E                              New_Def C_LEAVE, "(LEAVE)", is_code, is_normal
 246+ 9B4E             >
 246+ 9B4E             >Dict_Ptr        defl    $
 246+ 9B4E             >
 246+ 9B4E             >//              ______________________________________________________________________
 246+ 9B4E             >//              Heap part
 246+ 9B4E             >
 246+ 9B4E             >
 246+ 9B4E             >                org     (Heap_Ptr & $1FFF) + $E000
 246+ E13C             >
 246+ E13C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 246+ E13C             >Latest_Definition defl  Heap_Ptr
 246+ E13C             >
 246+ E13C             >                // dummy db directives used to calculate length of namec
 246+ E13C 28 4C 45 41 >                db      "(LEAVE)"
 246+ E140 56 45 29    >
 246+ E143             >len_NFA         defl    $ - temp_NFA
 246+ E143             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 246+ E13C             >
 246+ E13C 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 246+ E13D 28 4C 45 41 >                db      "(LEAVE)"               // name string in 7-bit ascii, but
 246+ E141 56 45 29    >
 246+ E144             >                org     $-1                 // alter last byte of Name just above to set
 246+ E143 A9          >                db      {b $} | END_BIT     // msb as name end
 246+ E144             >
 246+ E144 30 01       >                dw      Prev_Ptr            // Link to previous definition Name
 246+ E146             >Prev_Ptr        defl    Heap_Ptr
 246+ E146             >
 246+ E146             >mirror_Ptr      defl    $
 246+ E146             >
 246+ E146 50 9B       >                dw      Dict_Ptr + 2        // xt
 246+ E148             >Heap_Ptr        defl    $ - $E000           // save current HP
 246+ E148             >
 246+ E148             >Current_HP      defl  $ - $E000             // used to set HP once!
 246+ E148             >
 246+ E148             >//              ______________________________________________________________________
 246+ E148             >//              Dictionary part
 246+ E148             >
 246+ E148             >                org     Dict_Ptr
 246+ 9B4E             >
 246+ 9B4E 46 20       >                dw      mirror_Ptr - $E000 + $1F00
 246+ 9B50             >
 246+ 9B50             >C_LEAVE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 246+ 9B50 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 246+ 9B50 ~           >
 246+ 9B50 ~           >
 246+ 9B50             >                endif           ; ok        // for other definitions it "points" the correct handler
 246+ 9B50             >                // Use of "; ok" to suppress "warning[fwdref]"
 246+ 9B50             >
 246+ 9B50             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 247+ 9B50 EB                           ex      de, hl
 248+ 9B51                              // *** ldhlrp
 249+ 9B51 3E 04                        ld      a, 4
 250+ 9B53 ED 31                        add     hl, a
 251+ 9B55                              // *** ldrphl
 252+ 9B55 EB                           ex      de, hl
 253+ 9B56 18 E0                        jr      Branch_Ptr       // perform branch consuming following cell
 254+ 9B58                              next
 254+ 9B58 DD E9       >                jp      (ix)
 255+ 9B5A
 256+ 9B5A              //  ______________________________________________________________________
 257+ 9B5A              //
 258+ 9B5A              // (?do)        lim ind --
 259+ 9B5A              // compiled by ?DO to make a loop checking for lim == ind first
 260+ 9B5A              // at run-time (?DO) must be followed by a BRANCH offset
 261+ 9B5A              // used to skip the loop if lim == ind
 262+ 9B5A                              New_Def C_Q_DO, "(?DO)", is_code, is_normal
 262+ 9B5A             >
 262+ 9B5A             >Dict_Ptr        defl    $
 262+ 9B5A             >
 262+ 9B5A             >//              ______________________________________________________________________
 262+ 9B5A             >//              Heap part
 262+ 9B5A             >
 262+ 9B5A             >
 262+ 9B5A             >                org     (Heap_Ptr & $1FFF) + $E000
 262+ E148             >
 262+ E148             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 262+ E148             >Latest_Definition defl  Heap_Ptr
 262+ E148             >
 262+ E148             >                // dummy db directives used to calculate length of namec
 262+ E148 28 3F 44 4F >                db      "(?DO)"
 262+ E14C 29          >
 262+ E14D             >len_NFA         defl    $ - temp_NFA
 262+ E14D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 262+ E148             >
 262+ E148 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 262+ E149 28 3F 44 4F >                db      "(?DO)"               // name string in 7-bit ascii, but
 262+ E14D 29          >
 262+ E14E             >                org     $-1                 // alter last byte of Name just above to set
 262+ E14D A9          >                db      {b $} | END_BIT     // msb as name end
 262+ E14E             >
 262+ E14E 3C 01       >                dw      Prev_Ptr            // Link to previous definition Name
 262+ E150             >Prev_Ptr        defl    Heap_Ptr
 262+ E150             >
 262+ E150             >mirror_Ptr      defl    $
 262+ E150             >
 262+ E150 5C 9B       >                dw      Dict_Ptr + 2        // xt
 262+ E152             >Heap_Ptr        defl    $ - $E000           // save current HP
 262+ E152             >
 262+ E152             >Current_HP      defl  $ - $E000             // used to set HP once!
 262+ E152             >
 262+ E152             >//              ______________________________________________________________________
 262+ E152             >//              Dictionary part
 262+ E152             >
 262+ E152             >                org     Dict_Ptr
 262+ 9B5A             >
 262+ 9B5A 50 20       >                dw      mirror_Ptr - $E000 + $1F00
 262+ 9B5C             >
 262+ 9B5C             >C_Q_DO:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 262+ 9B5C ~           >                call    runcode ; ok        // for primitive definitions  actual code
 262+ 9B5C ~           >
 262+ 9B5C ~           >
 262+ 9B5C             >                endif           ; ok        // for other definitions it "points" the correct handler
 262+ 9B5C             >                // Use of "; ok" to suppress "warning[fwdref]"
 262+ 9B5C             >
 262+ 9B5C             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 263+ 9B5C D9                           exx
 264+ 9B5D D1                            pop     de                  // de has the index
 265+ 9B5E E1                            pop     hl                  // hl has the limit
 266+ 9B5F 44                            ld      b, h
 267+ 9B60 4D                            ld      c, l
 268+ 9B61 E5                            push    hl                  // put them back to stack for later
 269+ 9B62 D5                            push    de
 270+ 9B63 A7                            and     a                   // reset carry flag
 271+ 9B64 ED 52                         sbc     hl, de              // compute limit - index
 272+ 9B66 D9                           exx
 273+ 9B67 20 04                        jr      nz, Do_Ptr          // if zero then don't even begin loop
 274+ 9B69 E1                               pop     hl
 275+ 9B6A E1                               pop     hl
 276+ 9B6B 18 CB                            jr      Branch_Ptr          // perform branch consuming following cell
 277+ 9B6D              Do_Ptr:
 278+ 9B6D                              // *** ldhlrp                 // prepare RP
 279+ 9B6D                              // *** ex      de, hl
 280+ 9B6D 1B                           dec     de
 281+ 9B6E 1B                           dec     de
 282+ 9B6F 1B                           dec     de
 283+ 9B70 1B                           dec     de
 284+ 9B71 D5                           push    de                  // pass it to h'l'
 285+ 9B72                              // *** ex      de, hl
 286+ 9B72                              // *** ldrphl
 287+ 9B72 D9                           exx
 288+ 9B73 E1                            pop     hl
 289+ 9B74
 290+ 9B74                               // store index as top RP
 291+ 9B74 D1                            pop     de
 292+ 9B75 73                            ld      (hl), e
 293+ 9B76 23                            inc     hl
 294+ 9B77 72                            ld      (hl), d
 295+ 9B78 23                            inc     hl
 296+ 9B79                               // stores lim as second from top RP
 297+ 9B79 D1                            pop     de
 298+ 9B7A 73                            ld      (hl), e
 299+ 9B7B 23                            inc     hl
 300+ 9B7C 72                            ld      (hl), d
 301+ 9B7D D9                           exx
 302+ 9B7E                              // skip branch-style offseet
 303+ 9B7E 03                           inc     bc
 304+ 9B7F 03                           inc     bc
 305+ 9B80                              next
 305+ 9B80 DD E9       >                jp      (ix)
 306+ 9B82
 307+ 9B82              //  ______________________________________________________________________
 308+ 9B82              //
 309+ 9B82              // (do)        lim ind --
 310+ 9B82              // compiled by DO to make a loop checking for lim == ind first
 311+ 9B82              // this is a simpler version of (?DO)
 312+ 9B82                              New_Def C_DO, "(DO)", is_code, is_normal
 312+ 9B82             >
 312+ 9B82             >Dict_Ptr        defl    $
 312+ 9B82             >
 312+ 9B82             >//              ______________________________________________________________________
 312+ 9B82             >//              Heap part
 312+ 9B82             >
 312+ 9B82             >
 312+ 9B82             >                org     (Heap_Ptr & $1FFF) + $E000
 312+ E152             >
 312+ E152             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 312+ E152             >Latest_Definition defl  Heap_Ptr
 312+ E152             >
 312+ E152             >                // dummy db directives used to calculate length of namec
 312+ E152 28 44 4F 29 >                db      "(DO)"
 312+ E156             >len_NFA         defl    $ - temp_NFA
 312+ E156             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 312+ E152             >
 312+ E152 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 312+ E153 28 44 4F 29 >                db      "(DO)"               // name string in 7-bit ascii, but
 312+ E157             >                org     $-1                 // alter last byte of Name just above to set
 312+ E156 A9          >                db      {b $} | END_BIT     // msb as name end
 312+ E157             >
 312+ E157 48 01       >                dw      Prev_Ptr            // Link to previous definition Name
 312+ E159             >Prev_Ptr        defl    Heap_Ptr
 312+ E159             >
 312+ E159             >mirror_Ptr      defl    $
 312+ E159             >
 312+ E159 84 9B       >                dw      Dict_Ptr + 2        // xt
 312+ E15B             >Heap_Ptr        defl    $ - $E000           // save current HP
 312+ E15B             >
 312+ E15B             >Current_HP      defl  $ - $E000             // used to set HP once!
 312+ E15B             >
 312+ E15B             >//              ______________________________________________________________________
 312+ E15B             >//              Dictionary part
 312+ E15B             >
 312+ E15B             >                org     Dict_Ptr
 312+ 9B82             >
 312+ 9B82 59 20       >                dw      mirror_Ptr - $E000 + $1F00
 312+ 9B84             >
 312+ 9B84             >C_DO:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 312+ 9B84 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 312+ 9B84 ~           >
 312+ 9B84 ~           >
 312+ 9B84             >                endif           ; ok        // for other definitions it "points" the correct handler
 312+ 9B84             >                // Use of "; ok" to suppress "warning[fwdref]"
 312+ 9B84             >
 312+ 9B84             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 313+ 9B84 0B                           dec     bc                  // prepare IP beforehand
 314+ 9B85 0B                           dec     bc                  // to balance the two final inc bc in (?do)
 315+ 9B86 18 E5                        jr      Do_Ptr
 316+ 9B88
 317+ 9B88              //  ______________________________________________________________________
 318+ 9B88              //
 319+ 9B88              // i            -- n
 320+ 9B88              // used between DO and LOOP or between DO e +LOOP to copy on top of stack
 321+ 9B88              // the current value of the index-loop
 322+ 9B88                              New_Def I, "I", is_code, is_normal
 322+ 9B88             >
 322+ 9B88             >Dict_Ptr        defl    $
 322+ 9B88             >
 322+ 9B88             >//              ______________________________________________________________________
 322+ 9B88             >//              Heap part
 322+ 9B88             >
 322+ 9B88             >
 322+ 9B88             >                org     (Heap_Ptr & $1FFF) + $E000
 322+ E15B             >
 322+ E15B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 322+ E15B             >Latest_Definition defl  Heap_Ptr
 322+ E15B             >
 322+ E15B             >                // dummy db directives used to calculate length of namec
 322+ E15B 49          >                db      "I"
 322+ E15C             >len_NFA         defl    $ - temp_NFA
 322+ E15C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 322+ E15B             >
 322+ E15B 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 322+ E15C 49          >                db      "I"               // name string in 7-bit ascii, but
 322+ E15D             >                org     $-1                 // alter last byte of Name just above to set
 322+ E15C C9          >                db      {b $} | END_BIT     // msb as name end
 322+ E15D             >
 322+ E15D 52 01       >                dw      Prev_Ptr            // Link to previous definition Name
 322+ E15F             >Prev_Ptr        defl    Heap_Ptr
 322+ E15F             >
 322+ E15F             >mirror_Ptr      defl    $
 322+ E15F             >
 322+ E15F 8A 9B       >                dw      Dict_Ptr + 2        // xt
 322+ E161             >Heap_Ptr        defl    $ - $E000           // save current HP
 322+ E161             >
 322+ E161             >Current_HP      defl  $ - $E000             // used to set HP once!
 322+ E161             >
 322+ E161             >//              ______________________________________________________________________
 322+ E161             >//              Dictionary part
 322+ E161             >
 322+ E161             >                org     Dict_Ptr
 322+ 9B88             >
 322+ 9B88 5F 20       >                dw      mirror_Ptr - $E000 + $1F00
 322+ 9B8A             >
 322+ 9B8A             >I:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 322+ 9B8A ~           >                call    runcode ; ok        // for primitive definitions  actual code
 322+ 9B8A ~           >
 322+ 9B8A ~           >
 322+ 9B8A             >                endif           ; ok        // for other definitions it "points" the correct handler
 322+ 9B8A             >                // Use of "; ok" to suppress "warning[fwdref]"
 322+ 9B8A             >
 322+ 9B8A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 323+ 9B8A              I_Ptr:
 324+ 9B8A 62                           ld      h, d
 325+ 9B8B 6B                           ld      l, e
 326+ 9B8C                              // *** ldhlrp
 327+ 9B8C              I_Ptr_prime:
 328+ 9B8C 7E                           ld      a, (hl)
 329+ 9B8D 23                           inc     hl
 330+ 9B8E 66                           ld      h, (hl)
 331+ 9B8F 6F                           ld      l, a
 332+ 9B90 E5                           push    hl
 333+ 9B91                              next
 333+ 9B91 DD E9       >                jp      (ix)
 334+ 9B93
 335+ 9B93
 336+ 9B93              //  ______________________________________________________________________
 337+ 9B93              //
 338+ 9B93              // i'            -- n
 339+ 9B93              // used between DO and LOOP or between DO e +LOOP to copy on top of stack
 340+ 9B93              // the limit of the index-loop
 341+ 9B93
 342+ 9B93                              New_Def II, "I'", is_code, is_normal
 342+ 9B93             >
 342+ 9B93             >Dict_Ptr        defl    $
 342+ 9B93             >
 342+ 9B93             >//              ______________________________________________________________________
 342+ 9B93             >//              Heap part
 342+ 9B93             >
 342+ 9B93             >
 342+ 9B93             >                org     (Heap_Ptr & $1FFF) + $E000
 342+ E161             >
 342+ E161             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 342+ E161             >Latest_Definition defl  Heap_Ptr
 342+ E161             >
 342+ E161             >                // dummy db directives used to calculate length of namec
 342+ E161 49 27       >                db      "I'"
 342+ E163             >len_NFA         defl    $ - temp_NFA
 342+ E163             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 342+ E161             >
 342+ E161 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 342+ E162 49 27       >                db      "I'"               // name string in 7-bit ascii, but
 342+ E164             >                org     $-1                 // alter last byte of Name just above to set
 342+ E163 A7          >                db      {b $} | END_BIT     // msb as name end
 342+ E164             >
 342+ E164 5B 01       >                dw      Prev_Ptr            // Link to previous definition Name
 342+ E166             >Prev_Ptr        defl    Heap_Ptr
 342+ E166             >
 342+ E166             >mirror_Ptr      defl    $
 342+ E166             >
 342+ E166 95 9B       >                dw      Dict_Ptr + 2        // xt
 342+ E168             >Heap_Ptr        defl    $ - $E000           // save current HP
 342+ E168             >
 342+ E168             >Current_HP      defl  $ - $E000             // used to set HP once!
 342+ E168             >
 342+ E168             >//              ______________________________________________________________________
 342+ E168             >//              Dictionary part
 342+ E168             >
 342+ E168             >                org     Dict_Ptr
 342+ 9B93             >
 342+ 9B93 66 20       >                dw      mirror_Ptr - $E000 + $1F00
 342+ 9B95             >
 342+ 9B95             >II:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 342+ 9B95 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 342+ 9B95 ~           >
 342+ 9B95 ~           >
 342+ 9B95             >                endif           ; ok        // for other definitions it "points" the correct handler
 342+ 9B95             >                // Use of "; ok" to suppress "warning[fwdref]"
 342+ 9B95             >
 342+ 9B95             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 343+ 9B95 62                           ld      h, d
 344+ 9B96 6B                           ld      l, e
 345+ 9B97                              // *** ldhlrp
 346+ 9B97 23                           inc     hl
 347+ 9B98 23                           inc     hl
 348+ 9B99 18 F1                        jr      I_Ptr_prime
 349+ 9B9B
 350+ 9B9B
 351+ 9B9B              //  ______________________________________________________________________
 352+ 9B9B              //
 353+ 9B9B              // digit        c n -- u tf  |  ff
 354+ 9B9B              // convert a character c using base n
 355+ 9B9B              // returns a unsigned number and a true flag
 356+ 9B9B              // or just a false flag if the conversion fails
 357+ 9B9B                              New_Def DIGIT, "DIGIT", is_code, is_normal
 357+ 9B9B             >
 357+ 9B9B             >Dict_Ptr        defl    $
 357+ 9B9B             >
 357+ 9B9B             >//              ______________________________________________________________________
 357+ 9B9B             >//              Heap part
 357+ 9B9B             >
 357+ 9B9B             >
 357+ 9B9B             >                org     (Heap_Ptr & $1FFF) + $E000
 357+ E168             >
 357+ E168             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 357+ E168             >Latest_Definition defl  Heap_Ptr
 357+ E168             >
 357+ E168             >                // dummy db directives used to calculate length of namec
 357+ E168 44 49 47 49 >                db      "DIGIT"
 357+ E16C 54          >
 357+ E16D             >len_NFA         defl    $ - temp_NFA
 357+ E16D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 357+ E168             >
 357+ E168 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 357+ E169 44 49 47 49 >                db      "DIGIT"               // name string in 7-bit ascii, but
 357+ E16D 54          >
 357+ E16E             >                org     $-1                 // alter last byte of Name just above to set
 357+ E16D D4          >                db      {b $} | END_BIT     // msb as name end
 357+ E16E             >
 357+ E16E 61 01       >                dw      Prev_Ptr            // Link to previous definition Name
 357+ E170             >Prev_Ptr        defl    Heap_Ptr
 357+ E170             >
 357+ E170             >mirror_Ptr      defl    $
 357+ E170             >
 357+ E170 9D 9B       >                dw      Dict_Ptr + 2        // xt
 357+ E172             >Heap_Ptr        defl    $ - $E000           // save current HP
 357+ E172             >
 357+ E172             >Current_HP      defl  $ - $E000             // used to set HP once!
 357+ E172             >
 357+ E172             >//              ______________________________________________________________________
 357+ E172             >//              Dictionary part
 357+ E172             >
 357+ E172             >                org     Dict_Ptr
 357+ 9B9B             >
 357+ 9B9B 70 20       >                dw      mirror_Ptr - $E000 + $1F00
 357+ 9B9D             >
 357+ 9B9D             >DIGIT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 357+ 9B9D ~           >                call    runcode ; ok        // for primitive definitions  actual code
 357+ 9B9D ~           >
 357+ 9B9D ~           >
 357+ 9B9D             >                endif           ; ok        // for other definitions it "points" the correct handler
 357+ 9B9D             >                // Use of "; ok" to suppress "warning[fwdref]"
 357+ 9B9D             >
 357+ 9B9D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 358+ 9B9D D9                           exx
 359+ 9B9E E1                           pop     hl                  // l has the base
 360+ 9B9F D1                           pop     de                  // e has the digit
 361+ 9BA0 7B                           ld      a, e
 362+ 9BA1 FE 60                        cp      $60                 // check if lowercase
 363+ 9BA3 38 02                        jr      c, Digit_Uppercase
 364+ 9BA5 D6 20                            sub     $20                 // quick'n'dirty uppercase
 365+ 9BA7              Digit_Uppercase:
 366+ 9BA7 D6 30                        sub     $30
 367+ 9BA9 38 16                        jr      c, Digit_Fail       // fail when character < "0"
 368+ 9BAB FE 0A                            cp      $0A
 369+ 9BAD 38 06                            jr      c, Digit_Decimal    // perhaps is not decimal
 370+ 9BAF D6 07                                sub     7                   // try hex and subtract 7
 371+ 9BB1 FE 0A                                cp      $0A
 372+ 9BB3 38 0C                                jr      c,  Digit_Fail      // it is not hex !
 373+ 9BB5
 374+ 9BB5              Digit_Decimal:
 375+ 9BB5                              // compare digit
 376+ 9BB5 BD                           cp      l                   // compare with base
 377+ 9BB6 30 09                        jr      nc, Digit_Fail      // fail when greater than base
 378+ 9BB8 5F                               ld      e, a                // digit is returned as second from TOS
 379+ 9BB9 21 01 00                         ld      hl, 1
 380+ 9BBC D5                               push    de
 381+ 9BBD E5                               push    hl
 382+ 9BBE D9                               exx
 383+ 9BBF                                  next
 383+ 9BBF DD E9       >                jp      (ix)
 384+ 9BC1              Digit_Fail:
 385+ 9BC1 21 00 00                     ld      hl, 0
 386+ 9BC4 E5                           push    hl
 387+ 9BC5 D9                           exx
 388+ 9BC6                              next
 388+ 9BC6 DD E9       >                jp      (ix)
 389+ 9BC8
 390+ 9BC8              //  ______________________________________________________________________
 391+ 9BC8              //
 392+ 9BC8              //  parametric uppercase routine
 393+ 9BC8              //  depending on the following op-code the routine can be by-passed
 394+ 9BC8              //  changing the behaviour of some callers.
 395+ 9BC8              //  If it is "ret" then the system is Case-Sensitive
 396+ 9BC8              //  If it is "Nop" then the system is Case-Insensitive
 397+ 9BC8              //  Only A register is touched.
 398+ 9BC8 00           Case_Sensitive: nop                         // Default is case-insensitive.
 399+ 9BC9              Case_Upper:
 400+ 9BC9 FE 61                        cp      LC_A_CHAR           // lower-case "a"
 401+ 9BCB D8                           ret     c                   // no change if A < "a"
 402+ 9BCC FE 7B                        cp      LC_Z_CHAR + 1       // lower-case "z" + 1
 403+ 9BCE D0                           ret     nc                  // no change if A > "z"
 404+ 9BCF D6 20                        sub     $20                 // Make uppercase if A in ["a".."z"]
 405+ 9BD1 C9                           ret
 406+ 9BD2
 407+ 9BD2              //  ______________________________________________________________________
 408+ 9BD2              //
 409+ 9BD2              //  caseon      --
 410+ 9BD2              // set system case-sensitivity on
 411+ 9BD2              // it patches a RET/NOP at the beginning of the uppercase-routine
 412+ 9BD2                              New_Def CASEON, "CASEON", is_code, is_normal
 412+ 9BD2             >
 412+ 9BD2             >Dict_Ptr        defl    $
 412+ 9BD2             >
 412+ 9BD2             >//              ______________________________________________________________________
 412+ 9BD2             >//              Heap part
 412+ 9BD2             >
 412+ 9BD2             >
 412+ 9BD2             >                org     (Heap_Ptr & $1FFF) + $E000
 412+ E172             >
 412+ E172             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 412+ E172             >Latest_Definition defl  Heap_Ptr
 412+ E172             >
 412+ E172             >                // dummy db directives used to calculate length of namec
 412+ E172 43 41 53 45 >                db      "CASEON"
 412+ E176 4F 4E       >
 412+ E178             >len_NFA         defl    $ - temp_NFA
 412+ E178             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 412+ E172             >
 412+ E172 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 412+ E173 43 41 53 45 >                db      "CASEON"               // name string in 7-bit ascii, but
 412+ E177 4F 4E       >
 412+ E179             >                org     $-1                 // alter last byte of Name just above to set
 412+ E178 CE          >                db      {b $} | END_BIT     // msb as name end
 412+ E179             >
 412+ E179 68 01       >                dw      Prev_Ptr            // Link to previous definition Name
 412+ E17B             >Prev_Ptr        defl    Heap_Ptr
 412+ E17B             >
 412+ E17B             >mirror_Ptr      defl    $
 412+ E17B             >
 412+ E17B D4 9B       >                dw      Dict_Ptr + 2        // xt
 412+ E17D             >Heap_Ptr        defl    $ - $E000           // save current HP
 412+ E17D             >
 412+ E17D             >Current_HP      defl  $ - $E000             // used to set HP once!
 412+ E17D             >
 412+ E17D             >//              ______________________________________________________________________
 412+ E17D             >//              Dictionary part
 412+ E17D             >
 412+ E17D             >                org     Dict_Ptr
 412+ 9BD2             >
 412+ 9BD2 7B 20       >                dw      mirror_Ptr - $E000 + $1F00
 412+ 9BD4             >
 412+ 9BD4             >CASEON:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 412+ 9BD4 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 412+ 9BD4 ~           >
 412+ 9BD4 ~           >
 412+ 9BD4             >                endif           ; ok        // for other definitions it "points" the correct handler
 412+ 9BD4             >                // Use of "; ok" to suppress "warning[fwdref]"
 412+ 9BD4             >
 412+ 9BD4             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 413+ 9BD4 3E C9                        ld      a, $C9              // "ret"
 414+ 9BD6 32 C8 9B                     ld      (Case_Sensitive), a
 415+ 9BD9                              next
 415+ 9BD9 DD E9       >                jp      (ix)
 416+ 9BDB
 417+ 9BDB              //  ______________________________________________________________________
 418+ 9BDB              //
 419+ 9BDB              //  caseoff     --
 420+ 9BDB              // set system case-sensitivity on
 421+ 9BDB              // it patches a RET/NOP at the beginning of the uppercase-routine
 422+ 9BDB                              New_Def CASEOFF, "CASEOFF", is_code, is_normal
 422+ 9BDB             >
 422+ 9BDB             >Dict_Ptr        defl    $
 422+ 9BDB             >
 422+ 9BDB             >//              ______________________________________________________________________
 422+ 9BDB             >//              Heap part
 422+ 9BDB             >
 422+ 9BDB             >
 422+ 9BDB             >                org     (Heap_Ptr & $1FFF) + $E000
 422+ E17D             >
 422+ E17D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 422+ E17D             >Latest_Definition defl  Heap_Ptr
 422+ E17D             >
 422+ E17D             >                // dummy db directives used to calculate length of namec
 422+ E17D 43 41 53 45 >                db      "CASEOFF"
 422+ E181 4F 46 46    >
 422+ E184             >len_NFA         defl    $ - temp_NFA
 422+ E184             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 422+ E17D             >
 422+ E17D 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 422+ E17E 43 41 53 45 >                db      "CASEOFF"               // name string in 7-bit ascii, but
 422+ E182 4F 46 46    >
 422+ E185             >                org     $-1                 // alter last byte of Name just above to set
 422+ E184 C6          >                db      {b $} | END_BIT     // msb as name end
 422+ E185             >
 422+ E185 72 01       >                dw      Prev_Ptr            // Link to previous definition Name
 422+ E187             >Prev_Ptr        defl    Heap_Ptr
 422+ E187             >
 422+ E187             >mirror_Ptr      defl    $
 422+ E187             >
 422+ E187 DD 9B       >                dw      Dict_Ptr + 2        // xt
 422+ E189             >Heap_Ptr        defl    $ - $E000           // save current HP
 422+ E189             >
 422+ E189             >Current_HP      defl  $ - $E000             // used to set HP once!
 422+ E189             >
 422+ E189             >//              ______________________________________________________________________
 422+ E189             >//              Dictionary part
 422+ E189             >
 422+ E189             >                org     Dict_Ptr
 422+ 9BDB             >
 422+ 9BDB 87 20       >                dw      mirror_Ptr - $E000 + $1F00
 422+ 9BDD             >
 422+ 9BDD             >CASEOFF:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 422+ 9BDD ~           >                call    runcode ; ok        // for primitive definitions  actual code
 422+ 9BDD ~           >
 422+ 9BDD ~           >
 422+ 9BDD             >                endif           ; ok        // for other definitions it "points" the correct handler
 422+ 9BDD             >                // Use of "; ok" to suppress "warning[fwdref]"
 422+ 9BDD             >
 422+ 9BDD             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 423+ 9BDD 3E 00                        ld      a, $00              // "nop"
 424+ 9BDF 32 C8 9B                     ld      (Case_Sensitive), a
 425+ 9BE2                              next
 425+ 9BE2 DD E9       >                jp      (ix)
 426+ 9BE4
 427+ 9BE4              //  ______________________________________________________________________
 428+ 9BE4              //
 429+ 9BE4              //  upper       c1 -- c1 | c2
 430+ 9BE4              // character on top of stack is forced to Uppercase.
 431+ 9BE4                              New_Def UPPER, "UPPER", is_code, is_normal
 431+ 9BE4             >
 431+ 9BE4             >Dict_Ptr        defl    $
 431+ 9BE4             >
 431+ 9BE4             >//              ______________________________________________________________________
 431+ 9BE4             >//              Heap part
 431+ 9BE4             >
 431+ 9BE4             >
 431+ 9BE4             >                org     (Heap_Ptr & $1FFF) + $E000
 431+ E189             >
 431+ E189             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 431+ E189             >Latest_Definition defl  Heap_Ptr
 431+ E189             >
 431+ E189             >                // dummy db directives used to calculate length of namec
 431+ E189 55 50 50 45 >                db      "UPPER"
 431+ E18D 52          >
 431+ E18E             >len_NFA         defl    $ - temp_NFA
 431+ E18E             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 431+ E189             >
 431+ E189 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 431+ E18A 55 50 50 45 >                db      "UPPER"               // name string in 7-bit ascii, but
 431+ E18E 52          >
 431+ E18F             >                org     $-1                 // alter last byte of Name just above to set
 431+ E18E D2          >                db      {b $} | END_BIT     // msb as name end
 431+ E18F             >
 431+ E18F 7D 01       >                dw      Prev_Ptr            // Link to previous definition Name
 431+ E191             >Prev_Ptr        defl    Heap_Ptr
 431+ E191             >
 431+ E191             >mirror_Ptr      defl    $
 431+ E191             >
 431+ E191 E6 9B       >                dw      Dict_Ptr + 2        // xt
 431+ E193             >Heap_Ptr        defl    $ - $E000           // save current HP
 431+ E193             >
 431+ E193             >Current_HP      defl  $ - $E000             // used to set HP once!
 431+ E193             >
 431+ E193             >//              ______________________________________________________________________
 431+ E193             >//              Dictionary part
 431+ E193             >
 431+ E193             >                org     Dict_Ptr
 431+ 9BE4             >
 431+ 9BE4 91 20       >                dw      mirror_Ptr - $E000 + $1F00
 431+ 9BE6             >
 431+ 9BE6             >UPPER:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 431+ 9BE6 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 431+ 9BE6 ~           >
 431+ 9BE6 ~           >
 431+ 9BE6             >                endif           ; ok        // for other definitions it "points" the correct handler
 431+ 9BE6             >                // Use of "; ok" to suppress "warning[fwdref]"
 431+ 9BE6             >
 431+ 9BE6             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 432+ 9BE6 E1                           pop     hl
 433+ 9BE7 7D                           ld      a, l
 434+ 9BE8 CD C9 9B                     call    Case_Upper
 435+ 9BEB 6F                           ld      l, a
 436+ 9BEC
 437+ 9BEC                              psh1
 437+ 9BEC E5          >                push    hl
 437+ 9BED DD E9       >                jp      (ix)
 438+ 9BEF
 439+ 9BEF              //  ______________________________________________________________________
 440+ 9BEF
 441+ 9BEF              MMU7_read:
 442+ 9BEF 01 3B 24                     ld      bc, $243B
 443+ 9BF2 3E 57                        ld      a, 87
 444+ 9BF4 ED 79                        out     (c), a
 445+ 9BF6 04                           inc     b
 446+ 9BF7 ED 78                        in      a, (c)
 447+ 9BF9 C9                           ret
 448+ 9BFA
 449+ 9BFA              //  ______________________________________________________________________
 450+ 9BFA
 451+ 9BFA              TO_FAR_rout:
 452+ 9BFA 7C                           ld      a, h
 453+ 9BFB 08                           ex      af, af
 454+ 9BFC 7C                           ld      a, h
 455+ 9BFD F6 E0                        or      $E0
 456+ 9BFF 67                           ld      h, a
 457+ 9C00 08                           ex      af, af
 458+ 9C01 07                           rlca
 459+ 9C02 07                           rlca
 460+ 9C03 07                           rlca
 461+ 9C04 E6 07                        and     $07
 462+ 9C06 C6 20                        add     $20
 463+ 9C08 C9                           ret
 464+ 9C09
 465+ 9C09
 466+ 9C09              //  ______________________________________________________________________
 467+ 9C09              //
 468+ 9C09              // (find)       addr voc -- 0 | cfa b 1
 469+ 9C09              // vocabulary search,
 470+ 9C09              // - voc is starting word's NFA
 471+ 9C09              // - addr is the string to be searched for
 472+ 9C09              // On success, it returns the CFA of found word, the first NFA byte
 473+ 9C09              // (which contains length and some flags) and a true flag.
 474+ 9C09              // On fail, a false flag  (no more: leaves addr unchanged)
 475+ 9C09                              New_Def C_FIND, "(FIND)", is_code, is_normal
 475+ 9C09             >
 475+ 9C09             >Dict_Ptr        defl    $
 475+ 9C09             >
 475+ 9C09             >//              ______________________________________________________________________
 475+ 9C09             >//              Heap part
 475+ 9C09             >
 475+ 9C09             >
 475+ 9C09             >                org     (Heap_Ptr & $1FFF) + $E000
 475+ E193             >
 475+ E193             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 475+ E193             >Latest_Definition defl  Heap_Ptr
 475+ E193             >
 475+ E193             >                // dummy db directives used to calculate length of namec
 475+ E193 28 46 49 4E >                db      "(FIND)"
 475+ E197 44 29       >
 475+ E199             >len_NFA         defl    $ - temp_NFA
 475+ E199             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 475+ E193             >
 475+ E193 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 475+ E194 28 46 49 4E >                db      "(FIND)"               // name string in 7-bit ascii, but
 475+ E198 44 29       >
 475+ E19A             >                org     $-1                 // alter last byte of Name just above to set
 475+ E199 A9          >                db      {b $} | END_BIT     // msb as name end
 475+ E19A             >
 475+ E19A 89 01       >                dw      Prev_Ptr            // Link to previous definition Name
 475+ E19C             >Prev_Ptr        defl    Heap_Ptr
 475+ E19C             >
 475+ E19C             >mirror_Ptr      defl    $
 475+ E19C             >
 475+ E19C 0B 9C       >                dw      Dict_Ptr + 2        // xt
 475+ E19E             >Heap_Ptr        defl    $ - $E000           // save current HP
 475+ E19E             >
 475+ E19E             >Current_HP      defl  $ - $E000             // used to set HP once!
 475+ E19E             >
 475+ E19E             >//              ______________________________________________________________________
 475+ E19E             >//              Dictionary part
 475+ E19E             >
 475+ E19E             >                org     Dict_Ptr
 475+ 9C09             >
 475+ 9C09 9C 20       >                dw      mirror_Ptr - $E000 + $1F00
 475+ 9C0B             >
 475+ 9C0B             >C_FIND:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 475+ 9C0B ~           >                call    runcode ; ok        // for primitive definitions  actual code
 475+ 9C0B ~           >
 475+ 9C0B ~           >
 475+ 9C0B             >                endif           ; ok        // for other definitions it "points" the correct handler
 475+ 9C0B             >                // Use of "; ok" to suppress "warning[fwdref]"
 475+ 9C0B             >
 475+ 9C0B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 476+ 9C0B D9                           exx
 477+ 9C0C CD EF 9B                     call    MMU7_read
 478+ 9C0F D9                           exx
 479+ 9C10 6F                           ld      l, a
 480+ 9C11 D9                           exx
 481+ 9C12
 482+ 9C12 D1                           pop     de                      // de has dictionary pointer
 483+ 9C13              Find_VocabularyLoop:
 484+ 9C13 7A                               ld      a, d
 485+ 9C14 D6 60                            sub     $60
 486+ 9C16 30 08                            jr      nc, Find_far_endif
 487+ 9C18 EB                                   ex      de, hl
 488+ 9C19 CD FA 9B                             call    TO_FAR_rout
 489+ 9C1C EB                                   ex      de, hl
 490+ 9C1D ED 92 57                             nextreg 87, a
 491+ 9C20              Find_far_endif:
 492+ 9C20 E1                               pop     hl                  // string pointer to search for
 493+ 9C21 E5                               push    hl                  // keep it on stack too for the end.
 494+ 9C22 1A                               ld      a, (de)             // save NFA length byte
 495+ 9C23 08                               ex      af,af'              // for later use (!)
 496+ 9C24 1A                               ld      a, (de)             // reload NFA length byte
 497+ 9C25 AE                               xor     (hl)                // check if same length
 498+ 9C26 E6 3F                            and     $3F                 // by resetting 3 high bits (flags)
 499+ 9C28                                  // word and text haven't the same length, skip to next vocabulary entry
 500+ 9C28 20 33                            jr      nz, Find_DifferentLenght
 501+ 9C2A
 502+ 9C2A              Find_ThisWord:      // begin loop
 503+ 9C2A 23                                   inc     hl
 504+ 9C2B 13                                   inc     de
 505+ 9C2C 1A                                   ld      a, (de)
 506+ 9C2D                                      // case insensitive option - begin
 507+ 9C2D                                      // push    bc
 508+ 9C2D E6 80                                and     $80                 // split A in msb and the rest
 509+ 9C2F 47                                   ld      b, a
 510+ 9C30 1A                                   ld      a, (de)
 511+ 9C31 E6 7F                                and     $7F                 // ... the rest (lower 7 bits)
 512+ 9C33 CD C8 9B                             call    Case_Sensitive      // uppercase routine
 513+ 9C36 4F                                   ld      c, a
 514+ 9C37 7E                                   ld      a, (hl)
 515+ 9C38 CD C8 9B                             call    Case_Sensitive      // uppercase routine
 516+ 9C3B A9                                   xor     c
 517+ 9C3C A8                                   xor     b
 518+ 9C3D                                      // pop     bc
 519+ 9C3D                                      // case insensitive option - end
 520+ 9C3D 87                                   add     a                   // ignore msb during compare
 521+ 9C3E 20 1B                                jr      nz, Find_DidntMatch  // jump if doesn't match (*)
 522+ 9C40
 523+ 9C40                                  // loop back until last byte msb is found set
 524+ 9C40                                  // that bit marks the ending char of this word
 525+ 9C40 30 E8                            jr      nc, Find_ThisWord
 526+ 9C42
 527+ 9C42                                  // match found !
 528+ 9C42 21 03 00                         ld      hl, 3               // 3 bytes for CFA offset to skip LFA
 529+ 9C45 19                               add     hl, de
 530+ 9C46
 531+ 9C46                              //  ld      a, h
 532+ 9C46                              //  and     $E0
 533+ 9C46                              //  xor     h
 534+ 9C46                              //  jr      nz, Non_MMU7
 535+ 9C46                                  //  call    MMU7_read
 536+ 9C46                                  //  dec     a
 537+ 9C46                                  //  jr      z, Non_MMU7
 538+ 9C46 5E                                       ld      e, (hl)
 539+ 9C47 23                                       inc     hl
 540+ 9C48 56                                       ld      d, (hl)
 541+ 9C49 EB                                       ex      de, hl
 542+ 9C4A              //Non_MMU7:
 543+ 9C4A E3                               ex      (sp), hl            // CFA on stack and drop addr
 544+ 9C4B 08                               ex      af, af'             // retrieve NFA byte (!)
 545+ 9C4C 5F                               ld      e, a
 546+ 9C4D 16 00                            ld      d, 0
 547+ 9C4F 21 FF FF                         ld      hl, -1
 548+ 9C52 D5                               push    de
 549+ 9C53 E5                               push    hl
 550+ 9C54 D9                               exx
 551+ 9C55 7D                               ld      a, l
 552+ 9C56 ED 92 57                         nextreg 87, a
 553+ 9C59                                  next
 553+ 9C59 DD E9       >                jp      (ix)
 554+ 9C5B
 555+ 9C5B              Find_DidntMatch: // didn't match (*)
 556+ 9C5B 38 05                            jr      c,  Find_WordEnd   // jump if not end of word (**)
 557+ 9C5D
 558+ 9C5D              Find_DifferentLenght:
 559+ 9C5D                                  // consume chars until the end of the word
 560+ 9C5D                                  // that is last byte msb is found set
 561+ 9C5D 13                                   inc     de
 562+ 9C5E 1A                                   ld      a, (de)
 563+ 9C5F 87                                   add     a, a
 564+ 9C60 30 FB                            jr      nc, Find_DifferentLenght
 565+ 9C62
 566+ 9C62              Find_WordEnd:   // word-end  found (**)
 567+ 9C62                                  // take LFA and use it
 568+ 9C62 13                               inc     de
 569+ 9C63 EB                               ex      de, hl
 570+ 9C64 5E                               ld      e, (hl)
 571+ 9C65 23                               inc     hl
 572+ 9C66 56                               ld      d, (hl)
 573+ 9C67 7A                               ld      a, d
 574+ 9C68 B3                               or      e
 575+ 9C69
 576+ 9C69                              // loop until end of vocabulary
 577+ 9C69 20 A8                        jr      nz, Find_VocabularyLoop
 578+ 9C6B
 579+ 9C6B E1                           pop     hl              // without this, leaves addr unchanged
 580+ 9C6C 21 00 00                     ld      hl, 0
 581+ 9C6F E5                           push    hl
 582+ 9C70 D9                           exx
 583+ 9C71 7D                           ld      a, l
 584+ 9C72 ED 92 57                     nextreg 87, a
 585+ 9C75                              next
 585+ 9C75 DD E9       >                jp      (ix)
 586+ 9C77
 587+ 9C77              //  ______________________________________________________________________
 588+ 9C77              //
 589+ 9C77              // enclose      a c -- a  n1 n2 n3
 590+ 9C77              // starting from a, using delimiter c, determines the offsets:
 591+ 9C77              //   n1   the first character non-delimiter
 592+ 9C77              //   n2   the first delimiter after the text
 593+ 9C77              //   n3   the first character non enclosed.
 594+ 9C77              // This procedure does not go beyond a 'nul' ASCII (0x00) that represents
 595+ 9C77              // an uncoditional delimiter.
 596+ 9C77              // Examples:
 597+ 9C77              //   i:	c  c  x  x  x  c  x	 -- 2  5  6
 598+ 9C77              //  ii:	c  c  x  x  x  'nul' -- 2  5  5
 599+ 9C77              // iii:	c  c  'nul'          -- 2  3  2
 600+ 9C77                              New_Def ENCLOSE, "ENCLOSE", is_code, is_normal
 600+ 9C77             >
 600+ 9C77             >Dict_Ptr        defl    $
 600+ 9C77             >
 600+ 9C77             >//              ______________________________________________________________________
 600+ 9C77             >//              Heap part
 600+ 9C77             >
 600+ 9C77             >
 600+ 9C77             >                org     (Heap_Ptr & $1FFF) + $E000
 600+ E19E             >
 600+ E19E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 600+ E19E             >Latest_Definition defl  Heap_Ptr
 600+ E19E             >
 600+ E19E             >                // dummy db directives used to calculate length of namec
 600+ E19E 45 4E 43 4C >                db      "ENCLOSE"
 600+ E1A2 4F 53 45    >
 600+ E1A5             >len_NFA         defl    $ - temp_NFA
 600+ E1A5             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 600+ E19E             >
 600+ E19E 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 600+ E19F 45 4E 43 4C >                db      "ENCLOSE"               // name string in 7-bit ascii, but
 600+ E1A3 4F 53 45    >
 600+ E1A6             >                org     $-1                 // alter last byte of Name just above to set
 600+ E1A5 C5          >                db      {b $} | END_BIT     // msb as name end
 600+ E1A6             >
 600+ E1A6 93 01       >                dw      Prev_Ptr            // Link to previous definition Name
 600+ E1A8             >Prev_Ptr        defl    Heap_Ptr
 600+ E1A8             >
 600+ E1A8             >mirror_Ptr      defl    $
 600+ E1A8             >
 600+ E1A8 79 9C       >                dw      Dict_Ptr + 2        // xt
 600+ E1AA             >Heap_Ptr        defl    $ - $E000           // save current HP
 600+ E1AA             >
 600+ E1AA             >Current_HP      defl  $ - $E000             // used to set HP once!
 600+ E1AA             >
 600+ E1AA             >//              ______________________________________________________________________
 600+ E1AA             >//              Dictionary part
 600+ E1AA             >
 600+ E1AA             >                org     Dict_Ptr
 600+ 9C77             >
 600+ 9C77 A8 20       >                dw      mirror_Ptr - $E000 + $1F00
 600+ 9C79             >
 600+ 9C79             >ENCLOSE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 600+ 9C79 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 600+ 9C79 ~           >
 600+ 9C79 ~           >
 600+ 9C79             >                endif           ; ok        // for other definitions it "points" the correct handler
 600+ 9C79             >                // Use of "; ok" to suppress "warning[fwdref]"
 600+ 9C79             >
 600+ 9C79             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 601+ 9C79 D9                           exx
 602+ 9C7A D1                           pop     de                  //  e has the character
 603+ 9C7B E1                           pop     hl                  // hl has the string address
 604+ 9C7C E5                           push    hl
 605+ 9C7D 7B                           ld      a, e
 606+ 9C7E 11 FF FF                     ld      de, -1              // let's start from -1
 607+ 9C81 2B                           dec     hl
 608+ 9C82              Enclose_NonDelimiter:
 609+ 9C82                              // find first non delimiter
 610+ 9C82 23                               inc     hl
 611+ 9C83 13                               inc     de
 612+ 9C84 BE                               cp      (hl)
 613+ 9C85 28 FB                        jr      z, Enclose_NonDelimiter
 614+ 9C87 D5                           push    de
 615+ 9C88
 616+ 9C88                              // push    bc                  // save Instruction Pointer
 617+ 9C88
 618+ 9C88 4F                           ld      c, a                // save char
 619+ 9C89 7E                           ld      a, (hl)
 620+ 9C8A A7                           and     a                   // stop if 0x00
 621+ 9C8B 20 07                        jr      nz, Enclose_NextChar
 622+ 9C8D                              /// case iii. no more character in string
 623+ 9C8D                                  // pop     bc                  // restore Instruction Pointer
 624+ 9C8D 13                               inc     de
 625+ 9C8E D5                               push    de
 626+ 9C8F 1B                               dec     de
 627+ 9C90 D5                               push    de
 628+ 9C91 D9                               exx
 629+ 9C92                                  next
 629+ 9C92 DD E9       >                jp      (ix)
 630+ 9C94              Enclose_NextChar:
 631+ 9C94 79                               ld      a, c
 632+ 9C95 23                               inc     hl
 633+ 9C96 13                               inc     de
 634+ 9C97 BE                               cp      (hl)
 635+ 9C98 20 06                            jr      nz, Enclose_NonSeparator
 636+ 9C9A                                      // case i. first non enclosed
 637+ 9C9A                                      // pop     bc                  // restore Instruction Pointer
 638+ 9C9A D5                                   push    de
 639+ 9C9B 13                                   inc     de
 640+ 9C9C D5                                   push    de
 641+ 9C9D D9                                   exx
 642+ 9C9E                                      next
 642+ 9C9E DD E9       >                jp      (ix)
 643+ 9CA0              Enclose_NonSeparator:
 644+ 9CA0 7E                               ld      a, (hl)
 645+ 9CA1 A7                               and     a
 646+ 9CA2 20 F0                        jr      nz, Enclose_NextChar
 647+ 9CA4
 648+ 9CA4                              // case ii. separator & terminator
 649+ 9CA4                              // pop     bc                  // restore Instruction Pointer
 650+ 9CA4 D5                           push    de
 651+ 9CA5 D5                           push    de
 652+ 9CA6 D9                           exx
 653+ 9CA7                              next
 653+ 9CA7 DD E9       >                jp      (ix)
 654+ 9CA9
 655+ 9CA9              //  ______________________________________________________________________
 656+ 9CA9              //
 657+ 9CA9              // (map)        a2 a1 n c1 -- c2
 658+ 9CA9              // translate character c1 using mapping string a2 and a2
 659+ 9CA9              // if c1 is not present within string a1 then
 660+ 9CA9              // c2 = c2 if it is not translated. n is the length of both a1 and a2.
 661+ 9CA9                              New_Def C_MAP, "(MAP)", is_code, is_normal
 661+ 9CA9             >
 661+ 9CA9             >Dict_Ptr        defl    $
 661+ 9CA9             >
 661+ 9CA9             >//              ______________________________________________________________________
 661+ 9CA9             >//              Heap part
 661+ 9CA9             >
 661+ 9CA9             >
 661+ 9CA9             >                org     (Heap_Ptr & $1FFF) + $E000
 661+ E1AA             >
 661+ E1AA             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 661+ E1AA             >Latest_Definition defl  Heap_Ptr
 661+ E1AA             >
 661+ E1AA             >                // dummy db directives used to calculate length of namec
 661+ E1AA 28 4D 41 50 >                db      "(MAP)"
 661+ E1AE 29          >
 661+ E1AF             >len_NFA         defl    $ - temp_NFA
 661+ E1AF             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 661+ E1AA             >
 661+ E1AA 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 661+ E1AB 28 4D 41 50 >                db      "(MAP)"               // name string in 7-bit ascii, but
 661+ E1AF 29          >
 661+ E1B0             >                org     $-1                 // alter last byte of Name just above to set
 661+ E1AF A9          >                db      {b $} | END_BIT     // msb as name end
 661+ E1B0             >
 661+ E1B0 9E 01       >                dw      Prev_Ptr            // Link to previous definition Name
 661+ E1B2             >Prev_Ptr        defl    Heap_Ptr
 661+ E1B2             >
 661+ E1B2             >mirror_Ptr      defl    $
 661+ E1B2             >
 661+ E1B2 AB 9C       >                dw      Dict_Ptr + 2        // xt
 661+ E1B4             >Heap_Ptr        defl    $ - $E000           // save current HP
 661+ E1B4             >
 661+ E1B4             >Current_HP      defl  $ - $E000             // used to set HP once!
 661+ E1B4             >
 661+ E1B4             >//              ______________________________________________________________________
 661+ E1B4             >//              Dictionary part
 661+ E1B4             >
 661+ E1B4             >                org     Dict_Ptr
 661+ 9CA9             >
 661+ 9CA9 B2 20       >                dw      mirror_Ptr - $E000 + $1F00
 661+ 9CAB             >
 661+ 9CAB             >C_MAP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 661+ 9CAB ~           >                call    runcode ; ok        // for primitive definitions  actual code
 661+ 9CAB ~           >
 661+ 9CAB ~           >
 661+ 9CAB             >                endif           ; ok        // for other definitions it "points" the correct handler
 661+ 9CAB             >                // Use of "; ok" to suppress "warning[fwdref]"
 661+ 9CAB             >
 661+ 9CAB             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 662+ 9CAB D9                           exx
 663+ 9CAC E1                           pop     hl
 664+ 9CAD 7D                           ld      a, l
 665+ 9CAE C1                           pop     bc
 666+ 9CAF E1                           pop     hl
 667+ 9CB0 50                           ld      d, b
 668+ 9CB1 59                           ld      e, c
 669+ 9CB2 ED B1                        cpir
 670+ 9CB4 E1                           pop     hl
 671+ 9CB5 20 05                        jr      nz, C_Map_Then
 671+ 9CB7
 672+ 9CB7 19                               add     hl, de
 673+ 9CB8 2B                               dec     hl
 674+ 9CB9 ED 42                            sbc     hl, bc
 675+ 9CBB 7E                               ld      a, (hl)
 676+ 9CBC              C_Map_Then:
 677+ 9CBC 6F                           ld      l, a
 678+ 9CBD 26 00                        ld      h, 0
 679+ 9CBF E5                           push    hl
 680+ 9CC0 D9                           exx
 681+ 9CC1                              next
 681+ 9CC1 DD E9       >                jp      (ix)
 682+ 9CC3
 683+ 9CC3              //  ______________________________________________________________________
 684+ 9CC3              //
 685+ 9CC3              // (compare)    a1 a2 n -- b
 686+ 9CC3              // this word performs a lexicographic compare of n bytes of text at address a1
 687+ 9CC3              // with n bytes of text at address a2. It returns numeric a value:
 688+ 9CC3              //  0 : if strings are equal
 689+ 9CC3              // +1 : if string at a1 greater than string at a2
 690+ 9CC3              // -1 : if string at a1 less than string at a2
 691+ 9CC3              // strings can be 256 bytes in length at most.
 692+ 9CC3                              New_Def C_COMPARE, "(COMPARE)", is_code, is_normal
 692+ 9CC3             >
 692+ 9CC3             >Dict_Ptr        defl    $
 692+ 9CC3             >
 692+ 9CC3             >//              ______________________________________________________________________
 692+ 9CC3             >//              Heap part
 692+ 9CC3             >
 692+ 9CC3             >
 692+ 9CC3             >                org     (Heap_Ptr & $1FFF) + $E000
 692+ E1B4             >
 692+ E1B4             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 692+ E1B4             >Latest_Definition defl  Heap_Ptr
 692+ E1B4             >
 692+ E1B4             >                // dummy db directives used to calculate length of namec
 692+ E1B4 28 43 4F 4D >                db      "(COMPARE)"
 692+ E1B8 50 41 52 45 >
 692+ E1BC 29          >
 692+ E1BD             >len_NFA         defl    $ - temp_NFA
 692+ E1BD             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 692+ E1B4             >
 692+ E1B4 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 692+ E1B5 28 43 4F 4D >                db      "(COMPARE)"               // name string in 7-bit ascii, but
 692+ E1B9 50 41 52 45 >
 692+ E1BD 29          >
 692+ E1BE             >                org     $-1                 // alter last byte of Name just above to set
 692+ E1BD A9          >                db      {b $} | END_BIT     // msb as name end
 692+ E1BE             >
 692+ E1BE AA 01       >                dw      Prev_Ptr            // Link to previous definition Name
 692+ E1C0             >Prev_Ptr        defl    Heap_Ptr
 692+ E1C0             >
 692+ E1C0             >mirror_Ptr      defl    $
 692+ E1C0             >
 692+ E1C0 C5 9C       >                dw      Dict_Ptr + 2        // xt
 692+ E1C2             >Heap_Ptr        defl    $ - $E000           // save current HP
 692+ E1C2             >
 692+ E1C2             >Current_HP      defl  $ - $E000             // used to set HP once!
 692+ E1C2             >
 692+ E1C2             >//              ______________________________________________________________________
 692+ E1C2             >//              Dictionary part
 692+ E1C2             >
 692+ E1C2             >                org     Dict_Ptr
 692+ 9CC3             >
 692+ 9CC3 C0 20       >                dw      mirror_Ptr - $E000 + $1F00
 692+ 9CC5             >
 692+ 9CC5             >C_COMPARE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 692+ 9CC5 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 692+ 9CC5 ~           >
 692+ 9CC5 ~           >
 692+ 9CC5             >                endif           ; ok        // for other definitions it "points" the correct handler
 692+ 9CC5             >                // Use of "; ok" to suppress "warning[fwdref]"
 692+ 9CC5             >
 692+ 9CC5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 693+ 9CC5 D9                           exx
 694+ 9CC6 E1                           pop     hl                  // Number of bytes
 695+ 9CC7 7D                           ld      a, l
 696+ 9CC8 E1                           pop     hl                  // hl points string a2
 697+ 9CC9 D1                           pop     de                  // hl points string a1
 698+ 9CCA              //              push    bc                  // Instruction pointer on stack
 699+ 9CCA 47                           ld      b, a
 700+ 9CCB              C_Compare_Loop:
 701+ 9CCB 7E                               ld      a, (hl)
 702+ 9CCC CD C8 9B                         call    Case_Sensitive
 703+ 9CCF 4F                               ld      c, a
 704+ 9CD0 1A                               ld      a, (de)
 705+ 9CD1 CD C8 9B                         call    Case_Sensitive
 706+ 9CD4 B9                               cp      c
 707+ 9CD5 13                               inc     de
 708+ 9CD6 23                               inc     hl
 709+ 9CD7 28 0E                            jr      z, C_Compare_Equal
 710+ 9CD9 38 05                                jr      c, C_Compare_NotLessThan  // If LessThan
 711+ 9CDB 21 01 00                                 ld      hl, 1               // a1 gt a2
 712+ 9CDE 18 03                                jr      C_Compare_Then      // Else
 713+ 9CE0              C_Compare_NotLessThan:
 714+ 9CE0 21 FF FF                                 ld      hl, -1              // a1 lt a2
 715+ 9CE3              C_Compare_Then:                                 // Endif
 716+ 9CE3              //                      pop     bc              // restore Instruction Pointer
 717+ 9CE3 E5                                   push    hl
 718+ 9CE4 D9                                   exx
 719+ 9CE5
 720+ 9CE5                                      next
 720+ 9CE5 DD E9       >                jp      (ix)
 721+ 9CE7
 722+ 9CE7              C_Compare_Equal:
 723+ 9CE7 10 E2                        djnz    C_Compare_Loop
 724+ 9CE9 21 00 00                     ld      hl, 0               // a1 eq a2
 725+ 9CEC              //              pop     bc                  // restore Instruction Pointer
 726+ 9CEC E5                           push    hl
 727+ 9CED D9                           exx
 728+ 9CEE
 729+ 9CEE                              next
 729+ 9CEE DD E9       >                jp      (ix)
 730+ 9CF0
 731+ 9CF0              //  ______________________________________________________________________
 732+ 9CF0              //
 733+ 9CF0              // emitc        c --
 734+ 9CF0              // low level emit, calls ROM routine at #10 to send a character to
 735+ 9CF0              // the the current channel (see SELECT to change stream-channel)
 736+ 9CF0                              New_Def EMITC, "EMITC", is_code, is_normal
 736+ 9CF0             >
 736+ 9CF0             >Dict_Ptr        defl    $
 736+ 9CF0             >
 736+ 9CF0             >//              ______________________________________________________________________
 736+ 9CF0             >//              Heap part
 736+ 9CF0             >
 736+ 9CF0             >
 736+ 9CF0             >                org     (Heap_Ptr & $1FFF) + $E000
 736+ E1C2             >
 736+ E1C2             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 736+ E1C2             >Latest_Definition defl  Heap_Ptr
 736+ E1C2             >
 736+ E1C2             >                // dummy db directives used to calculate length of namec
 736+ E1C2 45 4D 49 54 >                db      "EMITC"
 736+ E1C6 43          >
 736+ E1C7             >len_NFA         defl    $ - temp_NFA
 736+ E1C7             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 736+ E1C2             >
 736+ E1C2 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 736+ E1C3 45 4D 49 54 >                db      "EMITC"               // name string in 7-bit ascii, but
 736+ E1C7 43          >
 736+ E1C8             >                org     $-1                 // alter last byte of Name just above to set
 736+ E1C7 C3          >                db      {b $} | END_BIT     // msb as name end
 736+ E1C8             >
 736+ E1C8 B4 01       >                dw      Prev_Ptr            // Link to previous definition Name
 736+ E1CA             >Prev_Ptr        defl    Heap_Ptr
 736+ E1CA             >
 736+ E1CA             >mirror_Ptr      defl    $
 736+ E1CA             >
 736+ E1CA F2 9C       >                dw      Dict_Ptr + 2        // xt
 736+ E1CC             >Heap_Ptr        defl    $ - $E000           // save current HP
 736+ E1CC             >
 736+ E1CC             >Current_HP      defl  $ - $E000             // used to set HP once!
 736+ E1CC             >
 736+ E1CC             >//              ______________________________________________________________________
 736+ E1CC             >//              Dictionary part
 736+ E1CC             >
 736+ E1CC             >                org     Dict_Ptr
 736+ 9CF0             >
 736+ 9CF0 CA 20       >                dw      mirror_Ptr - $E000 + $1F00
 736+ 9CF2             >
 736+ 9CF2             >EMITC:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 736+ 9CF2 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 736+ 9CF2 ~           >
 736+ 9CF2 ~           >
 736+ 9CF2             >                endif           ; ok        // for other definitions it "points" the correct handler
 736+ 9CF2             >                // Use of "; ok" to suppress "warning[fwdref]"
 736+ 9CF2             >
 736+ 9CF2             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 737+ 9CF2 E1                           pop     hl
 738+ 9CF3 7D                           ld      a, l
 739+ 9CF4              Emitc_Ptr:
 740+ 9CF4 C5                           push    bc
 741+ 9CF5 D5                           push    de
 742+ 9CF6 DD E5                        push    ix
 743+ 9CF8 D7                           rst     $10
 744+ 9CF9 DD E1                        pop     ix
 745+ 9CFB D1                           pop     de
 746+ 9CFC C1                           pop     bc
 747+ 9CFD 3E FF                        ld      a, 255            // max possible
 748+ 9CFF 32 8C 5C                     ld      (SCR_CT), a
 749+ 9D02                              next
 749+ 9D02 DD E9       >                jp      (ix)
 750+ 9D04
 751+ 9D04              //  ______________________________________________________________________
 752+ 9D04              //
 753+ 9D04              // cr           --
 754+ 9D04              // send a CR via EMITC
 755+ 9D04                              New_Def CR, "CR", is_code, is_normal
 755+ 9D04             >
 755+ 9D04             >Dict_Ptr        defl    $
 755+ 9D04             >
 755+ 9D04             >//              ______________________________________________________________________
 755+ 9D04             >//              Heap part
 755+ 9D04             >
 755+ 9D04             >
 755+ 9D04             >                org     (Heap_Ptr & $1FFF) + $E000
 755+ E1CC             >
 755+ E1CC             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 755+ E1CC             >Latest_Definition defl  Heap_Ptr
 755+ E1CC             >
 755+ E1CC             >                // dummy db directives used to calculate length of namec
 755+ E1CC 43 52       >                db      "CR"
 755+ E1CE             >len_NFA         defl    $ - temp_NFA
 755+ E1CE             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 755+ E1CC             >
 755+ E1CC 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 755+ E1CD 43 52       >                db      "CR"               // name string in 7-bit ascii, but
 755+ E1CF             >                org     $-1                 // alter last byte of Name just above to set
 755+ E1CE D2          >                db      {b $} | END_BIT     // msb as name end
 755+ E1CF             >
 755+ E1CF C2 01       >                dw      Prev_Ptr            // Link to previous definition Name
 755+ E1D1             >Prev_Ptr        defl    Heap_Ptr
 755+ E1D1             >
 755+ E1D1             >mirror_Ptr      defl    $
 755+ E1D1             >
 755+ E1D1 06 9D       >                dw      Dict_Ptr + 2        // xt
 755+ E1D3             >Heap_Ptr        defl    $ - $E000           // save current HP
 755+ E1D3             >
 755+ E1D3             >Current_HP      defl  $ - $E000             // used to set HP once!
 755+ E1D3             >
 755+ E1D3             >//              ______________________________________________________________________
 755+ E1D3             >//              Dictionary part
 755+ E1D3             >
 755+ E1D3             >                org     Dict_Ptr
 755+ 9D04             >
 755+ 9D04 D1 20       >                dw      mirror_Ptr - $E000 + $1F00
 755+ 9D06             >
 755+ 9D06             >CR:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 755+ 9D06 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 755+ 9D06 ~           >
 755+ 9D06 ~           >
 755+ 9D06             >                endif           ; ok        // for other definitions it "points" the correct handler
 755+ 9D06             >                // Use of "; ok" to suppress "warning[fwdref]"
 755+ 9D06             >
 755+ 9D06             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 756+ 9D06
 757+ 9D06 3E 0D                        ld      a, CR_CHAR
 758+ 9D08 18 EA                        jr      Emitc_Ptr
 759+ 9D0A
 760+ 9D0A              Emitc_Vec:
 761+ 9D0A 43 9D                        dw      C_Emit_Printable  // comma
 762+ 9D0C 4A 9D                        dw      C_Emit_Bel        // bel
 763+ 9D0E 43 9D                        dw      C_Emit_Printable  // bs
 764+ 9D10 62 9D                        dw      C_Emit_Tab        // tab
 765+ 9D12 43 9D                        dw      C_Emit_Printable  // cr
 766+ 9D14 69 9D                        dw      C_Emit_NL         // lf (unix newline)
 767+ 9D16 43 9D                        dw      C_Emit_Printable  // blank
 768+ 9D18 43 9D                        dw      C_Emit_Printable  // blank
 769+ 9D1A
 770+ 9D1A              Emit_Selector_Start:
 771+ 9D1A 06                           db      $06                 // comma
 772+ 9D1B 07                           db      $07                 // bel
 773+ 9D1C 08                           db      $08                 // bs
 774+ 9D1D 09                           db      $09                 // tab
 775+ 9D1E 0D                           db      $0D                 // cr
 776+ 9D1F 0A                           db      $0A                 // lf (unix newline)
 777+ 9D20 20                           db      $20
 778+ 9D21              Emit_Selector_End:
 779+ 9D21 20                           db      $20
 780+ 9D22
 781+ 9D22              //  ______________________________________________________________________
 782+ 9D22              //
 783+ 9D22              // (?emit)      c1 -- c2 | c1
 784+ 9D22              // decode a character to be sent via EMIT
 785+ 9D22              // search first the Emit_Selector table, if found jump to the corresponding routine in Emit_Vector
 786+ 9D22              // the routine should resolve anything and convert the character anyway.
 787+ 9D22                              New_Def C_EMIT, "(?EMIT)", is_code, is_normal
 787+ 9D22             >
 787+ 9D22             >Dict_Ptr        defl    $
 787+ 9D22             >
 787+ 9D22             >//              ______________________________________________________________________
 787+ 9D22             >//              Heap part
 787+ 9D22             >
 787+ 9D22             >
 787+ 9D22             >                org     (Heap_Ptr & $1FFF) + $E000
 787+ E1D3             >
 787+ E1D3             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 787+ E1D3             >Latest_Definition defl  Heap_Ptr
 787+ E1D3             >
 787+ E1D3             >                // dummy db directives used to calculate length of namec
 787+ E1D3 28 3F 45 4D >                db      "(?EMIT)"
 787+ E1D7 49 54 29    >
 787+ E1DA             >len_NFA         defl    $ - temp_NFA
 787+ E1DA             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 787+ E1D3             >
 787+ E1D3 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 787+ E1D4 28 3F 45 4D >                db      "(?EMIT)"               // name string in 7-bit ascii, but
 787+ E1D8 49 54 29    >
 787+ E1DB             >                org     $-1                 // alter last byte of Name just above to set
 787+ E1DA A9          >                db      {b $} | END_BIT     // msb as name end
 787+ E1DB             >
 787+ E1DB CC 01       >                dw      Prev_Ptr            // Link to previous definition Name
 787+ E1DD             >Prev_Ptr        defl    Heap_Ptr
 787+ E1DD             >
 787+ E1DD             >mirror_Ptr      defl    $
 787+ E1DD             >
 787+ E1DD 24 9D       >                dw      Dict_Ptr + 2        // xt
 787+ E1DF             >Heap_Ptr        defl    $ - $E000           // save current HP
 787+ E1DF             >
 787+ E1DF             >Current_HP      defl  $ - $E000             // used to set HP once!
 787+ E1DF             >
 787+ E1DF             >//              ______________________________________________________________________
 787+ E1DF             >//              Dictionary part
 787+ E1DF             >
 787+ E1DF             >                org     Dict_Ptr
 787+ 9D22             >
 787+ 9D22 DD 20       >                dw      mirror_Ptr - $E000 + $1F00
 787+ 9D24             >
 787+ 9D24             >C_EMIT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 787+ 9D24 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 787+ 9D24 ~           >
 787+ 9D24 ~           >
 787+ 9D24             >                endif           ; ok        // for other definitions it "points" the correct handler
 787+ 9D24             >                // Use of "; ok" to suppress "warning[fwdref]"
 787+ 9D24             >
 787+ 9D24             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 788+ 9D24 D9                           exx
 789+ 9D25 D1                           pop     de
 790+ 9D26 7B                           ld      a, e                //  de has c1
 791+ 9D27 E6 7F                        and     $7F                 // 7-bit ascii only
 792+ 9D29                              // push    bc                  // save Instruction Pointer
 793+ 9D29 01 08 00                     ld      bc, Emit_Selector_End - Emit_Selector_Start + 1
 794+ 9D2C 21 21 9D                     ld      hl, Emit_Selector_End
 795+ 9D2F ED B9                        cpdr                        // search for c1 in Emit_Selector table, backward
 796+ 9D31 20 0A                        jr      nz, C_Emit_Not_Found
 797+ 9D33                                  // Found then decode it
 798+ 9D33 21 0A 9D                         ld      hl, Emitc_Vec
 799+ 9D36 09                               add     hl, bc
 800+ 9D37 09                               add     hl, bc
 801+ 9D38 5E                               ld      e, (hl)
 802+ 9D39 23                               inc     hl
 803+ 9D3A 56                               ld      d, (hl)
 804+ 9D3B EB                               ex      de, hl
 805+ 9D3C                                  // pop     bc                  // restore Instruction Pointer
 806+ 9D3C E9                               jp      (hl)                // one of the following labels
 807+ 9D3D              C_Emit_Not_Found:
 808+ 9D3D                              // pop     bc                  // restore Instruction Pointer
 809+ 9D3D FE 20                        cp      BLANK_CHAR          // cp $20 non-printable check
 810+ 9D3F 30 02                        jr      nc, C_Emit_Printable
 811+ 9D41 3E 00                            ld      a, NUL_CHAR         // NUL is never "printed"
 812+ 9D43              C_Emit_Printable:
 813+ 9D43 6F                           ld      l, a
 814+ 9D44 26 00                        ld      h, 0
 815+ 9D46 E5                           push    hl
 816+ 9D47 D9                           exx
 817+ 9D48                              next
 817+ 9D48 DD E9       >                jp      (ix)
 818+ 9D4A
 819+ 9D4A              C_Emit_Bel:
 820+ 9D4A D9                            exx
 821+ 9D4B C5                           push    bc                  // save Instruction Pointer
 822+ 9D4C D5                           push    de
 823+ 9D4D 11 00 01                     ld      de, $0100
 824+ 9D50 21 00 02                     ld      hl, $0200
 825+ 9D53 DD E5                        push    ix                  // save Next Pointer
 826+ 9D55 CD B6 03                     call    $03B6               // bleep Standard-ROM routine
 827+ 9D58 DD E1                        pop     ix                  // restore Next Pointer
 828+ 9D5A D1                           pop     de
 829+ 9D5B C1                           pop     bc                  // restore Instruction Pointer
 830+ 9D5C 21 00 00                     ld      hl, NUL_CHAR
 831+ 9D5F E5                           push    hl
 832+ 9D60                              next
 832+ 9D60 DD E9       >                jp      (ix)
 833+ 9D62
 834+ 9D62 21 06 00     C_Emit_Tab:     ld      hl, COMMA_CHAR
 835+ 9D65 E5                           push    hl
 836+ 9D66 D9                           exx
 837+ 9D67                              next
 837+ 9D67 DD E9       >                jp      (ix)
 838+ 9D69
 839+ 9D69 21 0D 00     C_Emit_NL       ld      hl, CR_CHAR           // 0x0A --> 0x0D  à la Spectrum
 840+ 9D6C E5                           push    hl
 841+ 9D6D D9                           exx
 842+ 9D6E                              next
 842+ 9D6E DD E9       >                jp      (ix)
 843+ 9D70
 844+ 9D70              //  ______________________________________________________________________
 845+ 9D70
 846+ 9D70              Key_Table:
 847+ 9D70 E2                           db      $E2                 //  0: STOP  --> SYMBOL+A : ~
 848+ 9D71 C3                           db      $C3                 //  1: NOT   --> SYMBOL+S : |
 849+ 9D72 CD                           db      $CD                 //  2: STEP  --> SYMBOl+D : //
 850+ 9D73 CC                           db      $CC                 //  3: TO    --> SYMBOL+F : {
 851+ 9D74 CB                           db      $CB                 //  4: THEN  --> SYMBOL+G : }
 852+ 9D75 C6                           db      $C6                 //  5: AND   --> SYMBOL+Y : [
 853+ 9D76 C5                           db      $C5                 //  6: OR    --> SYMBOL+U : ]
 854+ 9D77 AC                           db      $AC                 //  7: AT    --> SYMBOL+I : (C) copyright symbol
 855+ 9D78 C7                           db      $C7                 //  8: <=    --> same as SHIFT-1 [EDIT]
 856+ 9D79 C8                           db      $C8                 //  9: >=    --> same as SHIFT-0 [BACKSPACE]
 857+ 9D7A C9                           db      $C9                 // 10: <>    --> SYMBOL+W is the same as CAPS (toggle) SHIFT+2
 858+ 9D7B              Key_MapTo:
 859+ 9D7B 06                           db      $06                 // 10: SYMBOL+W is the same as CAPS (toggle) SHIFT+2
 860+ 9D7C 0C                           db      $0C                 //  9: same as SHIFT-0 [BACKSPACE]
 861+ 9D7D 07                           db      $07                 //  8: same as SHIFT-1 [EDIT]
 862+ 9D7E 7F                           db      $7F                 //  7: SYMBOL+I : (C) copyright symbol
 863+ 9D7F 5D                           db      $5D                 //  6: SYMBOL+U : ]
 864+ 9D80 5B                           db      $5B                 //  5: SYMBOL+Y : [
 865+ 9D81 7D                           db      $7D                 //  4: SYMBOL+G : }
 866+ 9D82 7B                           db      $7B                 //  3: SYMBOL+F : {
 867+ 9D83 5C                           db      $5C                 //  2: SYMBOl+D : //
 868+ 9D84 7C                           db      $7C                 //  1: SYMBOL+S : |
 869+ 9D85 7E                           db      $7E                 //  0: SYMBOL+A : ~
 870+ 9D86
 871+ 9D86              //  ______________________________________________________________________
 872+ 9D86              //
 873+ 9D86              // curs         -- c
 874+ 9D86              // wait for a keypress
 875+ 9D86              // This definition need Standard ROM Interrupt to be served
 876+ 9D86
 877+ 9D86                              New_Def CUR, "CURS", is_code, is_normal
 877+ 9D86             >
 877+ 9D86             >Dict_Ptr        defl    $
 877+ 9D86             >
 877+ 9D86             >//              ______________________________________________________________________
 877+ 9D86             >//              Heap part
 877+ 9D86             >
 877+ 9D86             >
 877+ 9D86             >                org     (Heap_Ptr & $1FFF) + $E000
 877+ E1DF             >
 877+ E1DF             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 877+ E1DF             >Latest_Definition defl  Heap_Ptr
 877+ E1DF             >
 877+ E1DF             >                // dummy db directives used to calculate length of namec
 877+ E1DF 43 55 52 53 >                db      "CURS"
 877+ E1E3             >len_NFA         defl    $ - temp_NFA
 877+ E1E3             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 877+ E1DF             >
 877+ E1DF 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 877+ E1E0 43 55 52 53 >                db      "CURS"               // name string in 7-bit ascii, but
 877+ E1E4             >                org     $-1                 // alter last byte of Name just above to set
 877+ E1E3 D3          >                db      {b $} | END_BIT     // msb as name end
 877+ E1E4             >
 877+ E1E4 D3 01       >                dw      Prev_Ptr            // Link to previous definition Name
 877+ E1E6             >Prev_Ptr        defl    Heap_Ptr
 877+ E1E6             >
 877+ E1E6             >mirror_Ptr      defl    $
 877+ E1E6             >
 877+ E1E6 88 9D       >                dw      Dict_Ptr + 2        // xt
 877+ E1E8             >Heap_Ptr        defl    $ - $E000           // save current HP
 877+ E1E8             >
 877+ E1E8             >Current_HP      defl  $ - $E000             // used to set HP once!
 877+ E1E8             >
 877+ E1E8             >//              ______________________________________________________________________
 877+ E1E8             >//              Dictionary part
 877+ E1E8             >
 877+ E1E8             >                org     Dict_Ptr
 877+ 9D86             >
 877+ 9D86 E6 20       >                dw      mirror_Ptr - $E000 + $1F00
 877+ 9D88             >
 877+ 9D88             >CUR:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 877+ 9D88 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 877+ 9D88 ~           >
 877+ 9D88 ~           >
 877+ 9D88             >                endif           ; ok        // for other definitions it "points" the correct handler
 877+ 9D88             >                // Use of "; ok" to suppress "warning[fwdref]"
 877+ 9D88             >
 877+ 9D88             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 878+ 9D88
 879+ 9D88 C5                           push    bc                  // save Instruction Pointer
 880+ 9D89 D5                           push    de                  // save Return Stack Pointer
 881+ 9D8A DD E5                        push    ix
 882+ 9D8C ED 73 E2 9A                  ld      (SP_Saved), sp      // be sure to not to be paged out.
 883+ 9D90 31 B1 9A                     ld      sp, Cold_origin - 5 // maybe $8000 in the future...
 884+ 9D93 FD CB 01 AE                  res     5, (iy + 1)         // FLAGS (5C3A+1)
 885+ 9D97
 886+ 9D97              Cur_Wait:
 887+ 9D97 76                               halt
 888+ 9D98 3E 02                            ld      a, 2                // selec channel #2 (Upper Video)
 889+ 9D9A CD 01 16                         call    $1601               // SELECT Standard-ROM Routine
 890+ 9D9D
 891+ 9D9D                                  // software-flash: flips face every 320 ms
 892+ 9D9D 3E 10                            ld      a, $10              // Timing based
 893+ 9D9F FD A6 3E                         and     (iy + $3E)          // FRAMES (5C3A+3E)
 894+ 9DA2
 895+ 9DA2 3A DE 9A                         ld      a, (Block_Face)     // see origin.asm
 896+ 9DA5 20 0C                            jr      nz, Cur_Cursor
 897+ 9DA7 3A DF 9A                             ld      a, (Half_Face)      // see origin.asm
 898+ 9DAA FD CB 30 5E                          bit     3, (iy + $30)       // FLAGS2 (5C3A+$30) that is CAPS-LOCK
 899+ 9DAE 28 03                                jr      z, Cur_Cursor
 900+ 9DB0 3A E0 9A                                 ld      a, (Underscore_Face) // see origin
 901+ 9DB3              Cur_Cursor:
 902+ 9DB3 D7                               rst     $10
 903+ 9DB4 3E 08                            ld      a, BACKSPACE_CHAR    // backspace
 904+ 9DB6 D7                               rst     $10
 905+ 9DB7
 906+ 9DB7 FD CB 01 6E                      bit     5, (iy + 1)         // FLAGS (5C3A+1)
 907+ 9DBB 28 DA                        jr      z, Cur_Wait
 908+ 9DBD
 909+ 9DBD 76                           halt    // this is to sync flashing cursor.
 910+ 9DBE
 911+ 9DBE 3E 20                        ld      a, BLANK_CHAR       // space to blank cursor
 912+ 9DC0 D7                           rst     $10
 913+ 9DC1 3E 08                        ld      a, BACKSPACE_CHAR   // backspace
 914+ 9DC3 D7                           rst     $10
 915+ 9DC4
 916+ 9DC4 ED 7B E2 9A                  ld      sp, (SP_Saved)
 917+ 9DC8
 918+ 9DC8 DD E1                        pop     ix
 919+ 9DCA D1                           pop     de                  // Restore Return Stack Pointer
 920+ 9DCB C1                           pop     bc                  // Restore Instruction Pointer
 921+ 9DCC                              next
 921+ 9DCC DD E9       >                jp      (ix)
 922+ 9DCE
 923+ 9DCE
 924+ 9DCE              //  ______________________________________________________________________
 925+ 9DCE              //
 926+ 9DCE              // key          -- c
 927+ 9DCE              // This definition need Standard ROM Interrupt to be served
 928+ 9DCE
 929+ 9DCE                              New_Def KEY, "KEY", is_code, is_normal
 929+ 9DCE             >
 929+ 9DCE             >Dict_Ptr        defl    $
 929+ 9DCE             >
 929+ 9DCE             >//              ______________________________________________________________________
 929+ 9DCE             >//              Heap part
 929+ 9DCE             >
 929+ 9DCE             >
 929+ 9DCE             >                org     (Heap_Ptr & $1FFF) + $E000
 929+ E1E8             >
 929+ E1E8             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 929+ E1E8             >Latest_Definition defl  Heap_Ptr
 929+ E1E8             >
 929+ E1E8             >                // dummy db directives used to calculate length of namec
 929+ E1E8 4B 45 59    >                db      "KEY"
 929+ E1EB             >len_NFA         defl    $ - temp_NFA
 929+ E1EB             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 929+ E1E8             >
 929+ E1E8 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 929+ E1E9 4B 45 59    >                db      "KEY"               // name string in 7-bit ascii, but
 929+ E1EC             >                org     $-1                 // alter last byte of Name just above to set
 929+ E1EB D9          >                db      {b $} | END_BIT     // msb as name end
 929+ E1EC             >
 929+ E1EC DF 01       >                dw      Prev_Ptr            // Link to previous definition Name
 929+ E1EE             >Prev_Ptr        defl    Heap_Ptr
 929+ E1EE             >
 929+ E1EE             >mirror_Ptr      defl    $
 929+ E1EE             >
 929+ E1EE D0 9D       >                dw      Dict_Ptr + 2        // xt
 929+ E1F0             >Heap_Ptr        defl    $ - $E000           // save current HP
 929+ E1F0             >
 929+ E1F0             >Current_HP      defl  $ - $E000             // used to set HP once!
 929+ E1F0             >
 929+ E1F0             >//              ______________________________________________________________________
 929+ E1F0             >//              Dictionary part
 929+ E1F0             >
 929+ E1F0             >                org     Dict_Ptr
 929+ 9DCE             >
 929+ 9DCE EE 20       >                dw      mirror_Ptr - $E000 + $1F00
 929+ 9DD0             >
 929+ 9DD0             >KEY:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 929+ 9DD0 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 929+ 9DD0 ~           >
 929+ 9DD0 ~           >
 929+ 9DD0             >                endif           ; ok        // for other definitions it "points" the correct handler
 929+ 9DD0             >                // Use of "; ok" to suppress "warning[fwdref]"
 929+ 9DD0             >
 929+ 9DD0             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 930+ 9DD0
 931+ 9DD0 C5                           push    bc                  // Save Instruction Pointer
 932+ 9DD1
 933+ 9DD1              Key_Wait:
 934+ 9DD1 FD CB 01 6E                      bit     5, (iy + 1)         // FLAGS (5C3A+1)
 935+ 9DD5 28 FA                        jr      z, Key_Wait
 936+ 9DD7
 937+ 9DD7 3A 08 5C                     ld      a, (LASTK)          // get typed character (5C08)
 938+ 9DDA
 939+ 9DDA                              // decode character from above table
 940+ 9DDA 21 70 9D                     ld      hl, Key_Table
 941+ 9DDD 01 0B 00                     ld      bc, $000B
 942+ 9DE0 ED B1                        cpir
 943+ 9DE2 20 05                        jr      nz, Key_DontMap
 944+ 9DE4 21 7B 9D                         ld      hl, Key_MapTo
 945+ 9DE7 09                               add     hl, bc
 946+ 9DE8 7E                               ld      a, (hl)
 947+ 9DE9 FE 06        Key_DontMap:    cp      $06                 // CAPS-LOCK management
 948+ 9DEB 20 09                        jr      nz, Key_NoCapsLock
 949+ 9DED 21 6A 5C                         ld      hl, $5C6A           // FLAGS2
 950+ 9DF0 7E                               ld      a, (hl)
 951+ 9DF1 EE 08                            xor     $08
 952+ 9DF3 77                               ld      (hl), a
 953+ 9DF4 3E 00                            ld      a, NUL_CHAR
 954+ 9DF6 6F           Key_NoCapsLock: ld      l, a
 955+ 9DF7 26 00                        ld      h, 0                // Prepare TOS
 956+ 9DF9
 957+ 9DF9 FD CB 01 AE                  res     5, (iy + 1)         // FLAGS (5C3A+1)
 958+ 9DFD
 959+ 9DFD C1                           pop     bc                  // Restore Instruction Pointer
 960+ 9DFE
 961+ 9DFE                              psh1
 961+ 9DFE E5          >                push    hl
 961+ 9DFF DD E9       >                jp      (ix)
 962+ 9E01
 963+ 9E01
 964+ 9E01              //  ______________________________________________________________________
 965+ 9E01              //
 966+ 9E01              // click        --
 967+ 9E01              // This definition need Standard ROM Interrupt to be served
 968+ 9E01              //
 969+ 9E01              //              New_Def CLICK, "CLICK", is_code, is_normal
 970+ 9E01              //
 971+ 9E01              //                push    bc
 972+ 9E01              //              ld      a, ($5C48)          // BORDCR system variable
 973+ 9E01              //              rra
 974+ 9E01              //              rra
 975+ 9E01              //              rra
 976+ 9E01              //              or      $18                 // quick'n'dirty click
 977+ 9E01              //              out     ($fe), a
 978+ 9E01              //              ld      b, 0
 979+ 9E01              //              djnz    $                   // wait loop
 980+ 9E01              //              xor     $18
 981+ 9E01              //              out     ($fe), a
 982+ 9E01              //                pop     bc
 983+ 9E01
 984+ 9E01              //              next
 985+ 9E01
 986+ 9E01              //  ______________________________________________________________________
 987+ 9E01              //
 988+ 9E01              // key?         -- f
 989+ 9E01              // key available
 990+ 9E01              //
 991+ 9E01              //              New_Def KEY_Q, "KEY?", is_code, is_normal
 992+ 9E01              //
 993+ 9E01              //              ld      hl, 0000
 994+ 9E01              //              bit     5, (iy + 1)         // FLAGS (5C3A+1)
 995+ 9E01              //              jr      z, Key_Q
 996+ 9E01              //                  dec     hl
 997+ 9E01              // Key_Q:
 998+ 9E01              //                psh1
 999+ 9E01              //              next
1000+ 9E01
1001+ 9E01              //  ______________________________________________________________________
1002+ 9E01              //
1003+ 9E01              // ?terminal    -- FALSE | TRUE
1004+ 9E01              // test for BREAK keypress
1005+ 9E01                              New_Def QTERMINAL, "?TERMINAL", is_code, is_normal
1005+ 9E01             >
1005+ 9E01             >Dict_Ptr        defl    $
1005+ 9E01             >
1005+ 9E01             >//              ______________________________________________________________________
1005+ 9E01             >//              Heap part
1005+ 9E01             >
1005+ 9E01             >
1005+ 9E01             >                org     (Heap_Ptr & $1FFF) + $E000
1005+ E1F0             >
1005+ E1F0             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1005+ E1F0             >Latest_Definition defl  Heap_Ptr
1005+ E1F0             >
1005+ E1F0             >                // dummy db directives used to calculate length of namec
1005+ E1F0 3F 54 45 52 >                db      "?TERMINAL"
1005+ E1F4 4D 49 4E 41 >
1005+ E1F8 4C          >
1005+ E1F9             >len_NFA         defl    $ - temp_NFA
1005+ E1F9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1005+ E1F0             >
1005+ E1F0 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1005+ E1F1 3F 54 45 52 >                db      "?TERMINAL"               // name string in 7-bit ascii, but
1005+ E1F5 4D 49 4E 41 >
1005+ E1F9 4C          >
1005+ E1FA             >                org     $-1                 // alter last byte of Name just above to set
1005+ E1F9 CC          >                db      {b $} | END_BIT     // msb as name end
1005+ E1FA             >
1005+ E1FA E8 01       >                dw      Prev_Ptr            // Link to previous definition Name
1005+ E1FC             >Prev_Ptr        defl    Heap_Ptr
1005+ E1FC             >
1005+ E1FC             >mirror_Ptr      defl    $
1005+ E1FC             >
1005+ E1FC 03 9E       >                dw      Dict_Ptr + 2        // xt
1005+ E1FE             >Heap_Ptr        defl    $ - $E000           // save current HP
1005+ E1FE             >
1005+ E1FE             >Current_HP      defl  $ - $E000             // used to set HP once!
1005+ E1FE             >
1005+ E1FE             >//              ______________________________________________________________________
1005+ E1FE             >//              Dictionary part
1005+ E1FE             >
1005+ E1FE             >                org     Dict_Ptr
1005+ 9E01             >
1005+ 9E01 FC 20       >                dw      mirror_Ptr - $E000 + $1F00
1005+ 9E03             >
1005+ 9E03             >QTERMINAL:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1005+ 9E03 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1005+ 9E03 ~           >
1005+ 9E03 ~           >
1005+ 9E03             >                endif           ; ok        // for other definitions it "points" the correct handler
1005+ 9E03             >                // Use of "; ok" to suppress "warning[fwdref]"
1005+ 9E03             >
1005+ 9E03             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1006+ 9E03 D9                           exx
1007+ 9E04 01 FE 7F                     ld      bc, $7ffe
1008+ 9E07 ED 50                        in      d, (c)
1009+ 9E09 41                           ld      b, c
1010+ 9E0A ED 78                        in      a, (c)
1011+ 9E0C B2                           or       d
1012+ 9E0D 1F                           rra
1013+ 9E0E 3F                           ccf
1014+ 9E0F ED 62                        sbc     hl, hl
1015+ 9E11 E5                           push    hl
1016+ 9E12 D9                           exx
1017+ 9E13                              next
1017+ 9E13 DD E9       >                jp      (ix)
1018+ 9E15
1019+ 9E15
1020+ 9E15              //  ______________________________________________________________________
1021+ 9E15              //
1022+ 9E15              // inkey        -- c | 0
1023+ 9E15              // call ROM inkey$ routine, returns c or "zero".
1024+ 9E15              //
1025+ 9E15              //              New_Def INKEY, "INKEY", is_code, is_normal
1026+ 9E15              //              push    bc
1027+ 9E15              //              push    de
1028+ 9E15              //              ld      (SP_Saved), sp
1029+ 9E15              //              ld      sp, Cold_origin - 5
1030+ 9E15              //              push    ix
1031+ 9E15              //              call    $15E6                   // instead of 15E9
1032+ 9E15              //              pop     ix
1033+ 9E15              //              ld      sp, (SP_Saved)
1034+ 9E15              //              ld      l, a
1035+ 9E15              //              ld      h, 0
1036+ 9E15              //              pop     de
1037+ 9E15              //              pop     bc
1038+ 9E15              //              psh1
1039+ 9E15
1040+ 9E15              //  ______________________________________________________________________
1041+ 9E15              //
1042+ 9E15              // select      n --
1043+ 9E15              // selects the given channel number
1044+ 9E15
1045+ 9E15                              New_Def SELECT, "SELECT", is_code, is_normal
1045+ 9E15             >
1045+ 9E15             >Dict_Ptr        defl    $
1045+ 9E15             >
1045+ 9E15             >//              ______________________________________________________________________
1045+ 9E15             >//              Heap part
1045+ 9E15             >
1045+ 9E15             >
1045+ 9E15             >                org     (Heap_Ptr & $1FFF) + $E000
1045+ E1FE             >
1045+ E1FE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1045+ E1FE             >Latest_Definition defl  Heap_Ptr
1045+ E1FE             >
1045+ E1FE             >                // dummy db directives used to calculate length of namec
1045+ E1FE 53 45 4C 45 >                db      "SELECT"
1045+ E202 43 54       >
1045+ E204             >len_NFA         defl    $ - temp_NFA
1045+ E204             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1045+ E1FE             >
1045+ E1FE 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1045+ E1FF 53 45 4C 45 >                db      "SELECT"               // name string in 7-bit ascii, but
1045+ E203 43 54       >
1045+ E205             >                org     $-1                 // alter last byte of Name just above to set
1045+ E204 D4          >                db      {b $} | END_BIT     // msb as name end
1045+ E205             >
1045+ E205 F0 01       >                dw      Prev_Ptr            // Link to previous definition Name
1045+ E207             >Prev_Ptr        defl    Heap_Ptr
1045+ E207             >
1045+ E207             >mirror_Ptr      defl    $
1045+ E207             >
1045+ E207 17 9E       >                dw      Dict_Ptr + 2        // xt
1045+ E209             >Heap_Ptr        defl    $ - $E000           // save current HP
1045+ E209             >
1045+ E209             >Current_HP      defl  $ - $E000             // used to set HP once!
1045+ E209             >
1045+ E209             >//              ______________________________________________________________________
1045+ E209             >//              Dictionary part
1045+ E209             >
1045+ E209             >                org     Dict_Ptr
1045+ 9E15             >
1045+ 9E15 07 21       >                dw      mirror_Ptr - $E000 + $1F00
1045+ 9E17             >
1045+ 9E17             >SELECT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1045+ 9E17 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1045+ 9E17 ~           >
1045+ 9E17 ~           >
1045+ 9E17             >                endif           ; ok        // for other definitions it "points" the correct handler
1045+ 9E17             >                // Use of "; ok" to suppress "warning[fwdref]"
1045+ 9E17             >
1045+ 9E17             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1046+ 9E17 E1                           pop     hl
1047+ 9E18 C5                           push    bc
1048+ 9E19 D5                           push    de
1049+ 9E1A 7D                           ld      a, l
1050+ 9E1B ED 73 E2 9A                  ld      (SP_Saved), sp
1051+ 9E1F 31 B1 9A                     ld      sp, Cold_origin - 5
1052+ 9E22 DD E5                        push    ix
1053+ 9E24 CD 01 16                     call    $1601
1054+ 9E27 DD E1                        pop     ix
1055+ 9E29 ED 7B E2 9A                  ld      sp, (SP_Saved)
1056+ 9E2D D1                           pop     de
1057+ 9E2E C1                           pop     bc
1058+ 9E2F                              next
1058+ 9E2F DD E9       >                jp      (ix)
1059+ 9E31
1060+ 9E31              //  ______________________________________________________________________
1061+ 9E31              //
1062+ 9E31              // ZX Spectrum Next - Low Level disk primitives.
1063+ 9E31              // this include is "here" for backward compatibility
1064+ 9E31
1065+ 9E31                              include "next-opt0.asm"
# file opened: C:\Zx\CSpect\Projects\vForth17_MMU7/source/next-opt0.asm
   1++9E31              //  ______________________________________________________________________
   2++9E31              //
   3++9E31              //  next-opt.asm
   4++9E31              //
   5++9E31              //  ZX Spectrum Next - peculiar definitions
   6++9E31              //  ______________________________________________________________________
   7++9E31
   8++9E31              //  ______________________________________________________________________
   9++9E31              //
  10++9E31              // f_seek       d u -- f
  11++9E31              // Seek to position d in file-handle u.
  12++9E31              // Return a false-flag 0 on success, True flag on error
  13++9E31                              New_Def F_SEEK, "F_SEEK", is_code, is_normal
  13++9E31             >
  13++9E31             >Dict_Ptr        defl    $
  13++9E31             >
  13++9E31             >//              ______________________________________________________________________
  13++9E31             >//              Heap part
  13++9E31             >
  13++9E31             >
  13++9E31             >                org     (Heap_Ptr & $1FFF) + $E000
  13++E209             >
  13++E209             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  13++E209             >Latest_Definition defl  Heap_Ptr
  13++E209             >
  13++E209             >                // dummy db directives used to calculate length of namec
  13++E209 46 5F 53 45 >                db      "F_SEEK"
  13++E20D 45 4B       >
  13++E20F             >len_NFA         defl    $ - temp_NFA
  13++E20F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  13++E209             >
  13++E209 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  13++E20A 46 5F 53 45 >                db      "F_SEEK"               // name string in 7-bit ascii, but
  13++E20E 45 4B       >
  13++E210             >                org     $-1                 // alter last byte of Name just above to set
  13++E20F CB          >                db      {b $} | END_BIT     // msb as name end
  13++E210             >
  13++E210 FE 01       >                dw      Prev_Ptr            // Link to previous definition Name
  13++E212             >Prev_Ptr        defl    Heap_Ptr
  13++E212             >
  13++E212             >mirror_Ptr      defl    $
  13++E212             >
  13++E212 33 9E       >                dw      Dict_Ptr + 2        // xt
  13++E214             >Heap_Ptr        defl    $ - $E000           // save current HP
  13++E214             >
  13++E214             >Current_HP      defl  $ - $E000             // used to set HP once!
  13++E214             >
  13++E214             >//              ______________________________________________________________________
  13++E214             >//              Dictionary part
  13++E214             >
  13++E214             >                org     Dict_Ptr
  13++9E31             >
  13++9E31 12 21       >                dw      mirror_Ptr - $E000 + $1F00
  13++9E33             >
  13++9E33             >F_SEEK:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
  13++9E33 ~           >                call    runcode ; ok        // for primitive definitions  actual code
  13++9E33 ~           >
  13++9E33 ~           >
  13++9E33             >                endif           ; ok        // for other definitions it "points" the correct handler
  13++9E33             >                // Use of "; ok" to suppress "warning[fwdref]"
  13++9E33             >
  13++9E33             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  14++9E33 D9                            exx
  15++9E34 E1                            pop     hl                  // file-handle
  16++9E35 7D                            ld      a, l
  17++9E36 C1                            pop     bc                  // bc has high-word of d
  18++9E37 D1                            pop     de
  19++9E38 D9                           exx
  20++9E39 DD E5                        push    ix
  21++9E3B D5                           push    de
  22++9E3C C5                           push    bc                  // save Instruction Pointer
  23++9E3D D9                            exx
  24++9E3E DD 21 00 00                   ld      ix, 0
  25++9E42 CF                            rst     $08
  26++9E43 9F                            db      $9F
  27++9E44              F_Seek_Exit:
  28++9E44 C1                           pop     bc                  // restore Instruction Pointer
  29++9E45 D1                           pop     de
  30++9E46 DD E1                        pop     ix
  31++9E48 ED 62                        sbc     hl, hl              // to get 0 or -1
  32++9E4A
  33++9E4A                              psh1
  33++9E4A E5          >                push    hl
  33++9E4B DD E9       >                jp      (ix)
  34++9E4D
  35++9E4D              //  ______________________________________________________________________
  36++9E4D              //
  37++9E4D              // f_close      u -- f
  38++9E4D              // Close file-handle u.
  39++9E4D              // Return 0 on success, True flag on error
  40++9E4D
  41++9E4D                              New_Def F_CLOSE, "F_CLOSE", is_code, is_normal
  41++9E4D             >
  41++9E4D             >Dict_Ptr        defl    $
  41++9E4D             >
  41++9E4D             >//              ______________________________________________________________________
  41++9E4D             >//              Heap part
  41++9E4D             >
  41++9E4D             >
  41++9E4D             >                org     (Heap_Ptr & $1FFF) + $E000
  41++E214             >
  41++E214             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  41++E214             >Latest_Definition defl  Heap_Ptr
  41++E214             >
  41++E214             >                // dummy db directives used to calculate length of namec
  41++E214 46 5F 43 4C >                db      "F_CLOSE"
  41++E218 4F 53 45    >
  41++E21B             >len_NFA         defl    $ - temp_NFA
  41++E21B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  41++E214             >
  41++E214 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  41++E215 46 5F 43 4C >                db      "F_CLOSE"               // name string in 7-bit ascii, but
  41++E219 4F 53 45    >
  41++E21C             >                org     $-1                 // alter last byte of Name just above to set
  41++E21B C5          >                db      {b $} | END_BIT     // msb as name end
  41++E21C             >
  41++E21C 09 02       >                dw      Prev_Ptr            // Link to previous definition Name
  41++E21E             >Prev_Ptr        defl    Heap_Ptr
  41++E21E             >
  41++E21E             >mirror_Ptr      defl    $
  41++E21E             >
  41++E21E 4F 9E       >                dw      Dict_Ptr + 2        // xt
  41++E220             >Heap_Ptr        defl    $ - $E000           // save current HP
  41++E220             >
  41++E220             >Current_HP      defl  $ - $E000             // used to set HP once!
  41++E220             >
  41++E220             >//              ______________________________________________________________________
  41++E220             >//              Dictionary part
  41++E220             >
  41++E220             >                org     Dict_Ptr
  41++9E4D             >
  41++9E4D 1E 21       >                dw      mirror_Ptr - $E000 + $1F00
  41++9E4F             >
  41++9E4F             >F_CLOSE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
  41++9E4F ~           >                call    runcode ; ok        // for primitive definitions  actual code
  41++9E4F ~           >
  41++9E4F ~           >
  41++9E4F             >                endif           ; ok        // for other definitions it "points" the correct handler
  41++9E4F             >                // Use of "; ok" to suppress "warning[fwdref]"
  41++9E4F             >
  41++9E4F             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  42++9E4F
  43++9E4F E1                           pop     hl
  44++9E50 7D                           ld      a, l                // file-handle
  45++9E51 DD E5                        push    ix
  46++9E53 D5                           push    de
  47++9E54 C5                           push    bc                  // Save Instruction pointer
  48++9E55 CF                           rst     $08
  49++9E56 9B                           db      $9B
  50++9E57 18 EB                        jr      F_Seek_Exit
  51++9E59              //              pop     de
  52++9E59              //              pop     bc
  53++9E59              //              pop     ix
  54++9E59              //              sbc     hl, hl
  55++9E59              //              psh1
  56++9E59
  57++9E59              //  ______________________________________________________________________
  58++9E59              //
  59++9E59              // f_sync      u -- f
  60++9E59              // Close file-handle u.
  61++9E59              // Return 0 on success, True flag on error
  62++9E59
  63++9E59                              New_Def F_SYNC, "F_SYNC", is_code, is_normal
  63++9E59             >
  63++9E59             >Dict_Ptr        defl    $
  63++9E59             >
  63++9E59             >//              ______________________________________________________________________
  63++9E59             >//              Heap part
  63++9E59             >
  63++9E59             >
  63++9E59             >                org     (Heap_Ptr & $1FFF) + $E000
  63++E220             >
  63++E220             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  63++E220             >Latest_Definition defl  Heap_Ptr
  63++E220             >
  63++E220             >                // dummy db directives used to calculate length of namec
  63++E220 46 5F 53 59 >                db      "F_SYNC"
  63++E224 4E 43       >
  63++E226             >len_NFA         defl    $ - temp_NFA
  63++E226             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  63++E220             >
  63++E220 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  63++E221 46 5F 53 59 >                db      "F_SYNC"               // name string in 7-bit ascii, but
  63++E225 4E 43       >
  63++E227             >                org     $-1                 // alter last byte of Name just above to set
  63++E226 C3          >                db      {b $} | END_BIT     // msb as name end
  63++E227             >
  63++E227 14 02       >                dw      Prev_Ptr            // Link to previous definition Name
  63++E229             >Prev_Ptr        defl    Heap_Ptr
  63++E229             >
  63++E229             >mirror_Ptr      defl    $
  63++E229             >
  63++E229 5B 9E       >                dw      Dict_Ptr + 2        // xt
  63++E22B             >Heap_Ptr        defl    $ - $E000           // save current HP
  63++E22B             >
  63++E22B             >Current_HP      defl  $ - $E000             // used to set HP once!
  63++E22B             >
  63++E22B             >//              ______________________________________________________________________
  63++E22B             >//              Dictionary part
  63++E22B             >
  63++E22B             >                org     Dict_Ptr
  63++9E59             >
  63++9E59 29 21       >                dw      mirror_Ptr - $E000 + $1F00
  63++9E5B             >
  63++9E5B             >F_SYNC:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
  63++9E5B ~           >                call    runcode ; ok        // for primitive definitions  actual code
  63++9E5B ~           >
  63++9E5B ~           >
  63++9E5B             >                endif           ; ok        // for other definitions it "points" the correct handler
  63++9E5B             >                // Use of "; ok" to suppress "warning[fwdref]"
  63++9E5B             >
  63++9E5B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  64++9E5B E1                           pop     hl
  65++9E5C 7D                           ld      a, l                // file-handle
  66++9E5D DD E5                        push    ix
  67++9E5F D5                           push    de
  68++9E60 C5                           push    bc
  69++9E61 CF                           rst     $08
  70++9E62 9C                           db      $9C
  71++9E63 18 DF                        jr      F_Seek_Exit
  72++9E65              //              pop     de
  73++9E65              //              pop     bc
  74++9E65              //              pop     ix
  75++9E65              //              sbc     hl, hl
  76++9E65              //              psh1
  77++9E65
  78++9E65              //  ______________________________________________________________________
  79++9E65              //
  80++9E65              // f_fgetpos    u -- d f
  81++9E65              // Seek to position d in file-handle u.
  82++9E65              // Return a false-flag 0 on success, True flag on error
  83++9E65                              New_Def F_FGETPOS, "F_FGETPOS", is_code, is_normal
  83++9E65             >
  83++9E65             >Dict_Ptr        defl    $
  83++9E65             >
  83++9E65             >//              ______________________________________________________________________
  83++9E65             >//              Heap part
  83++9E65             >
  83++9E65             >
  83++9E65             >                org     (Heap_Ptr & $1FFF) + $E000
  83++E22B             >
  83++E22B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  83++E22B             >Latest_Definition defl  Heap_Ptr
  83++E22B             >
  83++E22B             >                // dummy db directives used to calculate length of namec
  83++E22B 46 5F 46 47 >                db      "F_FGETPOS"
  83++E22F 45 54 50 4F >
  83++E233 53          >
  83++E234             >len_NFA         defl    $ - temp_NFA
  83++E234             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  83++E22B             >
  83++E22B 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  83++E22C 46 5F 46 47 >                db      "F_FGETPOS"               // name string in 7-bit ascii, but
  83++E230 45 54 50 4F >
  83++E234 53          >
  83++E235             >                org     $-1                 // alter last byte of Name just above to set
  83++E234 D3          >                db      {b $} | END_BIT     // msb as name end
  83++E235             >
  83++E235 20 02       >                dw      Prev_Ptr            // Link to previous definition Name
  83++E237             >Prev_Ptr        defl    Heap_Ptr
  83++E237             >
  83++E237             >mirror_Ptr      defl    $
  83++E237             >
  83++E237 67 9E       >                dw      Dict_Ptr + 2        // xt
  83++E239             >Heap_Ptr        defl    $ - $E000           // save current HP
  83++E239             >
  83++E239             >Current_HP      defl  $ - $E000             // used to set HP once!
  83++E239             >
  83++E239             >//              ______________________________________________________________________
  83++E239             >//              Dictionary part
  83++E239             >
  83++E239             >                org     Dict_Ptr
  83++9E65             >
  83++9E65 37 21       >                dw      mirror_Ptr - $E000 + $1F00
  83++9E67             >
  83++9E67             >F_FGETPOS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
  83++9E67 ~           >                call    runcode ; ok        // for primitive definitions  actual code
  83++9E67 ~           >
  83++9E67 ~           >
  83++9E67             >                endif           ; ok        // for other definitions it "points" the correct handler
  83++9E67             >                // Use of "; ok" to suppress "warning[fwdref]"
  83++9E67             >
  83++9E67             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  84++9E67 E1                            pop     hl
  85++9E68 7D                            ld      a, l                // file-handle
  86++9E69 DD E5                         push    ix
  87++9E6B D5                            push    de
  88++9E6C C5                            push    bc
  89++9E6D CF                            rst     $08
  90++9E6E A0                            db      $A0
  91++9E6F D9                           exx
  92++9E70 C1                           pop     bc                  // IP
  93++9E71 D1                           pop     de                  // Return Stack Pointer
  94++9E72 DD E1                        pop     ix
  95++9E74 D9                            exx
  96++9E75 D5                            push    de
  97++9E76 C5                            push    bc
  98++9E77 ED 62                         sbc     hl, hl
  99++9E79 E5                            push    hl
 100++9E7A D9                           exx
 101++9E7B                              next
 101++9E7B DD E9       >                jp      (ix)
 102++9E7D
 103++9E7D              //  ______________________________________________________________________
 104++9E7D              //
 105++9E7D              // f_read       a b u -- n f
 106++9E7D              // Read b bytes from file-handle u to address a
 107++9E7D              // Return the actual number n of bytes read
 108++9E7D              // Return 0 on success, True flag on error
 109++9E7D                              New_Def F_READ, "F_READ", is_code, is_normal
 109++9E7D             >
 109++9E7D             >Dict_Ptr        defl    $
 109++9E7D             >
 109++9E7D             >//              ______________________________________________________________________
 109++9E7D             >//              Heap part
 109++9E7D             >
 109++9E7D             >
 109++9E7D             >                org     (Heap_Ptr & $1FFF) + $E000
 109++E239             >
 109++E239             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 109++E239             >Latest_Definition defl  Heap_Ptr
 109++E239             >
 109++E239             >                // dummy db directives used to calculate length of namec
 109++E239 46 5F 52 45 >                db      "F_READ"
 109++E23D 41 44       >
 109++E23F             >len_NFA         defl    $ - temp_NFA
 109++E23F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 109++E239             >
 109++E239 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 109++E23A 46 5F 52 45 >                db      "F_READ"               // name string in 7-bit ascii, but
 109++E23E 41 44       >
 109++E240             >                org     $-1                 // alter last byte of Name just above to set
 109++E23F C4          >                db      {b $} | END_BIT     // msb as name end
 109++E240             >
 109++E240 2B 02       >                dw      Prev_Ptr            // Link to previous definition Name
 109++E242             >Prev_Ptr        defl    Heap_Ptr
 109++E242             >
 109++E242             >mirror_Ptr      defl    $
 109++E242             >
 109++E242 7F 9E       >                dw      Dict_Ptr + 2        // xt
 109++E244             >Heap_Ptr        defl    $ - $E000           // save current HP
 109++E244             >
 109++E244             >Current_HP      defl  $ - $E000             // used to set HP once!
 109++E244             >
 109++E244             >//              ______________________________________________________________________
 109++E244             >//              Dictionary part
 109++E244             >
 109++E244             >                org     Dict_Ptr
 109++9E7D             >
 109++9E7D 42 21       >                dw      mirror_Ptr - $E000 + $1F00
 109++9E7F             >
 109++9E7F             >F_READ:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 109++9E7F ~           >                call    runcode ; ok        // for primitive definitions  actual code
 109++9E7F ~           >
 109++9E7F ~           >
 109++9E7F             >                endif           ; ok        // for other definitions it "points" the correct handler
 109++9E7F             >                // Use of "; ok" to suppress "warning[fwdref]"
 109++9E7F             >
 109++9E7F             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 110++9E7F D9                            exx
 111++9E80 E1                            pop     hl
 112++9E81 7D                            ld      a, l                // file-handle
 113++9E82 C1                            pop     bc                  // bc has bytes to read
 114++9E83 DD E3                         ex      (sp), ix            // ix has address
 115++9E85 D9                           exx
 116++9E86 D5                           push    de                  // Save Return Stack pointer
 117++9E87 C5                           push    bc                  // Save Instruction pointer
 118++9E88 D9                            exx
 119++9E89 CF                            rst     $08
 120++9E8A 9D                            db      $9D
 121++9E8B              F_Read_Exit:
 122++9E8B D9                           exx
 123++9E8C C1                           pop     bc                  // Restore Instruction pointer
 124++9E8D D1                           pop     de                  // Restore Return Stack pointer
 125++9E8E DD E1                        pop     ix                  // Restore ix
 126++9E90 D9                            exx
 127++9E91 D5                            push    de                  // bytes involved in i/o operation
 128++9E92 ED 62                         sbc     hl, hl
 129++9E94 E5                            push    hl
 130++9E95 D9                           exx
 131++9E96                              next
 131++9E96 DD E9       >                jp      (ix)
 132++9E98
 133++9E98              //  ______________________________________________________________________
 134++9E98              //
 135++9E98              // f_write      a b u -- n f
 136++9E98              // Write bytes currently stored at address a to file-handle u.
 137++9E98              // Return the actual n bytes written and 0 on success, True flag on error.
 138++9E98                              New_Def F_WRITE, "F_WRITE", is_code, is_normal
 138++9E98             >
 138++9E98             >Dict_Ptr        defl    $
 138++9E98             >
 138++9E98             >//              ______________________________________________________________________
 138++9E98             >//              Heap part
 138++9E98             >
 138++9E98             >
 138++9E98             >                org     (Heap_Ptr & $1FFF) + $E000
 138++E244             >
 138++E244             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 138++E244             >Latest_Definition defl  Heap_Ptr
 138++E244             >
 138++E244             >                // dummy db directives used to calculate length of namec
 138++E244 46 5F 57 52 >                db      "F_WRITE"
 138++E248 49 54 45    >
 138++E24B             >len_NFA         defl    $ - temp_NFA
 138++E24B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 138++E244             >
 138++E244 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 138++E245 46 5F 57 52 >                db      "F_WRITE"               // name string in 7-bit ascii, but
 138++E249 49 54 45    >
 138++E24C             >                org     $-1                 // alter last byte of Name just above to set
 138++E24B C5          >                db      {b $} | END_BIT     // msb as name end
 138++E24C             >
 138++E24C 39 02       >                dw      Prev_Ptr            // Link to previous definition Name
 138++E24E             >Prev_Ptr        defl    Heap_Ptr
 138++E24E             >
 138++E24E             >mirror_Ptr      defl    $
 138++E24E             >
 138++E24E 9A 9E       >                dw      Dict_Ptr + 2        // xt
 138++E250             >Heap_Ptr        defl    $ - $E000           // save current HP
 138++E250             >
 138++E250             >Current_HP      defl  $ - $E000             // used to set HP once!
 138++E250             >
 138++E250             >//              ______________________________________________________________________
 138++E250             >//              Dictionary part
 138++E250             >
 138++E250             >                org     Dict_Ptr
 138++9E98             >
 138++9E98 4E 21       >                dw      mirror_Ptr - $E000 + $1F00
 138++9E9A             >
 138++9E9A             >F_WRITE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 138++9E9A ~           >                call    runcode ; ok        // for primitive definitions  actual code
 138++9E9A ~           >
 138++9E9A ~           >
 138++9E9A             >                endif           ; ok        // for other definitions it "points" the correct handler
 138++9E9A             >                // Use of "; ok" to suppress "warning[fwdref]"
 138++9E9A             >
 138++9E9A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 139++9E9A D9                            exx
 140++9E9B E1                            pop     hl
 141++9E9C 7D                            ld      a, l                // file-handle
 142++9E9D C1                            pop     bc                  // bc has bytes to read
 143++9E9E DD E3                         ex      (sp), ix            // ix has address
 144++9EA0 D9                           exx
 145++9EA1 D5                           push    de                  // Save Return Stack pointer
 146++9EA2 C5                           push    bc                  // Save Instruction pointer
 147++9EA3 D9                            exx
 148++9EA4 CF                            rst     $08
 149++9EA5 9E                            db      $9E
 150++9EA6 18 E3                         jr F_Read_Exit
 151++9EA8              //                exx
 152++9EA8              //                pop     de                  // Restore Return Stack pointer
 153++9EA8              //                pop     bc                  // Restore Instruction pointer
 154++9EA8              //                pop     ix                  // Restore ix
 155++9EA8              //                 exx
 156++9EA8              //                 push    de                  // bytes involved in i/o operation
 157++9EA8              //                 sbc     hl, hl
 158++9EA8              //                 push    hl
 159++9EA8              //                exx
 160++9EA8              //                next
 161++9EA8
 162++9EA8              //  ______________________________________________________________________
 163++9EA8              //
 164++9EA8              // f_open       a1 a2 b -- u f
 165++9EA8              // open a file
 166++9EA8              // a1 (filespec) is a null-terminated string, such as produced by ," definition
 167++9EA8              // a2 is address to an 8-byte header data used in some cases.
 168++9EA8              // b is access mode-byte, that is a combination of:
 169++9EA8              // any/all of:
 170++9EA8              //   esx_mode_read          $01 request read access
 171++9EA8              //   esx_mode_write         $02 request write access
 172++9EA8              //   esx_mode_use_header    $40 read/write +3DOS header
 173++9EA8              // plus one of:
 174++9EA8              //   esx_mode_open_exist    $00 only open existing file
 175++9EA8              //   esx_mode_open_creat    $08 open existing or create file
 176++9EA8              //   esx_mode_creat_noexist $04 create new file, error if exists
 177++9EA8              //   esx_mode_creat_trunc   $0c create new file, delete existing
 178++9EA8              // Return file-handle u and 0 on success, True flag on error
 179++9EA8                              New_Def F_OPEN, "F_OPEN", is_code, is_normal
 179++9EA8             >
 179++9EA8             >Dict_Ptr        defl    $
 179++9EA8             >
 179++9EA8             >//              ______________________________________________________________________
 179++9EA8             >//              Heap part
 179++9EA8             >
 179++9EA8             >
 179++9EA8             >                org     (Heap_Ptr & $1FFF) + $E000
 179++E250             >
 179++E250             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 179++E250             >Latest_Definition defl  Heap_Ptr
 179++E250             >
 179++E250             >                // dummy db directives used to calculate length of namec
 179++E250 46 5F 4F 50 >                db      "F_OPEN"
 179++E254 45 4E       >
 179++E256             >len_NFA         defl    $ - temp_NFA
 179++E256             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 179++E250             >
 179++E250 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 179++E251 46 5F 4F 50 >                db      "F_OPEN"               // name string in 7-bit ascii, but
 179++E255 45 4E       >
 179++E257             >                org     $-1                 // alter last byte of Name just above to set
 179++E256 CE          >                db      {b $} | END_BIT     // msb as name end
 179++E257             >
 179++E257 44 02       >                dw      Prev_Ptr            // Link to previous definition Name
 179++E259             >Prev_Ptr        defl    Heap_Ptr
 179++E259             >
 179++E259             >mirror_Ptr      defl    $
 179++E259             >
 179++E259 AA 9E       >                dw      Dict_Ptr + 2        // xt
 179++E25B             >Heap_Ptr        defl    $ - $E000           // save current HP
 179++E25B             >
 179++E25B             >Current_HP      defl  $ - $E000             // used to set HP once!
 179++E25B             >
 179++E25B             >//              ______________________________________________________________________
 179++E25B             >//              Dictionary part
 179++E25B             >
 179++E25B             >                org     Dict_Ptr
 179++9EA8             >
 179++9EA8 59 21       >                dw      mirror_Ptr - $E000 + $1F00
 179++9EAA             >
 179++9EAA             >F_OPEN:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 179++9EAA ~           >                call    runcode ; ok        // for primitive definitions  actual code
 179++9EAA ~           >
 179++9EAA ~           >
 179++9EAA             >                endif           ; ok        // for other definitions it "points" the correct handler
 179++9EAA             >                // Use of "; ok" to suppress "warning[fwdref]"
 179++9EAA             >
 179++9EAA             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 180++9EAA D9                            exx
 181++9EAB C1                            pop     bc                  // file-mode
 182++9EAC 41                            ld      b, c                // file-mode
 183++9EAD D1                            pop     de                  // 8-bytes buffer if any
 184++9EAE DD E3                         ex      (sp), ix            // filespec nul-terminated
 185++9EB0 D9                           exx
 186++9EB1 D5                           push    de                  // Save Return Stack pointer
 187++9EB2 C5                           push    bc                  // Save Instruction pointer
 188++9EB3 D9                            exx
 189++9EB4 3E 2A                         ld      a, "*"
 190++9EB6 CF                            rst     $08
 191++9EB7 9A                            db      $9A
 192++9EB8              F_Open_Exit:
 193++9EB8 5F                            ld      e, a                // return the handle-number
 194++9EB9 16 00                         ld      d, 0
 195++9EBB 18 CE                        jr F_Read_Exit
 196++9EBD
 197++9EBD              //   \ CREATE FILENAME ," test.txt"   \ new Counted String
 198++9EBD              //   \ FILENAME 1+ PAD 1 F_OPEN
 199++9EBD              //   \ DROP
 200++9EBD              //   \ F_CLOSE
 201++9EBD
 202++9EBD
 203++9EBD              //  ______________________________________________________________________
 204++9EBD              //
 205++9EBD              // f_opendir    a1 -- u f
 206++9EBD              // open a file
 207++9EBD                              New_Def F_OPENDIR, "F_OPENDIR", is_code, is_normal
 207++9EBD             >
 207++9EBD             >Dict_Ptr        defl    $
 207++9EBD             >
 207++9EBD             >//              ______________________________________________________________________
 207++9EBD             >//              Heap part
 207++9EBD             >
 207++9EBD             >
 207++9EBD             >                org     (Heap_Ptr & $1FFF) + $E000
 207++E25B             >
 207++E25B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 207++E25B             >Latest_Definition defl  Heap_Ptr
 207++E25B             >
 207++E25B             >                // dummy db directives used to calculate length of namec
 207++E25B 46 5F 4F 50 >                db      "F_OPENDIR"
 207++E25F 45 4E 44 49 >
 207++E263 52          >
 207++E264             >len_NFA         defl    $ - temp_NFA
 207++E264             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 207++E25B             >
 207++E25B 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 207++E25C 46 5F 4F 50 >                db      "F_OPENDIR"               // name string in 7-bit ascii, but
 207++E260 45 4E 44 49 >
 207++E264 52          >
 207++E265             >                org     $-1                 // alter last byte of Name just above to set
 207++E264 D2          >                db      {b $} | END_BIT     // msb as name end
 207++E265             >
 207++E265 50 02       >                dw      Prev_Ptr            // Link to previous definition Name
 207++E267             >Prev_Ptr        defl    Heap_Ptr
 207++E267             >
 207++E267             >mirror_Ptr      defl    $
 207++E267             >
 207++E267 BF 9E       >                dw      Dict_Ptr + 2        // xt
 207++E269             >Heap_Ptr        defl    $ - $E000           // save current HP
 207++E269             >
 207++E269             >Current_HP      defl  $ - $E000             // used to set HP once!
 207++E269             >
 207++E269             >//              ______________________________________________________________________
 207++E269             >//              Dictionary part
 207++E269             >
 207++E269             >                org     Dict_Ptr
 207++9EBD             >
 207++9EBD 67 21       >                dw      mirror_Ptr - $E000 + $1F00
 207++9EBF             >
 207++9EBF             >F_OPENDIR:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 207++9EBF ~           >                call    runcode ; ok        // for primitive definitions  actual code
 207++9EBF ~           >
 207++9EBF ~           >
 207++9EBF             >                endif           ; ok        // for other definitions it "points" the correct handler
 207++9EBF             >                // Use of "; ok" to suppress "warning[fwdref]"
 207++9EBF             >
 207++9EBF             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 208++9EBF DD E3                        ex      (sp), ix            // filespec nul-terminated
 209++9EC1 D5                           push    de                  // Save Return Stack pointer
 210++9EC2 C5                           push    bc                  // Save Instruction pointer
 211++9EC3 06 10                        ld      b, $10              // file-mode
 212++9EC5 3E 43                        ld      a, "C"
 213++9EC7 CF                           rst     $08
 214++9EC8 A3                           db      $A3
 215++9EC9 18 ED                        jr      F_Open_Exit
 216++9ECB
 217++9ECB
 218++9ECB              //  ______________________________________________________________________
 219++9ECB              //
 220++9ECB              // f_readdir    a1 a2 b -- u f
 221++9ECB              // open a file
 222++9ECB                              New_Def F_READDIR, "F_READDIR", is_code, is_normal
 222++9ECB             >
 222++9ECB             >Dict_Ptr        defl    $
 222++9ECB             >
 222++9ECB             >//              ______________________________________________________________________
 222++9ECB             >//              Heap part
 222++9ECB             >
 222++9ECB             >
 222++9ECB             >                org     (Heap_Ptr & $1FFF) + $E000
 222++E269             >
 222++E269             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 222++E269             >Latest_Definition defl  Heap_Ptr
 222++E269             >
 222++E269             >                // dummy db directives used to calculate length of namec
 222++E269 46 5F 52 45 >                db      "F_READDIR"
 222++E26D 41 44 44 49 >
 222++E271 52          >
 222++E272             >len_NFA         defl    $ - temp_NFA
 222++E272             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 222++E269             >
 222++E269 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 222++E26A 46 5F 52 45 >                db      "F_READDIR"               // name string in 7-bit ascii, but
 222++E26E 41 44 44 49 >
 222++E272 52          >
 222++E273             >                org     $-1                 // alter last byte of Name just above to set
 222++E272 D2          >                db      {b $} | END_BIT     // msb as name end
 222++E273             >
 222++E273 5B 02       >                dw      Prev_Ptr            // Link to previous definition Name
 222++E275             >Prev_Ptr        defl    Heap_Ptr
 222++E275             >
 222++E275             >mirror_Ptr      defl    $
 222++E275             >
 222++E275 CD 9E       >                dw      Dict_Ptr + 2        // xt
 222++E277             >Heap_Ptr        defl    $ - $E000           // save current HP
 222++E277             >
 222++E277             >Current_HP      defl  $ - $E000             // used to set HP once!
 222++E277             >
 222++E277             >//              ______________________________________________________________________
 222++E277             >//              Dictionary part
 222++E277             >
 222++E277             >                org     Dict_Ptr
 222++9ECB             >
 222++9ECB 75 21       >                dw      mirror_Ptr - $E000 + $1F00
 222++9ECD             >
 222++9ECD             >F_READDIR:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 222++9ECD ~           >                call    runcode ; ok        // for primitive definitions  actual code
 222++9ECD ~           >
 222++9ECD ~           >
 222++9ECD             >                endif           ; ok        // for other definitions it "points" the correct handler
 222++9ECD             >                // Use of "; ok" to suppress "warning[fwdref]"
 222++9ECD             >
 222++9ECD             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 223++9ECD D9                            exx
 224++9ECE E1                            pop     hl
 225++9ECF 7D                            ld      a, l
 226++9ED0 D1                            pop     de
 227++9ED1 DD E3                         ex      (sp), ix            // filespec nul-terminated
 228++9ED3 D9                           exx
 229++9ED4 D5                           push    de                  // Save Return Stack pointer
 230++9ED5 C5                           push    bc                  // Save Instruction pointer
 231++9ED6 D9                            exx
 232++9ED7 CF                            rst     $08
 233++9ED8 A4                            db      $A4
 234++9ED9 18 DD                         jr      F_Open_Exit
 235++9EDB
# file closed: C:\Zx\CSpect\Projects\vForth17_MMU7/source/next-opt0.asm
1066+ 9EDB
1067+ 9EDB
1068+ 9EDB              //  ______________________________________________________________________
1069+ 9EDB              //
1070+ 9EDB              // cmove    a1 a2 u --
1071+ 9EDB              // If u > 0, moves memory content starting at address a1 for n bytes long
1072+ 9EDB              // storing then starting at address addr2.
1073+ 9EDB              // The content of a1 is moved first. See CMOVE> also.
1074+ 9EDB                              New_Def CMOVE, "CMOVE", is_code, is_normal
1074+ 9EDB             >
1074+ 9EDB             >Dict_Ptr        defl    $
1074+ 9EDB             >
1074+ 9EDB             >//              ______________________________________________________________________
1074+ 9EDB             >//              Heap part
1074+ 9EDB             >
1074+ 9EDB             >
1074+ 9EDB             >                org     (Heap_Ptr & $1FFF) + $E000
1074+ E277             >
1074+ E277             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1074+ E277             >Latest_Definition defl  Heap_Ptr
1074+ E277             >
1074+ E277             >                // dummy db directives used to calculate length of namec
1074+ E277 43 4D 4F 56 >                db      "CMOVE"
1074+ E27B 45          >
1074+ E27C             >len_NFA         defl    $ - temp_NFA
1074+ E27C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1074+ E277             >
1074+ E277 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1074+ E278 43 4D 4F 56 >                db      "CMOVE"               // name string in 7-bit ascii, but
1074+ E27C 45          >
1074+ E27D             >                org     $-1                 // alter last byte of Name just above to set
1074+ E27C C5          >                db      {b $} | END_BIT     // msb as name end
1074+ E27D             >
1074+ E27D 69 02       >                dw      Prev_Ptr            // Link to previous definition Name
1074+ E27F             >Prev_Ptr        defl    Heap_Ptr
1074+ E27F             >
1074+ E27F             >mirror_Ptr      defl    $
1074+ E27F             >
1074+ E27F DD 9E       >                dw      Dict_Ptr + 2        // xt
1074+ E281             >Heap_Ptr        defl    $ - $E000           // save current HP
1074+ E281             >
1074+ E281             >Current_HP      defl  $ - $E000             // used to set HP once!
1074+ E281             >
1074+ E281             >//              ______________________________________________________________________
1074+ E281             >//              Dictionary part
1074+ E281             >
1074+ E281             >                org     Dict_Ptr
1074+ 9EDB             >
1074+ 9EDB 7F 21       >                dw      mirror_Ptr - $E000 + $1F00
1074+ 9EDD             >
1074+ 9EDD             >CMOVE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1074+ 9EDD ~           >                call    runcode ; ok        // for primitive definitions  actual code
1074+ 9EDD ~           >
1074+ 9EDD ~           >
1074+ 9EDD             >                endif           ; ok        // for other definitions it "points" the correct handler
1074+ 9EDD             >                // Use of "; ok" to suppress "warning[fwdref]"
1074+ 9EDD             >
1074+ 9EDD             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1075+ 9EDD D9                           exx
1076+ 9EDE
1077+ 9EDE C1                           pop     bc                  // bc has counter
1078+ 9EDF D1                           pop     de                  // de now has dest
1079+ 9EE0 E1                           pop     hl                 // hl has source, save Instruction Pointer
1080+ 9EE1 78                           ld      a, b
1081+ 9EE2 B1                           or      c
1082+ 9EE3 28 02                        jr      z, Cmove_NoMove
1083+ 9EE5 ED B0                            ldir
1084+ 9EE7              Cmove_NoMove:
1085+ 9EE7 D9                           exx
1086+ 9EE8
1087+ 9EE8                              next
1087+ 9EE8 DD E9       >                jp      (ix)
1088+ 9EEA
1089+ 9EEA              //  ______________________________________________________________________
1090+ 9EEA              //
1091+ 9EEA              // cmove>    a1 a2 u --
1092+ 9EEA              // If u > 0, moves memory content starting at address a1 for n bytes long
1093+ 9EEA              // storing then starting at address addr2.
1094+ 9EEA              // The content of a1 is moved last. See cmove.
1095+ 9EEA                              New_Def CMOVE_TO, "CMOVE>", is_code, is_normal
1095+ 9EEA             >
1095+ 9EEA             >Dict_Ptr        defl    $
1095+ 9EEA             >
1095+ 9EEA             >//              ______________________________________________________________________
1095+ 9EEA             >//              Heap part
1095+ 9EEA             >
1095+ 9EEA             >
1095+ 9EEA             >                org     (Heap_Ptr & $1FFF) + $E000
1095+ E281             >
1095+ E281             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1095+ E281             >Latest_Definition defl  Heap_Ptr
1095+ E281             >
1095+ E281             >                // dummy db directives used to calculate length of namec
1095+ E281 43 4D 4F 56 >                db      "CMOVE>"
1095+ E285 45 3E       >
1095+ E287             >len_NFA         defl    $ - temp_NFA
1095+ E287             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1095+ E281             >
1095+ E281 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1095+ E282 43 4D 4F 56 >                db      "CMOVE>"               // name string in 7-bit ascii, but
1095+ E286 45 3E       >
1095+ E288             >                org     $-1                 // alter last byte of Name just above to set
1095+ E287 BE          >                db      {b $} | END_BIT     // msb as name end
1095+ E288             >
1095+ E288 77 02       >                dw      Prev_Ptr            // Link to previous definition Name
1095+ E28A             >Prev_Ptr        defl    Heap_Ptr
1095+ E28A             >
1095+ E28A             >mirror_Ptr      defl    $
1095+ E28A             >
1095+ E28A EC 9E       >                dw      Dict_Ptr + 2        // xt
1095+ E28C             >Heap_Ptr        defl    $ - $E000           // save current HP
1095+ E28C             >
1095+ E28C             >Current_HP      defl  $ - $E000             // used to set HP once!
1095+ E28C             >
1095+ E28C             >//              ______________________________________________________________________
1095+ E28C             >//              Dictionary part
1095+ E28C             >
1095+ E28C             >                org     Dict_Ptr
1095+ 9EEA             >
1095+ 9EEA 8A 21       >                dw      mirror_Ptr - $E000 + $1F00
1095+ 9EEC             >
1095+ 9EEC             >CMOVE_TO:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1095+ 9EEC ~           >                call    runcode ; ok        // for primitive definitions  actual code
1095+ 9EEC ~           >
1095+ 9EEC ~           >
1095+ 9EEC             >                endif           ; ok        // for other definitions it "points" the correct handler
1095+ 9EEC             >                // Use of "; ok" to suppress "warning[fwdref]"
1095+ 9EEC             >
1095+ 9EEC             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1096+ 9EEC D9                           exx
1097+ 9EED
1098+ 9EED C1                           pop     bc                  // bc has counter
1099+ 9EEE D1                           pop     de                  // de has dest
1100+ 9EEF E1                           pop     hl                  // hl has source, save Instruction Pointer
1101+ 9EF0 78                           ld      a, b
1102+ 9EF1 B1                           or      c
1103+ 9EF2 28 08                        jr      z, CmoveV_NoMove
1104+ 9EF4 EB                               ex      de, hl              // compute address to
1105+ 9EF5 09                               add     hl, bc              // operate backward
1106+ 9EF6 2B                               dec     hl
1107+ 9EF7 EB                               ex      de, hl
1108+ 9EF8 09                               add     hl, bc
1109+ 9EF9 2B                               dec     hl
1110+ 9EFA ED B8                            lddr                        // backward
1111+ 9EFC              CmoveV_NoMove:
1112+ 9EFC D9                           exx
1113+ 9EFD
1114+ 9EFD                              next
1114+ 9EFD DD E9       >                jp      (ix)
1115+ 9EFF
1116+ 9EFF              //  ______________________________________________________________________
1117+ 9EFF              //
1118+ 9EFF              // um*      u1 u2 -- ud
1119+ 9EFF              // Unsigned multiplication
1120+ 9EFF              // A double-integer is kept in CPU registers as DEHL then pushed on stack.
1121+ 9EFF              // On the stack a double number is treated as two single numbers
1122+ 9EFF              // where DE is on the top of the stack and HL is the second from top,
1123+ 9EFF              // Instead, in 2VARIABLE a double number is stored as EDLH.
1124+ 9EFF              // this definition could use "MUL" Z80N new op-code.
1125+ 9EFF                              New_Def UM_MUL, "UM*", is_code, is_normal
1125+ 9EFF             >
1125+ 9EFF             >Dict_Ptr        defl    $
1125+ 9EFF             >
1125+ 9EFF             >//              ______________________________________________________________________
1125+ 9EFF             >//              Heap part
1125+ 9EFF             >
1125+ 9EFF             >
1125+ 9EFF             >                org     (Heap_Ptr & $1FFF) + $E000
1125+ E28C             >
1125+ E28C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1125+ E28C             >Latest_Definition defl  Heap_Ptr
1125+ E28C             >
1125+ E28C             >                // dummy db directives used to calculate length of namec
1125+ E28C 55 4D 2A    >                db      "UM*"
1125+ E28F             >len_NFA         defl    $ - temp_NFA
1125+ E28F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1125+ E28C             >
1125+ E28C 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1125+ E28D 55 4D 2A    >                db      "UM*"               // name string in 7-bit ascii, but
1125+ E290             >                org     $-1                 // alter last byte of Name just above to set
1125+ E28F AA          >                db      {b $} | END_BIT     // msb as name end
1125+ E290             >
1125+ E290 81 02       >                dw      Prev_Ptr            // Link to previous definition Name
1125+ E292             >Prev_Ptr        defl    Heap_Ptr
1125+ E292             >
1125+ E292             >mirror_Ptr      defl    $
1125+ E292             >
1125+ E292 01 9F       >                dw      Dict_Ptr + 2        // xt
1125+ E294             >Heap_Ptr        defl    $ - $E000           // save current HP
1125+ E294             >
1125+ E294             >Current_HP      defl  $ - $E000             // used to set HP once!
1125+ E294             >
1125+ E294             >//              ______________________________________________________________________
1125+ E294             >//              Dictionary part
1125+ E294             >
1125+ E294             >                org     Dict_Ptr
1125+ 9EFF             >
1125+ 9EFF 92 21       >                dw      mirror_Ptr - $E000 + $1F00
1125+ 9F01             >
1125+ 9F01             >UM_MUL:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1125+ 9F01 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1125+ 9F01 ~           >
1125+ 9F01 ~           >
1125+ 9F01             >                endif           ; ok        // for other definitions it "points" the correct handler
1125+ 9F01             >                // Use of "; ok" to suppress "warning[fwdref]"
1125+ 9F01             >
1125+ 9F01             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1126+ 9F01 D9                           exx
1127+ 9F02 D1                           pop     de                    // de has u2 operand
1128+ 9F03 E1                           pop     hl                    // hl has u1 operand
1129+ 9F04 45                           ld      b, l
1130+ 9F05 4B                           ld      c, e
1131+ 9F06 5D                           ld      e, l
1132+ 9F07 6A                           ld      l, d
1133+ 9F08 E5                           push    hl
1134+ 9F09 69                           ld      l, c
1135+ 9F0A ED 30                        mul
1136+ 9F0C EB                           ex      de, hl
1137+ 9F0D ED 30                        mul
1138+ 9F0F AF                           xor     a
1139+ 9F10 19                           add     hl, de
1140+ 9F11 8F                           adc     a
1141+ 9F12 59                           ld      e, c
1142+ 9F13 50                           ld      d, b
1143+ 9F14 ED 30                        mul
1144+ 9F16 47                           ld      b, a
1145+ 9F17 4C                           ld      c, h
1146+ 9F18 7A                           ld      a, d
1147+ 9F19 85                           add     l
1148+ 9F1A 67                           ld      h, a
1149+ 9F1B 6B                           ld      l, e
1150+ 9F1C D1                           pop     de
1151+ 9F1D ED 30                        mul
1152+ 9F1F EB                           ex      de, hl
1153+ 9F20 ED 4A                        adc     hl, bc
1154+ 9F22 D5                           push    de
1155+ 9F23 E5                           push    hl
1156+ 9F24 D9                           exx
1157+ 9F25                              next
1157+ 9F25 DD E9       >                jp      (ix)
1158+ 9F27
1159+ 9F27              //  ______________________________________________________________________
1160+ 9F27              //
1161+ 9F27              // um/mod      ud u1 -- q r
1162+ 9F27              // divides ud into u1 giving quotient q and remainder r
1163+ 9F27              // algorithm takes 16 bit at a time starting from msb
1164+ 9F27              // DE grows from lsb upward with quotient result
1165+ 9F27              // HL keeps the remainder at each stage of division
1166+ 9F27              // each loop 'lowers' the next binary digit to form the current dividend
1167+ 9F27                              New_Def UMDIVMOD, "UM/MOD", is_code, is_normal
1167+ 9F27             >
1167+ 9F27             >Dict_Ptr        defl    $
1167+ 9F27             >
1167+ 9F27             >//              ______________________________________________________________________
1167+ 9F27             >//              Heap part
1167+ 9F27             >
1167+ 9F27             >
1167+ 9F27             >                org     (Heap_Ptr & $1FFF) + $E000
1167+ E294             >
1167+ E294             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1167+ E294             >Latest_Definition defl  Heap_Ptr
1167+ E294             >
1167+ E294             >                // dummy db directives used to calculate length of namec
1167+ E294 55 4D 2F 4D >                db      "UM/MOD"
1167+ E298 4F 44       >
1167+ E29A             >len_NFA         defl    $ - temp_NFA
1167+ E29A             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1167+ E294             >
1167+ E294 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1167+ E295 55 4D 2F 4D >                db      "UM/MOD"               // name string in 7-bit ascii, but
1167+ E299 4F 44       >
1167+ E29B             >                org     $-1                 // alter last byte of Name just above to set
1167+ E29A C4          >                db      {b $} | END_BIT     // msb as name end
1167+ E29B             >
1167+ E29B 8C 02       >                dw      Prev_Ptr            // Link to previous definition Name
1167+ E29D             >Prev_Ptr        defl    Heap_Ptr
1167+ E29D             >
1167+ E29D             >mirror_Ptr      defl    $
1167+ E29D             >
1167+ E29D 29 9F       >                dw      Dict_Ptr + 2        // xt
1167+ E29F             >Heap_Ptr        defl    $ - $E000           // save current HP
1167+ E29F             >
1167+ E29F             >Current_HP      defl  $ - $E000             // used to set HP once!
1167+ E29F             >
1167+ E29F             >//              ______________________________________________________________________
1167+ E29F             >//              Dictionary part
1167+ E29F             >
1167+ E29F             >                org     Dict_Ptr
1167+ 9F27             >
1167+ 9F27 9D 21       >                dw      mirror_Ptr - $E000 + $1F00
1167+ 9F29             >
1167+ 9F29             >UMDIVMOD:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1167+ 9F29 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1167+ 9F29 ~           >
1167+ 9F29 ~           >
1167+ 9F29             >                endif           ; ok        // for other definitions it "points" the correct handler
1167+ 9F29             >                // Use of "; ok" to suppress "warning[fwdref]"
1167+ 9F29             >
1167+ 9F29             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1168+ 9F29 D9                           exx
1169+ 9F2A C1                           pop     bc                      // divisor
1170+ 9F2B
1171+ 9F2B E1                           pop     hl                      // < high part
1172+ 9F2C D1                           pop     de                      // < low part and
1173+ 9F2D
1174+ 9F2D 7D                           ld      a, l                    // check without changing arguments
1175+ 9F2E 91                           sub     c                       // if divisor is greater than high part
1176+ 9F2F 7C                           ld      a, h                    // so quotient will be in range
1177+ 9F30 98                           sbc     a, b
1178+ 9F31 30 20                        jr      nc, Um_DivMod_OutOfRange
1179+ 9F33 3E 10                            ld      a, 16
1180+ 9F35              Um_DivMod_Loop:
1181+ 9F35 CB 23                                sla     e
1182+ 9F37 CB 12                                rl      d
1183+ 9F39 ED 6A                                adc     hl, hl
1184+ 9F3B 30 05                                jr      nc, Um_DivMod_Carry
1185+ 9F3D A7                                       and     a
1186+ 9F3E ED 42                                    sbc     hl, bc
1187+ 9F40 18 07                                jr      Um_DivMod_Endif    // else
1188+ 9F42              Um_DivMod_Carry:
1189+ 9F42 A7                                       and     a
1190+ 9F43 ED 42                                    sbc     hl, bc
1191+ 9F45 30 02                                    jr      nc, Um_DivMod_Endif
1192+ 9F47 09                                           add     hl, bc
1193+ 9F48 1B                                           dec     de
1194+ 9F49              Um_DivMod_Endif:                                   // endif
1195+ 9F49 13                                   inc     de
1196+ 9F4A 3D                                   dec     a
1197+ 9F4B 20 E8                            jr      nz, Um_DivMod_Loop
1198+ 9F4D EB                               ex      de, hl
1199+ 9F4E              Um_DivMod_Bailout:
1200+ 9F4E D5                               push    de                  // de := remanider
1201+ 9F4F E5                               push    hl                  // hl := quotient
1202+ 9F50 D9                               exx
1203+ 9F51                                  next
1203+ 9F51 DD E9       >                jp      (ix)
1204+ 9F53
1205+ 9F53              Um_DivMod_OutOfRange:
1206+ 9F53 21 FF FF                     ld      hl, -1
1207+ 9F56 54                           ld      d, h
1208+ 9F57 5D                           ld      e, l
1209+ 9F58 18 F4                        jr      Um_DivMod_Bailout
1210+ 9F5A
1211+ 9F5A              //  ______________________________________________________________________
1212+ 9F5A              //
1213+ 9F5A              // and          n1 n2 -- n3
1214+ 9F5A              // bit logical AND. Returns n3 as n1 & n2
1215+ 9F5A                              New_Def AND_OP, "AND", is_code, is_normal
1215+ 9F5A             >
1215+ 9F5A             >Dict_Ptr        defl    $
1215+ 9F5A             >
1215+ 9F5A             >//              ______________________________________________________________________
1215+ 9F5A             >//              Heap part
1215+ 9F5A             >
1215+ 9F5A             >
1215+ 9F5A             >                org     (Heap_Ptr & $1FFF) + $E000
1215+ E29F             >
1215+ E29F             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1215+ E29F             >Latest_Definition defl  Heap_Ptr
1215+ E29F             >
1215+ E29F             >                // dummy db directives used to calculate length of namec
1215+ E29F 41 4E 44    >                db      "AND"
1215+ E2A2             >len_NFA         defl    $ - temp_NFA
1215+ E2A2             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1215+ E29F             >
1215+ E29F 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1215+ E2A0 41 4E 44    >                db      "AND"               // name string in 7-bit ascii, but
1215+ E2A3             >                org     $-1                 // alter last byte of Name just above to set
1215+ E2A2 C4          >                db      {b $} | END_BIT     // msb as name end
1215+ E2A3             >
1215+ E2A3 94 02       >                dw      Prev_Ptr            // Link to previous definition Name
1215+ E2A5             >Prev_Ptr        defl    Heap_Ptr
1215+ E2A5             >
1215+ E2A5             >mirror_Ptr      defl    $
1215+ E2A5             >
1215+ E2A5 5C 9F       >                dw      Dict_Ptr + 2        // xt
1215+ E2A7             >Heap_Ptr        defl    $ - $E000           // save current HP
1215+ E2A7             >
1215+ E2A7             >Current_HP      defl  $ - $E000             // used to set HP once!
1215+ E2A7             >
1215+ E2A7             >//              ______________________________________________________________________
1215+ E2A7             >//              Dictionary part
1215+ E2A7             >
1215+ E2A7             >                org     Dict_Ptr
1215+ 9F5A             >
1215+ 9F5A A5 21       >                dw      mirror_Ptr - $E000 + $1F00
1215+ 9F5C             >
1215+ 9F5C             >AND_OP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1215+ 9F5C ~           >                call    runcode ; ok        // for primitive definitions  actual code
1215+ 9F5C ~           >
1215+ 9F5C ~           >
1215+ 9F5C             >                endif           ; ok        // for other definitions it "points" the correct handler
1215+ 9F5C             >                // Use of "; ok" to suppress "warning[fwdref]"
1215+ 9F5C             >
1215+ 9F5C             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1216+ 9F5C D9                           exx
1217+ 9F5D D1                           pop     de
1218+ 9F5E E1                           pop     hl
1219+ 9F5F 7B                           ld      a, e
1220+ 9F60 A5                           and     l
1221+ 9F61 6F                           ld      l, a
1222+ 9F62 7A                           ld      a, d
1223+ 9F63 A4                           and     h
1224+ 9F64 67                           ld      h, a
1225+ 9F65 E5                           push    hl
1226+ 9F66 D9                           exx
1227+ 9F67                              next
1227+ 9F67 DD E9       >                jp      (ix)
1228+ 9F69
1229+ 9F69              //  ______________________________________________________________________
1230+ 9F69              //
1231+ 9F69              // or           n1 n2 -- n3
1232+ 9F69              // bit logical OR. Returns n3 as n1 | n2
1233+ 9F69                              New_Def OR_OP, "OR", is_code, is_normal
1233+ 9F69             >
1233+ 9F69             >Dict_Ptr        defl    $
1233+ 9F69             >
1233+ 9F69             >//              ______________________________________________________________________
1233+ 9F69             >//              Heap part
1233+ 9F69             >
1233+ 9F69             >
1233+ 9F69             >                org     (Heap_Ptr & $1FFF) + $E000
1233+ E2A7             >
1233+ E2A7             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1233+ E2A7             >Latest_Definition defl  Heap_Ptr
1233+ E2A7             >
1233+ E2A7             >                // dummy db directives used to calculate length of namec
1233+ E2A7 4F 52       >                db      "OR"
1233+ E2A9             >len_NFA         defl    $ - temp_NFA
1233+ E2A9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1233+ E2A7             >
1233+ E2A7 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1233+ E2A8 4F 52       >                db      "OR"               // name string in 7-bit ascii, but
1233+ E2AA             >                org     $-1                 // alter last byte of Name just above to set
1233+ E2A9 D2          >                db      {b $} | END_BIT     // msb as name end
1233+ E2AA             >
1233+ E2AA 9F 02       >                dw      Prev_Ptr            // Link to previous definition Name
1233+ E2AC             >Prev_Ptr        defl    Heap_Ptr
1233+ E2AC             >
1233+ E2AC             >mirror_Ptr      defl    $
1233+ E2AC             >
1233+ E2AC 6B 9F       >                dw      Dict_Ptr + 2        // xt
1233+ E2AE             >Heap_Ptr        defl    $ - $E000           // save current HP
1233+ E2AE             >
1233+ E2AE             >Current_HP      defl  $ - $E000             // used to set HP once!
1233+ E2AE             >
1233+ E2AE             >//              ______________________________________________________________________
1233+ E2AE             >//              Dictionary part
1233+ E2AE             >
1233+ E2AE             >                org     Dict_Ptr
1233+ 9F69             >
1233+ 9F69 AC 21       >                dw      mirror_Ptr - $E000 + $1F00
1233+ 9F6B             >
1233+ 9F6B             >OR_OP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1233+ 9F6B ~           >                call    runcode ; ok        // for primitive definitions  actual code
1233+ 9F6B ~           >
1233+ 9F6B ~           >
1233+ 9F6B             >                endif           ; ok        // for other definitions it "points" the correct handler
1233+ 9F6B             >                // Use of "; ok" to suppress "warning[fwdref]"
1233+ 9F6B             >
1233+ 9F6B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1234+ 9F6B D9                           exx
1235+ 9F6C D1                           pop     de
1236+ 9F6D E1                           pop     hl
1237+ 9F6E 7B                           ld      a, e
1238+ 9F6F B5                           or      l
1239+ 9F70 6F                           ld      l, a
1240+ 9F71 7A                           ld      a, d
1241+ 9F72 B4                           or      h
1242+ 9F73 67                           ld      h, a
1243+ 9F74 E5                           push    hl
1244+ 9F75 D9                           exx
1245+ 9F76                              next
1245+ 9F76 DD E9       >                jp      (ix)
1246+ 9F78
1247+ 9F78              //  ______________________________________________________________________
1248+ 9F78              //
1249+ 9F78              // xor          n1 n2 -- n3
1250+ 9F78              // bit logical OR. Returns n3 as n1 ^ n2
1251+ 9F78                              New_Def XOR_OP, "XOR", is_code, is_normal
1251+ 9F78             >
1251+ 9F78             >Dict_Ptr        defl    $
1251+ 9F78             >
1251+ 9F78             >//              ______________________________________________________________________
1251+ 9F78             >//              Heap part
1251+ 9F78             >
1251+ 9F78             >
1251+ 9F78             >                org     (Heap_Ptr & $1FFF) + $E000
1251+ E2AE             >
1251+ E2AE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1251+ E2AE             >Latest_Definition defl  Heap_Ptr
1251+ E2AE             >
1251+ E2AE             >                // dummy db directives used to calculate length of namec
1251+ E2AE 58 4F 52    >                db      "XOR"
1251+ E2B1             >len_NFA         defl    $ - temp_NFA
1251+ E2B1             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1251+ E2AE             >
1251+ E2AE 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1251+ E2AF 58 4F 52    >                db      "XOR"               // name string in 7-bit ascii, but
1251+ E2B2             >                org     $-1                 // alter last byte of Name just above to set
1251+ E2B1 D2          >                db      {b $} | END_BIT     // msb as name end
1251+ E2B2             >
1251+ E2B2 A7 02       >                dw      Prev_Ptr            // Link to previous definition Name
1251+ E2B4             >Prev_Ptr        defl    Heap_Ptr
1251+ E2B4             >
1251+ E2B4             >mirror_Ptr      defl    $
1251+ E2B4             >
1251+ E2B4 7A 9F       >                dw      Dict_Ptr + 2        // xt
1251+ E2B6             >Heap_Ptr        defl    $ - $E000           // save current HP
1251+ E2B6             >
1251+ E2B6             >Current_HP      defl  $ - $E000             // used to set HP once!
1251+ E2B6             >
1251+ E2B6             >//              ______________________________________________________________________
1251+ E2B6             >//              Dictionary part
1251+ E2B6             >
1251+ E2B6             >                org     Dict_Ptr
1251+ 9F78             >
1251+ 9F78 B4 21       >                dw      mirror_Ptr - $E000 + $1F00
1251+ 9F7A             >
1251+ 9F7A             >XOR_OP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1251+ 9F7A ~           >                call    runcode ; ok        // for primitive definitions  actual code
1251+ 9F7A ~           >
1251+ 9F7A ~           >
1251+ 9F7A             >                endif           ; ok        // for other definitions it "points" the correct handler
1251+ 9F7A             >                // Use of "; ok" to suppress "warning[fwdref]"
1251+ 9F7A             >
1251+ 9F7A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1252+ 9F7A D9                           exx
1253+ 9F7B D1                           pop     de
1254+ 9F7C E1                           pop     hl
1255+ 9F7D 7B                           ld      a, e
1256+ 9F7E AD                           xor     l
1257+ 9F7F 6F                           ld      l, a
1258+ 9F80 7A                           ld      a, d
1259+ 9F81 AC                           xor     h
1260+ 9F82 67                           ld      h, a
1261+ 9F83 E5                           push    hl
1262+ 9F84 D9                           exx
1263+ 9F85                              next
1263+ 9F85 DD E9       >                jp      (ix)
1264+ 9F87
1265+ 9F87              //  ______________________________________________________________________
1266+ 9F87              //
1267+ 9F87              // sp@      -- a
1268+ 9F87              // returns on top of stack the value of SP before execution
1269+ 9F87                              New_Def SPFETCH, "SP@", is_code, is_normal
1269+ 9F87             >
1269+ 9F87             >Dict_Ptr        defl    $
1269+ 9F87             >
1269+ 9F87             >//              ______________________________________________________________________
1269+ 9F87             >//              Heap part
1269+ 9F87             >
1269+ 9F87             >
1269+ 9F87             >                org     (Heap_Ptr & $1FFF) + $E000
1269+ E2B6             >
1269+ E2B6             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1269+ E2B6             >Latest_Definition defl  Heap_Ptr
1269+ E2B6             >
1269+ E2B6             >                // dummy db directives used to calculate length of namec
1269+ E2B6 53 50 40    >                db      "SP@"
1269+ E2B9             >len_NFA         defl    $ - temp_NFA
1269+ E2B9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1269+ E2B6             >
1269+ E2B6 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1269+ E2B7 53 50 40    >                db      "SP@"               // name string in 7-bit ascii, but
1269+ E2BA             >                org     $-1                 // alter last byte of Name just above to set
1269+ E2B9 C0          >                db      {b $} | END_BIT     // msb as name end
1269+ E2BA             >
1269+ E2BA AE 02       >                dw      Prev_Ptr            // Link to previous definition Name
1269+ E2BC             >Prev_Ptr        defl    Heap_Ptr
1269+ E2BC             >
1269+ E2BC             >mirror_Ptr      defl    $
1269+ E2BC             >
1269+ E2BC 89 9F       >                dw      Dict_Ptr + 2        // xt
1269+ E2BE             >Heap_Ptr        defl    $ - $E000           // save current HP
1269+ E2BE             >
1269+ E2BE             >Current_HP      defl  $ - $E000             // used to set HP once!
1269+ E2BE             >
1269+ E2BE             >//              ______________________________________________________________________
1269+ E2BE             >//              Dictionary part
1269+ E2BE             >
1269+ E2BE             >                org     Dict_Ptr
1269+ 9F87             >
1269+ 9F87 BC 21       >                dw      mirror_Ptr - $E000 + $1F00
1269+ 9F89             >
1269+ 9F89             >SPFETCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1269+ 9F89 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1269+ 9F89 ~           >
1269+ 9F89 ~           >
1269+ 9F89             >                endif           ; ok        // for other definitions it "points" the correct handler
1269+ 9F89             >                // Use of "; ok" to suppress "warning[fwdref]"
1269+ 9F89             >
1269+ 9F89             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1270+ 9F89
1271+ 9F89 21 00 00                     ld      hl, 0
1272+ 9F8C 39                           add     hl, sp
1273+ 9F8D
1274+ 9F8D                              psh1
1274+ 9F8D E5          >                push    hl
1274+ 9F8E DD E9       >                jp      (ix)
1275+ 9F90
1276+ 9F90              //  ______________________________________________________________________
1277+ 9F90              //
1278+ 9F90              // sp!      a --
1279+ 9F90              // restore SP to the initial value passed
1280+ 9F90              // normally it is S0, i.e. the word at offset 6 and 7 of user variabiles area.
1281+ 9F90                              New_Def SPSTORE, "SP!", is_code, is_normal
1281+ 9F90             >
1281+ 9F90             >Dict_Ptr        defl    $
1281+ 9F90             >
1281+ 9F90             >//              ______________________________________________________________________
1281+ 9F90             >//              Heap part
1281+ 9F90             >
1281+ 9F90             >
1281+ 9F90             >                org     (Heap_Ptr & $1FFF) + $E000
1281+ E2BE             >
1281+ E2BE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1281+ E2BE             >Latest_Definition defl  Heap_Ptr
1281+ E2BE             >
1281+ E2BE             >                // dummy db directives used to calculate length of namec
1281+ E2BE 53 50 21    >                db      "SP!"
1281+ E2C1             >len_NFA         defl    $ - temp_NFA
1281+ E2C1             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1281+ E2BE             >
1281+ E2BE 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1281+ E2BF 53 50 21    >                db      "SP!"               // name string in 7-bit ascii, but
1281+ E2C2             >                org     $-1                 // alter last byte of Name just above to set
1281+ E2C1 A1          >                db      {b $} | END_BIT     // msb as name end
1281+ E2C2             >
1281+ E2C2 B6 02       >                dw      Prev_Ptr            // Link to previous definition Name
1281+ E2C4             >Prev_Ptr        defl    Heap_Ptr
1281+ E2C4             >
1281+ E2C4             >mirror_Ptr      defl    $
1281+ E2C4             >
1281+ E2C4 92 9F       >                dw      Dict_Ptr + 2        // xt
1281+ E2C6             >Heap_Ptr        defl    $ - $E000           // save current HP
1281+ E2C6             >
1281+ E2C6             >Current_HP      defl  $ - $E000             // used to set HP once!
1281+ E2C6             >
1281+ E2C6             >//              ______________________________________________________________________
1281+ E2C6             >//              Dictionary part
1281+ E2C6             >
1281+ E2C6             >                org     Dict_Ptr
1281+ 9F90             >
1281+ 9F90 C4 21       >                dw      mirror_Ptr - $E000 + $1F00
1281+ 9F92             >
1281+ 9F92             >SPSTORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1281+ 9F92 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1281+ 9F92 ~           >
1281+ 9F92 ~           >
1281+ 9F92             >                endif           ; ok        // for other definitions it "points" the correct handler
1281+ 9F92             >                // Use of "; ok" to suppress "warning[fwdref]"
1281+ 9F92             >
1281+ 9F92             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1282+ 9F92 E1                           pop     hl
1283+ 9F93 F9                           ld      sp, hl
1284+ 9F94
1285+ 9F94                              next
1285+ 9F94 DD E9       >                jp      (ix)
1286+ 9F96
1287+ 9F96              //  ______________________________________________________________________
1288+ 9F96              //
1289+ 9F96              // rp@      -- a
1290+ 9F96              // returns on top of stack the value of Return-Pointer
1291+ 9F96                              New_Def RPFETCH, "RP@", is_code, is_normal
1291+ 9F96             >
1291+ 9F96             >Dict_Ptr        defl    $
1291+ 9F96             >
1291+ 9F96             >//              ______________________________________________________________________
1291+ 9F96             >//              Heap part
1291+ 9F96             >
1291+ 9F96             >
1291+ 9F96             >                org     (Heap_Ptr & $1FFF) + $E000
1291+ E2C6             >
1291+ E2C6             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1291+ E2C6             >Latest_Definition defl  Heap_Ptr
1291+ E2C6             >
1291+ E2C6             >                // dummy db directives used to calculate length of namec
1291+ E2C6 52 50 40    >                db      "RP@"
1291+ E2C9             >len_NFA         defl    $ - temp_NFA
1291+ E2C9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1291+ E2C6             >
1291+ E2C6 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1291+ E2C7 52 50 40    >                db      "RP@"               // name string in 7-bit ascii, but
1291+ E2CA             >                org     $-1                 // alter last byte of Name just above to set
1291+ E2C9 C0          >                db      {b $} | END_BIT     // msb as name end
1291+ E2CA             >
1291+ E2CA BE 02       >                dw      Prev_Ptr            // Link to previous definition Name
1291+ E2CC             >Prev_Ptr        defl    Heap_Ptr
1291+ E2CC             >
1291+ E2CC             >mirror_Ptr      defl    $
1291+ E2CC             >
1291+ E2CC 98 9F       >                dw      Dict_Ptr + 2        // xt
1291+ E2CE             >Heap_Ptr        defl    $ - $E000           // save current HP
1291+ E2CE             >
1291+ E2CE             >Current_HP      defl  $ - $E000             // used to set HP once!
1291+ E2CE             >
1291+ E2CE             >//              ______________________________________________________________________
1291+ E2CE             >//              Dictionary part
1291+ E2CE             >
1291+ E2CE             >                org     Dict_Ptr
1291+ 9F96             >
1291+ 9F96 CC 21       >                dw      mirror_Ptr - $E000 + $1F00
1291+ 9F98             >
1291+ 9F98             >RPFETCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1291+ 9F98 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1291+ 9F98 ~           >
1291+ 9F98 ~           >
1291+ 9F98             >                endif           ; ok        // for other definitions it "points" the correct handler
1291+ 9F98             >                // Use of "; ok" to suppress "warning[fwdref]"
1291+ 9F98             >
1291+ 9F98             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1292+ 9F98
1293+ 9F98                              // *** ldhlrp
1294+ 9F98                              // *** ex      de, hl
1295+ 9F98 D5                           push de
1296+ 9F99
1297+ 9F99                              next
1297+ 9F99 DD E9       >                jp      (ix)
1298+ 9F9B
1299+ 9F9B              //  ______________________________________________________________________
1300+ 9F9B              //
1301+ 9F9B              // rp!      a --
1302+ 9F9B              // restore RP to the initial value passed
1303+ 9F9B              // normally it is R0 @, i.e. the word at offset 8 of user variabiles area.
1304+ 9F9B                              New_Def RPSTORE, "RP!", is_code, is_normal
1304+ 9F9B             >
1304+ 9F9B             >Dict_Ptr        defl    $
1304+ 9F9B             >
1304+ 9F9B             >//              ______________________________________________________________________
1304+ 9F9B             >//              Heap part
1304+ 9F9B             >
1304+ 9F9B             >
1304+ 9F9B             >                org     (Heap_Ptr & $1FFF) + $E000
1304+ E2CE             >
1304+ E2CE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1304+ E2CE             >Latest_Definition defl  Heap_Ptr
1304+ E2CE             >
1304+ E2CE             >                // dummy db directives used to calculate length of namec
1304+ E2CE 52 50 21    >                db      "RP!"
1304+ E2D1             >len_NFA         defl    $ - temp_NFA
1304+ E2D1             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1304+ E2CE             >
1304+ E2CE 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1304+ E2CF 52 50 21    >                db      "RP!"               // name string in 7-bit ascii, but
1304+ E2D2             >                org     $-1                 // alter last byte of Name just above to set
1304+ E2D1 A1          >                db      {b $} | END_BIT     // msb as name end
1304+ E2D2             >
1304+ E2D2 C6 02       >                dw      Prev_Ptr            // Link to previous definition Name
1304+ E2D4             >Prev_Ptr        defl    Heap_Ptr
1304+ E2D4             >
1304+ E2D4             >mirror_Ptr      defl    $
1304+ E2D4             >
1304+ E2D4 9D 9F       >                dw      Dict_Ptr + 2        // xt
1304+ E2D6             >Heap_Ptr        defl    $ - $E000           // save current HP
1304+ E2D6             >
1304+ E2D6             >Current_HP      defl  $ - $E000             // used to set HP once!
1304+ E2D6             >
1304+ E2D6             >//              ______________________________________________________________________
1304+ E2D6             >//              Dictionary part
1304+ E2D6             >
1304+ E2D6             >                org     Dict_Ptr
1304+ 9F9B             >
1304+ 9F9B D4 21       >                dw      mirror_Ptr - $E000 + $1F00
1304+ 9F9D             >
1304+ 9F9D             >RPSTORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1304+ 9F9D ~           >                call    runcode ; ok        // for primitive definitions  actual code
1304+ 9F9D ~           >
1304+ 9F9D ~           >
1304+ 9F9D             >                endif           ; ok        // for other definitions it "points" the correct handler
1304+ 9F9D             >                // Use of "; ok" to suppress "warning[fwdref]"
1304+ 9F9D             >
1304+ 9F9D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1305+ 9F9D D1                           pop     de
1306+ 9F9E                              // *** ex      de, hl
1307+ 9F9E                              // *** ldrphl
1308+ 9F9E
1309+ 9F9E                              next
1309+ 9F9E DD E9       >                jp      (ix)
1310+ 9FA0
1311+ 9FA0              //  ______________________________________________________________________
1312+ 9FA0              //
1313+ 9FA0              // exit       --
1314+ 9FA0              // exits back to the caller word
1315+ 9FA0                              New_Def EXIT, "EXIT", is_code, is_normal
1315+ 9FA0             >
1315+ 9FA0             >Dict_Ptr        defl    $
1315+ 9FA0             >
1315+ 9FA0             >//              ______________________________________________________________________
1315+ 9FA0             >//              Heap part
1315+ 9FA0             >
1315+ 9FA0             >
1315+ 9FA0             >                org     (Heap_Ptr & $1FFF) + $E000
1315+ E2D6             >
1315+ E2D6             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1315+ E2D6             >Latest_Definition defl  Heap_Ptr
1315+ E2D6             >
1315+ E2D6             >                // dummy db directives used to calculate length of namec
1315+ E2D6 45 58 49 54 >                db      "EXIT"
1315+ E2DA             >len_NFA         defl    $ - temp_NFA
1315+ E2DA             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1315+ E2D6             >
1315+ E2D6 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1315+ E2D7 45 58 49 54 >                db      "EXIT"               // name string in 7-bit ascii, but
1315+ E2DB             >                org     $-1                 // alter last byte of Name just above to set
1315+ E2DA D4          >                db      {b $} | END_BIT     // msb as name end
1315+ E2DB             >
1315+ E2DB CE 02       >                dw      Prev_Ptr            // Link to previous definition Name
1315+ E2DD             >Prev_Ptr        defl    Heap_Ptr
1315+ E2DD             >
1315+ E2DD             >mirror_Ptr      defl    $
1315+ E2DD             >
1315+ E2DD A2 9F       >                dw      Dict_Ptr + 2        // xt
1315+ E2DF             >Heap_Ptr        defl    $ - $E000           // save current HP
1315+ E2DF             >
1315+ E2DF             >Current_HP      defl  $ - $E000             // used to set HP once!
1315+ E2DF             >
1315+ E2DF             >//              ______________________________________________________________________
1315+ E2DF             >//              Dictionary part
1315+ E2DF             >
1315+ E2DF             >                org     Dict_Ptr
1315+ 9FA0             >
1315+ 9FA0 DD 21       >                dw      mirror_Ptr - $E000 + $1F00
1315+ 9FA2             >
1315+ 9FA2             >EXIT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1315+ 9FA2 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1315+ 9FA2 ~           >
1315+ 9FA2 ~           >
1315+ 9FA2             >                endif           ; ok        // for other definitions it "points" the correct handler
1315+ 9FA2             >                // Use of "; ok" to suppress "warning[fwdref]"
1315+ 9FA2             >
1315+ 9FA2             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1316+ 9FA2 EB                           ex      de, hl
1317+ 9FA3                              // *** ldhlrp                      // Get Return Stack Pointer
1318+ 9FA3 4E                           ld      c, (hl)             // pop Instruction Pointer
1319+ 9FA4 23                           inc     hl                  // from Return Stack
1320+ 9FA5 46                           ld      b, (hl)
1321+ 9FA6 23                           inc     hl
1322+ 9FA7                              // *** ldrphl                      // Set Return Stack Pointer
1323+ 9FA7 EB                           ex      de, hl
1324+ 9FA8                              next
1324+ 9FA8 DD E9       >                jp      (ix)
1325+ 9FAA
1326+ 9FAA              //  ______________________________________________________________________
1327+ 9FAA              //
1328+ 9FAA              // lastl      --
1329+ 9FAA              // exits back to the caller word
1330+ 9FAA              //              New_Def EXIT, "LASTL", is_code, is_normal
1331+ 9FAA              //              push    de
1332+ 9FAA              //              ex      de, hl //**
1333+ 9FAA              //              // *** ldhlrp                      // Get Return Stack Pointer
1334+ 9FAA              //              ld      e, (hl)             // pop Instruction Pointer
1335+ 9FAA              //              inc     hl                  // from Return Stack
1336+ 9FAA              //              ld      d, (hl)
1337+ 9FAA              //              inc     hl
1338+ 9FAA              //              ld      (hl), e
1339+ 9FAA              //              inc     hl
1340+ 9FAA              //              ld      (hl), d
1341+ 9FAA              //              add     hl, -3
1342+ 9FAA              //              pop     de
1343+ 9FAA              //              next
1344+ 9FAA
1345+ 9FAA              //  ______________________________________________________________________
1346+ 9FAA              //
1347+ 9FAA              // >r      n --
1348+ 9FAA              // pop from calculator-stack and push into return-stack
1349+ 9FAA                              New_Def TO_R, ">R", is_code, is_normal
1349+ 9FAA             >
1349+ 9FAA             >Dict_Ptr        defl    $
1349+ 9FAA             >
1349+ 9FAA             >//              ______________________________________________________________________
1349+ 9FAA             >//              Heap part
1349+ 9FAA             >
1349+ 9FAA             >
1349+ 9FAA             >                org     (Heap_Ptr & $1FFF) + $E000
1349+ E2DF             >
1349+ E2DF             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1349+ E2DF             >Latest_Definition defl  Heap_Ptr
1349+ E2DF             >
1349+ E2DF             >                // dummy db directives used to calculate length of namec
1349+ E2DF 3E 52       >                db      ">R"
1349+ E2E1             >len_NFA         defl    $ - temp_NFA
1349+ E2E1             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1349+ E2DF             >
1349+ E2DF 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1349+ E2E0 3E 52       >                db      ">R"               // name string in 7-bit ascii, but
1349+ E2E2             >                org     $-1                 // alter last byte of Name just above to set
1349+ E2E1 D2          >                db      {b $} | END_BIT     // msb as name end
1349+ E2E2             >
1349+ E2E2 D6 02       >                dw      Prev_Ptr            // Link to previous definition Name
1349+ E2E4             >Prev_Ptr        defl    Heap_Ptr
1349+ E2E4             >
1349+ E2E4             >mirror_Ptr      defl    $
1349+ E2E4             >
1349+ E2E4 AC 9F       >                dw      Dict_Ptr + 2        // xt
1349+ E2E6             >Heap_Ptr        defl    $ - $E000           // save current HP
1349+ E2E6             >
1349+ E2E6             >Current_HP      defl  $ - $E000             // used to set HP once!
1349+ E2E6             >
1349+ E2E6             >//              ______________________________________________________________________
1349+ E2E6             >//              Dictionary part
1349+ E2E6             >
1349+ E2E6             >                org     Dict_Ptr
1349+ 9FAA             >
1349+ 9FAA E4 21       >                dw      mirror_Ptr - $E000 + $1F00
1349+ 9FAC             >
1349+ 9FAC             >TO_R:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1349+ 9FAC ~           >                call    runcode ; ok        // for primitive definitions  actual code
1349+ 9FAC ~           >
1349+ 9FAC ~           >
1349+ 9FAC             >                endif           ; ok        // for other definitions it "points" the correct handler
1349+ 9FAC             >                // Use of "; ok" to suppress "warning[fwdref]"
1349+ 9FAC             >
1349+ 9FAC             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1350+ 9FAC E1                           pop     hl
1351+ 9FAD EB                           ex      de, hl //**
1352+ 9FAE                              // *** ldhlrp
1353+ 9FAE 2B                           dec     hl
1354+ 9FAF 72                           ld      (hl), d             // store current TOS
1355+ 9FB0 2B                           dec     hl                  // to Return Stack
1356+ 9FB1 73                           ld      (hl), e
1357+ 9FB2                              // *** ldrphl
1358+ 9FB2 EB                           ex      de, hl //**
1359+ 9FB3                              next
1359+ 9FB3 DD E9       >                jp      (ix)
1360+ 9FB5
1361+ 9FB5              //  ______________________________________________________________________
1362+ 9FB5              //
1363+ 9FB5              // r>      -- n
1364+ 9FB5              // pop from return-stack and push into calculator-stack
1365+ 9FB5                              New_Def R_TO, "R>", is_code, is_normal
1365+ 9FB5             >
1365+ 9FB5             >Dict_Ptr        defl    $
1365+ 9FB5             >
1365+ 9FB5             >//              ______________________________________________________________________
1365+ 9FB5             >//              Heap part
1365+ 9FB5             >
1365+ 9FB5             >
1365+ 9FB5             >                org     (Heap_Ptr & $1FFF) + $E000
1365+ E2E6             >
1365+ E2E6             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1365+ E2E6             >Latest_Definition defl  Heap_Ptr
1365+ E2E6             >
1365+ E2E6             >                // dummy db directives used to calculate length of namec
1365+ E2E6 52 3E       >                db      "R>"
1365+ E2E8             >len_NFA         defl    $ - temp_NFA
1365+ E2E8             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1365+ E2E6             >
1365+ E2E6 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1365+ E2E7 52 3E       >                db      "R>"               // name string in 7-bit ascii, but
1365+ E2E9             >                org     $-1                 // alter last byte of Name just above to set
1365+ E2E8 BE          >                db      {b $} | END_BIT     // msb as name end
1365+ E2E9             >
1365+ E2E9 DF 02       >                dw      Prev_Ptr            // Link to previous definition Name
1365+ E2EB             >Prev_Ptr        defl    Heap_Ptr
1365+ E2EB             >
1365+ E2EB             >mirror_Ptr      defl    $
1365+ E2EB             >
1365+ E2EB B7 9F       >                dw      Dict_Ptr + 2        // xt
1365+ E2ED             >Heap_Ptr        defl    $ - $E000           // save current HP
1365+ E2ED             >
1365+ E2ED             >Current_HP      defl  $ - $E000             // used to set HP once!
1365+ E2ED             >
1365+ E2ED             >//              ______________________________________________________________________
1365+ E2ED             >//              Dictionary part
1365+ E2ED             >
1365+ E2ED             >                org     Dict_Ptr
1365+ 9FB5             >
1365+ 9FB5 EB 21       >                dw      mirror_Ptr - $E000 + $1F00
1365+ 9FB7             >
1365+ 9FB7             >R_TO:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1365+ 9FB7 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1365+ 9FB7 ~           >
1365+ 9FB7 ~           >
1365+ 9FB7             >                endif           ; ok        // for other definitions it "points" the correct handler
1365+ 9FB7             >                // Use of "; ok" to suppress "warning[fwdref]"
1365+ 9FB7             >
1365+ 9FB7             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1366+ 9FB7
1367+ 9FB7 EB                           ex      de, hl //**
1368+ 9FB8                              // *** ldhlrp
1369+ 9FB8 5E                           ld      e, (hl)             // retrieve from Return Stack
1370+ 9FB9 23                           inc     hl
1371+ 9FBA 56                           ld      d, (hl)
1372+ 9FBB 23                           inc     hl
1373+ 9FBC                              // *** ldrphl
1374+ 9FBC EB                           ex      de, hl //**
1375+ 9FBD E5                           push    hl
1376+ 9FBE                              next
1376+ 9FBE DD E9       >                jp      (ix)
1377+ 9FC0
1378+ 9FC0              //  ______________________________________________________________________
1379+ 9FC0              //
1380+ 9FC0              // r@           -- n
1381+ 9FC0              // return on top of stack the value of top of return-stack
1382+ 9FC0              // Since this is the same as I, we alter R's CFA to jump there
1383+ 9FC0                              New_Def R_OP, "R@", is_code, is_normal
1383+ 9FC0             >
1383+ 9FC0             >Dict_Ptr        defl    $
1383+ 9FC0             >
1383+ 9FC0             >//              ______________________________________________________________________
1383+ 9FC0             >//              Heap part
1383+ 9FC0             >
1383+ 9FC0             >
1383+ 9FC0             >                org     (Heap_Ptr & $1FFF) + $E000
1383+ E2ED             >
1383+ E2ED             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1383+ E2ED             >Latest_Definition defl  Heap_Ptr
1383+ E2ED             >
1383+ E2ED             >                // dummy db directives used to calculate length of namec
1383+ E2ED 52 40       >                db      "R@"
1383+ E2EF             >len_NFA         defl    $ - temp_NFA
1383+ E2EF             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1383+ E2ED             >
1383+ E2ED 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1383+ E2EE 52 40       >                db      "R@"               // name string in 7-bit ascii, but
1383+ E2F0             >                org     $-1                 // alter last byte of Name just above to set
1383+ E2EF C0          >                db      {b $} | END_BIT     // msb as name end
1383+ E2F0             >
1383+ E2F0 E6 02       >                dw      Prev_Ptr            // Link to previous definition Name
1383+ E2F2             >Prev_Ptr        defl    Heap_Ptr
1383+ E2F2             >
1383+ E2F2             >mirror_Ptr      defl    $
1383+ E2F2             >
1383+ E2F2 C2 9F       >                dw      Dict_Ptr + 2        // xt
1383+ E2F4             >Heap_Ptr        defl    $ - $E000           // save current HP
1383+ E2F4             >
1383+ E2F4             >Current_HP      defl  $ - $E000             // used to set HP once!
1383+ E2F4             >
1383+ E2F4             >//              ______________________________________________________________________
1383+ E2F4             >//              Dictionary part
1383+ E2F4             >
1383+ E2F4             >                org     Dict_Ptr
1383+ 9FC0             >
1383+ 9FC0 F2 21       >                dw      mirror_Ptr - $E000 + $1F00
1383+ 9FC2             >
1383+ 9FC2             >R_OP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1383+ 9FC2 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1383+ 9FC2 ~           >
1383+ 9FC2 ~           >
1383+ 9FC2             >                endif           ; ok        // for other definitions it "points" the correct handler
1383+ 9FC2             >                // Use of "; ok" to suppress "warning[fwdref]"
1383+ 9FC2             >
1383+ 9FC2             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1384+ 9FC2 C3 8A 9B                     jp      I_Ptr
1385+ 9FC5
1386+ 9FC5              //  ______________________________________________________________________
1387+ 9FC5              //
1388+ 9FC5              // r            -- n
1389+ 9FC5              // return on top of stack the value of top of return-stack
1390+ 9FC5              // Since this is the same as I, we alter R's CFA to jump there
1391+ 9FC5              //              New_Def R_OLD, "R", is_code, is_normal
1392+ 9FC5              //              jp      I_Ptr
1393+ 9FC5
1394+ 9FC5              //  ______________________________________________________________________
1395+ 9FC5              //
1396+ 9FC5              // 0=           n -- f
1397+ 9FC5              // true (non zero) if n is zero, false (0) elsewere
1398+ 9FC5                              New_Def ZEQUAL, "0=", is_code, is_normal
1398+ 9FC5             >
1398+ 9FC5             >Dict_Ptr        defl    $
1398+ 9FC5             >
1398+ 9FC5             >//              ______________________________________________________________________
1398+ 9FC5             >//              Heap part
1398+ 9FC5             >
1398+ 9FC5             >
1398+ 9FC5             >                org     (Heap_Ptr & $1FFF) + $E000
1398+ E2F4             >
1398+ E2F4             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1398+ E2F4             >Latest_Definition defl  Heap_Ptr
1398+ E2F4             >
1398+ E2F4             >                // dummy db directives used to calculate length of namec
1398+ E2F4 30 3D       >                db      "0="
1398+ E2F6             >len_NFA         defl    $ - temp_NFA
1398+ E2F6             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1398+ E2F4             >
1398+ E2F4 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1398+ E2F5 30 3D       >                db      "0="               // name string in 7-bit ascii, but
1398+ E2F7             >                org     $-1                 // alter last byte of Name just above to set
1398+ E2F6 BD          >                db      {b $} | END_BIT     // msb as name end
1398+ E2F7             >
1398+ E2F7 ED 02       >                dw      Prev_Ptr            // Link to previous definition Name
1398+ E2F9             >Prev_Ptr        defl    Heap_Ptr
1398+ E2F9             >
1398+ E2F9             >mirror_Ptr      defl    $
1398+ E2F9             >
1398+ E2F9 C7 9F       >                dw      Dict_Ptr + 2        // xt
1398+ E2FB             >Heap_Ptr        defl    $ - $E000           // save current HP
1398+ E2FB             >
1398+ E2FB             >Current_HP      defl  $ - $E000             // used to set HP once!
1398+ E2FB             >
1398+ E2FB             >//              ______________________________________________________________________
1398+ E2FB             >//              Dictionary part
1398+ E2FB             >
1398+ E2FB             >                org     Dict_Ptr
1398+ 9FC5             >
1398+ 9FC5 F9 21       >                dw      mirror_Ptr - $E000 + $1F00
1398+ 9FC7             >
1398+ 9FC7             >ZEQUAL:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1398+ 9FC7 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1398+ 9FC7 ~           >
1398+ 9FC7 ~           >
1398+ 9FC7             >                endif           ; ok        // for other definitions it "points" the correct handler
1398+ 9FC7             >                // Use of "; ok" to suppress "warning[fwdref]"
1398+ 9FC7             >
1398+ 9FC7             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1399+ 9FC7              Zero_Equal:
1400+ 9FC7 E1                           pop     hl
1401+ 9FC8 7D                           ld      a, l
1402+ 9FC9 B4                           or      h
1403+ 9FCA 21 00 00                     ld      hl, FALSE_FLAG
1404+ 9FCD 20 01                        jr      nz, ZEqual_Skip
1405+ 9FCF 2B                               dec     hl
1406+ 9FD0              ZEqual_Skip:
1407+ 9FD0                              psh1
1407+ 9FD0 E5          >                push    hl
1407+ 9FD1 DD E9       >                jp      (ix)
1408+ 9FD3
1409+ 9FD3              //  ______________________________________________________________________
1410+ 9FD3              //
1411+ 9FD3              // not         a1 -- a2
1412+ 9FD3              // increment by 2 top of stack
1413+ 9FD3                              New_Def NOT_OP, "NOT", is_code, is_normal
1413+ 9FD3             >
1413+ 9FD3             >Dict_Ptr        defl    $
1413+ 9FD3             >
1413+ 9FD3             >//              ______________________________________________________________________
1413+ 9FD3             >//              Heap part
1413+ 9FD3             >
1413+ 9FD3             >
1413+ 9FD3             >                org     (Heap_Ptr & $1FFF) + $E000
1413+ E2FB             >
1413+ E2FB             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1413+ E2FB             >Latest_Definition defl  Heap_Ptr
1413+ E2FB             >
1413+ E2FB             >                // dummy db directives used to calculate length of namec
1413+ E2FB 4E 4F 54    >                db      "NOT"
1413+ E2FE             >len_NFA         defl    $ - temp_NFA
1413+ E2FE             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1413+ E2FB             >
1413+ E2FB 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1413+ E2FC 4E 4F 54    >                db      "NOT"               // name string in 7-bit ascii, but
1413+ E2FF             >                org     $-1                 // alter last byte of Name just above to set
1413+ E2FE D4          >                db      {b $} | END_BIT     // msb as name end
1413+ E2FF             >
1413+ E2FF F4 02       >                dw      Prev_Ptr            // Link to previous definition Name
1413+ E301             >Prev_Ptr        defl    Heap_Ptr
1413+ E301             >
1413+ E301             >mirror_Ptr      defl    $
1413+ E301             >
1413+ E301 D5 9F       >                dw      Dict_Ptr + 2        // xt
1413+ E303             >Heap_Ptr        defl    $ - $E000           // save current HP
1413+ E303             >
1413+ E303             >Current_HP      defl  $ - $E000             // used to set HP once!
1413+ E303             >
1413+ E303             >//              ______________________________________________________________________
1413+ E303             >//              Dictionary part
1413+ E303             >
1413+ E303             >                org     Dict_Ptr
1413+ 9FD3             >
1413+ 9FD3 01 22       >                dw      mirror_Ptr - $E000 + $1F00
1413+ 9FD5             >
1413+ 9FD5             >NOT_OP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1413+ 9FD5 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1413+ 9FD5 ~           >
1413+ 9FD5 ~           >
1413+ 9FD5             >                endif           ; ok        // for other definitions it "points" the correct handler
1413+ 9FD5             >                // Use of "; ok" to suppress "warning[fwdref]"
1413+ 9FD5             >
1413+ 9FD5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1414+ 9FD5 C3 C7 9F                     jp      Zero_Equal
1415+ 9FD8
1416+ 9FD8              //  ______________________________________________________________________
1417+ 9FD8              //
1418+ 9FD8              // 0<           n -- f
1419+ 9FD8              // true (non zero) if n is less than zero, false (0) elsewere
1420+ 9FD8                              New_Def ZLESS, "0<", is_code, is_normal
1420+ 9FD8             >
1420+ 9FD8             >Dict_Ptr        defl    $
1420+ 9FD8             >
1420+ 9FD8             >//              ______________________________________________________________________
1420+ 9FD8             >//              Heap part
1420+ 9FD8             >
1420+ 9FD8             >
1420+ 9FD8             >                org     (Heap_Ptr & $1FFF) + $E000
1420+ E303             >
1420+ E303             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1420+ E303             >Latest_Definition defl  Heap_Ptr
1420+ E303             >
1420+ E303             >                // dummy db directives used to calculate length of namec
1420+ E303 30 3C       >                db      "0<"
1420+ E305             >len_NFA         defl    $ - temp_NFA
1420+ E305             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1420+ E303             >
1420+ E303 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1420+ E304 30 3C       >                db      "0<"               // name string in 7-bit ascii, but
1420+ E306             >                org     $-1                 // alter last byte of Name just above to set
1420+ E305 BC          >                db      {b $} | END_BIT     // msb as name end
1420+ E306             >
1420+ E306 FB 02       >                dw      Prev_Ptr            // Link to previous definition Name
1420+ E308             >Prev_Ptr        defl    Heap_Ptr
1420+ E308             >
1420+ E308             >mirror_Ptr      defl    $
1420+ E308             >
1420+ E308 DA 9F       >                dw      Dict_Ptr + 2        // xt
1420+ E30A             >Heap_Ptr        defl    $ - $E000           // save current HP
1420+ E30A             >
1420+ E30A             >Current_HP      defl  $ - $E000             // used to set HP once!
1420+ E30A             >
1420+ E30A             >//              ______________________________________________________________________
1420+ E30A             >//              Dictionary part
1420+ E30A             >
1420+ E30A             >                org     Dict_Ptr
1420+ 9FD8             >
1420+ 9FD8 08 22       >                dw      mirror_Ptr - $E000 + $1F00
1420+ 9FDA             >
1420+ 9FDA             >ZLESS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1420+ 9FDA ~           >                call    runcode ; ok        // for primitive definitions  actual code
1420+ 9FDA ~           >
1420+ 9FDA ~           >
1420+ 9FDA             >                endif           ; ok        // for other definitions it "points" the correct handler
1420+ 9FDA             >                // Use of "; ok" to suppress "warning[fwdref]"
1420+ 9FDA             >
1420+ 9FDA             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1421+ 9FDA E1                           pop     hl
1422+ 9FDB 29                           add     hl, hl
1423+ 9FDC ED 62                        sbc     hl, hl
1424+ 9FDE                              psh1
1424+ 9FDE E5          >                push    hl
1424+ 9FDF DD E9       >                jp      (ix)
1425+ 9FE1
1426+ 9FE1              //  ______________________________________________________________________
1427+ 9FE1              //
1428+ 9FE1              // 0>           n -- f
1429+ 9FE1              // true (non zero) if n is less than zero, false (0) elsewere
1430+ 9FE1                              New_Def ZGREATER, "0>", is_code, is_normal
1430+ 9FE1             >
1430+ 9FE1             >Dict_Ptr        defl    $
1430+ 9FE1             >
1430+ 9FE1             >//              ______________________________________________________________________
1430+ 9FE1             >//              Heap part
1430+ 9FE1             >
1430+ 9FE1             >
1430+ 9FE1             >                org     (Heap_Ptr & $1FFF) + $E000
1430+ E30A             >
1430+ E30A             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1430+ E30A             >Latest_Definition defl  Heap_Ptr
1430+ E30A             >
1430+ E30A             >                // dummy db directives used to calculate length of namec
1430+ E30A 30 3E       >                db      "0>"
1430+ E30C             >len_NFA         defl    $ - temp_NFA
1430+ E30C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1430+ E30A             >
1430+ E30A 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1430+ E30B 30 3E       >                db      "0>"               // name string in 7-bit ascii, but
1430+ E30D             >                org     $-1                 // alter last byte of Name just above to set
1430+ E30C BE          >                db      {b $} | END_BIT     // msb as name end
1430+ E30D             >
1430+ E30D 03 03       >                dw      Prev_Ptr            // Link to previous definition Name
1430+ E30F             >Prev_Ptr        defl    Heap_Ptr
1430+ E30F             >
1430+ E30F             >mirror_Ptr      defl    $
1430+ E30F             >
1430+ E30F E3 9F       >                dw      Dict_Ptr + 2        // xt
1430+ E311             >Heap_Ptr        defl    $ - $E000           // save current HP
1430+ E311             >
1430+ E311             >Current_HP      defl  $ - $E000             // used to set HP once!
1430+ E311             >
1430+ E311             >//              ______________________________________________________________________
1430+ E311             >//              Dictionary part
1430+ E311             >
1430+ E311             >                org     Dict_Ptr
1430+ 9FE1             >
1430+ 9FE1 0F 22       >                dw      mirror_Ptr - $E000 + $1F00
1430+ 9FE3             >
1430+ 9FE3             >ZGREATER:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1430+ 9FE3 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1430+ 9FE3 ~           >
1430+ 9FE3 ~           >
1430+ 9FE3             >                endif           ; ok        // for other definitions it "points" the correct handler
1430+ 9FE3             >                // Use of "; ok" to suppress "warning[fwdref]"
1430+ 9FE3             >
1430+ 9FE3             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1431+ 9FE3 E1                           pop     hl
1432+ 9FE4 7D                           ld      a, l
1433+ 9FE5 B4                           or      h
1434+ 9FE6 29                           add     hl, hl
1435+ 9FE7 21 00 00                     ld      hl, FALSE_FLAG
1436+ 9FEA 38 04                        jr      c, ZGreater_Skip
1437+ 9FEC A7                               and     a
1438+ 9FED 28 01                            jr      z, ZGreater_Skip
1439+ 9FEF 2B                                   dec     hl
1440+ 9FF0              ZGreater_Skip:
1441+ 9FF0                              psh1
1441+ 9FF0 E5          >                push    hl
1441+ 9FF1 DD E9       >                jp      (ix)
1442+ 9FF3
1443+ 9FF3              //  ______________________________________________________________________
1444+ 9FF3              //
1445+ 9FF3              // +            n1 n2 -- n3
1446+ 9FF3              // returns the unsigned sum of two top values
1447+ 9FF3                              New_Def PLUS, "+", is_code, is_normal
1447+ 9FF3             >
1447+ 9FF3             >Dict_Ptr        defl    $
1447+ 9FF3             >
1447+ 9FF3             >//              ______________________________________________________________________
1447+ 9FF3             >//              Heap part
1447+ 9FF3             >
1447+ 9FF3             >
1447+ 9FF3             >                org     (Heap_Ptr & $1FFF) + $E000
1447+ E311             >
1447+ E311             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1447+ E311             >Latest_Definition defl  Heap_Ptr
1447+ E311             >
1447+ E311             >                // dummy db directives used to calculate length of namec
1447+ E311 2B          >                db      "+"
1447+ E312             >len_NFA         defl    $ - temp_NFA
1447+ E312             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1447+ E311             >
1447+ E311 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1447+ E312 2B          >                db      "+"               // name string in 7-bit ascii, but
1447+ E313             >                org     $-1                 // alter last byte of Name just above to set
1447+ E312 AB          >                db      {b $} | END_BIT     // msb as name end
1447+ E313             >
1447+ E313 0A 03       >                dw      Prev_Ptr            // Link to previous definition Name
1447+ E315             >Prev_Ptr        defl    Heap_Ptr
1447+ E315             >
1447+ E315             >mirror_Ptr      defl    $
1447+ E315             >
1447+ E315 F5 9F       >                dw      Dict_Ptr + 2        // xt
1447+ E317             >Heap_Ptr        defl    $ - $E000           // save current HP
1447+ E317             >
1447+ E317             >Current_HP      defl  $ - $E000             // used to set HP once!
1447+ E317             >
1447+ E317             >//              ______________________________________________________________________
1447+ E317             >//              Dictionary part
1447+ E317             >
1447+ E317             >                org     Dict_Ptr
1447+ 9FF3             >
1447+ 9FF3 15 22       >                dw      mirror_Ptr - $E000 + $1F00
1447+ 9FF5             >
1447+ 9FF5             >PLUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1447+ 9FF5 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1447+ 9FF5 ~           >
1447+ 9FF5 ~           >
1447+ 9FF5             >                endif           ; ok        // for other definitions it "points" the correct handler
1447+ 9FF5             >                // Use of "; ok" to suppress "warning[fwdref]"
1447+ 9FF5             >
1447+ 9FF5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1448+ 9FF5 D9                           exx
1449+ 9FF6 E1                           pop     hl
1450+ 9FF7 D1                           pop     de
1451+ 9FF8 19                           add     hl, de
1452+ 9FF9 E5                           push    hl
1453+ 9FFA D9                           exx
1454+ 9FFB                              next
1454+ 9FFB DD E9       >                jp      (ix)
1455+ 9FFD
1456+ 9FFD
1457+ 9FFD              //  ______________________________________________________________________
1458+ 9FFD              //
1459+ 9FFD              // d+           d1 d2 -- d3
1460+ 9FFD              // returns the unsigned sum of two top double-numbers
1461+ 9FFD              //      d2  d1
1462+ 9FFD              //      h l h l
1463+ 9FFD              // SP   LHEDLHED
1464+ 9FFD              // SP  +01234567
1465+ 9FFD                              New_Def DPLUS, "D+", is_code, is_normal
1465+ 9FFD             >
1465+ 9FFD             >Dict_Ptr        defl    $
1465+ 9FFD             >
1465+ 9FFD             >//              ______________________________________________________________________
1465+ 9FFD             >//              Heap part
1465+ 9FFD             >
1465+ 9FFD             >
1465+ 9FFD             >                org     (Heap_Ptr & $1FFF) + $E000
1465+ E317             >
1465+ E317             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1465+ E317             >Latest_Definition defl  Heap_Ptr
1465+ E317             >
1465+ E317             >                // dummy db directives used to calculate length of namec
1465+ E317 44 2B       >                db      "D+"
1465+ E319             >len_NFA         defl    $ - temp_NFA
1465+ E319             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1465+ E317             >
1465+ E317 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1465+ E318 44 2B       >                db      "D+"               // name string in 7-bit ascii, but
1465+ E31A             >                org     $-1                 // alter last byte of Name just above to set
1465+ E319 AB          >                db      {b $} | END_BIT     // msb as name end
1465+ E31A             >
1465+ E31A 11 03       >                dw      Prev_Ptr            // Link to previous definition Name
1465+ E31C             >Prev_Ptr        defl    Heap_Ptr
1465+ E31C             >
1465+ E31C             >mirror_Ptr      defl    $
1465+ E31C             >
1465+ E31C FF 9F       >                dw      Dict_Ptr + 2        // xt
1465+ E31E             >Heap_Ptr        defl    $ - $E000           // save current HP
1465+ E31E             >
1465+ E31E             >Current_HP      defl  $ - $E000             // used to set HP once!
1465+ E31E             >
1465+ E31E             >//              ______________________________________________________________________
1465+ E31E             >//              Dictionary part
1465+ E31E             >
1465+ E31E             >                org     Dict_Ptr
1465+ 9FFD             >
1465+ 9FFD 1C 22       >                dw      mirror_Ptr - $E000 + $1F00
1465+ 9FFF             >
1465+ 9FFF             >DPLUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1465+ 9FFF ~           >                call    runcode ; ok        // for primitive definitions  actual code
1465+ 9FFF ~           >
1465+ 9FFF ~           >
1465+ 9FFF             >                endif           ; ok        // for other definitions it "points" the correct handler
1465+ 9FFF             >                // Use of "; ok" to suppress "warning[fwdref]"
1465+ 9FFF             >
1465+ 9FFF             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1466+ 9FFF
1467+ 9FFF D9                           exx
1468+ A000 C1                           pop     bc                  // bc := d2.H
1469+ A001 D1                           pop     de                  // hl := d2.L
1470+ A002 E1                           pop     hl                  // d1.H
1471+ A003 E3                           ex      (sp), hl            // d1.L
1472+ A004 19                           add     hl, de              // hl := d2.L + d1.L
1473+ A005 E3                           ex      (sp), hl            // d1.H
1474+ A006 ED 4A                        adc     hl, bc              // d1.H + d2.H
1475+ A008 E5                           push    hl
1476+ A009 D9                           exx
1477+ A00A                              next
1477+ A00A DD E9       >                jp      (ix)
1478+ A00C
1479+ A00C              //  ______________________________________________________________________
1480+ A00C              //
1481+ A00C              // 1+           n1 -- n2
1482+ A00C              // increment by 1 top of stack
1483+ A00C                              New_Def ONE_PLUS, "1+", is_code, is_normal
1483+ A00C             >
1483+ A00C             >Dict_Ptr        defl    $
1483+ A00C             >
1483+ A00C             >//              ______________________________________________________________________
1483+ A00C             >//              Heap part
1483+ A00C             >
1483+ A00C             >
1483+ A00C             >                org     (Heap_Ptr & $1FFF) + $E000
1483+ E31E             >
1483+ E31E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1483+ E31E             >Latest_Definition defl  Heap_Ptr
1483+ E31E             >
1483+ E31E             >                // dummy db directives used to calculate length of namec
1483+ E31E 31 2B       >                db      "1+"
1483+ E320             >len_NFA         defl    $ - temp_NFA
1483+ E320             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1483+ E31E             >
1483+ E31E 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1483+ E31F 31 2B       >                db      "1+"               // name string in 7-bit ascii, but
1483+ E321             >                org     $-1                 // alter last byte of Name just above to set
1483+ E320 AB          >                db      {b $} | END_BIT     // msb as name end
1483+ E321             >
1483+ E321 17 03       >                dw      Prev_Ptr            // Link to previous definition Name
1483+ E323             >Prev_Ptr        defl    Heap_Ptr
1483+ E323             >
1483+ E323             >mirror_Ptr      defl    $
1483+ E323             >
1483+ E323 0E A0       >                dw      Dict_Ptr + 2        // xt
1483+ E325             >Heap_Ptr        defl    $ - $E000           // save current HP
1483+ E325             >
1483+ E325             >Current_HP      defl  $ - $E000             // used to set HP once!
1483+ E325             >
1483+ E325             >//              ______________________________________________________________________
1483+ E325             >//              Dictionary part
1483+ E325             >
1483+ E325             >                org     Dict_Ptr
1483+ A00C             >
1483+ A00C 23 22       >                dw      mirror_Ptr - $E000 + $1F00
1483+ A00E             >
1483+ A00E             >ONE_PLUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1483+ A00E ~           >                call    runcode ; ok        // for primitive definitions  actual code
1483+ A00E ~           >
1483+ A00E ~           >
1483+ A00E             >                endif           ; ok        // for other definitions it "points" the correct handler
1483+ A00E             >                // Use of "; ok" to suppress "warning[fwdref]"
1483+ A00E             >
1483+ A00E             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1484+ A00E E1                           pop     hl
1485+ A00F 23                           inc     hl
1486+ A010
1487+ A010                              psh1
1487+ A010 E5          >                push    hl
1487+ A011 DD E9       >                jp      (ix)
1488+ A013
1489+ A013              //  ______________________________________________________________________
1490+ A013              //
1491+ A013              // 1-           n1 -- n2
1492+ A013              // decrement by 1 top of stack
1493+ A013                              New_Def ONE_SUBTRACT, "1-", is_code, is_normal
1493+ A013             >
1493+ A013             >Dict_Ptr        defl    $
1493+ A013             >
1493+ A013             >//              ______________________________________________________________________
1493+ A013             >//              Heap part
1493+ A013             >
1493+ A013             >
1493+ A013             >                org     (Heap_Ptr & $1FFF) + $E000
1493+ E325             >
1493+ E325             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1493+ E325             >Latest_Definition defl  Heap_Ptr
1493+ E325             >
1493+ E325             >                // dummy db directives used to calculate length of namec
1493+ E325 31 2D       >                db      "1-"
1493+ E327             >len_NFA         defl    $ - temp_NFA
1493+ E327             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1493+ E325             >
1493+ E325 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1493+ E326 31 2D       >                db      "1-"               // name string in 7-bit ascii, but
1493+ E328             >                org     $-1                 // alter last byte of Name just above to set
1493+ E327 AD          >                db      {b $} | END_BIT     // msb as name end
1493+ E328             >
1493+ E328 1E 03       >                dw      Prev_Ptr            // Link to previous definition Name
1493+ E32A             >Prev_Ptr        defl    Heap_Ptr
1493+ E32A             >
1493+ E32A             >mirror_Ptr      defl    $
1493+ E32A             >
1493+ E32A 15 A0       >                dw      Dict_Ptr + 2        // xt
1493+ E32C             >Heap_Ptr        defl    $ - $E000           // save current HP
1493+ E32C             >
1493+ E32C             >Current_HP      defl  $ - $E000             // used to set HP once!
1493+ E32C             >
1493+ E32C             >//              ______________________________________________________________________
1493+ E32C             >//              Dictionary part
1493+ E32C             >
1493+ E32C             >                org     Dict_Ptr
1493+ A013             >
1493+ A013 2A 22       >                dw      mirror_Ptr - $E000 + $1F00
1493+ A015             >
1493+ A015             >ONE_SUBTRACT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1493+ A015 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1493+ A015 ~           >
1493+ A015 ~           >
1493+ A015             >                endif           ; ok        // for other definitions it "points" the correct handler
1493+ A015             >                // Use of "; ok" to suppress "warning[fwdref]"
1493+ A015             >
1493+ A015             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1494+ A015 E1                           pop     hl
1495+ A016 2B                           dec     hl
1496+ A017
1497+ A017                              psh1
1497+ A017 E5          >                push    hl
1497+ A018 DD E9       >                jp      (ix)
1498+ A01A
1499+ A01A              //  ______________________________________________________________________
1500+ A01A              //
1501+ A01A              // 2+           n1 -- n2
1502+ A01A              // increment by 2 top of stack
1503+ A01A                              New_Def TWO_PLUS, "2+", is_code, is_normal
1503+ A01A             >
1503+ A01A             >Dict_Ptr        defl    $
1503+ A01A             >
1503+ A01A             >//              ______________________________________________________________________
1503+ A01A             >//              Heap part
1503+ A01A             >
1503+ A01A             >
1503+ A01A             >                org     (Heap_Ptr & $1FFF) + $E000
1503+ E32C             >
1503+ E32C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1503+ E32C             >Latest_Definition defl  Heap_Ptr
1503+ E32C             >
1503+ E32C             >                // dummy db directives used to calculate length of namec
1503+ E32C 32 2B       >                db      "2+"
1503+ E32E             >len_NFA         defl    $ - temp_NFA
1503+ E32E             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1503+ E32C             >
1503+ E32C 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1503+ E32D 32 2B       >                db      "2+"               // name string in 7-bit ascii, but
1503+ E32F             >                org     $-1                 // alter last byte of Name just above to set
1503+ E32E AB          >                db      {b $} | END_BIT     // msb as name end
1503+ E32F             >
1503+ E32F 25 03       >                dw      Prev_Ptr            // Link to previous definition Name
1503+ E331             >Prev_Ptr        defl    Heap_Ptr
1503+ E331             >
1503+ E331             >mirror_Ptr      defl    $
1503+ E331             >
1503+ E331 1C A0       >                dw      Dict_Ptr + 2        // xt
1503+ E333             >Heap_Ptr        defl    $ - $E000           // save current HP
1503+ E333             >
1503+ E333             >Current_HP      defl  $ - $E000             // used to set HP once!
1503+ E333             >
1503+ E333             >//              ______________________________________________________________________
1503+ E333             >//              Dictionary part
1503+ E333             >
1503+ E333             >                org     Dict_Ptr
1503+ A01A             >
1503+ A01A 31 22       >                dw      mirror_Ptr - $E000 + $1F00
1503+ A01C             >
1503+ A01C             >TWO_PLUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1503+ A01C ~           >                call    runcode ; ok        // for primitive definitions  actual code
1503+ A01C ~           >
1503+ A01C ~           >
1503+ A01C             >                endif           ; ok        // for other definitions it "points" the correct handler
1503+ A01C             >                // Use of "; ok" to suppress "warning[fwdref]"
1503+ A01C             >
1503+ A01C             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1504+ A01C              Two_Plus:
1505+ A01C E1                           pop     hl
1506+ A01D 23                           inc     hl
1507+ A01E 23                           inc     hl
1508+ A01F
1509+ A01F                              psh1
1509+ A01F E5          >                push    hl
1509+ A020 DD E9       >                jp      (ix)
1510+ A022
1511+ A022              //  ______________________________________________________________________
1512+ A022              //
1513+ A022              // cell+        a1 -- a2
1514+ A022              // increment by 2 top of stack
1515+ A022                              New_Def CELL_PLUS, "CELL+", is_code, is_normal
1515+ A022             >
1515+ A022             >Dict_Ptr        defl    $
1515+ A022             >
1515+ A022             >//              ______________________________________________________________________
1515+ A022             >//              Heap part
1515+ A022             >
1515+ A022             >
1515+ A022             >                org     (Heap_Ptr & $1FFF) + $E000
1515+ E333             >
1515+ E333             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1515+ E333             >Latest_Definition defl  Heap_Ptr
1515+ E333             >
1515+ E333             >                // dummy db directives used to calculate length of namec
1515+ E333 43 45 4C 4C >                db      "CELL+"
1515+ E337 2B          >
1515+ E338             >len_NFA         defl    $ - temp_NFA
1515+ E338             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1515+ E333             >
1515+ E333 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1515+ E334 43 45 4C 4C >                db      "CELL+"               // name string in 7-bit ascii, but
1515+ E338 2B          >
1515+ E339             >                org     $-1                 // alter last byte of Name just above to set
1515+ E338 AB          >                db      {b $} | END_BIT     // msb as name end
1515+ E339             >
1515+ E339 2C 03       >                dw      Prev_Ptr            // Link to previous definition Name
1515+ E33B             >Prev_Ptr        defl    Heap_Ptr
1515+ E33B             >
1515+ E33B             >mirror_Ptr      defl    $
1515+ E33B             >
1515+ E33B 24 A0       >                dw      Dict_Ptr + 2        // xt
1515+ E33D             >Heap_Ptr        defl    $ - $E000           // save current HP
1515+ E33D             >
1515+ E33D             >Current_HP      defl  $ - $E000             // used to set HP once!
1515+ E33D             >
1515+ E33D             >//              ______________________________________________________________________
1515+ E33D             >//              Dictionary part
1515+ E33D             >
1515+ E33D             >                org     Dict_Ptr
1515+ A022             >
1515+ A022 3B 22       >                dw      mirror_Ptr - $E000 + $1F00
1515+ A024             >
1515+ A024             >CELL_PLUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1515+ A024 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1515+ A024 ~           >
1515+ A024 ~           >
1515+ A024             >                endif           ; ok        // for other definitions it "points" the correct handler
1515+ A024             >                // Use of "; ok" to suppress "warning[fwdref]"
1515+ A024             >
1515+ A024             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1516+ A024 C3 1C A0                     jp      Two_Plus
1517+ A027
1518+ A027              //  ______________________________________________________________________
1519+ A027              //
1520+ A027              // align        a1 -- a2
1521+ A027              // align memory : not used
1522+ A027              //              New_Def ALIGN_ADDR, "ALIGN", is_code, is_normal
1523+ A027              //            next
1524+ A027
1525+ A027              //  ______________________________________________________________________
1526+ A027              //
1527+ A027              // cell-        a1 -- a2
1528+ A027              // decrement by 2 top of stack
1529+ A027                              New_Def CELL_MINUS, "CELL-", is_code, is_normal
1529+ A027             >
1529+ A027             >Dict_Ptr        defl    $
1529+ A027             >
1529+ A027             >//              ______________________________________________________________________
1529+ A027             >//              Heap part
1529+ A027             >
1529+ A027             >
1529+ A027             >                org     (Heap_Ptr & $1FFF) + $E000
1529+ E33D             >
1529+ E33D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1529+ E33D             >Latest_Definition defl  Heap_Ptr
1529+ E33D             >
1529+ E33D             >                // dummy db directives used to calculate length of namec
1529+ E33D 43 45 4C 4C >                db      "CELL-"
1529+ E341 2D          >
1529+ E342             >len_NFA         defl    $ - temp_NFA
1529+ E342             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1529+ E33D             >
1529+ E33D 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1529+ E33E 43 45 4C 4C >                db      "CELL-"               // name string in 7-bit ascii, but
1529+ E342 2D          >
1529+ E343             >                org     $-1                 // alter last byte of Name just above to set
1529+ E342 AD          >                db      {b $} | END_BIT     // msb as name end
1529+ E343             >
1529+ E343 33 03       >                dw      Prev_Ptr            // Link to previous definition Name
1529+ E345             >Prev_Ptr        defl    Heap_Ptr
1529+ E345             >
1529+ E345             >mirror_Ptr      defl    $
1529+ E345             >
1529+ E345 29 A0       >                dw      Dict_Ptr + 2        // xt
1529+ E347             >Heap_Ptr        defl    $ - $E000           // save current HP
1529+ E347             >
1529+ E347             >Current_HP      defl  $ - $E000             // used to set HP once!
1529+ E347             >
1529+ E347             >//              ______________________________________________________________________
1529+ E347             >//              Dictionary part
1529+ E347             >
1529+ E347             >                org     Dict_Ptr
1529+ A027             >
1529+ A027 45 22       >                dw      mirror_Ptr - $E000 + $1F00
1529+ A029             >
1529+ A029             >CELL_MINUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1529+ A029 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1529+ A029 ~           >
1529+ A029 ~           >
1529+ A029             >                endif           ; ok        // for other definitions it "points" the correct handler
1529+ A029             >                // Use of "; ok" to suppress "warning[fwdref]"
1529+ A029             >
1529+ A029             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1530+ A029              CellMinus:
1531+ A029 E1                           pop     hl
1532+ A02A 2B                           dec     hl
1533+ A02B 2B                           dec     hl
1534+ A02C
1535+ A02C                              psh1
1535+ A02C E5          >                push    hl
1535+ A02D DD E9       >                jp      (ix)
1536+ A02F
1537+ A02F              //  ______________________________________________________________________
1538+ A02F              //
1539+ A02F              // 2-           a1 -- a2
1540+ A02F              // decrement by 2 top of stack
1541+ A02F                              New_Def TWO_MINUS, "2-", is_code, is_normal
1541+ A02F             >
1541+ A02F             >Dict_Ptr        defl    $
1541+ A02F             >
1541+ A02F             >//              ______________________________________________________________________
1541+ A02F             >//              Heap part
1541+ A02F             >
1541+ A02F             >
1541+ A02F             >                org     (Heap_Ptr & $1FFF) + $E000
1541+ E347             >
1541+ E347             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1541+ E347             >Latest_Definition defl  Heap_Ptr
1541+ E347             >
1541+ E347             >                // dummy db directives used to calculate length of namec
1541+ E347 32 2D       >                db      "2-"
1541+ E349             >len_NFA         defl    $ - temp_NFA
1541+ E349             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1541+ E347             >
1541+ E347 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1541+ E348 32 2D       >                db      "2-"               // name string in 7-bit ascii, but
1541+ E34A             >                org     $-1                 // alter last byte of Name just above to set
1541+ E349 AD          >                db      {b $} | END_BIT     // msb as name end
1541+ E34A             >
1541+ E34A 3D 03       >                dw      Prev_Ptr            // Link to previous definition Name
1541+ E34C             >Prev_Ptr        defl    Heap_Ptr
1541+ E34C             >
1541+ E34C             >mirror_Ptr      defl    $
1541+ E34C             >
1541+ E34C 31 A0       >                dw      Dict_Ptr + 2        // xt
1541+ E34E             >Heap_Ptr        defl    $ - $E000           // save current HP
1541+ E34E             >
1541+ E34E             >Current_HP      defl  $ - $E000             // used to set HP once!
1541+ E34E             >
1541+ E34E             >//              ______________________________________________________________________
1541+ E34E             >//              Dictionary part
1541+ E34E             >
1541+ E34E             >                org     Dict_Ptr
1541+ A02F             >
1541+ A02F 4C 22       >                dw      mirror_Ptr - $E000 + $1F00
1541+ A031             >
1541+ A031             >TWO_MINUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1541+ A031 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1541+ A031 ~           >
1541+ A031 ~           >
1541+ A031             >                endif           ; ok        // for other definitions it "points" the correct handler
1541+ A031             >                // Use of "; ok" to suppress "warning[fwdref]"
1541+ A031             >
1541+ A031             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1542+ A031 C3 29 A0                     jp      CellMinus
1543+ A034
1544+ A034              //  ______________________________________________________________________
1545+ A034              //
1546+ A034              // negate       n1 -- n2
1547+ A034              // change the sign of number
1548+ A034                              New_Def MINUS, "NEGATE", is_code, is_normal
1548+ A034             >
1548+ A034             >Dict_Ptr        defl    $
1548+ A034             >
1548+ A034             >//              ______________________________________________________________________
1548+ A034             >//              Heap part
1548+ A034             >
1548+ A034             >
1548+ A034             >                org     (Heap_Ptr & $1FFF) + $E000
1548+ E34E             >
1548+ E34E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1548+ E34E             >Latest_Definition defl  Heap_Ptr
1548+ E34E             >
1548+ E34E             >                // dummy db directives used to calculate length of namec
1548+ E34E 4E 45 47 41 >                db      "NEGATE"
1548+ E352 54 45       >
1548+ E354             >len_NFA         defl    $ - temp_NFA
1548+ E354             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1548+ E34E             >
1548+ E34E 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1548+ E34F 4E 45 47 41 >                db      "NEGATE"               // name string in 7-bit ascii, but
1548+ E353 54 45       >
1548+ E355             >                org     $-1                 // alter last byte of Name just above to set
1548+ E354 C5          >                db      {b $} | END_BIT     // msb as name end
1548+ E355             >
1548+ E355 47 03       >                dw      Prev_Ptr            // Link to previous definition Name
1548+ E357             >Prev_Ptr        defl    Heap_Ptr
1548+ E357             >
1548+ E357             >mirror_Ptr      defl    $
1548+ E357             >
1548+ E357 36 A0       >                dw      Dict_Ptr + 2        // xt
1548+ E359             >Heap_Ptr        defl    $ - $E000           // save current HP
1548+ E359             >
1548+ E359             >Current_HP      defl  $ - $E000             // used to set HP once!
1548+ E359             >
1548+ E359             >//              ______________________________________________________________________
1548+ E359             >//              Dictionary part
1548+ E359             >
1548+ E359             >                org     Dict_Ptr
1548+ A034             >
1548+ A034 57 22       >                dw      mirror_Ptr - $E000 + $1F00
1548+ A036             >
1548+ A036             >MINUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1548+ A036 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1548+ A036 ~           >
1548+ A036 ~           >
1548+ A036             >                endif           ; ok        // for other definitions it "points" the correct handler
1548+ A036             >                // Use of "; ok" to suppress "warning[fwdref]"
1548+ A036             >
1548+ A036             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1549+ A036 D9                           exx
1550+ A037 21 00 00                     ld      hl, 0               // subtract from 0
1551+ A03A D1                           pop     de
1552+ A03B B7                           or      a
1553+ A03C ED 52                        sbc     hl, de
1554+ A03E E5                           push    hl
1555+ A03F D9                           exx
1556+ A040                              next
1556+ A040 DD E9       >                jp      (ix)
1557+ A042
1558+ A042              //  ______________________________________________________________________
1559+ A042              //
1560+ A042              // dnegate      d1 -- d2
1561+ A042              // change the sign of a double number
1562+ A042                              New_Def DMINUS, "DNEGATE", is_code, is_normal
1562+ A042             >
1562+ A042             >Dict_Ptr        defl    $
1562+ A042             >
1562+ A042             >//              ______________________________________________________________________
1562+ A042             >//              Heap part
1562+ A042             >
1562+ A042             >
1562+ A042             >                org     (Heap_Ptr & $1FFF) + $E000
1562+ E359             >
1562+ E359             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1562+ E359             >Latest_Definition defl  Heap_Ptr
1562+ E359             >
1562+ E359             >                // dummy db directives used to calculate length of namec
1562+ E359 44 4E 45 47 >                db      "DNEGATE"
1562+ E35D 41 54 45    >
1562+ E360             >len_NFA         defl    $ - temp_NFA
1562+ E360             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1562+ E359             >
1562+ E359 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1562+ E35A 44 4E 45 47 >                db      "DNEGATE"               // name string in 7-bit ascii, but
1562+ E35E 41 54 45    >
1562+ E361             >                org     $-1                 // alter last byte of Name just above to set
1562+ E360 C5          >                db      {b $} | END_BIT     // msb as name end
1562+ E361             >
1562+ E361 4E 03       >                dw      Prev_Ptr            // Link to previous definition Name
1562+ E363             >Prev_Ptr        defl    Heap_Ptr
1562+ E363             >
1562+ E363             >mirror_Ptr      defl    $
1562+ E363             >
1562+ E363 44 A0       >                dw      Dict_Ptr + 2        // xt
1562+ E365             >Heap_Ptr        defl    $ - $E000           // save current HP
1562+ E365             >
1562+ E365             >Current_HP      defl  $ - $E000             // used to set HP once!
1562+ E365             >
1562+ E365             >//              ______________________________________________________________________
1562+ E365             >//              Dictionary part
1562+ E365             >
1562+ E365             >                org     Dict_Ptr
1562+ A042             >
1562+ A042 63 22       >                dw      mirror_Ptr - $E000 + $1F00
1562+ A044             >
1562+ A044             >DMINUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1562+ A044 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1562+ A044 ~           >
1562+ A044 ~           >
1562+ A044             >                endif           ; ok        // for other definitions it "points" the correct handler
1562+ A044             >                // Use of "; ok" to suppress "warning[fwdref]"
1562+ A044             >
1562+ A044             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1563+ A044 D9                           exx
1564+ A045 C1                           pop     bc                  // d1.H
1565+ A046 D1                           pop     de                  // d1.L
1566+ A047 AF                           xor     a
1567+ A048 67                           ld      h, a
1568+ A049 6F                           ld      l, a
1569+ A04A ED 52                        sbc     hl, de              // subtact from zero
1570+ A04C E5                           push    hl                  // > d2-L
1571+ A04D 67                           ld      h, a
1572+ A04E 6F                           ld      l, a
1573+ A04F ED 42                        sbc     hl, bc              // subtract from zero with carry
1574+ A051                                                          // > d2-H
1575+ A051 E5                           push    hl
1576+ A052 D9                           exx
1577+ A053                              next
1577+ A053 DD E9       >                jp      (ix)
1578+ A055
1579+ A055              //  ______________________________________________________________________
1580+ A055              //
1581+ A055              // over         n1 n2 -- n1 n2 n1
1582+ A055              // copy the second value of stack and put it on top.
1583+ A055                              New_Def OVER, "OVER", is_code, is_normal
1583+ A055             >
1583+ A055             >Dict_Ptr        defl    $
1583+ A055             >
1583+ A055             >//              ______________________________________________________________________
1583+ A055             >//              Heap part
1583+ A055             >
1583+ A055             >
1583+ A055             >                org     (Heap_Ptr & $1FFF) + $E000
1583+ E365             >
1583+ E365             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1583+ E365             >Latest_Definition defl  Heap_Ptr
1583+ E365             >
1583+ E365             >                // dummy db directives used to calculate length of namec
1583+ E365 4F 56 45 52 >                db      "OVER"
1583+ E369             >len_NFA         defl    $ - temp_NFA
1583+ E369             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1583+ E365             >
1583+ E365 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1583+ E366 4F 56 45 52 >                db      "OVER"               // name string in 7-bit ascii, but
1583+ E36A             >                org     $-1                 // alter last byte of Name just above to set
1583+ E369 D2          >                db      {b $} | END_BIT     // msb as name end
1583+ E36A             >
1583+ E36A 59 03       >                dw      Prev_Ptr            // Link to previous definition Name
1583+ E36C             >Prev_Ptr        defl    Heap_Ptr
1583+ E36C             >
1583+ E36C             >mirror_Ptr      defl    $
1583+ E36C             >
1583+ E36C 57 A0       >                dw      Dict_Ptr + 2        // xt
1583+ E36E             >Heap_Ptr        defl    $ - $E000           // save current HP
1583+ E36E             >
1583+ E36E             >Current_HP      defl  $ - $E000             // used to set HP once!
1583+ E36E             >
1583+ E36E             >//              ______________________________________________________________________
1583+ E36E             >//              Dictionary part
1583+ E36E             >
1583+ E36E             >                org     Dict_Ptr
1583+ A055             >
1583+ A055 6C 22       >                dw      mirror_Ptr - $E000 + $1F00
1583+ A057             >
1583+ A057             >OVER:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1583+ A057 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1583+ A057 ~           >
1583+ A057 ~           >
1583+ A057             >                endif           ; ok        // for other definitions it "points" the correct handler
1583+ A057             >                // Use of "; ok" to suppress "warning[fwdref]"
1583+ A057             >
1583+ A057             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1584+ A057                              // exx     // we can use af instead OPTIMIZATION possible
1585+ A057 F1                           pop     af                  //   n2
1586+ A058 E1                           pop     hl                  // < n1
1587+ A059 E5                           push    hl                  // > n1
1588+ A05A F5                           push    af                  // > n2
1589+ A05B E5                           push    hl                  // > n1
1590+ A05C                              // exx
1591+ A05C                              next
1591+ A05C DD E9       >                jp      (ix)
1592+ A05E
1593+ A05E              //  ______________________________________________________________________
1594+ A05E              //
1595+ A05E              // drop         n1 --
1596+ A05E              // drops the top of stack
1597+ A05E                              New_Def DROP, "DROP", is_code, is_normal
1597+ A05E             >
1597+ A05E             >Dict_Ptr        defl    $
1597+ A05E             >
1597+ A05E             >//              ______________________________________________________________________
1597+ A05E             >//              Heap part
1597+ A05E             >
1597+ A05E             >
1597+ A05E             >                org     (Heap_Ptr & $1FFF) + $E000
1597+ E36E             >
1597+ E36E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1597+ E36E             >Latest_Definition defl  Heap_Ptr
1597+ E36E             >
1597+ E36E             >                // dummy db directives used to calculate length of namec
1597+ E36E 44 52 4F 50 >                db      "DROP"
1597+ E372             >len_NFA         defl    $ - temp_NFA
1597+ E372             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1597+ E36E             >
1597+ E36E 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1597+ E36F 44 52 4F 50 >                db      "DROP"               // name string in 7-bit ascii, but
1597+ E373             >                org     $-1                 // alter last byte of Name just above to set
1597+ E372 D0          >                db      {b $} | END_BIT     // msb as name end
1597+ E373             >
1597+ E373 65 03       >                dw      Prev_Ptr            // Link to previous definition Name
1597+ E375             >Prev_Ptr        defl    Heap_Ptr
1597+ E375             >
1597+ E375             >mirror_Ptr      defl    $
1597+ E375             >
1597+ E375 60 A0       >                dw      Dict_Ptr + 2        // xt
1597+ E377             >Heap_Ptr        defl    $ - $E000           // save current HP
1597+ E377             >
1597+ E377             >Current_HP      defl  $ - $E000             // used to set HP once!
1597+ E377             >
1597+ E377             >//              ______________________________________________________________________
1597+ E377             >//              Dictionary part
1597+ E377             >
1597+ E377             >                org     Dict_Ptr
1597+ A05E             >
1597+ A05E 75 22       >                dw      mirror_Ptr - $E000 + $1F00
1597+ A060             >
1597+ A060             >DROP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1597+ A060 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1597+ A060 ~           >
1597+ A060 ~           >
1597+ A060             >                endif           ; ok        // for other definitions it "points" the correct handler
1597+ A060             >                // Use of "; ok" to suppress "warning[fwdref]"
1597+ A060             >
1597+ A060             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1598+ A060 E1                           pop     hl                  // < n1 and discard previous TOS
1599+ A061                              next
1599+ A061 DD E9       >                jp      (ix)
1600+ A063
1601+ A063              //  ______________________________________________________________________
1602+ A063              //
1603+ A063              // nip          n1 n2 -- n2
1604+ A063              // drops the second elemento on the stack
1605+ A063                              New_Def NIP, "NIP", is_code, is_normal
1605+ A063             >
1605+ A063             >Dict_Ptr        defl    $
1605+ A063             >
1605+ A063             >//              ______________________________________________________________________
1605+ A063             >//              Heap part
1605+ A063             >
1605+ A063             >
1605+ A063             >                org     (Heap_Ptr & $1FFF) + $E000
1605+ E377             >
1605+ E377             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1605+ E377             >Latest_Definition defl  Heap_Ptr
1605+ E377             >
1605+ E377             >                // dummy db directives used to calculate length of namec
1605+ E377 4E 49 50    >                db      "NIP"
1605+ E37A             >len_NFA         defl    $ - temp_NFA
1605+ E37A             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1605+ E377             >
1605+ E377 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1605+ E378 4E 49 50    >                db      "NIP"               // name string in 7-bit ascii, but
1605+ E37B             >                org     $-1                 // alter last byte of Name just above to set
1605+ E37A D0          >                db      {b $} | END_BIT     // msb as name end
1605+ E37B             >
1605+ E37B 6E 03       >                dw      Prev_Ptr            // Link to previous definition Name
1605+ E37D             >Prev_Ptr        defl    Heap_Ptr
1605+ E37D             >
1605+ E37D             >mirror_Ptr      defl    $
1605+ E37D             >
1605+ E37D 65 A0       >                dw      Dict_Ptr + 2        // xt
1605+ E37F             >Heap_Ptr        defl    $ - $E000           // save current HP
1605+ E37F             >
1605+ E37F             >Current_HP      defl  $ - $E000             // used to set HP once!
1605+ E37F             >
1605+ E37F             >//              ______________________________________________________________________
1605+ E37F             >//              Dictionary part
1605+ E37F             >
1605+ E37F             >                org     Dict_Ptr
1605+ A063             >
1605+ A063 7D 22       >                dw      mirror_Ptr - $E000 + $1F00
1605+ A065             >
1605+ A065             >NIP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1605+ A065 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1605+ A065 ~           >
1605+ A065 ~           >
1605+ A065             >                endif           ; ok        // for other definitions it "points" the correct handler
1605+ A065             >                // Use of "; ok" to suppress "warning[fwdref]"
1605+ A065             >
1605+ A065             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1606+ A065
1607+ A065 E1                           pop     hl                  // < n1 discarded
1608+ A066 E3                           ex      (sp), hl
1609+ A067                              next
1609+ A067 DD E9       >                jp      (ix)
1610+ A069
1611+ A069              //  ______________________________________________________________________
1612+ A069              //
1613+ A069              // tuck         n1 n2 -- n2 n1 n2
1614+ A069              // copy the top element after the second.
1615+ A069                              New_Def TUCK, "TUCK", is_code, is_normal
1615+ A069             >
1615+ A069             >Dict_Ptr        defl    $
1615+ A069             >
1615+ A069             >//              ______________________________________________________________________
1615+ A069             >//              Heap part
1615+ A069             >
1615+ A069             >
1615+ A069             >                org     (Heap_Ptr & $1FFF) + $E000
1615+ E37F             >
1615+ E37F             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1615+ E37F             >Latest_Definition defl  Heap_Ptr
1615+ E37F             >
1615+ E37F             >                // dummy db directives used to calculate length of namec
1615+ E37F 54 55 43 4B >                db      "TUCK"
1615+ E383             >len_NFA         defl    $ - temp_NFA
1615+ E383             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1615+ E37F             >
1615+ E37F 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1615+ E380 54 55 43 4B >                db      "TUCK"               // name string in 7-bit ascii, but
1615+ E384             >                org     $-1                 // alter last byte of Name just above to set
1615+ E383 CB          >                db      {b $} | END_BIT     // msb as name end
1615+ E384             >
1615+ E384 77 03       >                dw      Prev_Ptr            // Link to previous definition Name
1615+ E386             >Prev_Ptr        defl    Heap_Ptr
1615+ E386             >
1615+ E386             >mirror_Ptr      defl    $
1615+ E386             >
1615+ E386 6B A0       >                dw      Dict_Ptr + 2        // xt
1615+ E388             >Heap_Ptr        defl    $ - $E000           // save current HP
1615+ E388             >
1615+ E388             >Current_HP      defl  $ - $E000             // used to set HP once!
1615+ E388             >
1615+ E388             >//              ______________________________________________________________________
1615+ E388             >//              Dictionary part
1615+ E388             >
1615+ E388             >                org     Dict_Ptr
1615+ A069             >
1615+ A069 86 22       >                dw      mirror_Ptr - $E000 + $1F00
1615+ A06B             >
1615+ A06B             >TUCK:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1615+ A06B ~           >                call    runcode ; ok        // for primitive definitions  actual code
1615+ A06B ~           >
1615+ A06B ~           >
1615+ A06B             >                endif           ; ok        // for other definitions it "points" the correct handler
1615+ A06B             >                // Use of "; ok" to suppress "warning[fwdref]"
1615+ A06B             >
1615+ A06B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1616+ A06B E1                           pop     hl
1617+ A06C F1                           pop     af                  // < n1
1618+ A06D E5                           push    hl                  // > n2  and TOS
1619+ A06E F5                           push    af                  // > n1
1620+ A06F E5                           push    hl
1621+ A070                              next
1621+ A070 DD E9       >                jp      (ix)
1622+ A072
1623+ A072              //  ______________________________________________________________________
1624+ A072              //
1625+ A072              // swap         n1 n2 -- n2 n1
1626+ A072              // swaps the two values on top of stack
1627+ A072                              New_Def SWAP, "SWAP", is_code, is_normal
1627+ A072             >
1627+ A072             >Dict_Ptr        defl    $
1627+ A072             >
1627+ A072             >//              ______________________________________________________________________
1627+ A072             >//              Heap part
1627+ A072             >
1627+ A072             >
1627+ A072             >                org     (Heap_Ptr & $1FFF) + $E000
1627+ E388             >
1627+ E388             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1627+ E388             >Latest_Definition defl  Heap_Ptr
1627+ E388             >
1627+ E388             >                // dummy db directives used to calculate length of namec
1627+ E388 53 57 41 50 >                db      "SWAP"
1627+ E38C             >len_NFA         defl    $ - temp_NFA
1627+ E38C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1627+ E388             >
1627+ E388 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1627+ E389 53 57 41 50 >                db      "SWAP"               // name string in 7-bit ascii, but
1627+ E38D             >                org     $-1                 // alter last byte of Name just above to set
1627+ E38C D0          >                db      {b $} | END_BIT     // msb as name end
1627+ E38D             >
1627+ E38D 7F 03       >                dw      Prev_Ptr            // Link to previous definition Name
1627+ E38F             >Prev_Ptr        defl    Heap_Ptr
1627+ E38F             >
1627+ E38F             >mirror_Ptr      defl    $
1627+ E38F             >
1627+ E38F 74 A0       >                dw      Dict_Ptr + 2        // xt
1627+ E391             >Heap_Ptr        defl    $ - $E000           // save current HP
1627+ E391             >
1627+ E391             >Current_HP      defl  $ - $E000             // used to set HP once!
1627+ E391             >
1627+ E391             >//              ______________________________________________________________________
1627+ E391             >//              Dictionary part
1627+ E391             >
1627+ E391             >                org     Dict_Ptr
1627+ A072             >
1627+ A072 8F 22       >                dw      mirror_Ptr - $E000 + $1F00
1627+ A074             >
1627+ A074             >SWAP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1627+ A074 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1627+ A074 ~           >
1627+ A074 ~           >
1627+ A074             >                endif           ; ok        // for other definitions it "points" the correct handler
1627+ A074             >                // Use of "; ok" to suppress "warning[fwdref]"
1627+ A074             >
1627+ A074             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1628+ A074 E1                           pop     hl                  // < n1
1629+ A075 E3                           ex      (sp),hl             // > n2
1630+ A076 E5                           push    hl                  // copy n1 to TOS
1631+ A077                              next
1631+ A077 DD E9       >                jp      (ix)
1632+ A079
1633+ A079              //  ______________________________________________________________________
1634+ A079              //
1635+ A079              // dup         n -- n n
1636+ A079              // duplicates the top value of stack
1637+ A079                              New_Def DUP, "DUP", is_code, is_normal
1637+ A079             >
1637+ A079             >Dict_Ptr        defl    $
1637+ A079             >
1637+ A079             >//              ______________________________________________________________________
1637+ A079             >//              Heap part
1637+ A079             >
1637+ A079             >
1637+ A079             >                org     (Heap_Ptr & $1FFF) + $E000
1637+ E391             >
1637+ E391             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1637+ E391             >Latest_Definition defl  Heap_Ptr
1637+ E391             >
1637+ E391             >                // dummy db directives used to calculate length of namec
1637+ E391 44 55 50    >                db      "DUP"
1637+ E394             >len_NFA         defl    $ - temp_NFA
1637+ E394             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1637+ E391             >
1637+ E391 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1637+ E392 44 55 50    >                db      "DUP"               // name string in 7-bit ascii, but
1637+ E395             >                org     $-1                 // alter last byte of Name just above to set
1637+ E394 D0          >                db      {b $} | END_BIT     // msb as name end
1637+ E395             >
1637+ E395 88 03       >                dw      Prev_Ptr            // Link to previous definition Name
1637+ E397             >Prev_Ptr        defl    Heap_Ptr
1637+ E397             >
1637+ E397             >mirror_Ptr      defl    $
1637+ E397             >
1637+ E397 7B A0       >                dw      Dict_Ptr + 2        // xt
1637+ E399             >Heap_Ptr        defl    $ - $E000           // save current HP
1637+ E399             >
1637+ E399             >Current_HP      defl  $ - $E000             // used to set HP once!
1637+ E399             >
1637+ E399             >//              ______________________________________________________________________
1637+ E399             >//              Dictionary part
1637+ E399             >
1637+ E399             >                org     Dict_Ptr
1637+ A079             >
1637+ A079 97 22       >                dw      mirror_Ptr - $E000 + $1F00
1637+ A07B             >
1637+ A07B             >DUP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1637+ A07B ~           >                call    runcode ; ok        // for primitive definitions  actual code
1637+ A07B ~           >
1637+ A07B ~           >
1637+ A07B             >                endif           ; ok        // for other definitions it "points" the correct handler
1637+ A07B             >                // Use of "; ok" to suppress "warning[fwdref]"
1637+ A07B             >
1637+ A07B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1638+ A07B E1                           pop     hl
1639+ A07C E5                           push    hl                  // > n duplicate TOS
1640+ A07D E5                           push    hl
1641+ A07E                              next
1641+ A07E DD E9       >                jp      (ix)
1642+ A080
1643+ A080              //  ______________________________________________________________________
1644+ A080              //
1645+ A080              // rot         n1 n2 n3 -- n2 n3 n1
1646+ A080              // Rotates the 3 top values of stack by picking the 3rd in access-order
1647+ A080              // and putting it on top. The other two are shifted down one place.
1648+ A080                              New_Def ROT, "ROT", is_code, is_normal
1648+ A080             >
1648+ A080             >Dict_Ptr        defl    $
1648+ A080             >
1648+ A080             >//              ______________________________________________________________________
1648+ A080             >//              Heap part
1648+ A080             >
1648+ A080             >
1648+ A080             >                org     (Heap_Ptr & $1FFF) + $E000
1648+ E399             >
1648+ E399             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1648+ E399             >Latest_Definition defl  Heap_Ptr
1648+ E399             >
1648+ E399             >                // dummy db directives used to calculate length of namec
1648+ E399 52 4F 54    >                db      "ROT"
1648+ E39C             >len_NFA         defl    $ - temp_NFA
1648+ E39C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1648+ E399             >
1648+ E399 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1648+ E39A 52 4F 54    >                db      "ROT"               // name string in 7-bit ascii, but
1648+ E39D             >                org     $-1                 // alter last byte of Name just above to set
1648+ E39C D4          >                db      {b $} | END_BIT     // msb as name end
1648+ E39D             >
1648+ E39D 91 03       >                dw      Prev_Ptr            // Link to previous definition Name
1648+ E39F             >Prev_Ptr        defl    Heap_Ptr
1648+ E39F             >
1648+ E39F             >mirror_Ptr      defl    $
1648+ E39F             >
1648+ E39F 82 A0       >                dw      Dict_Ptr + 2        // xt
1648+ E3A1             >Heap_Ptr        defl    $ - $E000           // save current HP
1648+ E3A1             >
1648+ E3A1             >Current_HP      defl  $ - $E000             // used to set HP once!
1648+ E3A1             >
1648+ E3A1             >//              ______________________________________________________________________
1648+ E3A1             >//              Dictionary part
1648+ E3A1             >
1648+ E3A1             >                org     Dict_Ptr
1648+ A080             >
1648+ A080 9F 22       >                dw      mirror_Ptr - $E000 + $1F00
1648+ A082             >
1648+ A082             >ROT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1648+ A082 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1648+ A082 ~           >
1648+ A082 ~           >
1648+ A082             >                endif           ; ok        // for other definitions it "points" the correct handler
1648+ A082             >                // Use of "; ok" to suppress "warning[fwdref]"
1648+ A082             >
1648+ A082             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1649+ A082 D9                           exx
1650+ A083 D1                           pop     de                  // < n3
1651+ A084 E1                           pop     hl                  // < n2
1652+ A085 E3                           ex      (sp),hl             // > n2 < n1
1653+ A086 D5                           push    de                  // > n3
1654+ A087 E5                           push    hl                  // copy n1 to TOS
1655+ A088 D9                           exx
1656+ A089                              next
1656+ A089 DD E9       >                jp      (ix)
1657+ A08B
1658+ A08B              //  ______________________________________________________________________
1659+ A08B              //
1660+ A08B              // -rot         n1 n2 n3 -- n3 n1 n2
1661+ A08B              // Rotates the 3 top values of stack by picking the 1st in access-order
1662+ A08B              // and putting back to 3rd place. The other two are shifted down one place.
1663+ A08B                              New_Def DASH_ROT, "-ROT", is_code, is_normal
1663+ A08B             >
1663+ A08B             >Dict_Ptr        defl    $
1663+ A08B             >
1663+ A08B             >//              ______________________________________________________________________
1663+ A08B             >//              Heap part
1663+ A08B             >
1663+ A08B             >
1663+ A08B             >                org     (Heap_Ptr & $1FFF) + $E000
1663+ E3A1             >
1663+ E3A1             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1663+ E3A1             >Latest_Definition defl  Heap_Ptr
1663+ E3A1             >
1663+ E3A1             >                // dummy db directives used to calculate length of namec
1663+ E3A1 2D 52 4F 54 >                db      "-ROT"
1663+ E3A5             >len_NFA         defl    $ - temp_NFA
1663+ E3A5             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1663+ E3A1             >
1663+ E3A1 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1663+ E3A2 2D 52 4F 54 >                db      "-ROT"               // name string in 7-bit ascii, but
1663+ E3A6             >                org     $-1                 // alter last byte of Name just above to set
1663+ E3A5 D4          >                db      {b $} | END_BIT     // msb as name end
1663+ E3A6             >
1663+ E3A6 99 03       >                dw      Prev_Ptr            // Link to previous definition Name
1663+ E3A8             >Prev_Ptr        defl    Heap_Ptr
1663+ E3A8             >
1663+ E3A8             >mirror_Ptr      defl    $
1663+ E3A8             >
1663+ E3A8 8D A0       >                dw      Dict_Ptr + 2        // xt
1663+ E3AA             >Heap_Ptr        defl    $ - $E000           // save current HP
1663+ E3AA             >
1663+ E3AA             >Current_HP      defl  $ - $E000             // used to set HP once!
1663+ E3AA             >
1663+ E3AA             >//              ______________________________________________________________________
1663+ E3AA             >//              Dictionary part
1663+ E3AA             >
1663+ E3AA             >                org     Dict_Ptr
1663+ A08B             >
1663+ A08B A8 22       >                dw      mirror_Ptr - $E000 + $1F00
1663+ A08D             >
1663+ A08D             >DASH_ROT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1663+ A08D ~           >                call    runcode ; ok        // for primitive definitions  actual code
1663+ A08D ~           >
1663+ A08D ~           >
1663+ A08D             >                endif           ; ok        // for other definitions it "points" the correct handler
1663+ A08D             >                // Use of "; ok" to suppress "warning[fwdref]"
1663+ A08D             >
1663+ A08D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1664+ A08D D9                           exx
1665+ A08E E1                           pop     hl                  // < n3
1666+ A08F D1                           pop     de                  // < n2
1667+ A090 E3                           ex      (sp),hl             // > n3 < n1
1668+ A091 E5                           push    hl                  // > n1
1669+ A092 D5                           push    de                  // copy n3 to TOS
1670+ A093 D9                           exx
1671+ A094                              next
1671+ A094 DD E9       >                jp      (ix)
1672+ A096
1673+ A096              //  ______________________________________________________________________
1674+ A096              //
1675+ A096              // pick        n1 -- nx
1676+ A096              // picks the nth element from TOS
1677+ A096                              New_Def PICK, "PICK", is_code, is_normal
1677+ A096             >
1677+ A096             >Dict_Ptr        defl    $
1677+ A096             >
1677+ A096             >//              ______________________________________________________________________
1677+ A096             >//              Heap part
1677+ A096             >
1677+ A096             >
1677+ A096             >                org     (Heap_Ptr & $1FFF) + $E000
1677+ E3AA             >
1677+ E3AA             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1677+ E3AA             >Latest_Definition defl  Heap_Ptr
1677+ E3AA             >
1677+ E3AA             >                // dummy db directives used to calculate length of namec
1677+ E3AA 50 49 43 4B >                db      "PICK"
1677+ E3AE             >len_NFA         defl    $ - temp_NFA
1677+ E3AE             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1677+ E3AA             >
1677+ E3AA 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1677+ E3AB 50 49 43 4B >                db      "PICK"               // name string in 7-bit ascii, but
1677+ E3AF             >                org     $-1                 // alter last byte of Name just above to set
1677+ E3AE CB          >                db      {b $} | END_BIT     // msb as name end
1677+ E3AF             >
1677+ E3AF A1 03       >                dw      Prev_Ptr            // Link to previous definition Name
1677+ E3B1             >Prev_Ptr        defl    Heap_Ptr
1677+ E3B1             >
1677+ E3B1             >mirror_Ptr      defl    $
1677+ E3B1             >
1677+ E3B1 98 A0       >                dw      Dict_Ptr + 2        // xt
1677+ E3B3             >Heap_Ptr        defl    $ - $E000           // save current HP
1677+ E3B3             >
1677+ E3B3             >Current_HP      defl  $ - $E000             // used to set HP once!
1677+ E3B3             >
1677+ E3B3             >//              ______________________________________________________________________
1677+ E3B3             >//              Dictionary part
1677+ E3B3             >
1677+ E3B3             >                org     Dict_Ptr
1677+ A096             >
1677+ A096 B1 22       >                dw      mirror_Ptr - $E000 + $1F00
1677+ A098             >
1677+ A098             >PICK:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1677+ A098 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1677+ A098 ~           >
1677+ A098 ~           >
1677+ A098             >                endif           ; ok        // for other definitions it "points" the correct handler
1677+ A098             >                // Use of "; ok" to suppress "warning[fwdref]"
1677+ A098             >
1677+ A098             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1678+ A098 E1                           pop     hl                  // take TOS as index
1679+ A099 29                           add     hl, hl              // as cells
1680+ A09A 39                           add     hl, sp              // from Stack Pointer
1681+ A09B 7E                           ld      a, (hl)             // replace TOS
1682+ A09C 23                           inc     hl
1683+ A09D 66                           ld      h, (hl)
1684+ A09E 6F                           ld      l, a
1685+ A09F E5                           push    hl
1686+ A0A0                              next
1686+ A0A0 DD E9       >                jp      (ix)
1687+ A0A2
1688+ A0A2
1689+ A0A2              //  ______________________________________________________________________
1690+ A0A2              //
1691+ A0A2              // roll        n1 n2 n3 ... n -- n2 n3 ... n1
1692+ A0A2              // picks the nth element from TOS
1693+ A0A2              //              New_Def ROLL, "ROLL", is_code, is_normal
1694+ A0A2              //              exx                     // we need all registers free
1695+ A0A2              //              pop     hl              // number of cells to roll
1696+ A0A2              //              ld      a, h
1697+ A0A2              //              or       l
1698+ A0A2              //              jr      z, Roll_Zero
1699+ A0A2              //                  add     hl, hl              // number of bytes to move
1700+ A0A2              //                  ld      b, h
1701+ A0A2              //                  ld      c, l
1702+ A0A2              //                  add     hl, sp          // address of n1
1703+ A0A2              //                  ld      a, (hl)         // take n1 into a and a,
1704+ A0A2              //                  inc     hl
1705+ A0A2              //                  ex      af, af'
1706+ A0A2              //                  ld      a, (hl)         // take n1 into a and a,
1707+ A0A2              //                  ld      d, h
1708+ A0A2              //                  ld      e, l
1709+ A0A2              //                  dec     hl
1710+ A0A2              //                  dec     hl
1711+ A0A2              //                  lddr
1712+ A0A2              //                  ex      de, hl
1713+ A0A2              //                  ld      (hl), a
1714+ A0A2              //                  dec     hl
1715+ A0A2              //                  ex      af, af'
1716+ A0A2              //                  ld      (hl), a
1717+ A0A2              //Roll_Zero:
1718+ A0A2              //              exx
1719+ A0A2              //              next
1720+ A0A2
1721+ A0A2
1722+ A0A2              //  ______________________________________________________________________
1723+ A0A2              //
1724+ A0A2              // 2over        d1 d2 -- d1 d2 d1
1725+ A0A2              //              n1 n2 n3 n4 -- n1 n2 n3 n4 n1 n2
1726+ A0A2              // copy the second double of stack and put on top.
1727+ A0A2              //              New_Def TWO_OVER, "2OVER", is_code, is_normal
1728+ A0A2              //              exx
1729+ A0A2              //              ld      hl, 7
1730+ A0A2              //              add     hl, sp
1731+ A0A2              //              ld      d, (hl)
1732+ A0A2              //              dec     hl
1733+ A0A2              //              ld      e, (hl)             // d1-L
1734+ A0A2              //              push    de
1735+ A0A2              //              dec     hl
1736+ A0A2              //              ld      d, (hl)
1737+ A0A2              //              dec     hl
1738+ A0A2              //              ld      e, (hl)             // d1-H
1739+ A0A2              //              push    de
1740+ A0A2              //              exx
1741+ A0A2              //              next
1742+ A0A2
1743+ A0A2              //  ______________________________________________________________________
1744+ A0A2              //
1745+ A0A2              // 2drop        d --
1746+ A0A2              //              n1 n2 --
1747+ A0A2              // drops the top double from stack
1748+ A0A2                              New_Def TWO_DROP, "2DROP", is_code, is_normal
1748+ A0A2             >
1748+ A0A2             >Dict_Ptr        defl    $
1748+ A0A2             >
1748+ A0A2             >//              ______________________________________________________________________
1748+ A0A2             >//              Heap part
1748+ A0A2             >
1748+ A0A2             >
1748+ A0A2             >                org     (Heap_Ptr & $1FFF) + $E000
1748+ E3B3             >
1748+ E3B3             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1748+ E3B3             >Latest_Definition defl  Heap_Ptr
1748+ E3B3             >
1748+ E3B3             >                // dummy db directives used to calculate length of namec
1748+ E3B3 32 44 52 4F >                db      "2DROP"
1748+ E3B7 50          >
1748+ E3B8             >len_NFA         defl    $ - temp_NFA
1748+ E3B8             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1748+ E3B3             >
1748+ E3B3 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1748+ E3B4 32 44 52 4F >                db      "2DROP"               // name string in 7-bit ascii, but
1748+ E3B8 50          >
1748+ E3B9             >                org     $-1                 // alter last byte of Name just above to set
1748+ E3B8 D0          >                db      {b $} | END_BIT     // msb as name end
1748+ E3B9             >
1748+ E3B9 AA 03       >                dw      Prev_Ptr            // Link to previous definition Name
1748+ E3BB             >Prev_Ptr        defl    Heap_Ptr
1748+ E3BB             >
1748+ E3BB             >mirror_Ptr      defl    $
1748+ E3BB             >
1748+ E3BB A4 A0       >                dw      Dict_Ptr + 2        // xt
1748+ E3BD             >Heap_Ptr        defl    $ - $E000           // save current HP
1748+ E3BD             >
1748+ E3BD             >Current_HP      defl  $ - $E000             // used to set HP once!
1748+ E3BD             >
1748+ E3BD             >//              ______________________________________________________________________
1748+ E3BD             >//              Dictionary part
1748+ E3BD             >
1748+ E3BD             >                org     Dict_Ptr
1748+ A0A2             >
1748+ A0A2 BB 22       >                dw      mirror_Ptr - $E000 + $1F00
1748+ A0A4             >
1748+ A0A4             >TWO_DROP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1748+ A0A4 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1748+ A0A4 ~           >
1748+ A0A4 ~           >
1748+ A0A4             >                endif           ; ok        // for other definitions it "points" the correct handler
1748+ A0A4             >                // Use of "; ok" to suppress "warning[fwdref]"
1748+ A0A4             >
1748+ A0A4             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1749+ A0A4 E1                           pop     hl
1750+ A0A5 E1                           pop     hl
1751+ A0A6                              next
1751+ A0A6 DD E9       >                jp      (ix)
1752+ A0A8
1753+ A0A8              //  ______________________________________________________________________
1754+ A0A8              //
1755+ A0A8              // 2nip         d1 d2 -- d2
1756+ A0A8              //              n1 n2 n3 n4 -- n3 n4
1757+ A0A8              // drops the second double on the stack
1758+ A0A8              //              New_Def TWO_NIP, 4, "2nip"
1759+ A0A8              //              ...
1760+ A0A8
1761+ A0A8              //  ______________________________________________________________________
1762+ A0A8              //
1763+ A0A8              // 2tuck         d1 d2 -- d2 d1 d2
1764+ A0A8              // copy the top element after the second.
1765+ A0A8              //              New_Def TWO_TUCK, 5, "2tuck"
1766+ A0A8              //              ...
1767+ A0A8
1768+ A0A8              //  ______________________________________________________________________
1769+ A0A8              //
1770+ A0A8              // 2swap         d1 d2 -- d2 d1
1771+ A0A8              //               n1 n2 n3 n4 -- n3 n4 n1 n2
1772+ A0A8              // swaps the two doubles on top of stack
1773+ A0A8                              New_Def TWO_SWAP, "2SWAP", is_code, is_normal
1773+ A0A8             >
1773+ A0A8             >Dict_Ptr        defl    $
1773+ A0A8             >
1773+ A0A8             >//              ______________________________________________________________________
1773+ A0A8             >//              Heap part
1773+ A0A8             >
1773+ A0A8             >
1773+ A0A8             >                org     (Heap_Ptr & $1FFF) + $E000
1773+ E3BD             >
1773+ E3BD             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1773+ E3BD             >Latest_Definition defl  Heap_Ptr
1773+ E3BD             >
1773+ E3BD             >                // dummy db directives used to calculate length of namec
1773+ E3BD 32 53 57 41 >                db      "2SWAP"
1773+ E3C1 50          >
1773+ E3C2             >len_NFA         defl    $ - temp_NFA
1773+ E3C2             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1773+ E3BD             >
1773+ E3BD 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1773+ E3BE 32 53 57 41 >                db      "2SWAP"               // name string in 7-bit ascii, but
1773+ E3C2 50          >
1773+ E3C3             >                org     $-1                 // alter last byte of Name just above to set
1773+ E3C2 D0          >                db      {b $} | END_BIT     // msb as name end
1773+ E3C3             >
1773+ E3C3 B3 03       >                dw      Prev_Ptr            // Link to previous definition Name
1773+ E3C5             >Prev_Ptr        defl    Heap_Ptr
1773+ E3C5             >
1773+ E3C5             >mirror_Ptr      defl    $
1773+ E3C5             >
1773+ E3C5 AA A0       >                dw      Dict_Ptr + 2        // xt
1773+ E3C7             >Heap_Ptr        defl    $ - $E000           // save current HP
1773+ E3C7             >
1773+ E3C7             >Current_HP      defl  $ - $E000             // used to set HP once!
1773+ E3C7             >
1773+ E3C7             >//              ______________________________________________________________________
1773+ E3C7             >//              Dictionary part
1773+ E3C7             >
1773+ E3C7             >                org     Dict_Ptr
1773+ A0A8             >
1773+ A0A8 C5 22       >                dw      mirror_Ptr - $E000 + $1F00
1773+ A0AA             >
1773+ A0AA             >TWO_SWAP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1773+ A0AA ~           >                call    runcode ; ok        // for primitive definitions  actual code
1773+ A0AA ~           >
1773+ A0AA ~           >
1773+ A0AA             >                endif           ; ok        // for other definitions it "points" the correct handler
1773+ A0AA             >                // Use of "; ok" to suppress "warning[fwdref]"
1773+ A0AA             >
1773+ A0AA             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1774+ A0AA D9                           exx
1775+ A0AB F1                           pop     af                  //   d2-H
1776+ A0AC E1                           pop     hl                  // < d2-L
1777+ A0AD D1                           pop     de                  // < d1-H
1778+ A0AE E3                           ex      (sp), hl            // < d1-L > d2-L
1779+ A0AF F5                           push    af                  // > d2-H
1780+ A0B0 E5                           push    hl                  // > d1-L
1781+ A0B1 D5                           push    de
1782+ A0B2 D9                           exx
1783+ A0B3                              next
1783+ A0B3 DD E9       >                jp      (ix)
1784+ A0B5
1785+ A0B5              //  ______________________________________________________________________
1786+ A0B5              //
1787+ A0B5              // 2dup         d -- d d
1788+ A0B5              //              n1 n2 -- n1 n2 n1 n2
1789+ A0B5              // duplicates the top double of stack
1790+ A0B5                              New_Def TWO_DUP, "2DUP", is_code, is_normal
1790+ A0B5             >
1790+ A0B5             >Dict_Ptr        defl    $
1790+ A0B5             >
1790+ A0B5             >//              ______________________________________________________________________
1790+ A0B5             >//              Heap part
1790+ A0B5             >
1790+ A0B5             >
1790+ A0B5             >                org     (Heap_Ptr & $1FFF) + $E000
1790+ E3C7             >
1790+ E3C7             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1790+ E3C7             >Latest_Definition defl  Heap_Ptr
1790+ E3C7             >
1790+ E3C7             >                // dummy db directives used to calculate length of namec
1790+ E3C7 32 44 55 50 >                db      "2DUP"
1790+ E3CB             >len_NFA         defl    $ - temp_NFA
1790+ E3CB             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1790+ E3C7             >
1790+ E3C7 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1790+ E3C8 32 44 55 50 >                db      "2DUP"               // name string in 7-bit ascii, but
1790+ E3CC             >                org     $-1                 // alter last byte of Name just above to set
1790+ E3CB D0          >                db      {b $} | END_BIT     // msb as name end
1790+ E3CC             >
1790+ E3CC BD 03       >                dw      Prev_Ptr            // Link to previous definition Name
1790+ E3CE             >Prev_Ptr        defl    Heap_Ptr
1790+ E3CE             >
1790+ E3CE             >mirror_Ptr      defl    $
1790+ E3CE             >
1790+ E3CE B7 A0       >                dw      Dict_Ptr + 2        // xt
1790+ E3D0             >Heap_Ptr        defl    $ - $E000           // save current HP
1790+ E3D0             >
1790+ E3D0             >Current_HP      defl  $ - $E000             // used to set HP once!
1790+ E3D0             >
1790+ E3D0             >//              ______________________________________________________________________
1790+ E3D0             >//              Dictionary part
1790+ E3D0             >
1790+ E3D0             >                org     Dict_Ptr
1790+ A0B5             >
1790+ A0B5 CE 22       >                dw      mirror_Ptr - $E000 + $1F00
1790+ A0B7             >
1790+ A0B7             >TWO_DUP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1790+ A0B7 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1790+ A0B7 ~           >
1790+ A0B7 ~           >
1790+ A0B7             >                endif           ; ok        // for other definitions it "points" the correct handler
1790+ A0B7             >                // Use of "; ok" to suppress "warning[fwdref]"
1790+ A0B7             >
1790+ A0B7             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1791+ A0B7 E1                           pop     hl                  // < d-H
1792+ A0B8 F1                           pop     af                  // < d-L
1793+ A0B9 F5                           push    af                  // < d-L
1794+ A0BA E5                           push    hl                  // > d-H
1795+ A0BB F5                           push    af                  // > d-L
1796+ A0BC E5                           push    hl                  // > d-H
1797+ A0BD                              next
1797+ A0BD DD E9       >                jp      (ix)
1798+ A0BF
1799+ A0BF              //  ______________________________________________________________________
1800+ A0BF              //
1801+ A0BF              // 2rot         d1 d2 d3 -- d2 d3 d1
1802+ A0BF              //              n1 n2 n3 n4 n5 n6 -- n3 n4 n5 n6 n1 n2
1803+ A0BF              // Rotates the 3 top doubles of stack by picking the 3rd in access-order
1804+ A0BF              // and putting it on top. The other two are shifted down one place.
1805+ A0BF              //              New_Def TWO?ROT, 4, "2rot"
1806+ A0BF              //              ...
1807+ A0BF              //              New_Def TWO_ROT, "2ROT", is_code, is_normal
1808+ A0BF              //
1809+ A0BF              //      d3  |d2  |d1  |
1810+ A0BF              //      h l |h l |h l |
1811+ A0BF              // SP   LHED|LHED|LHED|
1812+ A0BF              // SP  +0123|4567|89ab|
1813+ A0BF              //              ld      hl, $000B
1814+ A0BF              //              add     hl, sp
1815+ A0BF              //              ld      d, (hl)
1816+ A0BF              //              dec     hl
1817+ A0BF              //              ld      e, (hl)
1818+ A0BF              //              dec     hl
1819+ A0BF              //              push    de
1820+ A0BF              //              ld      d, (hl)
1821+ A0BF              //              dec     hl
1822+ A0BF              //              ld      e, (hl)
1823+ A0BF              //              dec     hl
1824+ A0BF              //              push    de
1825+ A0BF
1826+ A0BF              //      d1  |d3  |d2  |d1  |
1827+ A0BF              //      h l |h l |h l |h l |
1828+ A0BF              // SP   LHED|LHED|LHED|LHED|
1829+ A0BF              // SP       +0123|4567|89ab|
1830+ A0BF
1831+ A0BF              //              ld      d, h
1832+ A0BF              //              ld      e, l
1833+ A0BF              //              inc     de
1834+ A0BF              //              inc     de
1835+ A0BF              //              inc     de
1836+ A0BF              //              inc     de
1837+ A0BF              //              push    bc
1838+ A0BF              //              ld      bc, $000C
1839+ A0BF              //              lddr
1840+ A0BF              //              pop     bc
1841+ A0BF              //              pop     de
1842+ A0BF              //              pop     de
1843+ A0BF              //
1844+ A0BF              //              next
1845+ A0BF
1846+ A0BF
1847+ A0BF              //  ______________________________________________________________________
1848+ A0BF              //
1849+ A0BF              // +!           n a --
1850+ A0BF              // Sums to the content of address a the number n.
1851+ A0BF              // It is the same of  a @ n + a !
1852+ A0BF                              New_Def PLUSSTORE, "+!", is_code, is_normal
1852+ A0BF             >
1852+ A0BF             >Dict_Ptr        defl    $
1852+ A0BF             >
1852+ A0BF             >//              ______________________________________________________________________
1852+ A0BF             >//              Heap part
1852+ A0BF             >
1852+ A0BF             >
1852+ A0BF             >                org     (Heap_Ptr & $1FFF) + $E000
1852+ E3D0             >
1852+ E3D0             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1852+ E3D0             >Latest_Definition defl  Heap_Ptr
1852+ E3D0             >
1852+ E3D0             >                // dummy db directives used to calculate length of namec
1852+ E3D0 2B 21       >                db      "+!"
1852+ E3D2             >len_NFA         defl    $ - temp_NFA
1852+ E3D2             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1852+ E3D0             >
1852+ E3D0 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1852+ E3D1 2B 21       >                db      "+!"               // name string in 7-bit ascii, but
1852+ E3D3             >                org     $-1                 // alter last byte of Name just above to set
1852+ E3D2 A1          >                db      {b $} | END_BIT     // msb as name end
1852+ E3D3             >
1852+ E3D3 C7 03       >                dw      Prev_Ptr            // Link to previous definition Name
1852+ E3D5             >Prev_Ptr        defl    Heap_Ptr
1852+ E3D5             >
1852+ E3D5             >mirror_Ptr      defl    $
1852+ E3D5             >
1852+ E3D5 C1 A0       >                dw      Dict_Ptr + 2        // xt
1852+ E3D7             >Heap_Ptr        defl    $ - $E000           // save current HP
1852+ E3D7             >
1852+ E3D7             >Current_HP      defl  $ - $E000             // used to set HP once!
1852+ E3D7             >
1852+ E3D7             >//              ______________________________________________________________________
1852+ E3D7             >//              Dictionary part
1852+ E3D7             >
1852+ E3D7             >                org     Dict_Ptr
1852+ A0BF             >
1852+ A0BF D5 22       >                dw      mirror_Ptr - $E000 + $1F00
1852+ A0C1             >
1852+ A0C1             >PLUSSTORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1852+ A0C1 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1852+ A0C1 ~           >
1852+ A0C1 ~           >
1852+ A0C1             >                endif           ; ok        // for other definitions it "points" the correct handler
1852+ A0C1             >                // Use of "; ok" to suppress "warning[fwdref]"
1852+ A0C1             >
1852+ A0C1             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1853+ A0C1 D9                           exx
1854+ A0C2 E1                           pop     hl                  // hl is the address
1855+ A0C3 D1                           pop     de                  // de is the number
1856+ A0C4 7E                           ld      a, (hl)
1857+ A0C5 83                           add     e
1858+ A0C6 77                           ld      (hl), a
1859+ A0C7 23                           inc     hl
1860+ A0C8 7E                           ld      a, (hl)
1861+ A0C9 8A                           adc     d
1862+ A0CA 77                           ld      (hl), a
1863+ A0CB D9                           exx
1864+ A0CC                              next
1864+ A0CC DD E9       >                jp      (ix)
1865+ A0CE
1866+ A0CE              //  ______________________________________________________________________
1867+ A0CE              //
1868+ A0CE              // toggle       a n --
1869+ A0CE              // Complements (xor) the byte at addrress  a  with the model n.
1870+ A0CE                              New_Def TOGGLE, "TOGGLE", is_code, is_normal
1870+ A0CE             >
1870+ A0CE             >Dict_Ptr        defl    $
1870+ A0CE             >
1870+ A0CE             >//              ______________________________________________________________________
1870+ A0CE             >//              Heap part
1870+ A0CE             >
1870+ A0CE             >
1870+ A0CE             >                org     (Heap_Ptr & $1FFF) + $E000
1870+ E3D7             >
1870+ E3D7             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1870+ E3D7             >Latest_Definition defl  Heap_Ptr
1870+ E3D7             >
1870+ E3D7             >                // dummy db directives used to calculate length of namec
1870+ E3D7 54 4F 47 47 >                db      "TOGGLE"
1870+ E3DB 4C 45       >
1870+ E3DD             >len_NFA         defl    $ - temp_NFA
1870+ E3DD             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1870+ E3D7             >
1870+ E3D7 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1870+ E3D8 54 4F 47 47 >                db      "TOGGLE"               // name string in 7-bit ascii, but
1870+ E3DC 4C 45       >
1870+ E3DE             >                org     $-1                 // alter last byte of Name just above to set
1870+ E3DD C5          >                db      {b $} | END_BIT     // msb as name end
1870+ E3DE             >
1870+ E3DE D0 03       >                dw      Prev_Ptr            // Link to previous definition Name
1870+ E3E0             >Prev_Ptr        defl    Heap_Ptr
1870+ E3E0             >
1870+ E3E0             >mirror_Ptr      defl    $
1870+ E3E0             >
1870+ E3E0 D0 A0       >                dw      Dict_Ptr + 2        // xt
1870+ E3E2             >Heap_Ptr        defl    $ - $E000           // save current HP
1870+ E3E2             >
1870+ E3E2             >Current_HP      defl  $ - $E000             // used to set HP once!
1870+ E3E2             >
1870+ E3E2             >//              ______________________________________________________________________
1870+ E3E2             >//              Dictionary part
1870+ E3E2             >
1870+ E3E2             >                org     Dict_Ptr
1870+ A0CE             >
1870+ A0CE E0 22       >                dw      mirror_Ptr - $E000 + $1F00
1870+ A0D0             >
1870+ A0D0             >TOGGLE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1870+ A0D0 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1870+ A0D0 ~           >
1870+ A0D0 ~           >
1870+ A0D0             >                endif           ; ok        // for other definitions it "points" the correct handler
1870+ A0D0             >                // Use of "; ok" to suppress "warning[fwdref]"
1870+ A0D0             >
1870+ A0D0             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1871+ A0D0 E1                           pop     hl
1872+ A0D1 7D                           ld      a, l
1873+ A0D2 E1                           pop     hl
1874+ A0D3 AE                           xor     (hl)
1875+ A0D4 77                           ld      (hl), a
1876+ A0D5
1877+ A0D5                              next
1877+ A0D5 DD E9       >                jp      (ix)
1878+ A0D7
1879+ A0D7              //  ______________________________________________________________________
1880+ A0D7              //
1881+ A0D7              // @            a -- n
1882+ A0D7              // fetch 16 bit number n from address a. Z80 keeps high byte is in high memory
1883+ A0D7                              New_Def FETCH, "@", is_code, is_normal
1883+ A0D7             >
1883+ A0D7             >Dict_Ptr        defl    $
1883+ A0D7             >
1883+ A0D7             >//              ______________________________________________________________________
1883+ A0D7             >//              Heap part
1883+ A0D7             >
1883+ A0D7             >
1883+ A0D7             >                org     (Heap_Ptr & $1FFF) + $E000
1883+ E3E2             >
1883+ E3E2             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1883+ E3E2             >Latest_Definition defl  Heap_Ptr
1883+ E3E2             >
1883+ E3E2             >                // dummy db directives used to calculate length of namec
1883+ E3E2 40          >                db      "@"
1883+ E3E3             >len_NFA         defl    $ - temp_NFA
1883+ E3E3             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1883+ E3E2             >
1883+ E3E2 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1883+ E3E3 40          >                db      "@"               // name string in 7-bit ascii, but
1883+ E3E4             >                org     $-1                 // alter last byte of Name just above to set
1883+ E3E3 C0          >                db      {b $} | END_BIT     // msb as name end
1883+ E3E4             >
1883+ E3E4 D7 03       >                dw      Prev_Ptr            // Link to previous definition Name
1883+ E3E6             >Prev_Ptr        defl    Heap_Ptr
1883+ E3E6             >
1883+ E3E6             >mirror_Ptr      defl    $
1883+ E3E6             >
1883+ E3E6 D9 A0       >                dw      Dict_Ptr + 2        // xt
1883+ E3E8             >Heap_Ptr        defl    $ - $E000           // save current HP
1883+ E3E8             >
1883+ E3E8             >Current_HP      defl  $ - $E000             // used to set HP once!
1883+ E3E8             >
1883+ E3E8             >//              ______________________________________________________________________
1883+ E3E8             >//              Dictionary part
1883+ E3E8             >
1883+ E3E8             >                org     Dict_Ptr
1883+ A0D7             >
1883+ A0D7 E6 22       >                dw      mirror_Ptr - $E000 + $1F00
1883+ A0D9             >
1883+ A0D9             >FETCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1883+ A0D9 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1883+ A0D9 ~           >
1883+ A0D9 ~           >
1883+ A0D9             >                endif           ; ok        // for other definitions it "points" the correct handler
1883+ A0D9             >                // Use of "; ok" to suppress "warning[fwdref]"
1883+ A0D9             >
1883+ A0D9             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1884+ A0D9 E1                           pop     hl
1885+ A0DA 7E                           ld      a, (hl)             // low-byte
1886+ A0DB 23                           inc     hl
1887+ A0DC 66                           ld      h, (hl)             // high-byte
1888+ A0DD 6F                           ld      l, a
1889+ A0DE E5                           push    hl
1890+ A0DF                              next
1890+ A0DF DD E9       >                jp      (ix)
1891+ A0E1
1892+ A0E1              //  ______________________________________________________________________
1893+ A0E1              //
1894+ A0E1              // !            n a --
1895+ A0E1              // store 16 bit number n from address a. Z80 keeps high byte is in high memory
1896+ A0E1                              New_Def STORE, "!", is_code, is_normal
1896+ A0E1             >
1896+ A0E1             >Dict_Ptr        defl    $
1896+ A0E1             >
1896+ A0E1             >//              ______________________________________________________________________
1896+ A0E1             >//              Heap part
1896+ A0E1             >
1896+ A0E1             >
1896+ A0E1             >                org     (Heap_Ptr & $1FFF) + $E000
1896+ E3E8             >
1896+ E3E8             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1896+ E3E8             >Latest_Definition defl  Heap_Ptr
1896+ E3E8             >
1896+ E3E8             >                // dummy db directives used to calculate length of namec
1896+ E3E8 21          >                db      "!"
1896+ E3E9             >len_NFA         defl    $ - temp_NFA
1896+ E3E9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1896+ E3E8             >
1896+ E3E8 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1896+ E3E9 21          >                db      "!"               // name string in 7-bit ascii, but
1896+ E3EA             >                org     $-1                 // alter last byte of Name just above to set
1896+ E3E9 A1          >                db      {b $} | END_BIT     // msb as name end
1896+ E3EA             >
1896+ E3EA E2 03       >                dw      Prev_Ptr            // Link to previous definition Name
1896+ E3EC             >Prev_Ptr        defl    Heap_Ptr
1896+ E3EC             >
1896+ E3EC             >mirror_Ptr      defl    $
1896+ E3EC             >
1896+ E3EC E3 A0       >                dw      Dict_Ptr + 2        // xt
1896+ E3EE             >Heap_Ptr        defl    $ - $E000           // save current HP
1896+ E3EE             >
1896+ E3EE             >Current_HP      defl  $ - $E000             // used to set HP once!
1896+ E3EE             >
1896+ E3EE             >//              ______________________________________________________________________
1896+ E3EE             >//              Dictionary part
1896+ E3EE             >
1896+ E3EE             >                org     Dict_Ptr
1896+ A0E1             >
1896+ A0E1 EC 22       >                dw      mirror_Ptr - $E000 + $1F00
1896+ A0E3             >
1896+ A0E3             >STORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1896+ A0E3 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1896+ A0E3 ~           >
1896+ A0E3 ~           >
1896+ A0E3             >                endif           ; ok        // for other definitions it "points" the correct handler
1896+ A0E3             >                // Use of "; ok" to suppress "warning[fwdref]"
1896+ A0E3             >
1896+ A0E3             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1897+ A0E3 D9                           exx
1898+ A0E4 E1                           pop     hl                  // address
1899+ A0E5 D1                           pop     de                  // < n
1900+ A0E6 73                           ld      (hl), e             // low-byte
1901+ A0E7 23                           inc     hl
1902+ A0E8 72                           ld      (hl), d             // high-byte
1903+ A0E9 D9                           exx
1904+ A0EA                              next
1904+ A0EA DD E9       >                jp      (ix)
1905+ A0EC
1906+ A0EC              //  ______________________________________________________________________
1907+ A0EC              //
1908+ A0EC              // c@           a -- c
1909+ A0EC              // fetch a character n from address a
1910+ A0EC                              New_Def CFETCH, "C@", is_code, is_normal
1910+ A0EC             >
1910+ A0EC             >Dict_Ptr        defl    $
1910+ A0EC             >
1910+ A0EC             >//              ______________________________________________________________________
1910+ A0EC             >//              Heap part
1910+ A0EC             >
1910+ A0EC             >
1910+ A0EC             >                org     (Heap_Ptr & $1FFF) + $E000
1910+ E3EE             >
1910+ E3EE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1910+ E3EE             >Latest_Definition defl  Heap_Ptr
1910+ E3EE             >
1910+ E3EE             >                // dummy db directives used to calculate length of namec
1910+ E3EE 43 40       >                db      "C@"
1910+ E3F0             >len_NFA         defl    $ - temp_NFA
1910+ E3F0             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1910+ E3EE             >
1910+ E3EE 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1910+ E3EF 43 40       >                db      "C@"               // name string in 7-bit ascii, but
1910+ E3F1             >                org     $-1                 // alter last byte of Name just above to set
1910+ E3F0 C0          >                db      {b $} | END_BIT     // msb as name end
1910+ E3F1             >
1910+ E3F1 E8 03       >                dw      Prev_Ptr            // Link to previous definition Name
1910+ E3F3             >Prev_Ptr        defl    Heap_Ptr
1910+ E3F3             >
1910+ E3F3             >mirror_Ptr      defl    $
1910+ E3F3             >
1910+ E3F3 EE A0       >                dw      Dict_Ptr + 2        // xt
1910+ E3F5             >Heap_Ptr        defl    $ - $E000           // save current HP
1910+ E3F5             >
1910+ E3F5             >Current_HP      defl  $ - $E000             // used to set HP once!
1910+ E3F5             >
1910+ E3F5             >//              ______________________________________________________________________
1910+ E3F5             >//              Dictionary part
1910+ E3F5             >
1910+ E3F5             >                org     Dict_Ptr
1910+ A0EC             >
1910+ A0EC F3 22       >                dw      mirror_Ptr - $E000 + $1F00
1910+ A0EE             >
1910+ A0EE             >CFETCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1910+ A0EE ~           >                call    runcode ; ok        // for primitive definitions  actual code
1910+ A0EE ~           >
1910+ A0EE ~           >
1910+ A0EE             >                endif           ; ok        // for other definitions it "points" the correct handler
1910+ A0EE             >                // Use of "; ok" to suppress "warning[fwdref]"
1910+ A0EE             >
1910+ A0EE             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1911+ A0EE E1                           pop     hl
1912+ A0EF 6E                           ld      l, (hl)             // low-byte
1913+ A0F0 26 00                        ld      h, 0
1914+ A0F2
1915+ A0F2                              psh1
1915+ A0F2 E5          >                push    hl
1915+ A0F3 DD E9       >                jp      (ix)
1916+ A0F5
1917+ A0F5              //  ______________________________________________________________________
1918+ A0F5              //
1919+ A0F5              // c!           c a --
1920+ A0F5              // fetch 16 bit number n from address a. Z80 keeps high byte is in high memory
1921+ A0F5                              New_Def CSTORE, "C!", is_code, is_normal
1921+ A0F5             >
1921+ A0F5             >Dict_Ptr        defl    $
1921+ A0F5             >
1921+ A0F5             >//              ______________________________________________________________________
1921+ A0F5             >//              Heap part
1921+ A0F5             >
1921+ A0F5             >
1921+ A0F5             >                org     (Heap_Ptr & $1FFF) + $E000
1921+ E3F5             >
1921+ E3F5             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1921+ E3F5             >Latest_Definition defl  Heap_Ptr
1921+ E3F5             >
1921+ E3F5             >                // dummy db directives used to calculate length of namec
1921+ E3F5 43 21       >                db      "C!"
1921+ E3F7             >len_NFA         defl    $ - temp_NFA
1921+ E3F7             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1921+ E3F5             >
1921+ E3F5 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1921+ E3F6 43 21       >                db      "C!"               // name string in 7-bit ascii, but
1921+ E3F8             >                org     $-1                 // alter last byte of Name just above to set
1921+ E3F7 A1          >                db      {b $} | END_BIT     // msb as name end
1921+ E3F8             >
1921+ E3F8 EE 03       >                dw      Prev_Ptr            // Link to previous definition Name
1921+ E3FA             >Prev_Ptr        defl    Heap_Ptr
1921+ E3FA             >
1921+ E3FA             >mirror_Ptr      defl    $
1921+ E3FA             >
1921+ E3FA F7 A0       >                dw      Dict_Ptr + 2        // xt
1921+ E3FC             >Heap_Ptr        defl    $ - $E000           // save current HP
1921+ E3FC             >
1921+ E3FC             >Current_HP      defl  $ - $E000             // used to set HP once!
1921+ E3FC             >
1921+ E3FC             >//              ______________________________________________________________________
1921+ E3FC             >//              Dictionary part
1921+ E3FC             >
1921+ E3FC             >                org     Dict_Ptr
1921+ A0F5             >
1921+ A0F5 FA 22       >                dw      mirror_Ptr - $E000 + $1F00
1921+ A0F7             >
1921+ A0F7             >CSTORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1921+ A0F7 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1921+ A0F7 ~           >
1921+ A0F7 ~           >
1921+ A0F7             >                endif           ; ok        // for other definitions it "points" the correct handler
1921+ A0F7             >                // Use of "; ok" to suppress "warning[fwdref]"
1921+ A0F7             >
1921+ A0F7             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1922+ A0F7 D9                           exx
1923+ A0F8 E1                           pop     hl                  // < address
1924+ A0F9 D1                           pop     de
1925+ A0FA 73                           ld      (hl), e             // low-byte
1926+ A0FB D9                           exx
1927+ A0FC                              next
1927+ A0FC DD E9       >                jp      (ix)
1928+ A0FE
1929+ A0FE              //  ______________________________________________________________________
1930+ A0FE              //
1931+ A0FE              // 2@           a -- d
1932+ A0FE              // fetch a 32 bits number d from address a and leaves it on top of the
1933+ A0FE              // stack as two single numbers, high part as top of the stack.
1934+ A0FE              // A double number is normally kept in CPU registers as HLDE.
1935+ A0FE              // On stack a double number is treated as two single numbers
1936+ A0FE              // where BC is on the top of the stack and HL is the second from top,
1937+ A0FE              // so the sign of the number can be checked on top of stack
1938+ A0FE              // and in the stack memory it appears as LHED.
1939+ A0FE                              New_Def TWO_FETCH, "2@", is_code, is_normal
1939+ A0FE             >
1939+ A0FE             >Dict_Ptr        defl    $
1939+ A0FE             >
1939+ A0FE             >//              ______________________________________________________________________
1939+ A0FE             >//              Heap part
1939+ A0FE             >
1939+ A0FE             >
1939+ A0FE             >                org     (Heap_Ptr & $1FFF) + $E000
1939+ E3FC             >
1939+ E3FC             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1939+ E3FC             >Latest_Definition defl  Heap_Ptr
1939+ E3FC             >
1939+ E3FC             >                // dummy db directives used to calculate length of namec
1939+ E3FC 32 40       >                db      "2@"
1939+ E3FE             >len_NFA         defl    $ - temp_NFA
1939+ E3FE             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1939+ E3FC             >
1939+ E3FC 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1939+ E3FD 32 40       >                db      "2@"               // name string in 7-bit ascii, but
1939+ E3FF             >                org     $-1                 // alter last byte of Name just above to set
1939+ E3FE C0          >                db      {b $} | END_BIT     // msb as name end
1939+ E3FF             >
1939+ E3FF F5 03       >                dw      Prev_Ptr            // Link to previous definition Name
1939+ E401             >Prev_Ptr        defl    Heap_Ptr
1939+ E401             >
1939+ E401             >mirror_Ptr      defl    $
1939+ E401             >
1939+ E401 00 A1       >                dw      Dict_Ptr + 2        // xt
1939+ E403             >Heap_Ptr        defl    $ - $E000           // save current HP
1939+ E403             >
1939+ E403             >Current_HP      defl  $ - $E000             // used to set HP once!
1939+ E403             >
1939+ E403             >//              ______________________________________________________________________
1939+ E403             >//              Dictionary part
1939+ E403             >
1939+ E403             >                org     Dict_Ptr
1939+ A0FE             >
1939+ A0FE 01 23       >                dw      mirror_Ptr - $E000 + $1F00
1939+ A100             >
1939+ A100             >TWO_FETCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1939+ A100 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1939+ A100 ~           >
1939+ A100 ~           >
1939+ A100             >                endif           ; ok        // for other definitions it "points" the correct handler
1939+ A100             >                // Use of "; ok" to suppress "warning[fwdref]"
1939+ A100             >
1939+ A100             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1940+ A100 D9                           exx
1941+ A101 E1                           pop     hl                  // address
1942+ A102 5E                           ld      e, (hl)             // low-byte
1943+ A103 23                           inc     hl
1944+ A104 56                           ld      d, (hl)             // high-byte
1945+ A105 23                           inc     hl
1946+ A106 7E                           ld      a, (hl)             // low-byte
1947+ A107 23                           inc     hl
1948+ A108 66                           ld      h, (hl)             // high-byte
1949+ A109 6F                           ld      l, a
1950+ A10A E5                           push    hl
1951+ A10B D5                           push    de
1952+ A10C D9                           exx
1953+ A10D                              next
1953+ A10D DD E9       >                jp      (ix)
1954+ A10F
1955+ A10F              //  ______________________________________________________________________
1956+ A10F              //
1957+ A10F              // 2!           d a --
1958+ A10F              // stores a 32 bits number d from address a and leaves it on top of the
1959+ A10F              // stack as two single numbers, high part as top of the stack.
1960+ A10F              // A double number is normally kept in CPU registers as HLDE.
1961+ A10F              // On stack a double number is treated as two single numbers
1962+ A10F              // where BC is on the top of the stack and HL is the second from top,
1963+ A10F              // so the sign of the number can be checked on top of stack
1964+ A10F              // and in the stack memory it appears as LHED.
1965+ A10F                              New_Def TWO_STORE, "2!", is_code, is_normal
1965+ A10F             >
1965+ A10F             >Dict_Ptr        defl    $
1965+ A10F             >
1965+ A10F             >//              ______________________________________________________________________
1965+ A10F             >//              Heap part
1965+ A10F             >
1965+ A10F             >
1965+ A10F             >                org     (Heap_Ptr & $1FFF) + $E000
1965+ E403             >
1965+ E403             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1965+ E403             >Latest_Definition defl  Heap_Ptr
1965+ E403             >
1965+ E403             >                // dummy db directives used to calculate length of namec
1965+ E403 32 21       >                db      "2!"
1965+ E405             >len_NFA         defl    $ - temp_NFA
1965+ E405             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1965+ E403             >
1965+ E403 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1965+ E404 32 21       >                db      "2!"               // name string in 7-bit ascii, but
1965+ E406             >                org     $-1                 // alter last byte of Name just above to set
1965+ E405 A1          >                db      {b $} | END_BIT     // msb as name end
1965+ E406             >
1965+ E406 FC 03       >                dw      Prev_Ptr            // Link to previous definition Name
1965+ E408             >Prev_Ptr        defl    Heap_Ptr
1965+ E408             >
1965+ E408             >mirror_Ptr      defl    $
1965+ E408             >
1965+ E408 11 A1       >                dw      Dict_Ptr + 2        // xt
1965+ E40A             >Heap_Ptr        defl    $ - $E000           // save current HP
1965+ E40A             >
1965+ E40A             >Current_HP      defl  $ - $E000             // used to set HP once!
1965+ E40A             >
1965+ E40A             >//              ______________________________________________________________________
1965+ E40A             >//              Dictionary part
1965+ E40A             >
1965+ E40A             >                org     Dict_Ptr
1965+ A10F             >
1965+ A10F 08 23       >                dw      mirror_Ptr - $E000 + $1F00
1965+ A111             >
1965+ A111             >TWO_STORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1965+ A111 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1965+ A111 ~           >
1965+ A111 ~           >
1965+ A111             >                endif           ; ok        // for other definitions it "points" the correct handler
1965+ A111             >                // Use of "; ok" to suppress "warning[fwdref]"
1965+ A111             >
1965+ A111             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1966+ A111 D9                           exx
1967+ A112 E1                           pop     hl                  // address
1968+ A113 C1                           pop     bc                  // < high-part
1969+ A114 D1                           pop     de                  // < low-part > Instruction Pointer
1970+ A115 71                           ld      (hl), c
1971+ A116 23                           inc     hl
1972+ A117 70                           ld      (hl), b
1973+ A118 23                           inc     hl
1974+ A119 73                           ld      (hl), e
1975+ A11A 23                           inc     hl
1976+ A11B 72                           ld      (hl), d
1977+ A11C D9                           exx
1978+ A11D                              next
1978+ A11D DD E9       >                jp      (ix)
1979+ A11F
1980+ A11F              //  ______________________________________________________________________
1981+ A11F              //
1982+ A11F              // p@           a -- c
1983+ A11F              // Read one byte from port a and leave the result on top of stack
1984+ A11F                              New_Def PFETCH, "P@", is_code, is_normal
1984+ A11F             >
1984+ A11F             >Dict_Ptr        defl    $
1984+ A11F             >
1984+ A11F             >//              ______________________________________________________________________
1984+ A11F             >//              Heap part
1984+ A11F             >
1984+ A11F             >
1984+ A11F             >                org     (Heap_Ptr & $1FFF) + $E000
1984+ E40A             >
1984+ E40A             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1984+ E40A             >Latest_Definition defl  Heap_Ptr
1984+ E40A             >
1984+ E40A             >                // dummy db directives used to calculate length of namec
1984+ E40A 50 40       >                db      "P@"
1984+ E40C             >len_NFA         defl    $ - temp_NFA
1984+ E40C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1984+ E40A             >
1984+ E40A 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1984+ E40B 50 40       >                db      "P@"               // name string in 7-bit ascii, but
1984+ E40D             >                org     $-1                 // alter last byte of Name just above to set
1984+ E40C C0          >                db      {b $} | END_BIT     // msb as name end
1984+ E40D             >
1984+ E40D 03 04       >                dw      Prev_Ptr            // Link to previous definition Name
1984+ E40F             >Prev_Ptr        defl    Heap_Ptr
1984+ E40F             >
1984+ E40F             >mirror_Ptr      defl    $
1984+ E40F             >
1984+ E40F 21 A1       >                dw      Dict_Ptr + 2        // xt
1984+ E411             >Heap_Ptr        defl    $ - $E000           // save current HP
1984+ E411             >
1984+ E411             >Current_HP      defl  $ - $E000             // used to set HP once!
1984+ E411             >
1984+ E411             >//              ______________________________________________________________________
1984+ E411             >//              Dictionary part
1984+ E411             >
1984+ E411             >                org     Dict_Ptr
1984+ A11F             >
1984+ A11F 0F 23       >                dw      mirror_Ptr - $E000 + $1F00
1984+ A121             >
1984+ A121             >PFETCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1984+ A121 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1984+ A121 ~           >
1984+ A121 ~           >
1984+ A121             >                endif           ; ok        // for other definitions it "points" the correct handler
1984+ A121             >                // Use of "; ok" to suppress "warning[fwdref]"
1984+ A121             >
1984+ A121             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1985+ A121 D9                           exx
1986+ A122 C1                           pop     bc
1987+ A123 26 00                        ld      h, 0
1988+ A125 ED 68                        in      l, (c)
1989+ A127 E5                           push    hl
1990+ A128 D9                           exx
1991+ A129                              next
1991+ A129 DD E9       >                jp      (ix)
1992+ A12B
1993+ A12B              //  ______________________________________________________________________
1994+ A12B              //
1995+ A12B              // p!           c a --
1996+ A12B              // Send one byte (top of stack) to port a
1997+ A12B                              New_Def PSTORE, "P!", is_code, is_normal
1997+ A12B             >
1997+ A12B             >Dict_Ptr        defl    $
1997+ A12B             >
1997+ A12B             >//              ______________________________________________________________________
1997+ A12B             >//              Heap part
1997+ A12B             >
1997+ A12B             >
1997+ A12B             >                org     (Heap_Ptr & $1FFF) + $E000
1997+ E411             >
1997+ E411             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1997+ E411             >Latest_Definition defl  Heap_Ptr
1997+ E411             >
1997+ E411             >                // dummy db directives used to calculate length of namec
1997+ E411 50 21       >                db      "P!"
1997+ E413             >len_NFA         defl    $ - temp_NFA
1997+ E413             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1997+ E411             >
1997+ E411 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1997+ E412 50 21       >                db      "P!"               // name string in 7-bit ascii, but
1997+ E414             >                org     $-1                 // alter last byte of Name just above to set
1997+ E413 A1          >                db      {b $} | END_BIT     // msb as name end
1997+ E414             >
1997+ E414 0A 04       >                dw      Prev_Ptr            // Link to previous definition Name
1997+ E416             >Prev_Ptr        defl    Heap_Ptr
1997+ E416             >
1997+ E416             >mirror_Ptr      defl    $
1997+ E416             >
1997+ E416 2D A1       >                dw      Dict_Ptr + 2        // xt
1997+ E418             >Heap_Ptr        defl    $ - $E000           // save current HP
1997+ E418             >
1997+ E418             >Current_HP      defl  $ - $E000             // used to set HP once!
1997+ E418             >
1997+ E418             >//              ______________________________________________________________________
1997+ E418             >//              Dictionary part
1997+ E418             >
1997+ E418             >                org     Dict_Ptr
1997+ A12B             >
1997+ A12B 16 23       >                dw      mirror_Ptr - $E000 + $1F00
1997+ A12D             >
1997+ A12D             >PSTORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1997+ A12D ~           >                call    runcode ; ok        // for primitive definitions  actual code
1997+ A12D ~           >
1997+ A12D ~           >
1997+ A12D             >                endif           ; ok        // for other definitions it "points" the correct handler
1997+ A12D             >                // Use of "; ok" to suppress "warning[fwdref]"
1997+ A12D             >
1997+ A12D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1998+ A12D D9                           exx
1999+ A12E C1                           pop     bc
2000+ A12F E1                           pop     hl                  // < c
2001+ A130 ED 69                        out     (c), l              // low-byte
2002+ A132 D9                           exx
2003+ A133                              next
2003+ A133 DD E9       >                jp      (ix)
2004+ A135
2005+ A135
2006+ A135              //  ______________________________________________________________________
2007+ A135              //
2008+ A135              // 2*           n1 -- n2
2009+ A135              // doubles the number at top of stack
2010+ A135                              New_Def TWO_MUL, "2*", is_code, is_normal
2010+ A135             >
2010+ A135             >Dict_Ptr        defl    $
2010+ A135             >
2010+ A135             >//              ______________________________________________________________________
2010+ A135             >//              Heap part
2010+ A135             >
2010+ A135             >
2010+ A135             >                org     (Heap_Ptr & $1FFF) + $E000
2010+ E418             >
2010+ E418             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
2010+ E418             >Latest_Definition defl  Heap_Ptr
2010+ E418             >
2010+ E418             >                // dummy db directives used to calculate length of namec
2010+ E418 32 2A       >                db      "2*"
2010+ E41A             >len_NFA         defl    $ - temp_NFA
2010+ E41A             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
2010+ E418             >
2010+ E418 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
2010+ E419 32 2A       >                db      "2*"               // name string in 7-bit ascii, but
2010+ E41B             >                org     $-1                 // alter last byte of Name just above to set
2010+ E41A AA          >                db      {b $} | END_BIT     // msb as name end
2010+ E41B             >
2010+ E41B 11 04       >                dw      Prev_Ptr            // Link to previous definition Name
2010+ E41D             >Prev_Ptr        defl    Heap_Ptr
2010+ E41D             >
2010+ E41D             >mirror_Ptr      defl    $
2010+ E41D             >
2010+ E41D 37 A1       >                dw      Dict_Ptr + 2        // xt
2010+ E41F             >Heap_Ptr        defl    $ - $E000           // save current HP
2010+ E41F             >
2010+ E41F             >Current_HP      defl  $ - $E000             // used to set HP once!
2010+ E41F             >
2010+ E41F             >//              ______________________________________________________________________
2010+ E41F             >//              Dictionary part
2010+ E41F             >
2010+ E41F             >                org     Dict_Ptr
2010+ A135             >
2010+ A135 1D 23       >                dw      mirror_Ptr - $E000 + $1F00
2010+ A137             >
2010+ A137             >TWO_MUL:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
2010+ A137 ~           >                call    runcode ; ok        // for primitive definitions  actual code
2010+ A137 ~           >
2010+ A137 ~           >
2010+ A137             >                endif           ; ok        // for other definitions it "points" the correct handler
2010+ A137             >                // Use of "; ok" to suppress "warning[fwdref]"
2010+ A137             >
2010+ A137             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
2011+ A137              Two_Mul_Ptr:
2012+ A137 E1                           pop     hl
2013+ A138 29                           add     hl, hl
2014+ A139
2015+ A139                              psh1
2015+ A139 E5          >                push    hl
2015+ A13A DD E9       >                jp      (ix)
2016+ A13C
2017+ A13C              //  ______________________________________________________________________
2018+ A13C              //
2019+ A13C              // 2/           n1 -- n2
2020+ A13C              // halves the top of stack, sign is unchanged
2021+ A13C                              New_Def TWO_DIV, "2/", is_code, is_normal
2021+ A13C             >
2021+ A13C             >Dict_Ptr        defl    $
2021+ A13C             >
2021+ A13C             >//              ______________________________________________________________________
2021+ A13C             >//              Heap part
2021+ A13C             >
2021+ A13C             >
2021+ A13C             >                org     (Heap_Ptr & $1FFF) + $E000
2021+ E41F             >
2021+ E41F             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
2021+ E41F             >Latest_Definition defl  Heap_Ptr
2021+ E41F             >
2021+ E41F             >                // dummy db directives used to calculate length of namec
2021+ E41F 32 2F       >                db      "2/"
2021+ E421             >len_NFA         defl    $ - temp_NFA
2021+ E421             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
2021+ E41F             >
2021+ E41F 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
2021+ E420 32 2F       >                db      "2/"               // name string in 7-bit ascii, but
2021+ E422             >                org     $-1                 // alter last byte of Name just above to set
2021+ E421 AF          >                db      {b $} | END_BIT     // msb as name end
2021+ E422             >
2021+ E422 18 04       >                dw      Prev_Ptr            // Link to previous definition Name
2021+ E424             >Prev_Ptr        defl    Heap_Ptr
2021+ E424             >
2021+ E424             >mirror_Ptr      defl    $
2021+ E424             >
2021+ E424 3E A1       >                dw      Dict_Ptr + 2        // xt
2021+ E426             >Heap_Ptr        defl    $ - $E000           // save current HP
2021+ E426             >
2021+ E426             >Current_HP      defl  $ - $E000             // used to set HP once!
2021+ E426             >
2021+ E426             >//              ______________________________________________________________________
2021+ E426             >//              Dictionary part
2021+ E426             >
2021+ E426             >                org     Dict_Ptr
2021+ A13C             >
2021+ A13C 24 23       >                dw      mirror_Ptr - $E000 + $1F00
2021+ A13E             >
2021+ A13E             >TWO_DIV:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
2021+ A13E ~           >                call    runcode ; ok        // for primitive definitions  actual code
2021+ A13E ~           >
2021+ A13E ~           >
2021+ A13E             >                endif           ; ok        // for other definitions it "points" the correct handler
2021+ A13E             >                // Use of "; ok" to suppress "warning[fwdref]"
2021+ A13E             >
2021+ A13E             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
2022+ A13E E1                           pop     hl
2023+ A13F CB 2C                        sra     h
2024+ A141 CB 1D                        rr      l
2025+ A143
2026+ A143                              psh1
2026+ A143 E5          >                push    hl
2026+ A144 DD E9       >                jp      (ix)
2027+ A146
2028+ A146              //  ______________________________________________________________________
2029+ A146              //
2030+ A146              // lshift       n1 u -- n2
2031+ A146              // bit left shift of u bits
2032+ A146                              New_Def LSHIFT, "LSHIFT", is_code, is_normal
2032+ A146             >
2032+ A146             >Dict_Ptr        defl    $
2032+ A146             >
2032+ A146             >//              ______________________________________________________________________
2032+ A146             >//              Heap part
2032+ A146             >
2032+ A146             >
2032+ A146             >                org     (Heap_Ptr & $1FFF) + $E000
2032+ E426             >
2032+ E426             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
2032+ E426             >Latest_Definition defl  Heap_Ptr
2032+ E426             >
2032+ E426             >                // dummy db directives used to calculate length of namec
2032+ E426 4C 53 48 49 >                db      "LSHIFT"
2032+ E42A 46 54       >
2032+ E42C             >len_NFA         defl    $ - temp_NFA
2032+ E42C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
2032+ E426             >
2032+ E426 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
2032+ E427 4C 53 48 49 >                db      "LSHIFT"               // name string in 7-bit ascii, but
2032+ E42B 46 54       >
2032+ E42D             >                org     $-1                 // alter last byte of Name just above to set
2032+ E42C D4          >                db      {b $} | END_BIT     // msb as name end
2032+ E42D             >
2032+ E42D 1F 04       >                dw      Prev_Ptr            // Link to previous definition Name
2032+ E42F             >Prev_Ptr        defl    Heap_Ptr
2032+ E42F             >
2032+ E42F             >mirror_Ptr      defl    $
2032+ E42F             >
2032+ E42F 48 A1       >                dw      Dict_Ptr + 2        // xt
2032+ E431             >Heap_Ptr        defl    $ - $E000           // save current HP
2032+ E431             >
2032+ E431             >Current_HP      defl  $ - $E000             // used to set HP once!
2032+ E431             >
2032+ E431             >//              ______________________________________________________________________
2032+ E431             >//              Dictionary part
2032+ E431             >
2032+ E431             >                org     Dict_Ptr
2032+ A146             >
2032+ A146 2F 23       >                dw      mirror_Ptr - $E000 + $1F00
2032+ A148             >
2032+ A148             >LSHIFT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
2032+ A148 ~           >                call    runcode ; ok        // for primitive definitions  actual code
2032+ A148 ~           >
2032+ A148 ~           >
2032+ A148             >                endif           ; ok        // for other definitions it "points" the correct handler
2032+ A148             >                // Use of "; ok" to suppress "warning[fwdref]"
2032+ A148             >
2032+ A148             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
2033+ A148 D9                           exx
2034+ A149 C1                           pop     bc
2035+ A14A 41                           ld      b, c
2036+ A14B D1                           pop     de
2037+ A14C ED 28                        bsla    de, b
2038+ A14E D5                           push    de
2039+ A14F D9                           exx
2040+ A150                              next
2040+ A150 DD E9       >                jp      (ix)
2041+ A152
2042+ A152              //  ______________________________________________________________________
2043+ A152              //
2044+ A152              // rshift       n1 u -- n2
2045+ A152              // bit right shift of u bits
2046+ A152                              New_Def RSHIFT, "RSHIFT", is_code, is_normal
2046+ A152             >
2046+ A152             >Dict_Ptr        defl    $
2046+ A152             >
2046+ A152             >//              ______________________________________________________________________
2046+ A152             >//              Heap part
2046+ A152             >
2046+ A152             >
2046+ A152             >                org     (Heap_Ptr & $1FFF) + $E000
2046+ E431             >
2046+ E431             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
2046+ E431             >Latest_Definition defl  Heap_Ptr
2046+ E431             >
2046+ E431             >                // dummy db directives used to calculate length of namec
2046+ E431 52 53 48 49 >                db      "RSHIFT"
2046+ E435 46 54       >
2046+ E437             >len_NFA         defl    $ - temp_NFA
2046+ E437             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
2046+ E431             >
2046+ E431 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
2046+ E432 52 53 48 49 >                db      "RSHIFT"               // name string in 7-bit ascii, but
2046+ E436 46 54       >
2046+ E438             >                org     $-1                 // alter last byte of Name just above to set
2046+ E437 D4          >                db      {b $} | END_BIT     // msb as name end
2046+ E438             >
2046+ E438 26 04       >                dw      Prev_Ptr            // Link to previous definition Name
2046+ E43A             >Prev_Ptr        defl    Heap_Ptr
2046+ E43A             >
2046+ E43A             >mirror_Ptr      defl    $
2046+ E43A             >
2046+ E43A 54 A1       >                dw      Dict_Ptr + 2        // xt
2046+ E43C             >Heap_Ptr        defl    $ - $E000           // save current HP
2046+ E43C             >
2046+ E43C             >Current_HP      defl  $ - $E000             // used to set HP once!
2046+ E43C             >
2046+ E43C             >//              ______________________________________________________________________
2046+ E43C             >//              Dictionary part
2046+ E43C             >
2046+ E43C             >                org     Dict_Ptr
2046+ A152             >
2046+ A152 3A 23       >                dw      mirror_Ptr - $E000 + $1F00
2046+ A154             >
2046+ A154             >RSHIFT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
2046+ A154 ~           >                call    runcode ; ok        // for primitive definitions  actual code
2046+ A154 ~           >
2046+ A154 ~           >
2046+ A154             >                endif           ; ok        // for other definitions it "points" the correct handler
2046+ A154             >                // Use of "; ok" to suppress "warning[fwdref]"
2046+ A154             >
2046+ A154             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
2047+ A154 D9                           exx
2048+ A155 C1                           pop     bc
2049+ A156 41                           ld      b, c
2050+ A157 D1                           pop     de
2051+ A158 ED 2A                        bsrl    de, b
2052+ A15A D5                           push    de
2053+ A15B D9                           exx
2054+ A15C                              next
2054+ A15C DD E9       >                jp      (ix)
2055+ A15E
2056+ A15E              //  ______________________________________________________________________
2057+ A15E              //
2058+ A15E              // cells        n1 -- n2
2059+ A15E              // decrement by 2 top of stack
2060+ A15E                              New_Def CELLS, "CELLS", is_code, is_normal
2060+ A15E             >
2060+ A15E             >Dict_Ptr        defl    $
2060+ A15E             >
2060+ A15E             >//              ______________________________________________________________________
2060+ A15E             >//              Heap part
2060+ A15E             >
2060+ A15E             >
2060+ A15E             >                org     (Heap_Ptr & $1FFF) + $E000
2060+ E43C             >
2060+ E43C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
2060+ E43C             >Latest_Definition defl  Heap_Ptr
2060+ E43C             >
2060+ E43C             >                // dummy db directives used to calculate length of namec
2060+ E43C 43 45 4C 4C >                db      "CELLS"
2060+ E440 53          >
2060+ E441             >len_NFA         defl    $ - temp_NFA
2060+ E441             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
2060+ E43C             >
2060+ E43C 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
2060+ E43D 43 45 4C 4C >                db      "CELLS"               // name string in 7-bit ascii, but
2060+ E441 53          >
2060+ E442             >                org     $-1                 // alter last byte of Name just above to set
2060+ E441 D3          >                db      {b $} | END_BIT     // msb as name end
2060+ E442             >
2060+ E442 31 04       >                dw      Prev_Ptr            // Link to previous definition Name
2060+ E444             >Prev_Ptr        defl    Heap_Ptr
2060+ E444             >
2060+ E444             >mirror_Ptr      defl    $
2060+ E444             >
2060+ E444 60 A1       >                dw      Dict_Ptr + 2        // xt
2060+ E446             >Heap_Ptr        defl    $ - $E000           // save current HP
2060+ E446             >
2060+ E446             >Current_HP      defl  $ - $E000             // used to set HP once!
2060+ E446             >
2060+ E446             >//              ______________________________________________________________________
2060+ E446             >//              Dictionary part
2060+ E446             >
2060+ E446             >                org     Dict_Ptr
2060+ A15E             >
2060+ A15E 44 23       >                dw      mirror_Ptr - $E000 + $1F00
2060+ A160             >
2060+ A160             >CELLS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
2060+ A160 ~           >                call    runcode ; ok        // for primitive definitions  actual code
2060+ A160 ~           >
2060+ A160 ~           >
2060+ A160             >                endif           ; ok        // for other definitions it "points" the correct handler
2060+ A160             >                // Use of "; ok" to suppress "warning[fwdref]"
2060+ A160             >
2060+ A160             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
2061+ A160 C3 37 A1                     jp      Two_Mul_Ptr
2062+ A163
2063+ A163
2064+ A163              //  ______________________________________________________________________
2065+ A163
# file closed: C:\Zx\CSpect\Projects\vForth17_MMU7/source/L0.asm
 112  A163                              include "L1.asm"
# file opened: C:\Zx\CSpect\Projects\vForth17_MMU7/source/L1.asm
   1+ A163              //  ______________________________________________________________________
   2+ A163              //
   3+ A163              //  L1.asm
   4+ A163              //
   5+ A163              //  Level-1 definitions and derivate
   6+ A163              //  ______________________________________________________________________
   7+ A163
   8+ A163              //  ______________________________________________________________________
   9+ A163              //
  10+ A163              // :            -- cccc     ( compile time )
  11+ A163              //              i*x -- j*x  ( run time )
  12+ A163              // Colon Definition
  13+ A163                              Colon_Def COLON, ":", is_normal      // has forward-ref
  13+ A163             >                New_Def  COLON, ":", Enter_Ptr, is_normal ; ok
  13+ A163             >
  13+ A163             >Dict_Ptr        defl    $
  13+ A163             >
  13+ A163             >//              ______________________________________________________________________
  13+ A163             >//              Heap part
  13+ A163             >
  13+ A163             >
  13+ A163             >                org     (Heap_Ptr & $1FFF) + $E000
  13+ E446             >
  13+ E446             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  13+ E446             >Latest_Definition defl  Heap_Ptr
  13+ E446             >
  13+ E446             >                // dummy db directives used to calculate length of namec
  13+ E446 3A          >                db      ":"
  13+ E447             >len_NFA         defl    $ - temp_NFA
  13+ E447             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  13+ E446             >
  13+ E446 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  13+ E447 3A          >                db      ":"               // name string in 7-bit ascii, but
  13+ E448             >                org     $-1                 // alter last byte of Name just above to set
  13+ E447 BA          >                db      {b $} | END_BIT     // msb as name end
  13+ E448             >
  13+ E448 3C 04       >                dw      Prev_Ptr            // Link to previous definition Name
  13+ E44A             >Prev_Ptr        defl    Heap_Ptr
  13+ E44A             >
  13+ E44A             >mirror_Ptr      defl    $
  13+ E44A             >
  13+ E44A 65 A1       >                dw      Dict_Ptr + 2        // xt
  13+ E44C             >Heap_Ptr        defl    $ - $E000           // save current HP
  13+ E44C             >
  13+ E44C             >Current_HP      defl  $ - $E000             // used to set HP once!
  13+ E44C             >
  13+ E44C             >//              ______________________________________________________________________
  13+ E44C             >//              Dictionary part
  13+ E44C             >
  13+ E44C             >                org     Dict_Ptr
  13+ A163             >
  13+ A163 4A 23       >                dw      mirror_Ptr - $E000 + $1F00
  13+ A165             >
  13+ A165             >COLON:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
  13+ A165 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
  13+ A168             >
  13+ A168             >
  13+ A168             >                endif           ; ok        // for other definitions it "points" the correct handler
  13+ A168             >                // Use of "; ok" to suppress "warning[fwdref]"
  13+ A168             >
  13+ A168             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  14+ A168
  15+ A168 5A A5                        dw      QEXEC                   // ?exec
  16+ A16A 25 A5                        dw      STORE_CSP               // !csp
  17+ A16C 96 A2 D9 A0                  dw      CURRENT, FETCH          // current @
  18+ A170 90 A2 E3 A0                  dw      CONTEXT, STORE          // context !
  19+ A174 B9 AA                        dw      CREATE                  // create  ( forward )
  20+ A176 DE A5                        dw      SMUDGE                  // dmudge
  21+ A178 CF A5                        dw      SQUARED_CLOSE           // ]
  22+ A17A 1A A6                        dw      C_SEMICOLON_CODE        // ;code ( change the 3-bytes CFA of defining word to call Enter_Ptr )
  23+ A17C                                                              // ... immediate
  24+ A17C              Enter_Ptr:
  25+ A17C                              // via call coded in CFA
  26+ A17C EB                           ex      de, hl //**
  27+ A17D                              // *** ldhlrp
  28+ A17D 2B                           dec     hl                  // push on Return-Stack current Instruction-Pointer
  29+ A17E 70                           ld      (hl), b
  30+ A17F 2B                           dec     hl
  31+ A180 71                           ld      (hl), c
  32+ A181                              // *** ldrphl
  33+ A181 EB                           ex      de, hl //**
  34+ A182
  35+ A182
  36+ A182 C1                           pop     bc                  // points to PFA of "this" word
  37+ A183                              next
  37+ A183 DD E9       >                jp      (ix)
  38+ A185
  39+ A185              //  ______________________________________________________________________
  40+ A185              //
  41+ A185              // ;            --
  42+ A185              // Semicolon. End of Colon-Definition. Stack must be balanced.
  43+ A185                              Colon_Def SEMICOLON, ";", is_immediate   // has forward-ref
  43+ A185             >                New_Def  SEMICOLON, ";", Enter_Ptr, is_immediate ; ok
  43+ A185             >
  43+ A185             >Dict_Ptr        defl    $
  43+ A185             >
  43+ A185             >//              ______________________________________________________________________
  43+ A185             >//              Heap part
  43+ A185             >
  43+ A185             >
  43+ A185             >                org     (Heap_Ptr & $1FFF) + $E000
  43+ E44C             >
  43+ E44C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  43+ E44C             >Latest_Definition defl  Heap_Ptr
  43+ E44C             >
  43+ E44C             >                // dummy db directives used to calculate length of namec
  43+ E44C 3B          >                db      ";"
  43+ E44D             >len_NFA         defl    $ - temp_NFA
  43+ E44D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  43+ E44C             >
  43+ E44C C1          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
  43+ E44D 3B          >                db      ";"               // name string in 7-bit ascii, but
  43+ E44E             >                org     $-1                 // alter last byte of Name just above to set
  43+ E44D BB          >                db      {b $} | END_BIT     // msb as name end
  43+ E44E             >
  43+ E44E 46 04       >                dw      Prev_Ptr            // Link to previous definition Name
  43+ E450             >Prev_Ptr        defl    Heap_Ptr
  43+ E450             >
  43+ E450             >mirror_Ptr      defl    $
  43+ E450             >
  43+ E450 87 A1       >                dw      Dict_Ptr + 2        // xt
  43+ E452             >Heap_Ptr        defl    $ - $E000           // save current HP
  43+ E452             >
  43+ E452             >Current_HP      defl  $ - $E000             // used to set HP once!
  43+ E452             >
  43+ E452             >//              ______________________________________________________________________
  43+ E452             >//              Dictionary part
  43+ E452             >
  43+ E452             >                org     Dict_Ptr
  43+ A185             >
  43+ A185 50 23       >                dw      mirror_Ptr - $E000 + $1F00
  43+ A187             >
  43+ A187             >SEMICOLON:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
  43+ A187 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
  43+ A18A             >
  43+ A18A             >
  43+ A18A             >                endif           ; ok        // for other definitions it "points" the correct handler
  43+ A18A             >                // Use of "; ok" to suppress "warning[fwdref]"
  43+ A18A             >
  43+ A18A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  44+ A18A
  45+ A18A 7A A5                        dw      QCSP                    // ?csp
  46+ A18C A2 A5 A2 9F                  dw      COMPILE, EXIT           // [compile] ;s
  47+ A190 DE A5                        dw      SMUDGE                  // smudge
  48+ A192 C2 A5                        dw      SQUARED_OPEN            // [
  49+ A194 A2 9F                        dw      EXIT                    // ; immediate
  50+ A196
  51+ A196              //  ______________________________________________________________________
  52+ A196              //
  53+ A196              // noop         --
  54+ A196
  55+ A196                              New_Def NOOP, "NOOP", is_code, is_normal
  55+ A196             >
  55+ A196             >Dict_Ptr        defl    $
  55+ A196             >
  55+ A196             >//              ______________________________________________________________________
  55+ A196             >//              Heap part
  55+ A196             >
  55+ A196             >
  55+ A196             >                org     (Heap_Ptr & $1FFF) + $E000
  55+ E452             >
  55+ E452             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  55+ E452             >Latest_Definition defl  Heap_Ptr
  55+ E452             >
  55+ E452             >                // dummy db directives used to calculate length of namec
  55+ E452 4E 4F 4F 50 >                db      "NOOP"
  55+ E456             >len_NFA         defl    $ - temp_NFA
  55+ E456             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  55+ E452             >
  55+ E452 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  55+ E453 4E 4F 4F 50 >                db      "NOOP"               // name string in 7-bit ascii, but
  55+ E457             >                org     $-1                 // alter last byte of Name just above to set
  55+ E456 D0          >                db      {b $} | END_BIT     // msb as name end
  55+ E457             >
  55+ E457 4C 04       >                dw      Prev_Ptr            // Link to previous definition Name
  55+ E459             >Prev_Ptr        defl    Heap_Ptr
  55+ E459             >
  55+ E459             >mirror_Ptr      defl    $
  55+ E459             >
  55+ E459 98 A1       >                dw      Dict_Ptr + 2        // xt
  55+ E45B             >Heap_Ptr        defl    $ - $E000           // save current HP
  55+ E45B             >
  55+ E45B             >Current_HP      defl  $ - $E000             // used to set HP once!
  55+ E45B             >
  55+ E45B             >//              ______________________________________________________________________
  55+ E45B             >//              Dictionary part
  55+ E45B             >
  55+ E45B             >                org     Dict_Ptr
  55+ A196             >
  55+ A196 59 23       >                dw      mirror_Ptr - $E000 + $1F00
  55+ A198             >
  55+ A198             >NOOP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
  55+ A198 ~           >                call    runcode ; ok        // for primitive definitions  actual code
  55+ A198 ~           >
  55+ A198 ~           >
  55+ A198             >                endif           ; ok        // for other definitions it "points" the correct handler
  55+ A198             >                // Use of "; ok" to suppress "warning[fwdref]"
  55+ A198             >
  55+ A198             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  56+ A198                              next
  56+ A198 DD E9       >                jp      (ix)
  57+ A19A
  58+ A19A              //  ______________________________________________________________________
  59+ A19A              //
  60+ A19A              // constant     n -- cccc     ( compile time )
  61+ A19A              //              -- n          ( run time )
  62+ A19A              // Constant definition.
  63+ A19A                              Colon_Def CONSTANT, "CONSTANT", is_normal   // has forward-ref
  63+ A19A             >                New_Def  CONSTANT, "CONSTANT", Enter_Ptr, is_normal ; ok
  63+ A19A             >
  63+ A19A             >Dict_Ptr        defl    $
  63+ A19A             >
  63+ A19A             >//              ______________________________________________________________________
  63+ A19A             >//              Heap part
  63+ A19A             >
  63+ A19A             >
  63+ A19A             >                org     (Heap_Ptr & $1FFF) + $E000
  63+ E45B             >
  63+ E45B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  63+ E45B             >Latest_Definition defl  Heap_Ptr
  63+ E45B             >
  63+ E45B             >                // dummy db directives used to calculate length of namec
  63+ E45B 43 4F 4E 53 >                db      "CONSTANT"
  63+ E45F 54 41 4E 54 >
  63+ E463             >len_NFA         defl    $ - temp_NFA
  63+ E463             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  63+ E45B             >
  63+ E45B 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  63+ E45C 43 4F 4E 53 >                db      "CONSTANT"               // name string in 7-bit ascii, but
  63+ E460 54 41 4E 54 >
  63+ E464             >                org     $-1                 // alter last byte of Name just above to set
  63+ E463 D4          >                db      {b $} | END_BIT     // msb as name end
  63+ E464             >
  63+ E464 52 04       >                dw      Prev_Ptr            // Link to previous definition Name
  63+ E466             >Prev_Ptr        defl    Heap_Ptr
  63+ E466             >
  63+ E466             >mirror_Ptr      defl    $
  63+ E466             >
  63+ E466 9C A1       >                dw      Dict_Ptr + 2        // xt
  63+ E468             >Heap_Ptr        defl    $ - $E000           // save current HP
  63+ E468             >
  63+ E468             >Current_HP      defl  $ - $E000             // used to set HP once!
  63+ E468             >
  63+ E468             >//              ______________________________________________________________________
  63+ E468             >//              Dictionary part
  63+ E468             >
  63+ E468             >                org     Dict_Ptr
  63+ A19A             >
  63+ A19A 66 23       >                dw      mirror_Ptr - $E000 + $1F00
  63+ A19C             >
  63+ A19C             >CONSTANT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
  63+ A19C CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
  63+ A19F             >
  63+ A19F             >
  63+ A19F             >                endif           ; ok        // for other definitions it "points" the correct handler
  63+ A19F             >                // Use of "; ok" to suppress "warning[fwdref]"
  63+ A19F             >
  63+ A19F             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  64+ A19F B9 AA                        dw      CREATE                  // create
  65+ A1A1 0C A3                        dw      COMMA                   // ,    ( at PFA then, store the value )
  66+ A1A3 1A A6                        dw      C_SEMICOLON_CODE        // ;code (  changes the 3-bytes CFA to call Constant_Ptr )
  67+ A1A5              Constant_Ptr:
  68+ A1A5
  69+ A1A5
  70+ A1A5 E1                           pop     hl
  71+ A1A6
  72+ A1A6 7E                           ld      a, (hl)
  73+ A1A7 23                           inc     hl
  74+ A1A8 66                           ld      h, (hl)
  75+ A1A9 6F                           ld      l, a
  76+ A1AA E5                           push    hl
  77+ A1AB                              next
  77+ A1AB DD E9       >                jp      (ix)
  78+ A1AD
  79+ A1AD              //  ______________________________________________________________________
  80+ A1AD              //
  81+ A1AD              // variable     n -- cccc     ( compile time )
  82+ A1AD              //              -- a          ( run time )
  83+ A1AD              // Variable definition, n is the initial value.
  84+ A1AD                              Colon_Def VARIABLE, "VARIABLE", is_normal   // has forward-ref
  84+ A1AD             >                New_Def  VARIABLE, "VARIABLE", Enter_Ptr, is_normal ; ok
  84+ A1AD             >
  84+ A1AD             >Dict_Ptr        defl    $
  84+ A1AD             >
  84+ A1AD             >//              ______________________________________________________________________
  84+ A1AD             >//              Heap part
  84+ A1AD             >
  84+ A1AD             >
  84+ A1AD             >                org     (Heap_Ptr & $1FFF) + $E000
  84+ E468             >
  84+ E468             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  84+ E468             >Latest_Definition defl  Heap_Ptr
  84+ E468             >
  84+ E468             >                // dummy db directives used to calculate length of namec
  84+ E468 56 41 52 49 >                db      "VARIABLE"
  84+ E46C 41 42 4C 45 >
  84+ E470             >len_NFA         defl    $ - temp_NFA
  84+ E470             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  84+ E468             >
  84+ E468 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  84+ E469 56 41 52 49 >                db      "VARIABLE"               // name string in 7-bit ascii, but
  84+ E46D 41 42 4C 45 >
  84+ E471             >                org     $-1                 // alter last byte of Name just above to set
  84+ E470 C5          >                db      {b $} | END_BIT     // msb as name end
  84+ E471             >
  84+ E471 5B 04       >                dw      Prev_Ptr            // Link to previous definition Name
  84+ E473             >Prev_Ptr        defl    Heap_Ptr
  84+ E473             >
  84+ E473             >mirror_Ptr      defl    $
  84+ E473             >
  84+ E473 AF A1       >                dw      Dict_Ptr + 2        // xt
  84+ E475             >Heap_Ptr        defl    $ - $E000           // save current HP
  84+ E475             >
  84+ E475             >Current_HP      defl  $ - $E000             // used to set HP once!
  84+ E475             >
  84+ E475             >//              ______________________________________________________________________
  84+ E475             >//              Dictionary part
  84+ E475             >
  84+ E475             >                org     Dict_Ptr
  84+ A1AD             >
  84+ A1AD 73 23       >                dw      mirror_Ptr - $E000 + $1F00
  84+ A1AF             >
  84+ A1AF             >VARIABLE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
  84+ A1AF CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
  84+ A1B2             >
  84+ A1B2             >
  84+ A1B2             >                endif           ; ok        // for other definitions it "points" the correct handler
  84+ A1B2             >                // Use of "; ok" to suppress "warning[fwdref]"
  84+ A1B2             >
  84+ A1B2             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  85+ A1B2
  86+ A1B2 D1 A1                        dw      ZERO
  87+ A1B4 9C A1                        dw      CONSTANT                // constant
  88+ A1B6 1A A6                        dw      C_SEMICOLON_CODE        // ;code ( changes the 3-bytes CFA to call Variable_Ptr )
  89+ A1B8              Variable_Ptr:
  90+ A1B8
  91+ A1B8
  92+ A1B8
  93+ A1B8
  94+ A1B8                              next
  94+ A1B8 DD E9       >                jp      (ix)
  95+ A1BA
  96+ A1BA              //  ______________________________________________________________________
  97+ A1BA              //
  98+ A1BA              // user         b -- cccc     ( compile time )
  99+ A1BA              //              -- a          ( run time )
 100+ A1BA              // User variable definition
 101+ A1BA                              Colon_Def USER, "USER", is_normal
 101+ A1BA             >                New_Def  USER, "USER", Enter_Ptr, is_normal ; ok
 101+ A1BA             >
 101+ A1BA             >Dict_Ptr        defl    $
 101+ A1BA             >
 101+ A1BA             >//              ______________________________________________________________________
 101+ A1BA             >//              Heap part
 101+ A1BA             >
 101+ A1BA             >
 101+ A1BA             >                org     (Heap_Ptr & $1FFF) + $E000
 101+ E475             >
 101+ E475             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 101+ E475             >Latest_Definition defl  Heap_Ptr
 101+ E475             >
 101+ E475             >                // dummy db directives used to calculate length of namec
 101+ E475 55 53 45 52 >                db      "USER"
 101+ E479             >len_NFA         defl    $ - temp_NFA
 101+ E479             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 101+ E475             >
 101+ E475 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 101+ E476 55 53 45 52 >                db      "USER"               // name string in 7-bit ascii, but
 101+ E47A             >                org     $-1                 // alter last byte of Name just above to set
 101+ E479 D2          >                db      {b $} | END_BIT     // msb as name end
 101+ E47A             >
 101+ E47A 68 04       >                dw      Prev_Ptr            // Link to previous definition Name
 101+ E47C             >Prev_Ptr        defl    Heap_Ptr
 101+ E47C             >
 101+ E47C             >mirror_Ptr      defl    $
 101+ E47C             >
 101+ E47C BC A1       >                dw      Dict_Ptr + 2        // xt
 101+ E47E             >Heap_Ptr        defl    $ - $E000           // save current HP
 101+ E47E             >
 101+ E47E             >Current_HP      defl  $ - $E000             // used to set HP once!
 101+ E47E             >
 101+ E47E             >//              ______________________________________________________________________
 101+ E47E             >//              Dictionary part
 101+ E47E             >
 101+ E47E             >                org     Dict_Ptr
 101+ A1BA             >
 101+ A1BA 7C 23       >                dw      mirror_Ptr - $E000 + $1F00
 101+ A1BC             >
 101+ A1BC             >USER:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 101+ A1BC CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 101+ A1BF             >
 101+ A1BF             >
 101+ A1BF             >                endif           ; ok        // for other definitions it "points" the correct handler
 101+ A1BF             >                // Use of "; ok" to suppress "warning[fwdref]"
 101+ A1BF             >
 101+ A1BF             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 102+ A1BF
 103+ A1BF B9 AA                        dw      CREATE                  // create
 104+ A1C1 1B A3                        dw      CCOMMA                  // c,
 105+ A1C3 1A A6                        dw      C_SEMICOLON_CODE        // ;code () changes the 3-bytes CFA to call User_Ptr )
 106+ A1C5
 107+ A1C5
 108+ A1C5              User_Ptr:
 109+ A1C5                              // via call coded in CFA
 110+ A1C5 E1                           pop     hl
 111+ A1C6
 112+ A1C6 7E                           ld      a, (hl)
 113+ A1C7 2A E4 9A                     ld      hl, (USER_Pointer)
 114+ A1CA ED 31                        add     hl, a
 115+ A1CC E5                           push    hl
 116+ A1CD                              next
 116+ A1CD DD E9       >                jp      (ix)
 117+ A1CF
 118+ A1CF              //  ______________________________________________________________________
 119+ A1CF              //
 120+ A1CF                              Constant_Def ZERO       ,   "0"     ,   0
 120+ A1CF             >                New_Def  ZERO, "0", Constant_Ptr, is_normal
 120+ A1CF             >
 120+ A1CF             >Dict_Ptr        defl    $
 120+ A1CF             >
 120+ A1CF             >//              ______________________________________________________________________
 120+ A1CF             >//              Heap part
 120+ A1CF             >
 120+ A1CF             >
 120+ A1CF             >                org     (Heap_Ptr & $1FFF) + $E000
 120+ E47E             >
 120+ E47E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 120+ E47E             >Latest_Definition defl  Heap_Ptr
 120+ E47E             >
 120+ E47E             >                // dummy db directives used to calculate length of namec
 120+ E47E 30          >                db      "0"
 120+ E47F             >len_NFA         defl    $ - temp_NFA
 120+ E47F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 120+ E47E             >
 120+ E47E 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 120+ E47F 30          >                db      "0"               // name string in 7-bit ascii, but
 120+ E480             >                org     $-1                 // alter last byte of Name just above to set
 120+ E47F B0          >                db      {b $} | END_BIT     // msb as name end
 120+ E480             >
 120+ E480 75 04       >                dw      Prev_Ptr            // Link to previous definition Name
 120+ E482             >Prev_Ptr        defl    Heap_Ptr
 120+ E482             >
 120+ E482             >mirror_Ptr      defl    $
 120+ E482             >
 120+ E482 D1 A1       >                dw      Dict_Ptr + 2        // xt
 120+ E484             >Heap_Ptr        defl    $ - $E000           // save current HP
 120+ E484             >
 120+ E484             >Current_HP      defl  $ - $E000             // used to set HP once!
 120+ E484             >
 120+ E484             >//              ______________________________________________________________________
 120+ E484             >//              Dictionary part
 120+ E484             >
 120+ E484             >                org     Dict_Ptr
 120+ A1CF             >
 120+ A1CF 82 23       >                dw      mirror_Ptr - $E000 + $1F00
 120+ A1D1             >
 120+ A1D1             >ZERO:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 120+ A1D1 CD A5 A1    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 120+ A1D4             >
 120+ A1D4             >
 120+ A1D4             >                endif           ; ok        // for other definitions it "points" the correct handler
 120+ A1D4             >                // Use of "; ok" to suppress "warning[fwdref]"
 120+ A1D4             >
 120+ A1D4             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 120+ A1D4 00 00       >                dw      0
 121+ A1D6                              Constant_Def ONE        ,   "1"     ,   1
 121+ A1D6             >                New_Def  ONE, "1", Constant_Ptr, is_normal
 121+ A1D6             >
 121+ A1D6             >Dict_Ptr        defl    $
 121+ A1D6             >
 121+ A1D6             >//              ______________________________________________________________________
 121+ A1D6             >//              Heap part
 121+ A1D6             >
 121+ A1D6             >
 121+ A1D6             >                org     (Heap_Ptr & $1FFF) + $E000
 121+ E484             >
 121+ E484             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 121+ E484             >Latest_Definition defl  Heap_Ptr
 121+ E484             >
 121+ E484             >                // dummy db directives used to calculate length of namec
 121+ E484 31          >                db      "1"
 121+ E485             >len_NFA         defl    $ - temp_NFA
 121+ E485             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 121+ E484             >
 121+ E484 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 121+ E485 31          >                db      "1"               // name string in 7-bit ascii, but
 121+ E486             >                org     $-1                 // alter last byte of Name just above to set
 121+ E485 B1          >                db      {b $} | END_BIT     // msb as name end
 121+ E486             >
 121+ E486 7E 04       >                dw      Prev_Ptr            // Link to previous definition Name
 121+ E488             >Prev_Ptr        defl    Heap_Ptr
 121+ E488             >
 121+ E488             >mirror_Ptr      defl    $
 121+ E488             >
 121+ E488 D8 A1       >                dw      Dict_Ptr + 2        // xt
 121+ E48A             >Heap_Ptr        defl    $ - $E000           // save current HP
 121+ E48A             >
 121+ E48A             >Current_HP      defl  $ - $E000             // used to set HP once!
 121+ E48A             >
 121+ E48A             >//              ______________________________________________________________________
 121+ E48A             >//              Dictionary part
 121+ E48A             >
 121+ E48A             >                org     Dict_Ptr
 121+ A1D6             >
 121+ A1D6 88 23       >                dw      mirror_Ptr - $E000 + $1F00
 121+ A1D8             >
 121+ A1D8             >ONE:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 121+ A1D8 CD A5 A1    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 121+ A1DB             >
 121+ A1DB             >
 121+ A1DB             >                endif           ; ok        // for other definitions it "points" the correct handler
 121+ A1DB             >                // Use of "; ok" to suppress "warning[fwdref]"
 121+ A1DB             >
 121+ A1DB             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 121+ A1DB 01 00       >                dw      1
 122+ A1DD                              Constant_Def TWO        ,   "2"     ,   2
 122+ A1DD             >                New_Def  TWO, "2", Constant_Ptr, is_normal
 122+ A1DD             >
 122+ A1DD             >Dict_Ptr        defl    $
 122+ A1DD             >
 122+ A1DD             >//              ______________________________________________________________________
 122+ A1DD             >//              Heap part
 122+ A1DD             >
 122+ A1DD             >
 122+ A1DD             >                org     (Heap_Ptr & $1FFF) + $E000
 122+ E48A             >
 122+ E48A             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 122+ E48A             >Latest_Definition defl  Heap_Ptr
 122+ E48A             >
 122+ E48A             >                // dummy db directives used to calculate length of namec
 122+ E48A 32          >                db      "2"
 122+ E48B             >len_NFA         defl    $ - temp_NFA
 122+ E48B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 122+ E48A             >
 122+ E48A 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 122+ E48B 32          >                db      "2"               // name string in 7-bit ascii, but
 122+ E48C             >                org     $-1                 // alter last byte of Name just above to set
 122+ E48B B2          >                db      {b $} | END_BIT     // msb as name end
 122+ E48C             >
 122+ E48C 84 04       >                dw      Prev_Ptr            // Link to previous definition Name
 122+ E48E             >Prev_Ptr        defl    Heap_Ptr
 122+ E48E             >
 122+ E48E             >mirror_Ptr      defl    $
 122+ E48E             >
 122+ E48E DF A1       >                dw      Dict_Ptr + 2        // xt
 122+ E490             >Heap_Ptr        defl    $ - $E000           // save current HP
 122+ E490             >
 122+ E490             >Current_HP      defl  $ - $E000             // used to set HP once!
 122+ E490             >
 122+ E490             >//              ______________________________________________________________________
 122+ E490             >//              Dictionary part
 122+ E490             >
 122+ E490             >                org     Dict_Ptr
 122+ A1DD             >
 122+ A1DD 8E 23       >                dw      mirror_Ptr - $E000 + $1F00
 122+ A1DF             >
 122+ A1DF             >TWO:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 122+ A1DF CD A5 A1    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 122+ A1E2             >
 122+ A1E2             >
 122+ A1E2             >                endif           ; ok        // for other definitions it "points" the correct handler
 122+ A1E2             >                // Use of "; ok" to suppress "warning[fwdref]"
 122+ A1E2             >
 122+ A1E2             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 122+ A1E2 02 00       >                dw      2
 123+ A1E4                              Constant_Def THREE      ,   "3"     ,   3
 123+ A1E4             >                New_Def  THREE, "3", Constant_Ptr, is_normal
 123+ A1E4             >
 123+ A1E4             >Dict_Ptr        defl    $
 123+ A1E4             >
 123+ A1E4             >//              ______________________________________________________________________
 123+ A1E4             >//              Heap part
 123+ A1E4             >
 123+ A1E4             >
 123+ A1E4             >                org     (Heap_Ptr & $1FFF) + $E000
 123+ E490             >
 123+ E490             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 123+ E490             >Latest_Definition defl  Heap_Ptr
 123+ E490             >
 123+ E490             >                // dummy db directives used to calculate length of namec
 123+ E490 33          >                db      "3"
 123+ E491             >len_NFA         defl    $ - temp_NFA
 123+ E491             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 123+ E490             >
 123+ E490 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 123+ E491 33          >                db      "3"               // name string in 7-bit ascii, but
 123+ E492             >                org     $-1                 // alter last byte of Name just above to set
 123+ E491 B3          >                db      {b $} | END_BIT     // msb as name end
 123+ E492             >
 123+ E492 8A 04       >                dw      Prev_Ptr            // Link to previous definition Name
 123+ E494             >Prev_Ptr        defl    Heap_Ptr
 123+ E494             >
 123+ E494             >mirror_Ptr      defl    $
 123+ E494             >
 123+ E494 E6 A1       >                dw      Dict_Ptr + 2        // xt
 123+ E496             >Heap_Ptr        defl    $ - $E000           // save current HP
 123+ E496             >
 123+ E496             >Current_HP      defl  $ - $E000             // used to set HP once!
 123+ E496             >
 123+ E496             >//              ______________________________________________________________________
 123+ E496             >//              Dictionary part
 123+ E496             >
 123+ E496             >                org     Dict_Ptr
 123+ A1E4             >
 123+ A1E4 94 23       >                dw      mirror_Ptr - $E000 + $1F00
 123+ A1E6             >
 123+ A1E6             >THREE:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 123+ A1E6 CD A5 A1    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 123+ A1E9             >
 123+ A1E9             >
 123+ A1E9             >                endif           ; ok        // for other definitions it "points" the correct handler
 123+ A1E9             >                // Use of "; ok" to suppress "warning[fwdref]"
 123+ A1E9             >
 123+ A1E9             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 123+ A1E9 03 00       >                dw      3
 124+ A1EB                              Constant_Def NEG_ONE    ,   "-1"    ,  -1
 124+ A1EB             >                New_Def  NEG_ONE, "-1", Constant_Ptr, is_normal
 124+ A1EB             >
 124+ A1EB             >Dict_Ptr        defl    $
 124+ A1EB             >
 124+ A1EB             >//              ______________________________________________________________________
 124+ A1EB             >//              Heap part
 124+ A1EB             >
 124+ A1EB             >
 124+ A1EB             >                org     (Heap_Ptr & $1FFF) + $E000
 124+ E496             >
 124+ E496             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 124+ E496             >Latest_Definition defl  Heap_Ptr
 124+ E496             >
 124+ E496             >                // dummy db directives used to calculate length of namec
 124+ E496 2D 31       >                db      "-1"
 124+ E498             >len_NFA         defl    $ - temp_NFA
 124+ E498             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 124+ E496             >
 124+ E496 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 124+ E497 2D 31       >                db      "-1"               // name string in 7-bit ascii, but
 124+ E499             >                org     $-1                 // alter last byte of Name just above to set
 124+ E498 B1          >                db      {b $} | END_BIT     // msb as name end
 124+ E499             >
 124+ E499 90 04       >                dw      Prev_Ptr            // Link to previous definition Name
 124+ E49B             >Prev_Ptr        defl    Heap_Ptr
 124+ E49B             >
 124+ E49B             >mirror_Ptr      defl    $
 124+ E49B             >
 124+ E49B ED A1       >                dw      Dict_Ptr + 2        // xt
 124+ E49D             >Heap_Ptr        defl    $ - $E000           // save current HP
 124+ E49D             >
 124+ E49D             >Current_HP      defl  $ - $E000             // used to set HP once!
 124+ E49D             >
 124+ E49D             >//              ______________________________________________________________________
 124+ E49D             >//              Dictionary part
 124+ E49D             >
 124+ E49D             >                org     Dict_Ptr
 124+ A1EB             >
 124+ A1EB 9B 23       >                dw      mirror_Ptr - $E000 + $1F00
 124+ A1ED             >
 124+ A1ED             >NEG_ONE:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 124+ A1ED CD A5 A1    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 124+ A1F0             >
 124+ A1F0             >
 124+ A1F0             >                endif           ; ok        // for other definitions it "points" the correct handler
 124+ A1F0             >                // Use of "; ok" to suppress "warning[fwdref]"
 124+ A1F0             >
 124+ A1F0             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 124+ A1F0 FF FF       >                dw      -1
 125+ A1F2                              Constant_Def BL         ,   "BL"    , $20
 125+ A1F2             >                New_Def  BL, "BL", Constant_Ptr, is_normal
 125+ A1F2             >
 125+ A1F2             >Dict_Ptr        defl    $
 125+ A1F2             >
 125+ A1F2             >//              ______________________________________________________________________
 125+ A1F2             >//              Heap part
 125+ A1F2             >
 125+ A1F2             >
 125+ A1F2             >                org     (Heap_Ptr & $1FFF) + $E000
 125+ E49D             >
 125+ E49D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 125+ E49D             >Latest_Definition defl  Heap_Ptr
 125+ E49D             >
 125+ E49D             >                // dummy db directives used to calculate length of namec
 125+ E49D 42 4C       >                db      "BL"
 125+ E49F             >len_NFA         defl    $ - temp_NFA
 125+ E49F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 125+ E49D             >
 125+ E49D 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 125+ E49E 42 4C       >                db      "BL"               // name string in 7-bit ascii, but
 125+ E4A0             >                org     $-1                 // alter last byte of Name just above to set
 125+ E49F CC          >                db      {b $} | END_BIT     // msb as name end
 125+ E4A0             >
 125+ E4A0 96 04       >                dw      Prev_Ptr            // Link to previous definition Name
 125+ E4A2             >Prev_Ptr        defl    Heap_Ptr
 125+ E4A2             >
 125+ E4A2             >mirror_Ptr      defl    $
 125+ E4A2             >
 125+ E4A2 F4 A1       >                dw      Dict_Ptr + 2        // xt
 125+ E4A4             >Heap_Ptr        defl    $ - $E000           // save current HP
 125+ E4A4             >
 125+ E4A4             >Current_HP      defl  $ - $E000             // used to set HP once!
 125+ E4A4             >
 125+ E4A4             >//              ______________________________________________________________________
 125+ E4A4             >//              Dictionary part
 125+ E4A4             >
 125+ E4A4             >                org     Dict_Ptr
 125+ A1F2             >
 125+ A1F2 A2 23       >                dw      mirror_Ptr - $E000 + $1F00
 125+ A1F4             >
 125+ A1F4             >BL:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 125+ A1F4 CD A5 A1    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 125+ A1F7             >
 125+ A1F7             >
 125+ A1F7             >                endif           ; ok        // for other definitions it "points" the correct handler
 125+ A1F7             >                // Use of "; ok" to suppress "warning[fwdref]"
 125+ A1F7             >
 125+ A1F7             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 125+ A1F7 20 00       >                dw      $20
 126+ A1F9                              Constant_Def CL         ,   "C/L"   ,  64
 126+ A1F9             >                New_Def  CL, "C/L", Constant_Ptr, is_normal
 126+ A1F9             >
 126+ A1F9             >Dict_Ptr        defl    $
 126+ A1F9             >
 126+ A1F9             >//              ______________________________________________________________________
 126+ A1F9             >//              Heap part
 126+ A1F9             >
 126+ A1F9             >
 126+ A1F9             >                org     (Heap_Ptr & $1FFF) + $E000
 126+ E4A4             >
 126+ E4A4             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 126+ E4A4             >Latest_Definition defl  Heap_Ptr
 126+ E4A4             >
 126+ E4A4             >                // dummy db directives used to calculate length of namec
 126+ E4A4 43 2F 4C    >                db      "C/L"
 126+ E4A7             >len_NFA         defl    $ - temp_NFA
 126+ E4A7             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 126+ E4A4             >
 126+ E4A4 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 126+ E4A5 43 2F 4C    >                db      "C/L"               // name string in 7-bit ascii, but
 126+ E4A8             >                org     $-1                 // alter last byte of Name just above to set
 126+ E4A7 CC          >                db      {b $} | END_BIT     // msb as name end
 126+ E4A8             >
 126+ E4A8 9D 04       >                dw      Prev_Ptr            // Link to previous definition Name
 126+ E4AA             >Prev_Ptr        defl    Heap_Ptr
 126+ E4AA             >
 126+ E4AA             >mirror_Ptr      defl    $
 126+ E4AA             >
 126+ E4AA FB A1       >                dw      Dict_Ptr + 2        // xt
 126+ E4AC             >Heap_Ptr        defl    $ - $E000           // save current HP
 126+ E4AC             >
 126+ E4AC             >Current_HP      defl  $ - $E000             // used to set HP once!
 126+ E4AC             >
 126+ E4AC             >//              ______________________________________________________________________
 126+ E4AC             >//              Dictionary part
 126+ E4AC             >
 126+ E4AC             >                org     Dict_Ptr
 126+ A1F9             >
 126+ A1F9 AA 23       >                dw      mirror_Ptr - $E000 + $1F00
 126+ A1FB             >
 126+ A1FB             >CL:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 126+ A1FB CD A5 A1    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 126+ A1FE             >
 126+ A1FE             >
 126+ A1FE             >                endif           ; ok        // for other definitions it "points" the correct handler
 126+ A1FE             >                // Use of "; ok" to suppress "warning[fwdref]"
 126+ A1FE             >
 126+ A1FE             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 126+ A1FE 40 00       >                dw      64
 127+ A200                              Constant_Def BBUF       ,   "B/BUF" , 512
 127+ A200             >                New_Def  BBUF, "B/BUF", Constant_Ptr, is_normal
 127+ A200             >
 127+ A200             >Dict_Ptr        defl    $
 127+ A200             >
 127+ A200             >//              ______________________________________________________________________
 127+ A200             >//              Heap part
 127+ A200             >
 127+ A200             >
 127+ A200             >                org     (Heap_Ptr & $1FFF) + $E000
 127+ E4AC             >
 127+ E4AC             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 127+ E4AC             >Latest_Definition defl  Heap_Ptr
 127+ E4AC             >
 127+ E4AC             >                // dummy db directives used to calculate length of namec
 127+ E4AC 42 2F 42 55 >                db      "B/BUF"
 127+ E4B0 46          >
 127+ E4B1             >len_NFA         defl    $ - temp_NFA
 127+ E4B1             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 127+ E4AC             >
 127+ E4AC 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 127+ E4AD 42 2F 42 55 >                db      "B/BUF"               // name string in 7-bit ascii, but
 127+ E4B1 46          >
 127+ E4B2             >                org     $-1                 // alter last byte of Name just above to set
 127+ E4B1 C6          >                db      {b $} | END_BIT     // msb as name end
 127+ E4B2             >
 127+ E4B2 A4 04       >                dw      Prev_Ptr            // Link to previous definition Name
 127+ E4B4             >Prev_Ptr        defl    Heap_Ptr
 127+ E4B4             >
 127+ E4B4             >mirror_Ptr      defl    $
 127+ E4B4             >
 127+ E4B4 02 A2       >                dw      Dict_Ptr + 2        // xt
 127+ E4B6             >Heap_Ptr        defl    $ - $E000           // save current HP
 127+ E4B6             >
 127+ E4B6             >Current_HP      defl  $ - $E000             // used to set HP once!
 127+ E4B6             >
 127+ E4B6             >//              ______________________________________________________________________
 127+ E4B6             >//              Dictionary part
 127+ E4B6             >
 127+ E4B6             >                org     Dict_Ptr
 127+ A200             >
 127+ A200 B4 23       >                dw      mirror_Ptr - $E000 + $1F00
 127+ A202             >
 127+ A202             >BBUF:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 127+ A202 CD A5 A1    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 127+ A205             >
 127+ A205             >
 127+ A205             >                endif           ; ok        // for other definitions it "points" the correct handler
 127+ A205             >                // Use of "; ok" to suppress "warning[fwdref]"
 127+ A205             >
 127+ A205             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 127+ A205 00 02       >                dw      512
 128+ A207                              Constant_Def BSCR       ,   "B/SCR" ,   2
 128+ A207             >                New_Def  BSCR, "B/SCR", Constant_Ptr, is_normal
 128+ A207             >
 128+ A207             >Dict_Ptr        defl    $
 128+ A207             >
 128+ A207             >//              ______________________________________________________________________
 128+ A207             >//              Heap part
 128+ A207             >
 128+ A207             >
 128+ A207             >                org     (Heap_Ptr & $1FFF) + $E000
 128+ E4B6             >
 128+ E4B6             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 128+ E4B6             >Latest_Definition defl  Heap_Ptr
 128+ E4B6             >
 128+ E4B6             >                // dummy db directives used to calculate length of namec
 128+ E4B6 42 2F 53 43 >                db      "B/SCR"
 128+ E4BA 52          >
 128+ E4BB             >len_NFA         defl    $ - temp_NFA
 128+ E4BB             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 128+ E4B6             >
 128+ E4B6 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 128+ E4B7 42 2F 53 43 >                db      "B/SCR"               // name string in 7-bit ascii, but
 128+ E4BB 52          >
 128+ E4BC             >                org     $-1                 // alter last byte of Name just above to set
 128+ E4BB D2          >                db      {b $} | END_BIT     // msb as name end
 128+ E4BC             >
 128+ E4BC AC 04       >                dw      Prev_Ptr            // Link to previous definition Name
 128+ E4BE             >Prev_Ptr        defl    Heap_Ptr
 128+ E4BE             >
 128+ E4BE             >mirror_Ptr      defl    $
 128+ E4BE             >
 128+ E4BE 09 A2       >                dw      Dict_Ptr + 2        // xt
 128+ E4C0             >Heap_Ptr        defl    $ - $E000           // save current HP
 128+ E4C0             >
 128+ E4C0             >Current_HP      defl  $ - $E000             // used to set HP once!
 128+ E4C0             >
 128+ E4C0             >//              ______________________________________________________________________
 128+ E4C0             >//              Dictionary part
 128+ E4C0             >
 128+ E4C0             >                org     Dict_Ptr
 128+ A207             >
 128+ A207 BE 23       >                dw      mirror_Ptr - $E000 + $1F00
 128+ A209             >
 128+ A209             >BSCR:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 128+ A209 CD A5 A1    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 128+ A20C             >
 128+ A20C             >
 128+ A20C             >                endif           ; ok        // for other definitions it "points" the correct handler
 128+ A20C             >                // Use of "; ok" to suppress "warning[fwdref]"
 128+ A20C             >
 128+ A20C             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 128+ A20C 02 00       >                dw      2
 129+ A20E                              Constant_Def LSCR       ,   "L/SCR" ,  16
 129+ A20E             >                New_Def  LSCR, "L/SCR", Constant_Ptr, is_normal
 129+ A20E             >
 129+ A20E             >Dict_Ptr        defl    $
 129+ A20E             >
 129+ A20E             >//              ______________________________________________________________________
 129+ A20E             >//              Heap part
 129+ A20E             >
 129+ A20E             >
 129+ A20E             >                org     (Heap_Ptr & $1FFF) + $E000
 129+ E4C0             >
 129+ E4C0             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 129+ E4C0             >Latest_Definition defl  Heap_Ptr
 129+ E4C0             >
 129+ E4C0             >                // dummy db directives used to calculate length of namec
 129+ E4C0 4C 2F 53 43 >                db      "L/SCR"
 129+ E4C4 52          >
 129+ E4C5             >len_NFA         defl    $ - temp_NFA
 129+ E4C5             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 129+ E4C0             >
 129+ E4C0 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 129+ E4C1 4C 2F 53 43 >                db      "L/SCR"               // name string in 7-bit ascii, but
 129+ E4C5 52          >
 129+ E4C6             >                org     $-1                 // alter last byte of Name just above to set
 129+ E4C5 D2          >                db      {b $} | END_BIT     // msb as name end
 129+ E4C6             >
 129+ E4C6 B6 04       >                dw      Prev_Ptr            // Link to previous definition Name
 129+ E4C8             >Prev_Ptr        defl    Heap_Ptr
 129+ E4C8             >
 129+ E4C8             >mirror_Ptr      defl    $
 129+ E4C8             >
 129+ E4C8 10 A2       >                dw      Dict_Ptr + 2        // xt
 129+ E4CA             >Heap_Ptr        defl    $ - $E000           // save current HP
 129+ E4CA             >
 129+ E4CA             >Current_HP      defl  $ - $E000             // used to set HP once!
 129+ E4CA             >
 129+ E4CA             >//              ______________________________________________________________________
 129+ E4CA             >//              Dictionary part
 129+ E4CA             >
 129+ E4CA             >                org     Dict_Ptr
 129+ A20E             >
 129+ A20E C8 23       >                dw      mirror_Ptr - $E000 + $1F00
 129+ A210             >
 129+ A210             >LSCR:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 129+ A210 CD A5 A1    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 129+ A213             >
 129+ A213             >
 129+ A213             >                endif           ; ok        // for other definitions it "points" the correct handler
 129+ A213             >                // Use of "; ok" to suppress "warning[fwdref]"
 129+ A213             >
 129+ A213             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 129+ A213 10 00       >                dw      16
 130+ A215
 131+ A215              //  ______________________________________________________________________
 132+ A215              //
 133+ A215              // +origin         --
 134+ A215              //              Colon_Def PLUS_ORIGIN, "+ORIGIN", is_normal
 135+ A215              //              dw      LIT, Cold_origin        // [ hex 6366 ] literal
 136+ A215              //              dw      PLUS                    // +
 137+ A215              //              dw      EXIT                    // ;
 138+ A215                              New_Def  PLUS_ORIGIN, "+ORIGIN", is_code, is_normal
 138+ A215             >
 138+ A215             >Dict_Ptr        defl    $
 138+ A215             >
 138+ A215             >//              ______________________________________________________________________
 138+ A215             >//              Heap part
 138+ A215             >
 138+ A215             >
 138+ A215             >                org     (Heap_Ptr & $1FFF) + $E000
 138+ E4CA             >
 138+ E4CA             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 138+ E4CA             >Latest_Definition defl  Heap_Ptr
 138+ E4CA             >
 138+ E4CA             >                // dummy db directives used to calculate length of namec
 138+ E4CA 2B 4F 52 49 >                db      "+ORIGIN"
 138+ E4CE 47 49 4E    >
 138+ E4D1             >len_NFA         defl    $ - temp_NFA
 138+ E4D1             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 138+ E4CA             >
 138+ E4CA 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 138+ E4CB 2B 4F 52 49 >                db      "+ORIGIN"               // name string in 7-bit ascii, but
 138+ E4CF 47 49 4E    >
 138+ E4D2             >                org     $-1                 // alter last byte of Name just above to set
 138+ E4D1 CE          >                db      {b $} | END_BIT     // msb as name end
 138+ E4D2             >
 138+ E4D2 C0 04       >                dw      Prev_Ptr            // Link to previous definition Name
 138+ E4D4             >Prev_Ptr        defl    Heap_Ptr
 138+ E4D4             >
 138+ E4D4             >mirror_Ptr      defl    $
 138+ E4D4             >
 138+ E4D4 17 A2       >                dw      Dict_Ptr + 2        // xt
 138+ E4D6             >Heap_Ptr        defl    $ - $E000           // save current HP
 138+ E4D6             >
 138+ E4D6             >Current_HP      defl  $ - $E000             // used to set HP once!
 138+ E4D6             >
 138+ E4D6             >//              ______________________________________________________________________
 138+ E4D6             >//              Dictionary part
 138+ E4D6             >
 138+ E4D6             >                org     Dict_Ptr
 138+ A215             >
 138+ A215 D4 23       >                dw      mirror_Ptr - $E000 + $1F00
 138+ A217             >
 138+ A217             >PLUS_ORIGIN:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 138+ A217 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 138+ A217 ~           >
 138+ A217 ~           >
 138+ A217             >                endif           ; ok        // for other definitions it "points" the correct handler
 138+ A217             >                // Use of "; ok" to suppress "warning[fwdref]"
 138+ A217             >
 138+ A217             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 139+ A217 D9                           exx
 140+ A218 E1                           pop     hl
 141+ A219 11 B6 9A                     ld      de, Cold_origin
 142+ A21C 19                           add     hl, de
 143+ A21D E5                           push    hl
 144+ A21E D9                           exx
 145+ A21F                              next
 145+ A21F DD E9       >                jp      (ix)
 146+ A221
 147+ A221
 148+ A221              //  ______________________________________________________________________
 149+ A221              //
 150+ A221                              Constant_Def CNEXT      ,   "(NEXT)", Next_Ptr
 150+ A221             >                New_Def  CNEXT, "(NEXT)", Constant_Ptr, is_normal
 150+ A221             >
 150+ A221             >Dict_Ptr        defl    $
 150+ A221             >
 150+ A221             >//              ______________________________________________________________________
 150+ A221             >//              Heap part
 150+ A221             >
 150+ A221             >
 150+ A221             >                org     (Heap_Ptr & $1FFF) + $E000
 150+ E4D6             >
 150+ E4D6             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 150+ E4D6             >Latest_Definition defl  Heap_Ptr
 150+ E4D6             >
 150+ E4D6             >                // dummy db directives used to calculate length of namec
 150+ E4D6 28 4E 45 58 >                db      "(NEXT)"
 150+ E4DA 54 29       >
 150+ E4DC             >len_NFA         defl    $ - temp_NFA
 150+ E4DC             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 150+ E4D6             >
 150+ E4D6 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 150+ E4D7 28 4E 45 58 >                db      "(NEXT)"               // name string in 7-bit ascii, but
 150+ E4DB 54 29       >
 150+ E4DD             >                org     $-1                 // alter last byte of Name just above to set
 150+ E4DC A9          >                db      {b $} | END_BIT     // msb as name end
 150+ E4DD             >
 150+ E4DD CA 04       >                dw      Prev_Ptr            // Link to previous definition Name
 150+ E4DF             >Prev_Ptr        defl    Heap_Ptr
 150+ E4DF             >
 150+ E4DF             >mirror_Ptr      defl    $
 150+ E4DF             >
 150+ E4DF 23 A2       >                dw      Dict_Ptr + 2        // xt
 150+ E4E1             >Heap_Ptr        defl    $ - $E000           // save current HP
 150+ E4E1             >
 150+ E4E1             >Current_HP      defl  $ - $E000             // used to set HP once!
 150+ E4E1             >
 150+ E4E1             >//              ______________________________________________________________________
 150+ E4E1             >//              Dictionary part
 150+ E4E1             >
 150+ E4E1             >                org     Dict_Ptr
 150+ A221             >
 150+ A221 DF 23       >                dw      mirror_Ptr - $E000 + $1F00
 150+ A223             >
 150+ A223             >CNEXT:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 150+ A223 CD A5 A1    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 150+ A226             >
 150+ A226             >
 150+ A226             >                endif           ; ok        // for other definitions it "points" the correct handler
 150+ A226             >                // Use of "; ok" to suppress "warning[fwdref]"
 150+ A226             >
 150+ A226             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 150+ A226 EA 9A       >                dw      Next_Ptr
 151+ A228
 152+ A228              //  ______________________________________________________________________
 153+ A228              //
 154+ A228
 155+ A228                              User_Def S0         , "S0"        , 06 // starting value of Stack-Pointer
 155+ A228             >                New_Def  S0, "S0", User_Ptr, is_normal
 155+ A228             >
 155+ A228             >Dict_Ptr        defl    $
 155+ A228             >
 155+ A228             >//              ______________________________________________________________________
 155+ A228             >//              Heap part
 155+ A228             >
 155+ A228             >
 155+ A228             >                org     (Heap_Ptr & $1FFF) + $E000
 155+ E4E1             >
 155+ E4E1             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 155+ E4E1             >Latest_Definition defl  Heap_Ptr
 155+ E4E1             >
 155+ E4E1             >                // dummy db directives used to calculate length of namec
 155+ E4E1 53 30       >                db      "S0"
 155+ E4E3             >len_NFA         defl    $ - temp_NFA
 155+ E4E3             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 155+ E4E1             >
 155+ E4E1 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 155+ E4E2 53 30       >                db      "S0"               // name string in 7-bit ascii, but
 155+ E4E4             >                org     $-1                 // alter last byte of Name just above to set
 155+ E4E3 B0          >                db      {b $} | END_BIT     // msb as name end
 155+ E4E4             >
 155+ E4E4 D6 04       >                dw      Prev_Ptr            // Link to previous definition Name
 155+ E4E6             >Prev_Ptr        defl    Heap_Ptr
 155+ E4E6             >
 155+ E4E6             >mirror_Ptr      defl    $
 155+ E4E6             >
 155+ E4E6 2A A2       >                dw      Dict_Ptr + 2        // xt
 155+ E4E8             >Heap_Ptr        defl    $ - $E000           // save current HP
 155+ E4E8             >
 155+ E4E8             >Current_HP      defl  $ - $E000             // used to set HP once!
 155+ E4E8             >
 155+ E4E8             >//              ______________________________________________________________________
 155+ E4E8             >//              Dictionary part
 155+ E4E8             >
 155+ E4E8             >                org     Dict_Ptr
 155+ A228             >
 155+ A228 E6 23       >                dw      mirror_Ptr - $E000 + $1F00
 155+ A22A             >
 155+ A22A             >S0:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 155+ A22A CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 155+ A22D             >
 155+ A22D             >
 155+ A22D             >                endif           ; ok        // for other definitions it "points" the correct handler
 155+ A22D             >                // Use of "; ok" to suppress "warning[fwdref]"
 155+ A22D             >
 155+ A22D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 155+ A22D 06          >                db      06
 156+ A22E                              User_Def R0         , "R0"        , 08 // starting value of Return-Pointer
 156+ A22E             >                New_Def  R0, "R0", User_Ptr, is_normal
 156+ A22E             >
 156+ A22E             >Dict_Ptr        defl    $
 156+ A22E             >
 156+ A22E             >//              ______________________________________________________________________
 156+ A22E             >//              Heap part
 156+ A22E             >
 156+ A22E             >
 156+ A22E             >                org     (Heap_Ptr & $1FFF) + $E000
 156+ E4E8             >
 156+ E4E8             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 156+ E4E8             >Latest_Definition defl  Heap_Ptr
 156+ E4E8             >
 156+ E4E8             >                // dummy db directives used to calculate length of namec
 156+ E4E8 52 30       >                db      "R0"
 156+ E4EA             >len_NFA         defl    $ - temp_NFA
 156+ E4EA             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 156+ E4E8             >
 156+ E4E8 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 156+ E4E9 52 30       >                db      "R0"               // name string in 7-bit ascii, but
 156+ E4EB             >                org     $-1                 // alter last byte of Name just above to set
 156+ E4EA B0          >                db      {b $} | END_BIT     // msb as name end
 156+ E4EB             >
 156+ E4EB E1 04       >                dw      Prev_Ptr            // Link to previous definition Name
 156+ E4ED             >Prev_Ptr        defl    Heap_Ptr
 156+ E4ED             >
 156+ E4ED             >mirror_Ptr      defl    $
 156+ E4ED             >
 156+ E4ED 30 A2       >                dw      Dict_Ptr + 2        // xt
 156+ E4EF             >Heap_Ptr        defl    $ - $E000           // save current HP
 156+ E4EF             >
 156+ E4EF             >Current_HP      defl  $ - $E000             // used to set HP once!
 156+ E4EF             >
 156+ E4EF             >//              ______________________________________________________________________
 156+ E4EF             >//              Dictionary part
 156+ E4EF             >
 156+ E4EF             >                org     Dict_Ptr
 156+ A22E             >
 156+ A22E ED 23       >                dw      mirror_Ptr - $E000 + $1F00
 156+ A230             >
 156+ A230             >R0:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 156+ A230 CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 156+ A233             >
 156+ A233             >
 156+ A233             >                endif           ; ok        // for other definitions it "points" the correct handler
 156+ A233             >                // Use of "; ok" to suppress "warning[fwdref]"
 156+ A233             >
 156+ A233             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 156+ A233 08          >                db      08
 157+ A234                              User_Def TIB        , "TIB"       , 10 // input terminal buffer address
 157+ A234             >                New_Def  TIB, "TIB", User_Ptr, is_normal
 157+ A234             >
 157+ A234             >Dict_Ptr        defl    $
 157+ A234             >
 157+ A234             >//              ______________________________________________________________________
 157+ A234             >//              Heap part
 157+ A234             >
 157+ A234             >
 157+ A234             >                org     (Heap_Ptr & $1FFF) + $E000
 157+ E4EF             >
 157+ E4EF             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 157+ E4EF             >Latest_Definition defl  Heap_Ptr
 157+ E4EF             >
 157+ E4EF             >                // dummy db directives used to calculate length of namec
 157+ E4EF 54 49 42    >                db      "TIB"
 157+ E4F2             >len_NFA         defl    $ - temp_NFA
 157+ E4F2             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 157+ E4EF             >
 157+ E4EF 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 157+ E4F0 54 49 42    >                db      "TIB"               // name string in 7-bit ascii, but
 157+ E4F3             >                org     $-1                 // alter last byte of Name just above to set
 157+ E4F2 C2          >                db      {b $} | END_BIT     // msb as name end
 157+ E4F3             >
 157+ E4F3 E8 04       >                dw      Prev_Ptr            // Link to previous definition Name
 157+ E4F5             >Prev_Ptr        defl    Heap_Ptr
 157+ E4F5             >
 157+ E4F5             >mirror_Ptr      defl    $
 157+ E4F5             >
 157+ E4F5 36 A2       >                dw      Dict_Ptr + 2        // xt
 157+ E4F7             >Heap_Ptr        defl    $ - $E000           // save current HP
 157+ E4F7             >
 157+ E4F7             >Current_HP      defl  $ - $E000             // used to set HP once!
 157+ E4F7             >
 157+ E4F7             >//              ______________________________________________________________________
 157+ E4F7             >//              Dictionary part
 157+ E4F7             >
 157+ E4F7             >                org     Dict_Ptr
 157+ A234             >
 157+ A234 F5 23       >                dw      mirror_Ptr - $E000 + $1F00
 157+ A236             >
 157+ A236             >TIB:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 157+ A236 CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 157+ A239             >
 157+ A239             >
 157+ A239             >                endif           ; ok        // for other definitions it "points" the correct handler
 157+ A239             >                // Use of "; ok" to suppress "warning[fwdref]"
 157+ A239             >
 157+ A239             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 157+ A239 0A          >                db      10
 158+ A23A                              User_Def WIDTH      , "WIDTH"     , 12 // maximum number of characters for a word name
 158+ A23A             >                New_Def  WIDTH, "WIDTH", User_Ptr, is_normal
 158+ A23A             >
 158+ A23A             >Dict_Ptr        defl    $
 158+ A23A             >
 158+ A23A             >//              ______________________________________________________________________
 158+ A23A             >//              Heap part
 158+ A23A             >
 158+ A23A             >
 158+ A23A             >                org     (Heap_Ptr & $1FFF) + $E000
 158+ E4F7             >
 158+ E4F7             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 158+ E4F7             >Latest_Definition defl  Heap_Ptr
 158+ E4F7             >
 158+ E4F7             >                // dummy db directives used to calculate length of namec
 158+ E4F7 57 49 44 54 >                db      "WIDTH"
 158+ E4FB 48          >
 158+ E4FC             >len_NFA         defl    $ - temp_NFA
 158+ E4FC             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 158+ E4F7             >
 158+ E4F7 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 158+ E4F8 57 49 44 54 >                db      "WIDTH"               // name string in 7-bit ascii, but
 158+ E4FC 48          >
 158+ E4FD             >                org     $-1                 // alter last byte of Name just above to set
 158+ E4FC C8          >                db      {b $} | END_BIT     // msb as name end
 158+ E4FD             >
 158+ E4FD EF 04       >                dw      Prev_Ptr            // Link to previous definition Name
 158+ E4FF             >Prev_Ptr        defl    Heap_Ptr
 158+ E4FF             >
 158+ E4FF             >mirror_Ptr      defl    $
 158+ E4FF             >
 158+ E4FF 3C A2       >                dw      Dict_Ptr + 2        // xt
 158+ E501             >Heap_Ptr        defl    $ - $E000           // save current HP
 158+ E501             >
 158+ E501             >Current_HP      defl  $ - $E000             // used to set HP once!
 158+ E501             >
 158+ E501             >//              ______________________________________________________________________
 158+ E501             >//              Dictionary part
 158+ E501             >
 158+ E501             >                org     Dict_Ptr
 158+ A23A             >
 158+ A23A FF 23       >                dw      mirror_Ptr - $E000 + $1F00
 158+ A23C             >
 158+ A23C             >WIDTH:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 158+ A23C CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 158+ A23F             >
 158+ A23F             >
 158+ A23F             >                endif           ; ok        // for other definitions it "points" the correct handler
 158+ A23F             >                // Use of "; ok" to suppress "warning[fwdref]"
 158+ A23F             >
 158+ A23F             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 158+ A23F 0C          >                db      12
 159+ A240                              User_Def WARNING    , "WARNING"   , 14 // error reporting method: 0 base, 1 verbose
 159+ A240             >                New_Def  WARNING, "WARNING", User_Ptr, is_normal
 159+ A240             >
 159+ A240             >Dict_Ptr        defl    $
 159+ A240             >
 159+ A240             >//              ______________________________________________________________________
 159+ A240             >//              Heap part
 159+ A240             >
 159+ A240             >
 159+ A240             >                org     (Heap_Ptr & $1FFF) + $E000
 159+ E501             >
 159+ E501             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 159+ E501             >Latest_Definition defl  Heap_Ptr
 159+ E501             >
 159+ E501             >                // dummy db directives used to calculate length of namec
 159+ E501 57 41 52 4E >                db      "WARNING"
 159+ E505 49 4E 47    >
 159+ E508             >len_NFA         defl    $ - temp_NFA
 159+ E508             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 159+ E501             >
 159+ E501 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 159+ E502 57 41 52 4E >                db      "WARNING"               // name string in 7-bit ascii, but
 159+ E506 49 4E 47    >
 159+ E509             >                org     $-1                 // alter last byte of Name just above to set
 159+ E508 C7          >                db      {b $} | END_BIT     // msb as name end
 159+ E509             >
 159+ E509 F7 04       >                dw      Prev_Ptr            // Link to previous definition Name
 159+ E50B             >Prev_Ptr        defl    Heap_Ptr
 159+ E50B             >
 159+ E50B             >mirror_Ptr      defl    $
 159+ E50B             >
 159+ E50B 42 A2       >                dw      Dict_Ptr + 2        // xt
 159+ E50D             >Heap_Ptr        defl    $ - $E000           // save current HP
 159+ E50D             >
 159+ E50D             >Current_HP      defl  $ - $E000             // used to set HP once!
 159+ E50D             >
 159+ E50D             >//              ______________________________________________________________________
 159+ E50D             >//              Dictionary part
 159+ E50D             >
 159+ E50D             >                org     Dict_Ptr
 159+ A240             >
 159+ A240 0B 24       >                dw      mirror_Ptr - $E000 + $1F00
 159+ A242             >
 159+ A242             >WARNING:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 159+ A242 CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 159+ A245             >
 159+ A245             >
 159+ A245             >                endif           ; ok        // for other definitions it "points" the correct handler
 159+ A245             >                // Use of "; ok" to suppress "warning[fwdref]"
 159+ A245             >
 159+ A245             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 159+ A245 0E          >                db      14
 160+ A246                              User_Def FENCE      , "FENCE"     , 16 // minimum address where FORGET can work
 160+ A246             >                New_Def  FENCE, "FENCE", User_Ptr, is_normal
 160+ A246             >
 160+ A246             >Dict_Ptr        defl    $
 160+ A246             >
 160+ A246             >//              ______________________________________________________________________
 160+ A246             >//              Heap part
 160+ A246             >
 160+ A246             >
 160+ A246             >                org     (Heap_Ptr & $1FFF) + $E000
 160+ E50D             >
 160+ E50D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 160+ E50D             >Latest_Definition defl  Heap_Ptr
 160+ E50D             >
 160+ E50D             >                // dummy db directives used to calculate length of namec
 160+ E50D 46 45 4E 43 >                db      "FENCE"
 160+ E511 45          >
 160+ E512             >len_NFA         defl    $ - temp_NFA
 160+ E512             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 160+ E50D             >
 160+ E50D 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 160+ E50E 46 45 4E 43 >                db      "FENCE"               // name string in 7-bit ascii, but
 160+ E512 45          >
 160+ E513             >                org     $-1                 // alter last byte of Name just above to set
 160+ E512 C5          >                db      {b $} | END_BIT     // msb as name end
 160+ E513             >
 160+ E513 01 05       >                dw      Prev_Ptr            // Link to previous definition Name
 160+ E515             >Prev_Ptr        defl    Heap_Ptr
 160+ E515             >
 160+ E515             >mirror_Ptr      defl    $
 160+ E515             >
 160+ E515 48 A2       >                dw      Dict_Ptr + 2        // xt
 160+ E517             >Heap_Ptr        defl    $ - $E000           // save current HP
 160+ E517             >
 160+ E517             >Current_HP      defl  $ - $E000             // used to set HP once!
 160+ E517             >
 160+ E517             >//              ______________________________________________________________________
 160+ E517             >//              Dictionary part
 160+ E517             >
 160+ E517             >                org     Dict_Ptr
 160+ A246             >
 160+ A246 15 24       >                dw      mirror_Ptr - $E000 + $1F00
 160+ A248             >
 160+ A248             >FENCE:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 160+ A248 CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 160+ A24B             >
 160+ A24B             >
 160+ A24B             >                endif           ; ok        // for other definitions it "points" the correct handler
 160+ A24B             >                // Use of "; ok" to suppress "warning[fwdref]"
 160+ A24B             >
 160+ A24B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 160+ A24B 10          >                db      16
 161+ A24C                              User_Def DP         , "DP"        , 18 // Dictionary Pointer
 161+ A24C             >                New_Def  DP, "DP", User_Ptr, is_normal
 161+ A24C             >
 161+ A24C             >Dict_Ptr        defl    $
 161+ A24C             >
 161+ A24C             >//              ______________________________________________________________________
 161+ A24C             >//              Heap part
 161+ A24C             >
 161+ A24C             >
 161+ A24C             >                org     (Heap_Ptr & $1FFF) + $E000
 161+ E517             >
 161+ E517             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 161+ E517             >Latest_Definition defl  Heap_Ptr
 161+ E517             >
 161+ E517             >                // dummy db directives used to calculate length of namec
 161+ E517 44 50       >                db      "DP"
 161+ E519             >len_NFA         defl    $ - temp_NFA
 161+ E519             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 161+ E517             >
 161+ E517 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 161+ E518 44 50       >                db      "DP"               // name string in 7-bit ascii, but
 161+ E51A             >                org     $-1                 // alter last byte of Name just above to set
 161+ E519 D0          >                db      {b $} | END_BIT     // msb as name end
 161+ E51A             >
 161+ E51A 0D 05       >                dw      Prev_Ptr            // Link to previous definition Name
 161+ E51C             >Prev_Ptr        defl    Heap_Ptr
 161+ E51C             >
 161+ E51C             >mirror_Ptr      defl    $
 161+ E51C             >
 161+ E51C 4E A2       >                dw      Dict_Ptr + 2        // xt
 161+ E51E             >Heap_Ptr        defl    $ - $E000           // save current HP
 161+ E51E             >
 161+ E51E             >Current_HP      defl  $ - $E000             // used to set HP once!
 161+ E51E             >
 161+ E51E             >//              ______________________________________________________________________
 161+ E51E             >//              Dictionary part
 161+ E51E             >
 161+ E51E             >                org     Dict_Ptr
 161+ A24C             >
 161+ A24C 1C 24       >                dw      mirror_Ptr - $E000 + $1F00
 161+ A24E             >
 161+ A24E             >DP:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 161+ A24E CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 161+ A251             >
 161+ A251             >
 161+ A251             >                endif           ; ok        // for other definitions it "points" the correct handler
 161+ A251             >                // Use of "; ok" to suppress "warning[fwdref]"
 161+ A251             >
 161+ A251             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 161+ A251 12          >                db      18
 162+ A252                              User_Def VOC_LINK   , "VOC-LINK"  , 20 // pointer to the latest vocabulary
 162+ A252             >                New_Def  VOC_LINK, "VOC-LINK", User_Ptr, is_normal
 162+ A252             >
 162+ A252             >Dict_Ptr        defl    $
 162+ A252             >
 162+ A252             >//              ______________________________________________________________________
 162+ A252             >//              Heap part
 162+ A252             >
 162+ A252             >
 162+ A252             >                org     (Heap_Ptr & $1FFF) + $E000
 162+ E51E             >
 162+ E51E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 162+ E51E             >Latest_Definition defl  Heap_Ptr
 162+ E51E             >
 162+ E51E             >                // dummy db directives used to calculate length of namec
 162+ E51E 56 4F 43 2D >                db      "VOC-LINK"
 162+ E522 4C 49 4E 4B >
 162+ E526             >len_NFA         defl    $ - temp_NFA
 162+ E526             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 162+ E51E             >
 162+ E51E 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 162+ E51F 56 4F 43 2D >                db      "VOC-LINK"               // name string in 7-bit ascii, but
 162+ E523 4C 49 4E 4B >
 162+ E527             >                org     $-1                 // alter last byte of Name just above to set
 162+ E526 CB          >                db      {b $} | END_BIT     // msb as name end
 162+ E527             >
 162+ E527 17 05       >                dw      Prev_Ptr            // Link to previous definition Name
 162+ E529             >Prev_Ptr        defl    Heap_Ptr
 162+ E529             >
 162+ E529             >mirror_Ptr      defl    $
 162+ E529             >
 162+ E529 54 A2       >                dw      Dict_Ptr + 2        // xt
 162+ E52B             >Heap_Ptr        defl    $ - $E000           // save current HP
 162+ E52B             >
 162+ E52B             >Current_HP      defl  $ - $E000             // used to set HP once!
 162+ E52B             >
 162+ E52B             >//              ______________________________________________________________________
 162+ E52B             >//              Dictionary part
 162+ E52B             >
 162+ E52B             >                org     Dict_Ptr
 162+ A252             >
 162+ A252 29 24       >                dw      mirror_Ptr - $E000 + $1F00
 162+ A254             >
 162+ A254             >VOC_LINK:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 162+ A254 CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 162+ A257             >
 162+ A257             >
 162+ A257             >                endif           ; ok        // for other definitions it "points" the correct handler
 162+ A257             >                // Use of "; ok" to suppress "warning[fwdref]"
 162+ A257             >
 162+ A257             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 162+ A257 14          >                db      20
 163+ A258                              User_Def FIRST      , "FIRST"     , 22 // address of first buffer
 163+ A258             >                New_Def  FIRST, "FIRST", User_Ptr, is_normal
 163+ A258             >
 163+ A258             >Dict_Ptr        defl    $
 163+ A258             >
 163+ A258             >//              ______________________________________________________________________
 163+ A258             >//              Heap part
 163+ A258             >
 163+ A258             >
 163+ A258             >                org     (Heap_Ptr & $1FFF) + $E000
 163+ E52B             >
 163+ E52B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 163+ E52B             >Latest_Definition defl  Heap_Ptr
 163+ E52B             >
 163+ E52B             >                // dummy db directives used to calculate length of namec
 163+ E52B 46 49 52 53 >                db      "FIRST"
 163+ E52F 54          >
 163+ E530             >len_NFA         defl    $ - temp_NFA
 163+ E530             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 163+ E52B             >
 163+ E52B 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 163+ E52C 46 49 52 53 >                db      "FIRST"               // name string in 7-bit ascii, but
 163+ E530 54          >
 163+ E531             >                org     $-1                 // alter last byte of Name just above to set
 163+ E530 D4          >                db      {b $} | END_BIT     // msb as name end
 163+ E531             >
 163+ E531 1E 05       >                dw      Prev_Ptr            // Link to previous definition Name
 163+ E533             >Prev_Ptr        defl    Heap_Ptr
 163+ E533             >
 163+ E533             >mirror_Ptr      defl    $
 163+ E533             >
 163+ E533 5A A2       >                dw      Dict_Ptr + 2        // xt
 163+ E535             >Heap_Ptr        defl    $ - $E000           // save current HP
 163+ E535             >
 163+ E535             >Current_HP      defl  $ - $E000             // used to set HP once!
 163+ E535             >
 163+ E535             >//              ______________________________________________________________________
 163+ E535             >//              Dictionary part
 163+ E535             >
 163+ E535             >                org     Dict_Ptr
 163+ A258             >
 163+ A258 33 24       >                dw      mirror_Ptr - $E000 + $1F00
 163+ A25A             >
 163+ A25A             >FIRST:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 163+ A25A CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 163+ A25D             >
 163+ A25D             >
 163+ A25D             >                endif           ; ok        // for other definitions it "points" the correct handler
 163+ A25D             >                // Use of "; ok" to suppress "warning[fwdref]"
 163+ A25D             >
 163+ A25D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 163+ A25D 16          >                db      22
 164+ A25E                              User_Def LIMIT      , "LIMIT"     , 24 // address of last buffer
 164+ A25E             >                New_Def  LIMIT, "LIMIT", User_Ptr, is_normal
 164+ A25E             >
 164+ A25E             >Dict_Ptr        defl    $
 164+ A25E             >
 164+ A25E             >//              ______________________________________________________________________
 164+ A25E             >//              Heap part
 164+ A25E             >
 164+ A25E             >
 164+ A25E             >                org     (Heap_Ptr & $1FFF) + $E000
 164+ E535             >
 164+ E535             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 164+ E535             >Latest_Definition defl  Heap_Ptr
 164+ E535             >
 164+ E535             >                // dummy db directives used to calculate length of namec
 164+ E535 4C 49 4D 49 >                db      "LIMIT"
 164+ E539 54          >
 164+ E53A             >len_NFA         defl    $ - temp_NFA
 164+ E53A             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 164+ E535             >
 164+ E535 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 164+ E536 4C 49 4D 49 >                db      "LIMIT"               // name string in 7-bit ascii, but
 164+ E53A 54          >
 164+ E53B             >                org     $-1                 // alter last byte of Name just above to set
 164+ E53A D4          >                db      {b $} | END_BIT     // msb as name end
 164+ E53B             >
 164+ E53B 2B 05       >                dw      Prev_Ptr            // Link to previous definition Name
 164+ E53D             >Prev_Ptr        defl    Heap_Ptr
 164+ E53D             >
 164+ E53D             >mirror_Ptr      defl    $
 164+ E53D             >
 164+ E53D 60 A2       >                dw      Dict_Ptr + 2        // xt
 164+ E53F             >Heap_Ptr        defl    $ - $E000           // save current HP
 164+ E53F             >
 164+ E53F             >Current_HP      defl  $ - $E000             // used to set HP once!
 164+ E53F             >
 164+ E53F             >//              ______________________________________________________________________
 164+ E53F             >//              Dictionary part
 164+ E53F             >
 164+ E53F             >                org     Dict_Ptr
 164+ A25E             >
 164+ A25E 3D 24       >                dw      mirror_Ptr - $E000 + $1F00
 164+ A260             >
 164+ A260             >LIMIT:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 164+ A260 CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 164+ A263             >
 164+ A263             >
 164+ A263             >                endif           ; ok        // for other definitions it "points" the correct handler
 164+ A263             >                // Use of "; ok" to suppress "warning[fwdref]"
 164+ A263             >
 164+ A263             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 164+ A263 18          >                db      24
 165+ A264                              User_Def HP         , "HP"        , 26 // heap-pointer address
 165+ A264             >                New_Def  HP, "HP", User_Ptr, is_normal
 165+ A264             >
 165+ A264             >Dict_Ptr        defl    $
 165+ A264             >
 165+ A264             >//              ______________________________________________________________________
 165+ A264             >//              Heap part
 165+ A264             >
 165+ A264             >
 165+ A264             >                org     (Heap_Ptr & $1FFF) + $E000
 165+ E53F             >
 165+ E53F             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 165+ E53F             >Latest_Definition defl  Heap_Ptr
 165+ E53F             >
 165+ E53F             >                // dummy db directives used to calculate length of namec
 165+ E53F 48 50       >                db      "HP"
 165+ E541             >len_NFA         defl    $ - temp_NFA
 165+ E541             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 165+ E53F             >
 165+ E53F 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 165+ E540 48 50       >                db      "HP"               // name string in 7-bit ascii, but
 165+ E542             >                org     $-1                 // alter last byte of Name just above to set
 165+ E541 D0          >                db      {b $} | END_BIT     // msb as name end
 165+ E542             >
 165+ E542 35 05       >                dw      Prev_Ptr            // Link to previous definition Name
 165+ E544             >Prev_Ptr        defl    Heap_Ptr
 165+ E544             >
 165+ E544             >mirror_Ptr      defl    $
 165+ E544             >
 165+ E544 66 A2       >                dw      Dict_Ptr + 2        // xt
 165+ E546             >Heap_Ptr        defl    $ - $E000           // save current HP
 165+ E546             >
 165+ E546             >Current_HP      defl  $ - $E000             // used to set HP once!
 165+ E546             >
 165+ E546             >//              ______________________________________________________________________
 165+ E546             >//              Dictionary part
 165+ E546             >
 165+ E546             >                org     Dict_Ptr
 165+ A264             >
 165+ A264 44 24       >                dw      mirror_Ptr - $E000 + $1F00
 165+ A266             >
 165+ A266             >HP:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 165+ A266 CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 165+ A269             >
 165+ A269             >
 165+ A269             >                endif           ; ok        // for other definitions it "points" the correct handler
 165+ A269             >                // Use of "; ok" to suppress "warning[fwdref]"
 165+ A269             >
 165+ A269             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 165+ A269 1A          >                db      26
 166+ A26A                              User_Def NMODE      , "NMODE"     , 28 // number mode: 0 integer, 1 floating point
 166+ A26A             >                New_Def  NMODE, "NMODE", User_Ptr, is_normal
 166+ A26A             >
 166+ A26A             >Dict_Ptr        defl    $
 166+ A26A             >
 166+ A26A             >//              ______________________________________________________________________
 166+ A26A             >//              Heap part
 166+ A26A             >
 166+ A26A             >
 166+ A26A             >                org     (Heap_Ptr & $1FFF) + $E000
 166+ E546             >
 166+ E546             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 166+ E546             >Latest_Definition defl  Heap_Ptr
 166+ E546             >
 166+ E546             >                // dummy db directives used to calculate length of namec
 166+ E546 4E 4D 4F 44 >                db      "NMODE"
 166+ E54A 45          >
 166+ E54B             >len_NFA         defl    $ - temp_NFA
 166+ E54B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 166+ E546             >
 166+ E546 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 166+ E547 4E 4D 4F 44 >                db      "NMODE"               // name string in 7-bit ascii, but
 166+ E54B 45          >
 166+ E54C             >                org     $-1                 // alter last byte of Name just above to set
 166+ E54B C5          >                db      {b $} | END_BIT     // msb as name end
 166+ E54C             >
 166+ E54C 3F 05       >                dw      Prev_Ptr            // Link to previous definition Name
 166+ E54E             >Prev_Ptr        defl    Heap_Ptr
 166+ E54E             >
 166+ E54E             >mirror_Ptr      defl    $
 166+ E54E             >
 166+ E54E 6C A2       >                dw      Dict_Ptr + 2        // xt
 166+ E550             >Heap_Ptr        defl    $ - $E000           // save current HP
 166+ E550             >
 166+ E550             >Current_HP      defl  $ - $E000             // used to set HP once!
 166+ E550             >
 166+ E550             >//              ______________________________________________________________________
 166+ E550             >//              Dictionary part
 166+ E550             >
 166+ E550             >                org     Dict_Ptr
 166+ A26A             >
 166+ A26A 4E 24       >                dw      mirror_Ptr - $E000 + $1F00
 166+ A26C             >
 166+ A26C             >NMODE:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 166+ A26C CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 166+ A26F             >
 166+ A26F             >
 166+ A26F             >                endif           ; ok        // for other definitions it "points" the correct handler
 166+ A26F             >                // Use of "; ok" to suppress "warning[fwdref]"
 166+ A26F             >
 166+ A26F             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 166+ A26F 1C          >                db      28
 167+ A270                              User_Def BLK        , "BLK"       , 30 // block number to be interpreted. 0 for terminal
 167+ A270             >                New_Def  BLK, "BLK", User_Ptr, is_normal
 167+ A270             >
 167+ A270             >Dict_Ptr        defl    $
 167+ A270             >
 167+ A270             >//              ______________________________________________________________________
 167+ A270             >//              Heap part
 167+ A270             >
 167+ A270             >
 167+ A270             >                org     (Heap_Ptr & $1FFF) + $E000
 167+ E550             >
 167+ E550             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 167+ E550             >Latest_Definition defl  Heap_Ptr
 167+ E550             >
 167+ E550             >                // dummy db directives used to calculate length of namec
 167+ E550 42 4C 4B    >                db      "BLK"
 167+ E553             >len_NFA         defl    $ - temp_NFA
 167+ E553             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 167+ E550             >
 167+ E550 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 167+ E551 42 4C 4B    >                db      "BLK"               // name string in 7-bit ascii, but
 167+ E554             >                org     $-1                 // alter last byte of Name just above to set
 167+ E553 CB          >                db      {b $} | END_BIT     // msb as name end
 167+ E554             >
 167+ E554 46 05       >                dw      Prev_Ptr            // Link to previous definition Name
 167+ E556             >Prev_Ptr        defl    Heap_Ptr
 167+ E556             >
 167+ E556             >mirror_Ptr      defl    $
 167+ E556             >
 167+ E556 72 A2       >                dw      Dict_Ptr + 2        // xt
 167+ E558             >Heap_Ptr        defl    $ - $E000           // save current HP
 167+ E558             >
 167+ E558             >Current_HP      defl  $ - $E000             // used to set HP once!
 167+ E558             >
 167+ E558             >//              ______________________________________________________________________
 167+ E558             >//              Dictionary part
 167+ E558             >
 167+ E558             >                org     Dict_Ptr
 167+ A270             >
 167+ A270 56 24       >                dw      mirror_Ptr - $E000 + $1F00
 167+ A272             >
 167+ A272             >BLK:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 167+ A272 CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 167+ A275             >
 167+ A275             >
 167+ A275             >                endif           ; ok        // for other definitions it "points" the correct handler
 167+ A275             >                // Use of "; ok" to suppress "warning[fwdref]"
 167+ A275             >
 167+ A275             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 167+ A275 1E          >                db      30
 168+ A276                              User_Def TO_IN      , ">IN"       , 32 // incremented when consuming input buffer
 168+ A276             >                New_Def  TO_IN, ">IN", User_Ptr, is_normal
 168+ A276             >
 168+ A276             >Dict_Ptr        defl    $
 168+ A276             >
 168+ A276             >//              ______________________________________________________________________
 168+ A276             >//              Heap part
 168+ A276             >
 168+ A276             >
 168+ A276             >                org     (Heap_Ptr & $1FFF) + $E000
 168+ E558             >
 168+ E558             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 168+ E558             >Latest_Definition defl  Heap_Ptr
 168+ E558             >
 168+ E558             >                // dummy db directives used to calculate length of namec
 168+ E558 3E 49 4E    >                db      ">IN"
 168+ E55B             >len_NFA         defl    $ - temp_NFA
 168+ E55B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 168+ E558             >
 168+ E558 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 168+ E559 3E 49 4E    >                db      ">IN"               // name string in 7-bit ascii, but
 168+ E55C             >                org     $-1                 // alter last byte of Name just above to set
 168+ E55B CE          >                db      {b $} | END_BIT     // msb as name end
 168+ E55C             >
 168+ E55C 50 05       >                dw      Prev_Ptr            // Link to previous definition Name
 168+ E55E             >Prev_Ptr        defl    Heap_Ptr
 168+ E55E             >
 168+ E55E             >mirror_Ptr      defl    $
 168+ E55E             >
 168+ E55E 78 A2       >                dw      Dict_Ptr + 2        // xt
 168+ E560             >Heap_Ptr        defl    $ - $E000           // save current HP
 168+ E560             >
 168+ E560             >Current_HP      defl  $ - $E000             // used to set HP once!
 168+ E560             >
 168+ E560             >//              ______________________________________________________________________
 168+ E560             >//              Dictionary part
 168+ E560             >
 168+ E560             >                org     Dict_Ptr
 168+ A276             >
 168+ A276 5E 24       >                dw      mirror_Ptr - $E000 + $1F00
 168+ A278             >
 168+ A278             >TO_IN:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 168+ A278 CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 168+ A27B             >
 168+ A27B             >
 168+ A27B             >                endif           ; ok        // for other definitions it "points" the correct handler
 168+ A27B             >                // Use of "; ok" to suppress "warning[fwdref]"
 168+ A27B             >
 168+ A27B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 168+ A27B 20          >                db      32
 169+ A27C                              User_Def OUT        , "OUT"       , 34 // incremented when sending to output
 169+ A27C             >                New_Def  OUT, "OUT", User_Ptr, is_normal
 169+ A27C             >
 169+ A27C             >Dict_Ptr        defl    $
 169+ A27C             >
 169+ A27C             >//              ______________________________________________________________________
 169+ A27C             >//              Heap part
 169+ A27C             >
 169+ A27C             >
 169+ A27C             >                org     (Heap_Ptr & $1FFF) + $E000
 169+ E560             >
 169+ E560             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 169+ E560             >Latest_Definition defl  Heap_Ptr
 169+ E560             >
 169+ E560             >                // dummy db directives used to calculate length of namec
 169+ E560 4F 55 54    >                db      "OUT"
 169+ E563             >len_NFA         defl    $ - temp_NFA
 169+ E563             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 169+ E560             >
 169+ E560 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 169+ E561 4F 55 54    >                db      "OUT"               // name string in 7-bit ascii, but
 169+ E564             >                org     $-1                 // alter last byte of Name just above to set
 169+ E563 D4          >                db      {b $} | END_BIT     // msb as name end
 169+ E564             >
 169+ E564 58 05       >                dw      Prev_Ptr            // Link to previous definition Name
 169+ E566             >Prev_Ptr        defl    Heap_Ptr
 169+ E566             >
 169+ E566             >mirror_Ptr      defl    $
 169+ E566             >
 169+ E566 7E A2       >                dw      Dict_Ptr + 2        // xt
 169+ E568             >Heap_Ptr        defl    $ - $E000           // save current HP
 169+ E568             >
 169+ E568             >Current_HP      defl  $ - $E000             // used to set HP once!
 169+ E568             >
 169+ E568             >//              ______________________________________________________________________
 169+ E568             >//              Dictionary part
 169+ E568             >
 169+ E568             >                org     Dict_Ptr
 169+ A27C             >
 169+ A27C 66 24       >                dw      mirror_Ptr - $E000 + $1F00
 169+ A27E             >
 169+ A27E             >OUT:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 169+ A27E CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 169+ A281             >
 169+ A281             >
 169+ A281             >                endif           ; ok        // for other definitions it "points" the correct handler
 169+ A281             >                // Use of "; ok" to suppress "warning[fwdref]"
 169+ A281             >
 169+ A281             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 169+ A281 22          >                db      34
 170+ A282                              User_Def SCR        , "SCR"       , 36 // latest screen retreieved by LIST
 170+ A282             >                New_Def  SCR, "SCR", User_Ptr, is_normal
 170+ A282             >
 170+ A282             >Dict_Ptr        defl    $
 170+ A282             >
 170+ A282             >//              ______________________________________________________________________
 170+ A282             >//              Heap part
 170+ A282             >
 170+ A282             >
 170+ A282             >                org     (Heap_Ptr & $1FFF) + $E000
 170+ E568             >
 170+ E568             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 170+ E568             >Latest_Definition defl  Heap_Ptr
 170+ E568             >
 170+ E568             >                // dummy db directives used to calculate length of namec
 170+ E568 53 43 52    >                db      "SCR"
 170+ E56B             >len_NFA         defl    $ - temp_NFA
 170+ E56B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 170+ E568             >
 170+ E568 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 170+ E569 53 43 52    >                db      "SCR"               // name string in 7-bit ascii, but
 170+ E56C             >                org     $-1                 // alter last byte of Name just above to set
 170+ E56B D2          >                db      {b $} | END_BIT     // msb as name end
 170+ E56C             >
 170+ E56C 60 05       >                dw      Prev_Ptr            // Link to previous definition Name
 170+ E56E             >Prev_Ptr        defl    Heap_Ptr
 170+ E56E             >
 170+ E56E             >mirror_Ptr      defl    $
 170+ E56E             >
 170+ E56E 84 A2       >                dw      Dict_Ptr + 2        // xt
 170+ E570             >Heap_Ptr        defl    $ - $E000           // save current HP
 170+ E570             >
 170+ E570             >Current_HP      defl  $ - $E000             // used to set HP once!
 170+ E570             >
 170+ E570             >//              ______________________________________________________________________
 170+ E570             >//              Dictionary part
 170+ E570             >
 170+ E570             >                org     Dict_Ptr
 170+ A282             >
 170+ A282 6E 24       >                dw      mirror_Ptr - $E000 + $1F00
 170+ A284             >
 170+ A284             >SCR:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 170+ A284 CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 170+ A287             >
 170+ A287             >
 170+ A287             >                endif           ; ok        // for other definitions it "points" the correct handler
 170+ A287             >                // Use of "; ok" to suppress "warning[fwdref]"
 170+ A287             >
 170+ A287             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 170+ A287 24          >                db      36
 171+ A288                              User_Def OFFSET     , "OFFSET"    , 38 //
 171+ A288             >                New_Def  OFFSET, "OFFSET", User_Ptr, is_normal
 171+ A288             >
 171+ A288             >Dict_Ptr        defl    $
 171+ A288             >
 171+ A288             >//              ______________________________________________________________________
 171+ A288             >//              Heap part
 171+ A288             >
 171+ A288             >
 171+ A288             >                org     (Heap_Ptr & $1FFF) + $E000
 171+ E570             >
 171+ E570             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 171+ E570             >Latest_Definition defl  Heap_Ptr
 171+ E570             >
 171+ E570             >                // dummy db directives used to calculate length of namec
 171+ E570 4F 46 46 53 >                db      "OFFSET"
 171+ E574 45 54       >
 171+ E576             >len_NFA         defl    $ - temp_NFA
 171+ E576             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 171+ E570             >
 171+ E570 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 171+ E571 4F 46 46 53 >                db      "OFFSET"               // name string in 7-bit ascii, but
 171+ E575 45 54       >
 171+ E577             >                org     $-1                 // alter last byte of Name just above to set
 171+ E576 D4          >                db      {b $} | END_BIT     // msb as name end
 171+ E577             >
 171+ E577 68 05       >                dw      Prev_Ptr            // Link to previous definition Name
 171+ E579             >Prev_Ptr        defl    Heap_Ptr
 171+ E579             >
 171+ E579             >mirror_Ptr      defl    $
 171+ E579             >
 171+ E579 8A A2       >                dw      Dict_Ptr + 2        // xt
 171+ E57B             >Heap_Ptr        defl    $ - $E000           // save current HP
 171+ E57B             >
 171+ E57B             >Current_HP      defl  $ - $E000             // used to set HP once!
 171+ E57B             >
 171+ E57B             >//              ______________________________________________________________________
 171+ E57B             >//              Dictionary part
 171+ E57B             >
 171+ E57B             >                org     Dict_Ptr
 171+ A288             >
 171+ A288 79 24       >                dw      mirror_Ptr - $E000 + $1F00
 171+ A28A             >
 171+ A28A             >OFFSET:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 171+ A28A CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 171+ A28D             >
 171+ A28D             >
 171+ A28D             >                endif           ; ok        // for other definitions it "points" the correct handler
 171+ A28D             >                // Use of "; ok" to suppress "warning[fwdref]"
 171+ A28D             >
 171+ A28D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 171+ A28D 26          >                db      38
 172+ A28E                              User_Def CONTEXT    , "CONTEXT"   , 40 // pointer to the vocabulary where search begins
 172+ A28E             >                New_Def  CONTEXT, "CONTEXT", User_Ptr, is_normal
 172+ A28E             >
 172+ A28E             >Dict_Ptr        defl    $
 172+ A28E             >
 172+ A28E             >//              ______________________________________________________________________
 172+ A28E             >//              Heap part
 172+ A28E             >
 172+ A28E             >
 172+ A28E             >                org     (Heap_Ptr & $1FFF) + $E000
 172+ E57B             >
 172+ E57B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 172+ E57B             >Latest_Definition defl  Heap_Ptr
 172+ E57B             >
 172+ E57B             >                // dummy db directives used to calculate length of namec
 172+ E57B 43 4F 4E 54 >                db      "CONTEXT"
 172+ E57F 45 58 54    >
 172+ E582             >len_NFA         defl    $ - temp_NFA
 172+ E582             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 172+ E57B             >
 172+ E57B 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 172+ E57C 43 4F 4E 54 >                db      "CONTEXT"               // name string in 7-bit ascii, but
 172+ E580 45 58 54    >
 172+ E583             >                org     $-1                 // alter last byte of Name just above to set
 172+ E582 D4          >                db      {b $} | END_BIT     // msb as name end
 172+ E583             >
 172+ E583 70 05       >                dw      Prev_Ptr            // Link to previous definition Name
 172+ E585             >Prev_Ptr        defl    Heap_Ptr
 172+ E585             >
 172+ E585             >mirror_Ptr      defl    $
 172+ E585             >
 172+ E585 90 A2       >                dw      Dict_Ptr + 2        // xt
 172+ E587             >Heap_Ptr        defl    $ - $E000           // save current HP
 172+ E587             >
 172+ E587             >Current_HP      defl  $ - $E000             // used to set HP once!
 172+ E587             >
 172+ E587             >//              ______________________________________________________________________
 172+ E587             >//              Dictionary part
 172+ E587             >
 172+ E587             >                org     Dict_Ptr
 172+ A28E             >
 172+ A28E 85 24       >                dw      mirror_Ptr - $E000 + $1F00
 172+ A290             >
 172+ A290             >CONTEXT:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 172+ A290 CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 172+ A293             >
 172+ A293             >
 172+ A293             >                endif           ; ok        // for other definitions it "points" the correct handler
 172+ A293             >                // Use of "; ok" to suppress "warning[fwdref]"
 172+ A293             >
 172+ A293             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 172+ A293 28          >                db      40
 173+ A294                              User_Def CURRENT    , "CURRENT"   , 42 // pointer to the vocabulary where search continues
 173+ A294             >                New_Def  CURRENT, "CURRENT", User_Ptr, is_normal
 173+ A294             >
 173+ A294             >Dict_Ptr        defl    $
 173+ A294             >
 173+ A294             >//              ______________________________________________________________________
 173+ A294             >//              Heap part
 173+ A294             >
 173+ A294             >
 173+ A294             >                org     (Heap_Ptr & $1FFF) + $E000
 173+ E587             >
 173+ E587             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 173+ E587             >Latest_Definition defl  Heap_Ptr
 173+ E587             >
 173+ E587             >                // dummy db directives used to calculate length of namec
 173+ E587 43 55 52 52 >                db      "CURRENT"
 173+ E58B 45 4E 54    >
 173+ E58E             >len_NFA         defl    $ - temp_NFA
 173+ E58E             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 173+ E587             >
 173+ E587 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 173+ E588 43 55 52 52 >                db      "CURRENT"               // name string in 7-bit ascii, but
 173+ E58C 45 4E 54    >
 173+ E58F             >                org     $-1                 // alter last byte of Name just above to set
 173+ E58E D4          >                db      {b $} | END_BIT     // msb as name end
 173+ E58F             >
 173+ E58F 7B 05       >                dw      Prev_Ptr            // Link to previous definition Name
 173+ E591             >Prev_Ptr        defl    Heap_Ptr
 173+ E591             >
 173+ E591             >mirror_Ptr      defl    $
 173+ E591             >
 173+ E591 96 A2       >                dw      Dict_Ptr + 2        // xt
 173+ E593             >Heap_Ptr        defl    $ - $E000           // save current HP
 173+ E593             >
 173+ E593             >Current_HP      defl  $ - $E000             // used to set HP once!
 173+ E593             >
 173+ E593             >//              ______________________________________________________________________
 173+ E593             >//              Dictionary part
 173+ E593             >
 173+ E593             >                org     Dict_Ptr
 173+ A294             >
 173+ A294 91 24       >                dw      mirror_Ptr - $E000 + $1F00
 173+ A296             >
 173+ A296             >CURRENT:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 173+ A296 CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 173+ A299             >
 173+ A299             >
 173+ A299             >                endif           ; ok        // for other definitions it "points" the correct handler
 173+ A299             >                // Use of "; ok" to suppress "warning[fwdref]"
 173+ A299             >
 173+ A299             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 173+ A299 2A          >                db      42
 174+ A29A                              User_Def STATE      , "STATE"     , 44 // compilation status. 0 interpreting.
 174+ A29A             >                New_Def  STATE, "STATE", User_Ptr, is_normal
 174+ A29A             >
 174+ A29A             >Dict_Ptr        defl    $
 174+ A29A             >
 174+ A29A             >//              ______________________________________________________________________
 174+ A29A             >//              Heap part
 174+ A29A             >
 174+ A29A             >
 174+ A29A             >                org     (Heap_Ptr & $1FFF) + $E000
 174+ E593             >
 174+ E593             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 174+ E593             >Latest_Definition defl  Heap_Ptr
 174+ E593             >
 174+ E593             >                // dummy db directives used to calculate length of namec
 174+ E593 53 54 41 54 >                db      "STATE"
 174+ E597 45          >
 174+ E598             >len_NFA         defl    $ - temp_NFA
 174+ E598             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 174+ E593             >
 174+ E593 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 174+ E594 53 54 41 54 >                db      "STATE"               // name string in 7-bit ascii, but
 174+ E598 45          >
 174+ E599             >                org     $-1                 // alter last byte of Name just above to set
 174+ E598 C5          >                db      {b $} | END_BIT     // msb as name end
 174+ E599             >
 174+ E599 87 05       >                dw      Prev_Ptr            // Link to previous definition Name
 174+ E59B             >Prev_Ptr        defl    Heap_Ptr
 174+ E59B             >
 174+ E59B             >mirror_Ptr      defl    $
 174+ E59B             >
 174+ E59B 9C A2       >                dw      Dict_Ptr + 2        // xt
 174+ E59D             >Heap_Ptr        defl    $ - $E000           // save current HP
 174+ E59D             >
 174+ E59D             >Current_HP      defl  $ - $E000             // used to set HP once!
 174+ E59D             >
 174+ E59D             >//              ______________________________________________________________________
 174+ E59D             >//              Dictionary part
 174+ E59D             >
 174+ E59D             >                org     Dict_Ptr
 174+ A29A             >
 174+ A29A 9B 24       >                dw      mirror_Ptr - $E000 + $1F00
 174+ A29C             >
 174+ A29C             >STATE:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 174+ A29C CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 174+ A29F             >
 174+ A29F             >
 174+ A29F             >                endif           ; ok        // for other definitions it "points" the correct handler
 174+ A29F             >                // Use of "; ok" to suppress "warning[fwdref]"
 174+ A29F             >
 174+ A29F             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 174+ A29F 2C          >                db      44
 175+ A2A0                              User_Def BASE       , "BASE"      , 46 //
 175+ A2A0             >                New_Def  BASE, "BASE", User_Ptr, is_normal
 175+ A2A0             >
 175+ A2A0             >Dict_Ptr        defl    $
 175+ A2A0             >
 175+ A2A0             >//              ______________________________________________________________________
 175+ A2A0             >//              Heap part
 175+ A2A0             >
 175+ A2A0             >
 175+ A2A0             >                org     (Heap_Ptr & $1FFF) + $E000
 175+ E59D             >
 175+ E59D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 175+ E59D             >Latest_Definition defl  Heap_Ptr
 175+ E59D             >
 175+ E59D             >                // dummy db directives used to calculate length of namec
 175+ E59D 42 41 53 45 >                db      "BASE"
 175+ E5A1             >len_NFA         defl    $ - temp_NFA
 175+ E5A1             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 175+ E59D             >
 175+ E59D 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 175+ E59E 42 41 53 45 >                db      "BASE"               // name string in 7-bit ascii, but
 175+ E5A2             >                org     $-1                 // alter last byte of Name just above to set
 175+ E5A1 C5          >                db      {b $} | END_BIT     // msb as name end
 175+ E5A2             >
 175+ E5A2 93 05       >                dw      Prev_Ptr            // Link to previous definition Name
 175+ E5A4             >Prev_Ptr        defl    Heap_Ptr
 175+ E5A4             >
 175+ E5A4             >mirror_Ptr      defl    $
 175+ E5A4             >
 175+ E5A4 A2 A2       >                dw      Dict_Ptr + 2        // xt
 175+ E5A6             >Heap_Ptr        defl    $ - $E000           // save current HP
 175+ E5A6             >
 175+ E5A6             >Current_HP      defl  $ - $E000             // used to set HP once!
 175+ E5A6             >
 175+ E5A6             >//              ______________________________________________________________________
 175+ E5A6             >//              Dictionary part
 175+ E5A6             >
 175+ E5A6             >                org     Dict_Ptr
 175+ A2A0             >
 175+ A2A0 A4 24       >                dw      mirror_Ptr - $E000 + $1F00
 175+ A2A2             >
 175+ A2A2             >BASE:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 175+ A2A2 CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 175+ A2A5             >
 175+ A2A5             >
 175+ A2A5             >                endif           ; ok        // for other definitions it "points" the correct handler
 175+ A2A5             >                // Use of "; ok" to suppress "warning[fwdref]"
 175+ A2A5             >
 175+ A2A5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 175+ A2A5 2E          >                db      46
 176+ A2A6                              User_Def DPL        , "DPL"       , 48 // number of digits after decimal point in conversion
 176+ A2A6             >                New_Def  DPL, "DPL", User_Ptr, is_normal
 176+ A2A6             >
 176+ A2A6             >Dict_Ptr        defl    $
 176+ A2A6             >
 176+ A2A6             >//              ______________________________________________________________________
 176+ A2A6             >//              Heap part
 176+ A2A6             >
 176+ A2A6             >
 176+ A2A6             >                org     (Heap_Ptr & $1FFF) + $E000
 176+ E5A6             >
 176+ E5A6             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 176+ E5A6             >Latest_Definition defl  Heap_Ptr
 176+ E5A6             >
 176+ E5A6             >                // dummy db directives used to calculate length of namec
 176+ E5A6 44 50 4C    >                db      "DPL"
 176+ E5A9             >len_NFA         defl    $ - temp_NFA
 176+ E5A9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 176+ E5A6             >
 176+ E5A6 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 176+ E5A7 44 50 4C    >                db      "DPL"               // name string in 7-bit ascii, but
 176+ E5AA             >                org     $-1                 // alter last byte of Name just above to set
 176+ E5A9 CC          >                db      {b $} | END_BIT     // msb as name end
 176+ E5AA             >
 176+ E5AA 9D 05       >                dw      Prev_Ptr            // Link to previous definition Name
 176+ E5AC             >Prev_Ptr        defl    Heap_Ptr
 176+ E5AC             >
 176+ E5AC             >mirror_Ptr      defl    $
 176+ E5AC             >
 176+ E5AC A8 A2       >                dw      Dict_Ptr + 2        // xt
 176+ E5AE             >Heap_Ptr        defl    $ - $E000           // save current HP
 176+ E5AE             >
 176+ E5AE             >Current_HP      defl  $ - $E000             // used to set HP once!
 176+ E5AE             >
 176+ E5AE             >//              ______________________________________________________________________
 176+ E5AE             >//              Dictionary part
 176+ E5AE             >
 176+ E5AE             >                org     Dict_Ptr
 176+ A2A6             >
 176+ A2A6 AC 24       >                dw      mirror_Ptr - $E000 + $1F00
 176+ A2A8             >
 176+ A2A8             >DPL:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 176+ A2A8 CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 176+ A2AB             >
 176+ A2AB             >
 176+ A2AB             >                endif           ; ok        // for other definitions it "points" the correct handler
 176+ A2AB             >                // Use of "; ok" to suppress "warning[fwdref]"
 176+ A2AB             >
 176+ A2AB             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 176+ A2AB 30          >                db      48
 177+ A2AC                              User_Def FLD        , "FLD"       , 50 // output field width
 177+ A2AC             >                New_Def  FLD, "FLD", User_Ptr, is_normal
 177+ A2AC             >
 177+ A2AC             >Dict_Ptr        defl    $
 177+ A2AC             >
 177+ A2AC             >//              ______________________________________________________________________
 177+ A2AC             >//              Heap part
 177+ A2AC             >
 177+ A2AC             >
 177+ A2AC             >                org     (Heap_Ptr & $1FFF) + $E000
 177+ E5AE             >
 177+ E5AE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 177+ E5AE             >Latest_Definition defl  Heap_Ptr
 177+ E5AE             >
 177+ E5AE             >                // dummy db directives used to calculate length of namec
 177+ E5AE 46 4C 44    >                db      "FLD"
 177+ E5B1             >len_NFA         defl    $ - temp_NFA
 177+ E5B1             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 177+ E5AE             >
 177+ E5AE 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 177+ E5AF 46 4C 44    >                db      "FLD"               // name string in 7-bit ascii, but
 177+ E5B2             >                org     $-1                 // alter last byte of Name just above to set
 177+ E5B1 C4          >                db      {b $} | END_BIT     // msb as name end
 177+ E5B2             >
 177+ E5B2 A6 05       >                dw      Prev_Ptr            // Link to previous definition Name
 177+ E5B4             >Prev_Ptr        defl    Heap_Ptr
 177+ E5B4             >
 177+ E5B4             >mirror_Ptr      defl    $
 177+ E5B4             >
 177+ E5B4 AE A2       >                dw      Dict_Ptr + 2        // xt
 177+ E5B6             >Heap_Ptr        defl    $ - $E000           // save current HP
 177+ E5B6             >
 177+ E5B6             >Current_HP      defl  $ - $E000             // used to set HP once!
 177+ E5B6             >
 177+ E5B6             >//              ______________________________________________________________________
 177+ E5B6             >//              Dictionary part
 177+ E5B6             >
 177+ E5B6             >                org     Dict_Ptr
 177+ A2AC             >
 177+ A2AC B4 24       >                dw      mirror_Ptr - $E000 + $1F00
 177+ A2AE             >
 177+ A2AE             >FLD:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 177+ A2AE CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 177+ A2B1             >
 177+ A2B1             >
 177+ A2B1             >                endif           ; ok        // for other definitions it "points" the correct handler
 177+ A2B1             >                // Use of "; ok" to suppress "warning[fwdref]"
 177+ A2B1             >
 177+ A2B1             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 177+ A2B1 32          >                db      50
 178+ A2B2                              User_Def CSP        , "CSP"       , 52 // used to temporary store Stack-Pointer value
 178+ A2B2             >                New_Def  CSP, "CSP", User_Ptr, is_normal
 178+ A2B2             >
 178+ A2B2             >Dict_Ptr        defl    $
 178+ A2B2             >
 178+ A2B2             >//              ______________________________________________________________________
 178+ A2B2             >//              Heap part
 178+ A2B2             >
 178+ A2B2             >
 178+ A2B2             >                org     (Heap_Ptr & $1FFF) + $E000
 178+ E5B6             >
 178+ E5B6             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 178+ E5B6             >Latest_Definition defl  Heap_Ptr
 178+ E5B6             >
 178+ E5B6             >                // dummy db directives used to calculate length of namec
 178+ E5B6 43 53 50    >                db      "CSP"
 178+ E5B9             >len_NFA         defl    $ - temp_NFA
 178+ E5B9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 178+ E5B6             >
 178+ E5B6 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 178+ E5B7 43 53 50    >                db      "CSP"               // name string in 7-bit ascii, but
 178+ E5BA             >                org     $-1                 // alter last byte of Name just above to set
 178+ E5B9 D0          >                db      {b $} | END_BIT     // msb as name end
 178+ E5BA             >
 178+ E5BA AE 05       >                dw      Prev_Ptr            // Link to previous definition Name
 178+ E5BC             >Prev_Ptr        defl    Heap_Ptr
 178+ E5BC             >
 178+ E5BC             >mirror_Ptr      defl    $
 178+ E5BC             >
 178+ E5BC B4 A2       >                dw      Dict_Ptr + 2        // xt
 178+ E5BE             >Heap_Ptr        defl    $ - $E000           // save current HP
 178+ E5BE             >
 178+ E5BE             >Current_HP      defl  $ - $E000             // used to set HP once!
 178+ E5BE             >
 178+ E5BE             >//              ______________________________________________________________________
 178+ E5BE             >//              Dictionary part
 178+ E5BE             >
 178+ E5BE             >                org     Dict_Ptr
 178+ A2B2             >
 178+ A2B2 BC 24       >                dw      mirror_Ptr - $E000 + $1F00
 178+ A2B4             >
 178+ A2B4             >CSP:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 178+ A2B4 CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 178+ A2B7             >
 178+ A2B7             >
 178+ A2B7             >                endif           ; ok        // for other definitions it "points" the correct handler
 178+ A2B7             >                // Use of "; ok" to suppress "warning[fwdref]"
 178+ A2B7             >
 178+ A2B7             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 178+ A2B7 34          >                db      52
 179+ A2B8                              User_Def RSHARP     , "R#"        , 54 // location of editing cursor
 179+ A2B8             >                New_Def  RSHARP, "R#", User_Ptr, is_normal
 179+ A2B8             >
 179+ A2B8             >Dict_Ptr        defl    $
 179+ A2B8             >
 179+ A2B8             >//              ______________________________________________________________________
 179+ A2B8             >//              Heap part
 179+ A2B8             >
 179+ A2B8             >
 179+ A2B8             >                org     (Heap_Ptr & $1FFF) + $E000
 179+ E5BE             >
 179+ E5BE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 179+ E5BE             >Latest_Definition defl  Heap_Ptr
 179+ E5BE             >
 179+ E5BE             >                // dummy db directives used to calculate length of namec
 179+ E5BE 52 23       >                db      "R#"
 179+ E5C0             >len_NFA         defl    $ - temp_NFA
 179+ E5C0             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 179+ E5BE             >
 179+ E5BE 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 179+ E5BF 52 23       >                db      "R#"               // name string in 7-bit ascii, but
 179+ E5C1             >                org     $-1                 // alter last byte of Name just above to set
 179+ E5C0 A3          >                db      {b $} | END_BIT     // msb as name end
 179+ E5C1             >
 179+ E5C1 B6 05       >                dw      Prev_Ptr            // Link to previous definition Name
 179+ E5C3             >Prev_Ptr        defl    Heap_Ptr
 179+ E5C3             >
 179+ E5C3             >mirror_Ptr      defl    $
 179+ E5C3             >
 179+ E5C3 BA A2       >                dw      Dict_Ptr + 2        // xt
 179+ E5C5             >Heap_Ptr        defl    $ - $E000           // save current HP
 179+ E5C5             >
 179+ E5C5             >Current_HP      defl  $ - $E000             // used to set HP once!
 179+ E5C5             >
 179+ E5C5             >//              ______________________________________________________________________
 179+ E5C5             >//              Dictionary part
 179+ E5C5             >
 179+ E5C5             >                org     Dict_Ptr
 179+ A2B8             >
 179+ A2B8 C3 24       >                dw      mirror_Ptr - $E000 + $1F00
 179+ A2BA             >
 179+ A2BA             >RSHARP:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 179+ A2BA CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 179+ A2BD             >
 179+ A2BD             >
 179+ A2BD             >                endif           ; ok        // for other definitions it "points" the correct handler
 179+ A2BD             >                // Use of "; ok" to suppress "warning[fwdref]"
 179+ A2BD             >
 179+ A2BD             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 179+ A2BD 36          >                db      54
 180+ A2BE                              User_Def HLD        , "HLD"       , 56 // last character during a number conversion output
 180+ A2BE             >                New_Def  HLD, "HLD", User_Ptr, is_normal
 180+ A2BE             >
 180+ A2BE             >Dict_Ptr        defl    $
 180+ A2BE             >
 180+ A2BE             >//              ______________________________________________________________________
 180+ A2BE             >//              Heap part
 180+ A2BE             >
 180+ A2BE             >
 180+ A2BE             >                org     (Heap_Ptr & $1FFF) + $E000
 180+ E5C5             >
 180+ E5C5             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 180+ E5C5             >Latest_Definition defl  Heap_Ptr
 180+ E5C5             >
 180+ E5C5             >                // dummy db directives used to calculate length of namec
 180+ E5C5 48 4C 44    >                db      "HLD"
 180+ E5C8             >len_NFA         defl    $ - temp_NFA
 180+ E5C8             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 180+ E5C5             >
 180+ E5C5 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 180+ E5C6 48 4C 44    >                db      "HLD"               // name string in 7-bit ascii, but
 180+ E5C9             >                org     $-1                 // alter last byte of Name just above to set
 180+ E5C8 C4          >                db      {b $} | END_BIT     // msb as name end
 180+ E5C9             >
 180+ E5C9 BE 05       >                dw      Prev_Ptr            // Link to previous definition Name
 180+ E5CB             >Prev_Ptr        defl    Heap_Ptr
 180+ E5CB             >
 180+ E5CB             >mirror_Ptr      defl    $
 180+ E5CB             >
 180+ E5CB C0 A2       >                dw      Dict_Ptr + 2        // xt
 180+ E5CD             >Heap_Ptr        defl    $ - $E000           // save current HP
 180+ E5CD             >
 180+ E5CD             >Current_HP      defl  $ - $E000             // used to set HP once!
 180+ E5CD             >
 180+ E5CD             >//              ______________________________________________________________________
 180+ E5CD             >//              Dictionary part
 180+ E5CD             >
 180+ E5CD             >                org     Dict_Ptr
 180+ A2BE             >
 180+ A2BE CB 24       >                dw      mirror_Ptr - $E000 + $1F00
 180+ A2C0             >
 180+ A2C0             >HLD:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 180+ A2C0 CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 180+ A2C3             >
 180+ A2C3             >
 180+ A2C3             >                endif           ; ok        // for other definitions it "points" the correct handler
 180+ A2C3             >                // Use of "; ok" to suppress "warning[fwdref]"
 180+ A2C3             >
 180+ A2C3             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 180+ A2C3 38          >                db      56
 181+ A2C4                              User_Def USE        , "USE"       , 58 // address of last used block
 181+ A2C4             >                New_Def  USE, "USE", User_Ptr, is_normal
 181+ A2C4             >
 181+ A2C4             >Dict_Ptr        defl    $
 181+ A2C4             >
 181+ A2C4             >//              ______________________________________________________________________
 181+ A2C4             >//              Heap part
 181+ A2C4             >
 181+ A2C4             >
 181+ A2C4             >                org     (Heap_Ptr & $1FFF) + $E000
 181+ E5CD             >
 181+ E5CD             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 181+ E5CD             >Latest_Definition defl  Heap_Ptr
 181+ E5CD             >
 181+ E5CD             >                // dummy db directives used to calculate length of namec
 181+ E5CD 55 53 45    >                db      "USE"
 181+ E5D0             >len_NFA         defl    $ - temp_NFA
 181+ E5D0             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 181+ E5CD             >
 181+ E5CD 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 181+ E5CE 55 53 45    >                db      "USE"               // name string in 7-bit ascii, but
 181+ E5D1             >                org     $-1                 // alter last byte of Name just above to set
 181+ E5D0 C5          >                db      {b $} | END_BIT     // msb as name end
 181+ E5D1             >
 181+ E5D1 C5 05       >                dw      Prev_Ptr            // Link to previous definition Name
 181+ E5D3             >Prev_Ptr        defl    Heap_Ptr
 181+ E5D3             >
 181+ E5D3             >mirror_Ptr      defl    $
 181+ E5D3             >
 181+ E5D3 C6 A2       >                dw      Dict_Ptr + 2        // xt
 181+ E5D5             >Heap_Ptr        defl    $ - $E000           // save current HP
 181+ E5D5             >
 181+ E5D5             >Current_HP      defl  $ - $E000             // used to set HP once!
 181+ E5D5             >
 181+ E5D5             >//              ______________________________________________________________________
 181+ E5D5             >//              Dictionary part
 181+ E5D5             >
 181+ E5D5             >                org     Dict_Ptr
 181+ A2C4             >
 181+ A2C4 D3 24       >                dw      mirror_Ptr - $E000 + $1F00
 181+ A2C6             >
 181+ A2C6             >USE:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 181+ A2C6 CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 181+ A2C9             >
 181+ A2C9             >
 181+ A2C9             >                endif           ; ok        // for other definitions it "points" the correct handler
 181+ A2C9             >                // Use of "; ok" to suppress "warning[fwdref]"
 181+ A2C9             >
 181+ A2C9             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 181+ A2C9 3A          >                db      58
 182+ A2CA                              User_Def PREV       , "PREV"      , 60 // address of previous used block
 182+ A2CA             >                New_Def  PREV, "PREV", User_Ptr, is_normal
 182+ A2CA             >
 182+ A2CA             >Dict_Ptr        defl    $
 182+ A2CA             >
 182+ A2CA             >//              ______________________________________________________________________
 182+ A2CA             >//              Heap part
 182+ A2CA             >
 182+ A2CA             >
 182+ A2CA             >                org     (Heap_Ptr & $1FFF) + $E000
 182+ E5D5             >
 182+ E5D5             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 182+ E5D5             >Latest_Definition defl  Heap_Ptr
 182+ E5D5             >
 182+ E5D5             >                // dummy db directives used to calculate length of namec
 182+ E5D5 50 52 45 56 >                db      "PREV"
 182+ E5D9             >len_NFA         defl    $ - temp_NFA
 182+ E5D9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 182+ E5D5             >
 182+ E5D5 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 182+ E5D6 50 52 45 56 >                db      "PREV"               // name string in 7-bit ascii, but
 182+ E5DA             >                org     $-1                 // alter last byte of Name just above to set
 182+ E5D9 D6          >                db      {b $} | END_BIT     // msb as name end
 182+ E5DA             >
 182+ E5DA CD 05       >                dw      Prev_Ptr            // Link to previous definition Name
 182+ E5DC             >Prev_Ptr        defl    Heap_Ptr
 182+ E5DC             >
 182+ E5DC             >mirror_Ptr      defl    $
 182+ E5DC             >
 182+ E5DC CC A2       >                dw      Dict_Ptr + 2        // xt
 182+ E5DE             >Heap_Ptr        defl    $ - $E000           // save current HP
 182+ E5DE             >
 182+ E5DE             >Current_HP      defl  $ - $E000             // used to set HP once!
 182+ E5DE             >
 182+ E5DE             >//              ______________________________________________________________________
 182+ E5DE             >//              Dictionary part
 182+ E5DE             >
 182+ E5DE             >                org     Dict_Ptr
 182+ A2CA             >
 182+ A2CA DC 24       >                dw      mirror_Ptr - $E000 + $1F00
 182+ A2CC             >
 182+ A2CC             >PREV:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 182+ A2CC CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 182+ A2CF             >
 182+ A2CF             >
 182+ A2CF             >                endif           ; ok        // for other definitions it "points" the correct handler
 182+ A2CF             >                // Use of "; ok" to suppress "warning[fwdref]"
 182+ A2CF             >
 182+ A2CF             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 182+ A2CF 3C          >                db      60
 183+ A2D0                              User_Def LP         , "LP"        , 62 // line printer (not used)
 183+ A2D0             >                New_Def  LP, "LP", User_Ptr, is_normal
 183+ A2D0             >
 183+ A2D0             >Dict_Ptr        defl    $
 183+ A2D0             >
 183+ A2D0             >//              ______________________________________________________________________
 183+ A2D0             >//              Heap part
 183+ A2D0             >
 183+ A2D0             >
 183+ A2D0             >                org     (Heap_Ptr & $1FFF) + $E000
 183+ E5DE             >
 183+ E5DE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 183+ E5DE             >Latest_Definition defl  Heap_Ptr
 183+ E5DE             >
 183+ E5DE             >                // dummy db directives used to calculate length of namec
 183+ E5DE 4C 50       >                db      "LP"
 183+ E5E0             >len_NFA         defl    $ - temp_NFA
 183+ E5E0             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 183+ E5DE             >
 183+ E5DE 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 183+ E5DF 4C 50       >                db      "LP"               // name string in 7-bit ascii, but
 183+ E5E1             >                org     $-1                 // alter last byte of Name just above to set
 183+ E5E0 D0          >                db      {b $} | END_BIT     // msb as name end
 183+ E5E1             >
 183+ E5E1 D5 05       >                dw      Prev_Ptr            // Link to previous definition Name
 183+ E5E3             >Prev_Ptr        defl    Heap_Ptr
 183+ E5E3             >
 183+ E5E3             >mirror_Ptr      defl    $
 183+ E5E3             >
 183+ E5E3 D2 A2       >                dw      Dict_Ptr + 2        // xt
 183+ E5E5             >Heap_Ptr        defl    $ - $E000           // save current HP
 183+ E5E5             >
 183+ E5E5             >Current_HP      defl  $ - $E000             // used to set HP once!
 183+ E5E5             >
 183+ E5E5             >//              ______________________________________________________________________
 183+ E5E5             >//              Dictionary part
 183+ E5E5             >
 183+ E5E5             >                org     Dict_Ptr
 183+ A2D0             >
 183+ A2D0 E3 24       >                dw      mirror_Ptr - $E000 + $1F00
 183+ A2D2             >
 183+ A2D2             >LP:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 183+ A2D2 CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 183+ A2D5             >
 183+ A2D5             >
 183+ A2D5             >                endif           ; ok        // for other definitions it "points" the correct handler
 183+ A2D5             >                // Use of "; ok" to suppress "warning[fwdref]"
 183+ A2D5             >
 183+ A2D5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 183+ A2D5 3E          >                db      62
 184+ A2D6                              User_Def PLACE      , "PLACE"     , 64 // number of digits after decimal point in output
 184+ A2D6             >                New_Def  PLACE, "PLACE", User_Ptr, is_normal
 184+ A2D6             >
 184+ A2D6             >Dict_Ptr        defl    $
 184+ A2D6             >
 184+ A2D6             >//              ______________________________________________________________________
 184+ A2D6             >//              Heap part
 184+ A2D6             >
 184+ A2D6             >
 184+ A2D6             >                org     (Heap_Ptr & $1FFF) + $E000
 184+ E5E5             >
 184+ E5E5             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 184+ E5E5             >Latest_Definition defl  Heap_Ptr
 184+ E5E5             >
 184+ E5E5             >                // dummy db directives used to calculate length of namec
 184+ E5E5 50 4C 41 43 >                db      "PLACE"
 184+ E5E9 45          >
 184+ E5EA             >len_NFA         defl    $ - temp_NFA
 184+ E5EA             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 184+ E5E5             >
 184+ E5E5 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 184+ E5E6 50 4C 41 43 >                db      "PLACE"               // name string in 7-bit ascii, but
 184+ E5EA 45          >
 184+ E5EB             >                org     $-1                 // alter last byte of Name just above to set
 184+ E5EA C5          >                db      {b $} | END_BIT     // msb as name end
 184+ E5EB             >
 184+ E5EB DE 05       >                dw      Prev_Ptr            // Link to previous definition Name
 184+ E5ED             >Prev_Ptr        defl    Heap_Ptr
 184+ E5ED             >
 184+ E5ED             >mirror_Ptr      defl    $
 184+ E5ED             >
 184+ E5ED D8 A2       >                dw      Dict_Ptr + 2        // xt
 184+ E5EF             >Heap_Ptr        defl    $ - $E000           // save current HP
 184+ E5EF             >
 184+ E5EF             >Current_HP      defl  $ - $E000             // used to set HP once!
 184+ E5EF             >
 184+ E5EF             >//              ______________________________________________________________________
 184+ E5EF             >//              Dictionary part
 184+ E5EF             >
 184+ E5EF             >                org     Dict_Ptr
 184+ A2D6             >
 184+ A2D6 ED 24       >                dw      mirror_Ptr - $E000 + $1F00
 184+ A2D8             >
 184+ A2D8             >PLACE:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 184+ A2D8 CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 184+ A2DB             >
 184+ A2DB             >
 184+ A2DB             >                endif           ; ok        // for other definitions it "points" the correct handler
 184+ A2DB             >                // Use of "; ok" to suppress "warning[fwdref]"
 184+ A2DB             >
 184+ A2DB             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 184+ A2DB 40          >                db      64
 185+ A2DC                              User_Def SOURCE_ID  , "SOURCE-ID" , 66 // data-stream number in INCLUDE and LOAD-
 185+ A2DC             >                New_Def  SOURCE_ID, "SOURCE-ID", User_Ptr, is_normal
 185+ A2DC             >
 185+ A2DC             >Dict_Ptr        defl    $
 185+ A2DC             >
 185+ A2DC             >//              ______________________________________________________________________
 185+ A2DC             >//              Heap part
 185+ A2DC             >
 185+ A2DC             >
 185+ A2DC             >                org     (Heap_Ptr & $1FFF) + $E000
 185+ E5EF             >
 185+ E5EF             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 185+ E5EF             >Latest_Definition defl  Heap_Ptr
 185+ E5EF             >
 185+ E5EF             >                // dummy db directives used to calculate length of namec
 185+ E5EF 53 4F 55 52 >                db      "SOURCE-ID"
 185+ E5F3 43 45 2D 49 >
 185+ E5F7 44          >
 185+ E5F8             >len_NFA         defl    $ - temp_NFA
 185+ E5F8             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 185+ E5EF             >
 185+ E5EF 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 185+ E5F0 53 4F 55 52 >                db      "SOURCE-ID"               // name string in 7-bit ascii, but
 185+ E5F4 43 45 2D 49 >
 185+ E5F8 44          >
 185+ E5F9             >                org     $-1                 // alter last byte of Name just above to set
 185+ E5F8 C4          >                db      {b $} | END_BIT     // msb as name end
 185+ E5F9             >
 185+ E5F9 E5 05       >                dw      Prev_Ptr            // Link to previous definition Name
 185+ E5FB             >Prev_Ptr        defl    Heap_Ptr
 185+ E5FB             >
 185+ E5FB             >mirror_Ptr      defl    $
 185+ E5FB             >
 185+ E5FB DE A2       >                dw      Dict_Ptr + 2        // xt
 185+ E5FD             >Heap_Ptr        defl    $ - $E000           // save current HP
 185+ E5FD             >
 185+ E5FD             >Current_HP      defl  $ - $E000             // used to set HP once!
 185+ E5FD             >
 185+ E5FD             >//              ______________________________________________________________________
 185+ E5FD             >//              Dictionary part
 185+ E5FD             >
 185+ E5FD             >                org     Dict_Ptr
 185+ A2DC             >
 185+ A2DC FB 24       >                dw      mirror_Ptr - $E000 + $1F00
 185+ A2DE             >
 185+ A2DE             >SOURCE_ID:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 185+ A2DE CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 185+ A2E1             >
 185+ A2E1             >
 185+ A2E1             >                endif           ; ok        // for other definitions it "points" the correct handler
 185+ A2E1             >                // Use of "; ok" to suppress "warning[fwdref]"
 185+ A2E1             >
 185+ A2E1             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 185+ A2E1 42          >                db      66
 186+ A2E2                              User_Def SPAN       , "SPAN"      , 68 // number of character of last EXPECT
 186+ A2E2             >                New_Def  SPAN, "SPAN", User_Ptr, is_normal
 186+ A2E2             >
 186+ A2E2             >Dict_Ptr        defl    $
 186+ A2E2             >
 186+ A2E2             >//              ______________________________________________________________________
 186+ A2E2             >//              Heap part
 186+ A2E2             >
 186+ A2E2             >
 186+ A2E2             >                org     (Heap_Ptr & $1FFF) + $E000
 186+ E5FD             >
 186+ E5FD             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 186+ E5FD             >Latest_Definition defl  Heap_Ptr
 186+ E5FD             >
 186+ E5FD             >                // dummy db directives used to calculate length of namec
 186+ E5FD 53 50 41 4E >                db      "SPAN"
 186+ E601             >len_NFA         defl    $ - temp_NFA
 186+ E601             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 186+ E5FD             >
 186+ E5FD 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 186+ E5FE 53 50 41 4E >                db      "SPAN"               // name string in 7-bit ascii, but
 186+ E602             >                org     $-1                 // alter last byte of Name just above to set
 186+ E601 CE          >                db      {b $} | END_BIT     // msb as name end
 186+ E602             >
 186+ E602 EF 05       >                dw      Prev_Ptr            // Link to previous definition Name
 186+ E604             >Prev_Ptr        defl    Heap_Ptr
 186+ E604             >
 186+ E604             >mirror_Ptr      defl    $
 186+ E604             >
 186+ E604 E4 A2       >                dw      Dict_Ptr + 2        // xt
 186+ E606             >Heap_Ptr        defl    $ - $E000           // save current HP
 186+ E606             >
 186+ E606             >Current_HP      defl  $ - $E000             // used to set HP once!
 186+ E606             >
 186+ E606             >//              ______________________________________________________________________
 186+ E606             >//              Dictionary part
 186+ E606             >
 186+ E606             >                org     Dict_Ptr
 186+ A2E2             >
 186+ A2E2 04 25       >                dw      mirror_Ptr - $E000 + $1F00
 186+ A2E4             >
 186+ A2E4             >SPAN:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 186+ A2E4 CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 186+ A2E7             >
 186+ A2E7             >
 186+ A2E7             >                endif           ; ok        // for other definitions it "points" the correct handler
 186+ A2E7             >                // Use of "; ok" to suppress "warning[fwdref]"
 186+ A2E7             >
 186+ A2E7             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 186+ A2E7 44          >                db      68
 187+ A2E8                              User_Def HANDLER    , "HANDLER"   , 70 // Used by THROW-CATCH
 187+ A2E8             >                New_Def  HANDLER, "HANDLER", User_Ptr, is_normal
 187+ A2E8             >
 187+ A2E8             >Dict_Ptr        defl    $
 187+ A2E8             >
 187+ A2E8             >//              ______________________________________________________________________
 187+ A2E8             >//              Heap part
 187+ A2E8             >
 187+ A2E8             >
 187+ A2E8             >                org     (Heap_Ptr & $1FFF) + $E000
 187+ E606             >
 187+ E606             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 187+ E606             >Latest_Definition defl  Heap_Ptr
 187+ E606             >
 187+ E606             >                // dummy db directives used to calculate length of namec
 187+ E606 48 41 4E 44 >                db      "HANDLER"
 187+ E60A 4C 45 52    >
 187+ E60D             >len_NFA         defl    $ - temp_NFA
 187+ E60D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 187+ E606             >
 187+ E606 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 187+ E607 48 41 4E 44 >                db      "HANDLER"               // name string in 7-bit ascii, but
 187+ E60B 4C 45 52    >
 187+ E60E             >                org     $-1                 // alter last byte of Name just above to set
 187+ E60D D2          >                db      {b $} | END_BIT     // msb as name end
 187+ E60E             >
 187+ E60E FD 05       >                dw      Prev_Ptr            // Link to previous definition Name
 187+ E610             >Prev_Ptr        defl    Heap_Ptr
 187+ E610             >
 187+ E610             >mirror_Ptr      defl    $
 187+ E610             >
 187+ E610 EA A2       >                dw      Dict_Ptr + 2        // xt
 187+ E612             >Heap_Ptr        defl    $ - $E000           // save current HP
 187+ E612             >
 187+ E612             >Current_HP      defl  $ - $E000             // used to set HP once!
 187+ E612             >
 187+ E612             >//              ______________________________________________________________________
 187+ E612             >//              Dictionary part
 187+ E612             >
 187+ E612             >                org     Dict_Ptr
 187+ A2E8             >
 187+ A2E8 10 25       >                dw      mirror_Ptr - $E000 + $1F00
 187+ A2EA             >
 187+ A2EA             >HANDLER:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 187+ A2EA CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 187+ A2ED             >
 187+ A2ED             >
 187+ A2ED             >                endif           ; ok        // for other definitions it "points" the correct handler
 187+ A2ED             >                // Use of "; ok" to suppress "warning[fwdref]"
 187+ A2ED             >
 187+ A2ED             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 187+ A2ED 46          >                db      70
 188+ A2EE                              User_Def EXP        , "EXP"       , 72 // keeps the exponent in number conversion
 188+ A2EE             >                New_Def  EXP, "EXP", User_Ptr, is_normal
 188+ A2EE             >
 188+ A2EE             >Dict_Ptr        defl    $
 188+ A2EE             >
 188+ A2EE             >//              ______________________________________________________________________
 188+ A2EE             >//              Heap part
 188+ A2EE             >
 188+ A2EE             >
 188+ A2EE             >                org     (Heap_Ptr & $1FFF) + $E000
 188+ E612             >
 188+ E612             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 188+ E612             >Latest_Definition defl  Heap_Ptr
 188+ E612             >
 188+ E612             >                // dummy db directives used to calculate length of namec
 188+ E612 45 58 50    >                db      "EXP"
 188+ E615             >len_NFA         defl    $ - temp_NFA
 188+ E615             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 188+ E612             >
 188+ E612 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 188+ E613 45 58 50    >                db      "EXP"               // name string in 7-bit ascii, but
 188+ E616             >                org     $-1                 // alter last byte of Name just above to set
 188+ E615 D0          >                db      {b $} | END_BIT     // msb as name end
 188+ E616             >
 188+ E616 06 06       >                dw      Prev_Ptr            // Link to previous definition Name
 188+ E618             >Prev_Ptr        defl    Heap_Ptr
 188+ E618             >
 188+ E618             >mirror_Ptr      defl    $
 188+ E618             >
 188+ E618 F0 A2       >                dw      Dict_Ptr + 2        // xt
 188+ E61A             >Heap_Ptr        defl    $ - $E000           // save current HP
 188+ E61A             >
 188+ E61A             >Current_HP      defl  $ - $E000             // used to set HP once!
 188+ E61A             >
 188+ E61A             >//              ______________________________________________________________________
 188+ E61A             >//              Dictionary part
 188+ E61A             >
 188+ E61A             >                org     Dict_Ptr
 188+ A2EE             >
 188+ A2EE 18 25       >                dw      mirror_Ptr - $E000 + $1F00
 188+ A2F0             >
 188+ A2F0             >EXP:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 188+ A2F0 CD C5 A1    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 188+ A2F3             >
 188+ A2F3             >
 188+ A2F3             >                endif           ; ok        // for other definitions it "points" the correct handler
 188+ A2F3             >                // Use of "; ok" to suppress "warning[fwdref]"
 188+ A2F3             >
 188+ A2F3             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 188+ A2F3 48          >                db      72
 189+ A2F4
 190+ A2F4              //  ______________________________________________________________________
 191+ A2F4              //
 192+ A2F4              // here         -- a
 193+ A2F4                              Colon_Def HERE, "HERE", is_normal
 193+ A2F4             >                New_Def  HERE, "HERE", Enter_Ptr, is_normal ; ok
 193+ A2F4             >
 193+ A2F4             >Dict_Ptr        defl    $
 193+ A2F4             >
 193+ A2F4             >//              ______________________________________________________________________
 193+ A2F4             >//              Heap part
 193+ A2F4             >
 193+ A2F4             >
 193+ A2F4             >                org     (Heap_Ptr & $1FFF) + $E000
 193+ E61A             >
 193+ E61A             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 193+ E61A             >Latest_Definition defl  Heap_Ptr
 193+ E61A             >
 193+ E61A             >                // dummy db directives used to calculate length of namec
 193+ E61A 48 45 52 45 >                db      "HERE"
 193+ E61E             >len_NFA         defl    $ - temp_NFA
 193+ E61E             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 193+ E61A             >
 193+ E61A 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 193+ E61B 48 45 52 45 >                db      "HERE"               // name string in 7-bit ascii, but
 193+ E61F             >                org     $-1                 // alter last byte of Name just above to set
 193+ E61E C5          >                db      {b $} | END_BIT     // msb as name end
 193+ E61F             >
 193+ E61F 12 06       >                dw      Prev_Ptr            // Link to previous definition Name
 193+ E621             >Prev_Ptr        defl    Heap_Ptr
 193+ E621             >
 193+ E621             >mirror_Ptr      defl    $
 193+ E621             >
 193+ E621 F6 A2       >                dw      Dict_Ptr + 2        // xt
 193+ E623             >Heap_Ptr        defl    $ - $E000           // save current HP
 193+ E623             >
 193+ E623             >Current_HP      defl  $ - $E000             // used to set HP once!
 193+ E623             >
 193+ E623             >//              ______________________________________________________________________
 193+ E623             >//              Dictionary part
 193+ E623             >
 193+ E623             >                org     Dict_Ptr
 193+ A2F4             >
 193+ A2F4 21 25       >                dw      mirror_Ptr - $E000 + $1F00
 193+ A2F6             >
 193+ A2F6             >HERE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 193+ A2F6 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 193+ A2F9             >
 193+ A2F9             >
 193+ A2F9             >                endif           ; ok        // for other definitions it "points" the correct handler
 193+ A2F9             >                // Use of "; ok" to suppress "warning[fwdref]"
 193+ A2F9             >
 193+ A2F9             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 194+ A2F9 4E A2 D9 A0                  dw      DP, FETCH               // dp @
 195+ A2FD A2 9F                        dw      EXIT                    // ;
 196+ A2FF
 197+ A2FF              //  ______________________________________________________________________
 198+ A2FF              //
 199+ A2FF              // allot        n --
 200+ A2FF                              Colon_Def ALLOT, "ALLOT", is_normal
 200+ A2FF             >                New_Def  ALLOT, "ALLOT", Enter_Ptr, is_normal ; ok
 200+ A2FF             >
 200+ A2FF             >Dict_Ptr        defl    $
 200+ A2FF             >
 200+ A2FF             >//              ______________________________________________________________________
 200+ A2FF             >//              Heap part
 200+ A2FF             >
 200+ A2FF             >
 200+ A2FF             >                org     (Heap_Ptr & $1FFF) + $E000
 200+ E623             >
 200+ E623             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 200+ E623             >Latest_Definition defl  Heap_Ptr
 200+ E623             >
 200+ E623             >                // dummy db directives used to calculate length of namec
 200+ E623 41 4C 4C 4F >                db      "ALLOT"
 200+ E627 54          >
 200+ E628             >len_NFA         defl    $ - temp_NFA
 200+ E628             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 200+ E623             >
 200+ E623 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 200+ E624 41 4C 4C 4F >                db      "ALLOT"               // name string in 7-bit ascii, but
 200+ E628 54          >
 200+ E629             >                org     $-1                 // alter last byte of Name just above to set
 200+ E628 D4          >                db      {b $} | END_BIT     // msb as name end
 200+ E629             >
 200+ E629 1A 06       >                dw      Prev_Ptr            // Link to previous definition Name
 200+ E62B             >Prev_Ptr        defl    Heap_Ptr
 200+ E62B             >
 200+ E62B             >mirror_Ptr      defl    $
 200+ E62B             >
 200+ E62B 01 A3       >                dw      Dict_Ptr + 2        // xt
 200+ E62D             >Heap_Ptr        defl    $ - $E000           // save current HP
 200+ E62D             >
 200+ E62D             >Current_HP      defl  $ - $E000             // used to set HP once!
 200+ E62D             >
 200+ E62D             >//              ______________________________________________________________________
 200+ E62D             >//              Dictionary part
 200+ E62D             >
 200+ E62D             >                org     Dict_Ptr
 200+ A2FF             >
 200+ A2FF 2B 25       >                dw      mirror_Ptr - $E000 + $1F00
 200+ A301             >
 200+ A301             >ALLOT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 200+ A301 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 200+ A304             >
 200+ A304             >
 200+ A304             >                endif           ; ok        // for other definitions it "points" the correct handler
 200+ A304             >                // Use of "; ok" to suppress "warning[fwdref]"
 200+ A304             >
 200+ A304             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 201+ A304 4E A2 C1 A0                  dw      DP,  PLUSSTORE          // dp +!
 202+ A308 A2 9F                        dw      EXIT                    // ;
 203+ A30A
 204+ A30A              //  ______________________________________________________________________
 205+ A30A              //
 206+ A30A              // comma        n --
 207+ A30A                              Colon_Def COMMA, ",", is_normal
 207+ A30A             >                New_Def  COMMA, ",", Enter_Ptr, is_normal ; ok
 207+ A30A             >
 207+ A30A             >Dict_Ptr        defl    $
 207+ A30A             >
 207+ A30A             >//              ______________________________________________________________________
 207+ A30A             >//              Heap part
 207+ A30A             >
 207+ A30A             >
 207+ A30A             >                org     (Heap_Ptr & $1FFF) + $E000
 207+ E62D             >
 207+ E62D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 207+ E62D             >Latest_Definition defl  Heap_Ptr
 207+ E62D             >
 207+ E62D             >                // dummy db directives used to calculate length of namec
 207+ E62D 2C          >                db      ","
 207+ E62E             >len_NFA         defl    $ - temp_NFA
 207+ E62E             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 207+ E62D             >
 207+ E62D 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 207+ E62E 2C          >                db      ","               // name string in 7-bit ascii, but
 207+ E62F             >                org     $-1                 // alter last byte of Name just above to set
 207+ E62E AC          >                db      {b $} | END_BIT     // msb as name end
 207+ E62F             >
 207+ E62F 23 06       >                dw      Prev_Ptr            // Link to previous definition Name
 207+ E631             >Prev_Ptr        defl    Heap_Ptr
 207+ E631             >
 207+ E631             >mirror_Ptr      defl    $
 207+ E631             >
 207+ E631 0C A3       >                dw      Dict_Ptr + 2        // xt
 207+ E633             >Heap_Ptr        defl    $ - $E000           // save current HP
 207+ E633             >
 207+ E633             >Current_HP      defl  $ - $E000             // used to set HP once!
 207+ E633             >
 207+ E633             >//              ______________________________________________________________________
 207+ E633             >//              Dictionary part
 207+ E633             >
 207+ E633             >                org     Dict_Ptr
 207+ A30A             >
 207+ A30A 31 25       >                dw      mirror_Ptr - $E000 + $1F00
 207+ A30C             >
 207+ A30C             >COMMA:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 207+ A30C CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 207+ A30F             >
 207+ A30F             >
 207+ A30F             >                endif           ; ok        // for other definitions it "points" the correct handler
 207+ A30F             >                // Use of "; ok" to suppress "warning[fwdref]"
 207+ A30F             >
 207+ A30F             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 208+ A30F F6 A2 E3 A0                  dw      HERE, STORE             // here !
 209+ A313 DF A1 01 A3                  dw      TWO, ALLOT              // 2 allot
 210+ A317 A2 9F                        dw      EXIT                    // ;
 211+ A319
 212+ A319              //  ______________________________________________________________________
 213+ A319              //
 214+ A319              // ccomma       c --
 215+ A319                              Colon_Def CCOMMA, "C,", is_normal
 215+ A319             >                New_Def  CCOMMA, "C,", Enter_Ptr, is_normal ; ok
 215+ A319             >
 215+ A319             >Dict_Ptr        defl    $
 215+ A319             >
 215+ A319             >//              ______________________________________________________________________
 215+ A319             >//              Heap part
 215+ A319             >
 215+ A319             >
 215+ A319             >                org     (Heap_Ptr & $1FFF) + $E000
 215+ E633             >
 215+ E633             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 215+ E633             >Latest_Definition defl  Heap_Ptr
 215+ E633             >
 215+ E633             >                // dummy db directives used to calculate length of namec
 215+ E633 43 2C       >                db      "C,"
 215+ E635             >len_NFA         defl    $ - temp_NFA
 215+ E635             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 215+ E633             >
 215+ E633 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 215+ E634 43 2C       >                db      "C,"               // name string in 7-bit ascii, but
 215+ E636             >                org     $-1                 // alter last byte of Name just above to set
 215+ E635 AC          >                db      {b $} | END_BIT     // msb as name end
 215+ E636             >
 215+ E636 2D 06       >                dw      Prev_Ptr            // Link to previous definition Name
 215+ E638             >Prev_Ptr        defl    Heap_Ptr
 215+ E638             >
 215+ E638             >mirror_Ptr      defl    $
 215+ E638             >
 215+ E638 1B A3       >                dw      Dict_Ptr + 2        // xt
 215+ E63A             >Heap_Ptr        defl    $ - $E000           // save current HP
 215+ E63A             >
 215+ E63A             >Current_HP      defl  $ - $E000             // used to set HP once!
 215+ E63A             >
 215+ E63A             >//              ______________________________________________________________________
 215+ E63A             >//              Dictionary part
 215+ E63A             >
 215+ E63A             >                org     Dict_Ptr
 215+ A319             >
 215+ A319 38 25       >                dw      mirror_Ptr - $E000 + $1F00
 215+ A31B             >
 215+ A31B             >CCOMMA:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 215+ A31B CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 215+ A31E             >
 215+ A31E             >
 215+ A31E             >                endif           ; ok        // for other definitions it "points" the correct handler
 215+ A31E             >                // Use of "; ok" to suppress "warning[fwdref]"
 215+ A31E             >
 215+ A31E             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 216+ A31E F6 A2 F7 A0                  dw      HERE, CSTORE            // here c!
 217+ A322 D8 A1 01 A3                  dw      ONE, ALLOT              // 1 allot
 218+ A326 A2 9F                        dw      EXIT                    // ;
 219+ A328
 220+ A328              //  ______________________________________________________________________
 221+ A328              //
 222+ A328              // s>d          n -- d
 223+ A328              // converts a single precision integer in a double precision
 224+ A328                              New_Def S_TO_D, "S>D", is_code, is_normal
 224+ A328             >
 224+ A328             >Dict_Ptr        defl    $
 224+ A328             >
 224+ A328             >//              ______________________________________________________________________
 224+ A328             >//              Heap part
 224+ A328             >
 224+ A328             >
 224+ A328             >                org     (Heap_Ptr & $1FFF) + $E000
 224+ E63A             >
 224+ E63A             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 224+ E63A             >Latest_Definition defl  Heap_Ptr
 224+ E63A             >
 224+ E63A             >                // dummy db directives used to calculate length of namec
 224+ E63A 53 3E 44    >                db      "S>D"
 224+ E63D             >len_NFA         defl    $ - temp_NFA
 224+ E63D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 224+ E63A             >
 224+ E63A 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 224+ E63B 53 3E 44    >                db      "S>D"               // name string in 7-bit ascii, but
 224+ E63E             >                org     $-1                 // alter last byte of Name just above to set
 224+ E63D C4          >                db      {b $} | END_BIT     // msb as name end
 224+ E63E             >
 224+ E63E 33 06       >                dw      Prev_Ptr            // Link to previous definition Name
 224+ E640             >Prev_Ptr        defl    Heap_Ptr
 224+ E640             >
 224+ E640             >mirror_Ptr      defl    $
 224+ E640             >
 224+ E640 2A A3       >                dw      Dict_Ptr + 2        // xt
 224+ E642             >Heap_Ptr        defl    $ - $E000           // save current HP
 224+ E642             >
 224+ E642             >Current_HP      defl  $ - $E000             // used to set HP once!
 224+ E642             >
 224+ E642             >//              ______________________________________________________________________
 224+ E642             >//              Dictionary part
 224+ E642             >
 224+ E642             >                org     Dict_Ptr
 224+ A328             >
 224+ A328 40 25       >                dw      mirror_Ptr - $E000 + $1F00
 224+ A32A             >
 224+ A32A             >S_TO_D:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 224+ A32A ~           >                call    runcode ; ok        // for primitive definitions  actual code
 224+ A32A ~           >
 224+ A32A ~           >
 224+ A32A             >                endif           ; ok        // for other definitions it "points" the correct handler
 224+ A32A             >                // Use of "; ok" to suppress "warning[fwdref]"
 224+ A32A             >
 224+ A32A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 225+ A32A E1                           pop     hl
 226+ A32B 7C                           ld      a, h
 227+ A32C E5                           push    hl
 228+ A32D 17                           rla
 229+ A32E ED 62                        sbc     hl, hl
 230+ A330 E5                           push    hl
 231+ A331                              next
 231+ A331 DD E9       >                jp      (ix)
 232+ A333
 233+ A333              //  ______________________________________________________________________
 234+ A333              //
 235+ A333              // -            n1 n2 -- n3
 236+ A333              // subtraction
 237+ A333                              New_Def SUBTRACT, "-", is_code, is_normal
 237+ A333             >
 237+ A333             >Dict_Ptr        defl    $
 237+ A333             >
 237+ A333             >//              ______________________________________________________________________
 237+ A333             >//              Heap part
 237+ A333             >
 237+ A333             >
 237+ A333             >                org     (Heap_Ptr & $1FFF) + $E000
 237+ E642             >
 237+ E642             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 237+ E642             >Latest_Definition defl  Heap_Ptr
 237+ E642             >
 237+ E642             >                // dummy db directives used to calculate length of namec
 237+ E642 2D          >                db      "-"
 237+ E643             >len_NFA         defl    $ - temp_NFA
 237+ E643             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 237+ E642             >
 237+ E642 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 237+ E643 2D          >                db      "-"               // name string in 7-bit ascii, but
 237+ E644             >                org     $-1                 // alter last byte of Name just above to set
 237+ E643 AD          >                db      {b $} | END_BIT     // msb as name end
 237+ E644             >
 237+ E644 3A 06       >                dw      Prev_Ptr            // Link to previous definition Name
 237+ E646             >Prev_Ptr        defl    Heap_Ptr
 237+ E646             >
 237+ E646             >mirror_Ptr      defl    $
 237+ E646             >
 237+ E646 35 A3       >                dw      Dict_Ptr + 2        // xt
 237+ E648             >Heap_Ptr        defl    $ - $E000           // save current HP
 237+ E648             >
 237+ E648             >Current_HP      defl  $ - $E000             // used to set HP once!
 237+ E648             >
 237+ E648             >//              ______________________________________________________________________
 237+ E648             >//              Dictionary part
 237+ E648             >
 237+ E648             >                org     Dict_Ptr
 237+ A333             >
 237+ A333 46 25       >                dw      mirror_Ptr - $E000 + $1F00
 237+ A335             >
 237+ A335             >SUBTRACT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 237+ A335 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 237+ A335 ~           >
 237+ A335 ~           >
 237+ A335             >                endif           ; ok        // for other definitions it "points" the correct handler
 237+ A335             >                // Use of "; ok" to suppress "warning[fwdref]"
 237+ A335             >
 237+ A335             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 238+ A335 D9                           exx
 239+ A336 D1                           pop     de
 240+ A337 E1                           pop     hl
 241+ A338 A7                           and     a
 242+ A339 ED 52                        sbc     hl, de
 243+ A33B E5                           push    hl
 244+ A33C D9                           exx
 245+ A33D                              next
 245+ A33D DD E9       >                jp      (ix)
 246+ A33F
 247+ A33F
 248+ A33F              //  ______________________________________________________________________
 249+ A33F              //
 250+ A33F              // =            n1 n2 -- n3
 251+ A33F              // equals
 252+ A33F                              Colon_Def EQUALS, "=", is_normal
 252+ A33F             >                New_Def  EQUALS, "=", Enter_Ptr, is_normal ; ok
 252+ A33F             >
 252+ A33F             >Dict_Ptr        defl    $
 252+ A33F             >
 252+ A33F             >//              ______________________________________________________________________
 252+ A33F             >//              Heap part
 252+ A33F             >
 252+ A33F             >
 252+ A33F             >                org     (Heap_Ptr & $1FFF) + $E000
 252+ E648             >
 252+ E648             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 252+ E648             >Latest_Definition defl  Heap_Ptr
 252+ E648             >
 252+ E648             >                // dummy db directives used to calculate length of namec
 252+ E648 3D          >                db      "="
 252+ E649             >len_NFA         defl    $ - temp_NFA
 252+ E649             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 252+ E648             >
 252+ E648 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 252+ E649 3D          >                db      "="               // name string in 7-bit ascii, but
 252+ E64A             >                org     $-1                 // alter last byte of Name just above to set
 252+ E649 BD          >                db      {b $} | END_BIT     // msb as name end
 252+ E64A             >
 252+ E64A 42 06       >                dw      Prev_Ptr            // Link to previous definition Name
 252+ E64C             >Prev_Ptr        defl    Heap_Ptr
 252+ E64C             >
 252+ E64C             >mirror_Ptr      defl    $
 252+ E64C             >
 252+ E64C 41 A3       >                dw      Dict_Ptr + 2        // xt
 252+ E64E             >Heap_Ptr        defl    $ - $E000           // save current HP
 252+ E64E             >
 252+ E64E             >Current_HP      defl  $ - $E000             // used to set HP once!
 252+ E64E             >
 252+ E64E             >//              ______________________________________________________________________
 252+ E64E             >//              Dictionary part
 252+ E64E             >
 252+ E64E             >                org     Dict_Ptr
 252+ A33F             >
 252+ A33F 4C 25       >                dw      mirror_Ptr - $E000 + $1F00
 252+ A341             >
 252+ A341             >EQUALS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 252+ A341 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 252+ A344             >
 252+ A344             >
 252+ A344             >                endif           ; ok        // for other definitions it "points" the correct handler
 252+ A344             >                // Use of "; ok" to suppress "warning[fwdref]"
 252+ A344             >
 252+ A344             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 253+ A344 35 A3 C7 9F                  dw      SUBTRACT, ZEQUAL        // - 0=
 254+ A348 A2 9F                        dw      EXIT                    // ;
 255+ A34A
 256+ A34A              //  ______________________________________________________________________
 257+ A34A              //
 258+ A34A              // u<           u1 u2 -- u3
 259+ A34A              // unsigned less-than
 260+ A34A                              New_Def ULESS, "U<", is_code, is_normal
 260+ A34A             >
 260+ A34A             >Dict_Ptr        defl    $
 260+ A34A             >
 260+ A34A             >//              ______________________________________________________________________
 260+ A34A             >//              Heap part
 260+ A34A             >
 260+ A34A             >
 260+ A34A             >                org     (Heap_Ptr & $1FFF) + $E000
 260+ E64E             >
 260+ E64E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 260+ E64E             >Latest_Definition defl  Heap_Ptr
 260+ E64E             >
 260+ E64E             >                // dummy db directives used to calculate length of namec
 260+ E64E 55 3C       >                db      "U<"
 260+ E650             >len_NFA         defl    $ - temp_NFA
 260+ E650             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 260+ E64E             >
 260+ E64E 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 260+ E64F 55 3C       >                db      "U<"               // name string in 7-bit ascii, but
 260+ E651             >                org     $-1                 // alter last byte of Name just above to set
 260+ E650 BC          >                db      {b $} | END_BIT     // msb as name end
 260+ E651             >
 260+ E651 48 06       >                dw      Prev_Ptr            // Link to previous definition Name
 260+ E653             >Prev_Ptr        defl    Heap_Ptr
 260+ E653             >
 260+ E653             >mirror_Ptr      defl    $
 260+ E653             >
 260+ E653 4C A3       >                dw      Dict_Ptr + 2        // xt
 260+ E655             >Heap_Ptr        defl    $ - $E000           // save current HP
 260+ E655             >
 260+ E655             >Current_HP      defl  $ - $E000             // used to set HP once!
 260+ E655             >
 260+ E655             >//              ______________________________________________________________________
 260+ E655             >//              Dictionary part
 260+ E655             >
 260+ E655             >                org     Dict_Ptr
 260+ A34A             >
 260+ A34A 53 25       >                dw      mirror_Ptr - $E000 + $1F00
 260+ A34C             >
 260+ A34C             >ULESS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 260+ A34C ~           >                call    runcode ; ok        // for primitive definitions  actual code
 260+ A34C ~           >
 260+ A34C ~           >
 260+ A34C             >                endif           ; ok        // for other definitions it "points" the correct handler
 260+ A34C             >                // Use of "; ok" to suppress "warning[fwdref]"
 260+ A34C             >
 260+ A34C             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 261+ A34C D9                           exx
 262+ A34D D1                           pop     de
 263+ A34E E1                           pop     hl
 264+ A34F A7                           and     a
 265+ A350 ED 52                        sbc     hl, de
 266+ A352 ED 62                        sbc     hl, hl
 267+ A354 E5                           push    hl
 268+ A355 D9                           exx
 269+ A356                              next
 269+ A356 DD E9       >                jp      (ix)
 270+ A358
 271+ A358              //  ______________________________________________________________________
 272+ A358              //
 273+ A358              // <           n1 n2 -- n3
 274+ A358              // less-than
 275+ A358                              New_Def LESS, "<", is_code, is_normal
 275+ A358             >
 275+ A358             >Dict_Ptr        defl    $
 275+ A358             >
 275+ A358             >//              ______________________________________________________________________
 275+ A358             >//              Heap part
 275+ A358             >
 275+ A358             >
 275+ A358             >                org     (Heap_Ptr & $1FFF) + $E000
 275+ E655             >
 275+ E655             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 275+ E655             >Latest_Definition defl  Heap_Ptr
 275+ E655             >
 275+ E655             >                // dummy db directives used to calculate length of namec
 275+ E655 3C          >                db      "<"
 275+ E656             >len_NFA         defl    $ - temp_NFA
 275+ E656             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 275+ E655             >
 275+ E655 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 275+ E656 3C          >                db      "<"               // name string in 7-bit ascii, but
 275+ E657             >                org     $-1                 // alter last byte of Name just above to set
 275+ E656 BC          >                db      {b $} | END_BIT     // msb as name end
 275+ E657             >
 275+ E657 4E 06       >                dw      Prev_Ptr            // Link to previous definition Name
 275+ E659             >Prev_Ptr        defl    Heap_Ptr
 275+ E659             >
 275+ E659             >mirror_Ptr      defl    $
 275+ E659             >
 275+ E659 5A A3       >                dw      Dict_Ptr + 2        // xt
 275+ E65B             >Heap_Ptr        defl    $ - $E000           // save current HP
 275+ E65B             >
 275+ E65B             >Current_HP      defl  $ - $E000             // used to set HP once!
 275+ E65B             >
 275+ E65B             >//              ______________________________________________________________________
 275+ E65B             >//              Dictionary part
 275+ E65B             >
 275+ E65B             >                org     Dict_Ptr
 275+ A358             >
 275+ A358 59 25       >                dw      mirror_Ptr - $E000 + $1F00
 275+ A35A             >
 275+ A35A             >LESS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 275+ A35A ~           >                call    runcode ; ok        // for primitive definitions  actual code
 275+ A35A ~           >
 275+ A35A ~           >
 275+ A35A             >                endif           ; ok        // for other definitions it "points" the correct handler
 275+ A35A             >                // Use of "; ok" to suppress "warning[fwdref]"
 275+ A35A             >
 275+ A35A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 276+ A35A D9                           exx
 277+ A35B D1                           pop     de
 278+ A35C E1                           pop     hl
 279+ A35D 7C                           ld      a, h
 280+ A35E EE 80                        xor     $80
 281+ A360 67                           ld      h, a
 282+ A361 7A                           ld      a, d
 283+ A362 EE 80                        xor     $80
 284+ A364 57                           ld      d, a
 285+ A365              //              and     a
 286+ A365 ED 52                        sbc     hl, de
 287+ A367 ED 62                        sbc     hl, hl
 288+ A369 E5                           push    hl
 289+ A36A D9                           exx
 290+ A36B                              next
 290+ A36B DD E9       >                jp      (ix)
 291+ A36D
 292+ A36D              //  ______________________________________________________________________
 293+ A36D              //
 294+ A36D              // >            n1 n2 -- n3
 295+ A36D              // greater than
 296+ A36D                              Colon_Def GREATER, ">", is_normal
 296+ A36D             >                New_Def  GREATER, ">", Enter_Ptr, is_normal ; ok
 296+ A36D             >
 296+ A36D             >Dict_Ptr        defl    $
 296+ A36D             >
 296+ A36D             >//              ______________________________________________________________________
 296+ A36D             >//              Heap part
 296+ A36D             >
 296+ A36D             >
 296+ A36D             >                org     (Heap_Ptr & $1FFF) + $E000
 296+ E65B             >
 296+ E65B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 296+ E65B             >Latest_Definition defl  Heap_Ptr
 296+ E65B             >
 296+ E65B             >                // dummy db directives used to calculate length of namec
 296+ E65B 3E          >                db      ">"
 296+ E65C             >len_NFA         defl    $ - temp_NFA
 296+ E65C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 296+ E65B             >
 296+ E65B 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 296+ E65C 3E          >                db      ">"               // name string in 7-bit ascii, but
 296+ E65D             >                org     $-1                 // alter last byte of Name just above to set
 296+ E65C BE          >                db      {b $} | END_BIT     // msb as name end
 296+ E65D             >
 296+ E65D 55 06       >                dw      Prev_Ptr            // Link to previous definition Name
 296+ E65F             >Prev_Ptr        defl    Heap_Ptr
 296+ E65F             >
 296+ E65F             >mirror_Ptr      defl    $
 296+ E65F             >
 296+ E65F 6F A3       >                dw      Dict_Ptr + 2        // xt
 296+ E661             >Heap_Ptr        defl    $ - $E000           // save current HP
 296+ E661             >
 296+ E661             >Current_HP      defl  $ - $E000             // used to set HP once!
 296+ E661             >
 296+ E661             >//              ______________________________________________________________________
 296+ E661             >//              Dictionary part
 296+ E661             >
 296+ E661             >                org     Dict_Ptr
 296+ A36D             >
 296+ A36D 5F 25       >                dw      mirror_Ptr - $E000 + $1F00
 296+ A36F             >
 296+ A36F             >GREATER:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 296+ A36F CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 296+ A372             >
 296+ A372             >
 296+ A372             >                endif           ; ok        // for other definitions it "points" the correct handler
 296+ A372             >                // Use of "; ok" to suppress "warning[fwdref]"
 296+ A372             >
 296+ A372             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 297+ A372 74 A0 5A A3                  dw      SWAP, LESS              // swap <
 298+ A376 A2 9F                        dw      EXIT                    // ;
 299+ A378              //  ______________________________________________________________________
 300+ A378              //
 301+ A378              // min          n1 n2 -- n3
 302+ A378              // minimum between n1 and n2
 303+ A378                              Colon_Def MIN, "MIN" , is_normal
 303+ A378             >                New_Def  MIN, "MIN", Enter_Ptr, is_normal ; ok
 303+ A378             >
 303+ A378             >Dict_Ptr        defl    $
 303+ A378             >
 303+ A378             >//              ______________________________________________________________________
 303+ A378             >//              Heap part
 303+ A378             >
 303+ A378             >
 303+ A378             >                org     (Heap_Ptr & $1FFF) + $E000
 303+ E661             >
 303+ E661             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 303+ E661             >Latest_Definition defl  Heap_Ptr
 303+ E661             >
 303+ E661             >                // dummy db directives used to calculate length of namec
 303+ E661 4D 49 4E    >                db      "MIN"
 303+ E664             >len_NFA         defl    $ - temp_NFA
 303+ E664             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 303+ E661             >
 303+ E661 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 303+ E662 4D 49 4E    >                db      "MIN"               // name string in 7-bit ascii, but
 303+ E665             >                org     $-1                 // alter last byte of Name just above to set
 303+ E664 CE          >                db      {b $} | END_BIT     // msb as name end
 303+ E665             >
 303+ E665 5B 06       >                dw      Prev_Ptr            // Link to previous definition Name
 303+ E667             >Prev_Ptr        defl    Heap_Ptr
 303+ E667             >
 303+ E667             >mirror_Ptr      defl    $
 303+ E667             >
 303+ E667 7A A3       >                dw      Dict_Ptr + 2        // xt
 303+ E669             >Heap_Ptr        defl    $ - $E000           // save current HP
 303+ E669             >
 303+ E669             >Current_HP      defl  $ - $E000             // used to set HP once!
 303+ E669             >
 303+ E669             >//              ______________________________________________________________________
 303+ E669             >//              Dictionary part
 303+ E669             >
 303+ E669             >                org     Dict_Ptr
 303+ A378             >
 303+ A378 67 25       >                dw      mirror_Ptr - $E000 + $1F00
 303+ A37A             >
 303+ A37A             >MIN:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 303+ A37A CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 303+ A37D             >
 303+ A37D             >
 303+ A37D             >                endif           ; ok        // for other definitions it "points" the correct handler
 303+ A37D             >                // Use of "; ok" to suppress "warning[fwdref]"
 303+ A37D             >
 303+ A37D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 304+ A37D B7 A0                        dw      TWO_DUP                 // 2dup
 305+ A37F 6F A3                        dw      GREATER                 // >
 306+ A381 45 9B                        dw      ZBRANCH
 307+ A383 04 00                        dw      Min_Skip - $   // if
 308+ A385 74 A0                        dw          SWAP                //      swap
 309+ A387              Min_Skip:                                       // endif
 310+ A387 60 A0                        dw      DROP                    // drop
 311+ A389 A2 9F                        dw      EXIT                    // ;
 312+ A38B
 313+ A38B              //  ______________________________________________________________________
 314+ A38B              //
 315+ A38B              // max          n1 n2 -- n3
 316+ A38B              // maximum between n1 and n2
 317+ A38B                              Colon_Def MAX, "MAX", is_normal
 317+ A38B             >                New_Def  MAX, "MAX", Enter_Ptr, is_normal ; ok
 317+ A38B             >
 317+ A38B             >Dict_Ptr        defl    $
 317+ A38B             >
 317+ A38B             >//              ______________________________________________________________________
 317+ A38B             >//              Heap part
 317+ A38B             >
 317+ A38B             >
 317+ A38B             >                org     (Heap_Ptr & $1FFF) + $E000
 317+ E669             >
 317+ E669             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 317+ E669             >Latest_Definition defl  Heap_Ptr
 317+ E669             >
 317+ E669             >                // dummy db directives used to calculate length of namec
 317+ E669 4D 41 58    >                db      "MAX"
 317+ E66C             >len_NFA         defl    $ - temp_NFA
 317+ E66C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 317+ E669             >
 317+ E669 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 317+ E66A 4D 41 58    >                db      "MAX"               // name string in 7-bit ascii, but
 317+ E66D             >                org     $-1                 // alter last byte of Name just above to set
 317+ E66C D8          >                db      {b $} | END_BIT     // msb as name end
 317+ E66D             >
 317+ E66D 61 06       >                dw      Prev_Ptr            // Link to previous definition Name
 317+ E66F             >Prev_Ptr        defl    Heap_Ptr
 317+ E66F             >
 317+ E66F             >mirror_Ptr      defl    $
 317+ E66F             >
 317+ E66F 8D A3       >                dw      Dict_Ptr + 2        // xt
 317+ E671             >Heap_Ptr        defl    $ - $E000           // save current HP
 317+ E671             >
 317+ E671             >Current_HP      defl  $ - $E000             // used to set HP once!
 317+ E671             >
 317+ E671             >//              ______________________________________________________________________
 317+ E671             >//              Dictionary part
 317+ E671             >
 317+ E671             >                org     Dict_Ptr
 317+ A38B             >
 317+ A38B 6F 25       >                dw      mirror_Ptr - $E000 + $1F00
 317+ A38D             >
 317+ A38D             >MAX:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 317+ A38D CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 317+ A390             >
 317+ A390             >
 317+ A390             >                endif           ; ok        // for other definitions it "points" the correct handler
 317+ A390             >                // Use of "; ok" to suppress "warning[fwdref]"
 317+ A390             >
 317+ A390             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 318+ A390 B7 A0                        dw      TWO_DUP                 // 2dup
 319+ A392 5A A3                        dw      LESS                    // <
 320+ A394 45 9B                        dw      ZBRANCH
 321+ A396 04 00                        dw      Max_Skip - $   // if
 322+ A398 74 A0                        dw          SWAP                //      swap
 323+ A39A              Max_Skip:                                       // endif
 324+ A39A 60 A0                        dw      DROP                    // drop
 325+ A39C A2 9F                        dw      EXIT                    // ;
 326+ A39E
 327+ A39E              //  ______________________________________________________________________
 328+ A39E              //
 329+ A39E              // ?dup         n -- 0 | n n
 330+ A39E              // duplicate if not zero
 331+ A39E                              New_Def QDUP, "?DUP", is_code, is_normal
 331+ A39E             >
 331+ A39E             >Dict_Ptr        defl    $
 331+ A39E             >
 331+ A39E             >//              ______________________________________________________________________
 331+ A39E             >//              Heap part
 331+ A39E             >
 331+ A39E             >
 331+ A39E             >                org     (Heap_Ptr & $1FFF) + $E000
 331+ E671             >
 331+ E671             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 331+ E671             >Latest_Definition defl  Heap_Ptr
 331+ E671             >
 331+ E671             >                // dummy db directives used to calculate length of namec
 331+ E671 3F 44 55 50 >                db      "?DUP"
 331+ E675             >len_NFA         defl    $ - temp_NFA
 331+ E675             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 331+ E671             >
 331+ E671 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 331+ E672 3F 44 55 50 >                db      "?DUP"               // name string in 7-bit ascii, but
 331+ E676             >                org     $-1                 // alter last byte of Name just above to set
 331+ E675 D0          >                db      {b $} | END_BIT     // msb as name end
 331+ E676             >
 331+ E676 69 06       >                dw      Prev_Ptr            // Link to previous definition Name
 331+ E678             >Prev_Ptr        defl    Heap_Ptr
 331+ E678             >
 331+ E678             >mirror_Ptr      defl    $
 331+ E678             >
 331+ E678 A0 A3       >                dw      Dict_Ptr + 2        // xt
 331+ E67A             >Heap_Ptr        defl    $ - $E000           // save current HP
 331+ E67A             >
 331+ E67A             >Current_HP      defl  $ - $E000             // used to set HP once!
 331+ E67A             >
 331+ E67A             >//              ______________________________________________________________________
 331+ E67A             >//              Dictionary part
 331+ E67A             >
 331+ E67A             >                org     Dict_Ptr
 331+ A39E             >
 331+ A39E 78 25       >                dw      mirror_Ptr - $E000 + $1F00
 331+ A3A0             >
 331+ A3A0             >QDUP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 331+ A3A0 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 331+ A3A0 ~           >
 331+ A3A0 ~           >
 331+ A3A0             >                endif           ; ok        // for other definitions it "points" the correct handler
 331+ A3A0             >                // Use of "; ok" to suppress "warning[fwdref]"
 331+ A3A0             >
 331+ A3A0             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 332+ A3A0              QDup_Ptr:
 333+ A3A0 E1                           pop     hl
 334+ A3A1 7C                           ld      a, h
 335+ A3A2 B5                           or      l
 336+ A3A3 28 01                        jr      z, QDup_Skip
 337+ A3A5 E5                               push    hl
 338+ A3A6              QDup_Skip:
 339+ A3A6                              psh1
 339+ A3A6 E5          >                push    hl
 339+ A3A7 DD E9       >                jp      (ix)
 340+ A3A9
 341+ A3A9              //  ______________________________________________________________________
 342+ A3A9              //
 343+ A3A9              // -dup         n -- 0 | n n
 344+ A3A9              // duplicate if not zero
 345+ A3A9                              New_Def LDUP, "-DUP", is_code, is_normal
 345+ A3A9             >
 345+ A3A9             >Dict_Ptr        defl    $
 345+ A3A9             >
 345+ A3A9             >//              ______________________________________________________________________
 345+ A3A9             >//              Heap part
 345+ A3A9             >
 345+ A3A9             >
 345+ A3A9             >                org     (Heap_Ptr & $1FFF) + $E000
 345+ E67A             >
 345+ E67A             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 345+ E67A             >Latest_Definition defl  Heap_Ptr
 345+ E67A             >
 345+ E67A             >                // dummy db directives used to calculate length of namec
 345+ E67A 2D 44 55 50 >                db      "-DUP"
 345+ E67E             >len_NFA         defl    $ - temp_NFA
 345+ E67E             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 345+ E67A             >
 345+ E67A 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 345+ E67B 2D 44 55 50 >                db      "-DUP"               // name string in 7-bit ascii, but
 345+ E67F             >                org     $-1                 // alter last byte of Name just above to set
 345+ E67E D0          >                db      {b $} | END_BIT     // msb as name end
 345+ E67F             >
 345+ E67F 71 06       >                dw      Prev_Ptr            // Link to previous definition Name
 345+ E681             >Prev_Ptr        defl    Heap_Ptr
 345+ E681             >
 345+ E681             >mirror_Ptr      defl    $
 345+ E681             >
 345+ E681 AB A3       >                dw      Dict_Ptr + 2        // xt
 345+ E683             >Heap_Ptr        defl    $ - $E000           // save current HP
 345+ E683             >
 345+ E683             >Current_HP      defl  $ - $E000             // used to set HP once!
 345+ E683             >
 345+ E683             >//              ______________________________________________________________________
 345+ E683             >//              Dictionary part
 345+ E683             >
 345+ E683             >                org     Dict_Ptr
 345+ A3A9             >
 345+ A3A9 81 25       >                dw      mirror_Ptr - $E000 + $1F00
 345+ A3AB             >
 345+ A3AB             >LDUP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 345+ A3AB ~           >                call    runcode ; ok        // for primitive definitions  actual code
 345+ A3AB ~           >
 345+ A3AB ~           >
 345+ A3AB             >                endif           ; ok        // for other definitions it "points" the correct handler
 345+ A3AB             >                // Use of "; ok" to suppress "warning[fwdref]"
 345+ A3AB             >
 345+ A3AB             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 346+ A3AB C3 A0 A3                     jp      QDup_Ptr
 347+ A3AE
 348+ A3AE              //  ______________________________________________________________________
 349+ A3AE              //
 350+ A3AE              // emit         c --
 351+ A3AE                              Colon_Def EMIT, "EMIT", is_normal
 351+ A3AE             >                New_Def  EMIT, "EMIT", Enter_Ptr, is_normal ; ok
 351+ A3AE             >
 351+ A3AE             >Dict_Ptr        defl    $
 351+ A3AE             >
 351+ A3AE             >//              ______________________________________________________________________
 351+ A3AE             >//              Heap part
 351+ A3AE             >
 351+ A3AE             >
 351+ A3AE             >                org     (Heap_Ptr & $1FFF) + $E000
 351+ E683             >
 351+ E683             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 351+ E683             >Latest_Definition defl  Heap_Ptr
 351+ E683             >
 351+ E683             >                // dummy db directives used to calculate length of namec
 351+ E683 45 4D 49 54 >                db      "EMIT"
 351+ E687             >len_NFA         defl    $ - temp_NFA
 351+ E687             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 351+ E683             >
 351+ E683 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 351+ E684 45 4D 49 54 >                db      "EMIT"               // name string in 7-bit ascii, but
 351+ E688             >                org     $-1                 // alter last byte of Name just above to set
 351+ E687 D4          >                db      {b $} | END_BIT     // msb as name end
 351+ E688             >
 351+ E688 7A 06       >                dw      Prev_Ptr            // Link to previous definition Name
 351+ E68A             >Prev_Ptr        defl    Heap_Ptr
 351+ E68A             >
 351+ E68A             >mirror_Ptr      defl    $
 351+ E68A             >
 351+ E68A B0 A3       >                dw      Dict_Ptr + 2        // xt
 351+ E68C             >Heap_Ptr        defl    $ - $E000           // save current HP
 351+ E68C             >
 351+ E68C             >Current_HP      defl  $ - $E000             // used to set HP once!
 351+ E68C             >
 351+ E68C             >//              ______________________________________________________________________
 351+ E68C             >//              Dictionary part
 351+ E68C             >
 351+ E68C             >                org     Dict_Ptr
 351+ A3AE             >
 351+ A3AE 8A 25       >                dw      mirror_Ptr - $E000 + $1F00
 351+ A3B0             >
 351+ A3B0             >EMIT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 351+ A3B0 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 351+ A3B3             >
 351+ A3B3             >
 351+ A3B3             >                endif           ; ok        // for other definitions it "points" the correct handler
 351+ A3B3             >                // Use of "; ok" to suppress "warning[fwdref]"
 351+ A3B3             >
 351+ A3B3             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 352+ A3B3 24 9D                        dw      C_EMIT                      // (?emit)
 353+ A3B5 A0 A3                        dw      QDUP                        // ?dup
 354+ A3B7                                                                  // if
 355+ A3B7 45 9B                        dw      ZBRANCH
 356+ A3B9 0A 00                        dw      Emit_Skip - $
 357+ A3BB F2 9C                        dw          EMITC                   //      emitc
 358+ A3BD D8 A1                        dw          ONE                     //      1
 359+ A3BF 7E A2 C1 A0                  dw          OUT, PLUSSTORE        //      out +!
 360+ A3C3              Emit_Skip:                                          // endif
 361+ A3C3 A2 9F                        dw      EXIT                        // ;
 362+ A3C5
 363+ A3C5              //  ______________________________________________________________________
 364+ A3C5              //
 365+ A3C5              // space        --
 366+ A3C5                              Colon_Def SPACE, "SPACE", is_normal
 366+ A3C5             >                New_Def  SPACE, "SPACE", Enter_Ptr, is_normal ; ok
 366+ A3C5             >
 366+ A3C5             >Dict_Ptr        defl    $
 366+ A3C5             >
 366+ A3C5             >//              ______________________________________________________________________
 366+ A3C5             >//              Heap part
 366+ A3C5             >
 366+ A3C5             >
 366+ A3C5             >                org     (Heap_Ptr & $1FFF) + $E000
 366+ E68C             >
 366+ E68C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 366+ E68C             >Latest_Definition defl  Heap_Ptr
 366+ E68C             >
 366+ E68C             >                // dummy db directives used to calculate length of namec
 366+ E68C 53 50 41 43 >                db      "SPACE"
 366+ E690 45          >
 366+ E691             >len_NFA         defl    $ - temp_NFA
 366+ E691             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 366+ E68C             >
 366+ E68C 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 366+ E68D 53 50 41 43 >                db      "SPACE"               // name string in 7-bit ascii, but
 366+ E691 45          >
 366+ E692             >                org     $-1                 // alter last byte of Name just above to set
 366+ E691 C5          >                db      {b $} | END_BIT     // msb as name end
 366+ E692             >
 366+ E692 83 06       >                dw      Prev_Ptr            // Link to previous definition Name
 366+ E694             >Prev_Ptr        defl    Heap_Ptr
 366+ E694             >
 366+ E694             >mirror_Ptr      defl    $
 366+ E694             >
 366+ E694 C7 A3       >                dw      Dict_Ptr + 2        // xt
 366+ E696             >Heap_Ptr        defl    $ - $E000           // save current HP
 366+ E696             >
 366+ E696             >Current_HP      defl  $ - $E000             // used to set HP once!
 366+ E696             >
 366+ E696             >//              ______________________________________________________________________
 366+ E696             >//              Dictionary part
 366+ E696             >
 366+ E696             >                org     Dict_Ptr
 366+ A3C5             >
 366+ A3C5 94 25       >                dw      mirror_Ptr - $E000 + $1F00
 366+ A3C7             >
 366+ A3C7             >SPACE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 366+ A3C7 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 366+ A3CA             >
 366+ A3CA             >
 366+ A3CA             >                endif           ; ok        // for other definitions it "points" the correct handler
 366+ A3CA             >                // Use of "; ok" to suppress "warning[fwdref]"
 366+ A3CA             >
 366+ A3CA             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 367+ A3CA F4 A1 B0 A3                  dw      BL, EMIT                // bl emit
 368+ A3CE A2 9F                        dw      EXIT                    // ;
 369+ A3D0
 370+ A3D0              //  ______________________________________________________________________
 371+ A3D0              //
 372+ A3D0              // traverse     a n -- a
 373+ A3D0              // A dictionary entry is structured as follows
 374+ A3D0              // NFA: +0   one byte of word-length (n<32) | some flags (immediate, smudge) | $80
 375+ A3D0              //      +1   word name, last character is toggled with $80
 376+ A3D0              // LFA: +1+n link to NFA ofprevious  dictionary entry.
 377+ A3D0              // CFA: +3+n routine address. Colon definitions here have a CALL aa
 378+ A3D0              // PFA: +6+n "is_code", definitions have no PFA. // +5
 379+ A3D0              //
 380+ A3D0                              Colon_Def TRAVERSE, "TRAVERSE", is_normal
 380+ A3D0             >                New_Def  TRAVERSE, "TRAVERSE", Enter_Ptr, is_normal ; ok
 380+ A3D0             >
 380+ A3D0             >Dict_Ptr        defl    $
 380+ A3D0             >
 380+ A3D0             >//              ______________________________________________________________________
 380+ A3D0             >//              Heap part
 380+ A3D0             >
 380+ A3D0             >
 380+ A3D0             >                org     (Heap_Ptr & $1FFF) + $E000
 380+ E696             >
 380+ E696             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 380+ E696             >Latest_Definition defl  Heap_Ptr
 380+ E696             >
 380+ E696             >                // dummy db directives used to calculate length of namec
 380+ E696 54 52 41 56 >                db      "TRAVERSE"
 380+ E69A 45 52 53 45 >
 380+ E69E             >len_NFA         defl    $ - temp_NFA
 380+ E69E             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 380+ E696             >
 380+ E696 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 380+ E697 54 52 41 56 >                db      "TRAVERSE"               // name string in 7-bit ascii, but
 380+ E69B 45 52 53 45 >
 380+ E69F             >                org     $-1                 // alter last byte of Name just above to set
 380+ E69E C5          >                db      {b $} | END_BIT     // msb as name end
 380+ E69F             >
 380+ E69F 8C 06       >                dw      Prev_Ptr            // Link to previous definition Name
 380+ E6A1             >Prev_Ptr        defl    Heap_Ptr
 380+ E6A1             >
 380+ E6A1             >mirror_Ptr      defl    $
 380+ E6A1             >
 380+ E6A1 D2 A3       >                dw      Dict_Ptr + 2        // xt
 380+ E6A3             >Heap_Ptr        defl    $ - $E000           // save current HP
 380+ E6A3             >
 380+ E6A3             >Current_HP      defl  $ - $E000             // used to set HP once!
 380+ E6A3             >
 380+ E6A3             >//              ______________________________________________________________________
 380+ E6A3             >//              Dictionary part
 380+ E6A3             >
 380+ E6A3             >                org     Dict_Ptr
 380+ A3D0             >
 380+ A3D0 A1 25       >                dw      mirror_Ptr - $E000 + $1F00
 380+ A3D2             >
 380+ A3D2             >TRAVERSE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 380+ A3D2 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 380+ A3D5             >
 380+ A3D5             >
 380+ A3D5             >                endif           ; ok        // for other definitions it "points" the correct handler
 380+ A3D5             >                // Use of "; ok" to suppress "warning[fwdref]"
 380+ A3D5             >
 380+ A3D5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 381+ A3D5 74 A0                        dw      SWAP                    // swap
 382+ A3D7              Traverse_Begin:                                 // begin
 383+ A3D7 57 A0 F5 9F                  dw          OVER, PLUS          //      over +
 384+ A3DB F3 9A 7F 00                  dw          LIT, 127            //      127
 385+ A3DF 57 A0 EE A0                  dw          OVER, CFETCH        //      over @
 386+ A3E3 5A A3                        dw          LESS                //      <
 387+ A3E5                                                              // until
 388+ A3E5 45 9B                        dw      ZBRANCH
 389+ A3E7 F0 FF                        dw      Traverse_Begin - $
 390+ A3E9 65 A0                        dw      NIP                     //  nip
 391+ A3EB A2 9F                        dw      EXIT                    //  ;
 392+ A3ED
 393+ A3ED              //  ______________________________________________________________________
 394+ A3ED              //
 395+ A3ED              // mmu7@        -- n
 396+ A3ED              // query current page in MMU7 8K-RAM : 0 and 223
 397+ A3ED
 398+ A3ED                              New_Def MMU7_FETCH, "MMU7@", is_code, is_normal
 398+ A3ED             >
 398+ A3ED             >Dict_Ptr        defl    $
 398+ A3ED             >
 398+ A3ED             >//              ______________________________________________________________________
 398+ A3ED             >//              Heap part
 398+ A3ED             >
 398+ A3ED             >
 398+ A3ED             >                org     (Heap_Ptr & $1FFF) + $E000
 398+ E6A3             >
 398+ E6A3             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 398+ E6A3             >Latest_Definition defl  Heap_Ptr
 398+ E6A3             >
 398+ E6A3             >                // dummy db directives used to calculate length of namec
 398+ E6A3 4D 4D 55 37 >                db      "MMU7@"
 398+ E6A7 40          >
 398+ E6A8             >len_NFA         defl    $ - temp_NFA
 398+ E6A8             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 398+ E6A3             >
 398+ E6A3 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 398+ E6A4 4D 4D 55 37 >                db      "MMU7@"               // name string in 7-bit ascii, but
 398+ E6A8 40          >
 398+ E6A9             >                org     $-1                 // alter last byte of Name just above to set
 398+ E6A8 C0          >                db      {b $} | END_BIT     // msb as name end
 398+ E6A9             >
 398+ E6A9 96 06       >                dw      Prev_Ptr            // Link to previous definition Name
 398+ E6AB             >Prev_Ptr        defl    Heap_Ptr
 398+ E6AB             >
 398+ E6AB             >mirror_Ptr      defl    $
 398+ E6AB             >
 398+ E6AB EF A3       >                dw      Dict_Ptr + 2        // xt
 398+ E6AD             >Heap_Ptr        defl    $ - $E000           // save current HP
 398+ E6AD             >
 398+ E6AD             >Current_HP      defl  $ - $E000             // used to set HP once!
 398+ E6AD             >
 398+ E6AD             >//              ______________________________________________________________________
 398+ E6AD             >//              Dictionary part
 398+ E6AD             >
 398+ E6AD             >                org     Dict_Ptr
 398+ A3ED             >
 398+ A3ED AB 25       >                dw      mirror_Ptr - $E000 + $1F00
 398+ A3EF             >
 398+ A3EF             >MMU7_FETCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 398+ A3EF ~           >                call    runcode ; ok        // for primitive definitions  actual code
 398+ A3EF ~           >
 398+ A3EF ~           >
 398+ A3EF             >                endif           ; ok        // for other definitions it "points" the correct handler
 398+ A3EF             >                // Use of "; ok" to suppress "warning[fwdref]"
 398+ A3EF             >
 398+ A3EF             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 399+ A3EF D9                           exx
 400+ A3F0 CD EF 9B                     call    MMU7_read
 401+ A3F3 D9                           exx
 402+ A3F4 6F                           ld      l, a
 403+ A3F5 26 00                        ld      h, 0
 404+ A3F7 E5                           push    hl
 405+ A3F8                              next
 405+ A3F8 DD E9       >                jp      (ix)
 406+ A3FA
 407+ A3FA              //  ______________________________________________________________________
 408+ A3FA              //
 409+ A3FA              // mmu7!        n --
 410+ A3FA              // set MMU7 8K-RAM page to n given between 0 and 223
 411+ A3FA              // optimized version that uses NEXTREG n,A Z80n op-code.
 412+ A3FA
 413+ A3FA                              New_Def MMU7_STORE, "MMU7!", is_code, is_normal
 413+ A3FA             >
 413+ A3FA             >Dict_Ptr        defl    $
 413+ A3FA             >
 413+ A3FA             >//              ______________________________________________________________________
 413+ A3FA             >//              Heap part
 413+ A3FA             >
 413+ A3FA             >
 413+ A3FA             >                org     (Heap_Ptr & $1FFF) + $E000
 413+ E6AD             >
 413+ E6AD             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 413+ E6AD             >Latest_Definition defl  Heap_Ptr
 413+ E6AD             >
 413+ E6AD             >                // dummy db directives used to calculate length of namec
 413+ E6AD 4D 4D 55 37 >                db      "MMU7!"
 413+ E6B1 21          >
 413+ E6B2             >len_NFA         defl    $ - temp_NFA
 413+ E6B2             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 413+ E6AD             >
 413+ E6AD 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 413+ E6AE 4D 4D 55 37 >                db      "MMU7!"               // name string in 7-bit ascii, but
 413+ E6B2 21          >
 413+ E6B3             >                org     $-1                 // alter last byte of Name just above to set
 413+ E6B2 A1          >                db      {b $} | END_BIT     // msb as name end
 413+ E6B3             >
 413+ E6B3 A3 06       >                dw      Prev_Ptr            // Link to previous definition Name
 413+ E6B5             >Prev_Ptr        defl    Heap_Ptr
 413+ E6B5             >
 413+ E6B5             >mirror_Ptr      defl    $
 413+ E6B5             >
 413+ E6B5 FC A3       >                dw      Dict_Ptr + 2        // xt
 413+ E6B7             >Heap_Ptr        defl    $ - $E000           // save current HP
 413+ E6B7             >
 413+ E6B7             >Current_HP      defl  $ - $E000             // used to set HP once!
 413+ E6B7             >
 413+ E6B7             >//              ______________________________________________________________________
 413+ E6B7             >//              Dictionary part
 413+ E6B7             >
 413+ E6B7             >                org     Dict_Ptr
 413+ A3FA             >
 413+ A3FA B5 25       >                dw      mirror_Ptr - $E000 + $1F00
 413+ A3FC             >
 413+ A3FC             >MMU7_STORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 413+ A3FC ~           >                call    runcode ; ok        // for primitive definitions  actual code
 413+ A3FC ~           >
 413+ A3FC ~           >
 413+ A3FC             >                endif           ; ok        // for other definitions it "points" the correct handler
 413+ A3FC             >                // Use of "; ok" to suppress "warning[fwdref]"
 413+ A3FC             >
 413+ A3FC             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 414+ A3FC E1                           pop     hl
 415+ A3FD 7D                           ld      a, l
 416+ A3FE ED 92 57                     nextreg 87, a
 417+ A401
 418+ A401                              next
 418+ A401 DD E9       >                jp      (ix)
 419+ A403
 420+ A403              //  ______________________________________________________________________
 421+ A403              //
 422+ A403              // >far         ha -- a n
 423+ A403              // decode bits 765 of H as one of the 8K-page between 64 and 71 (40h-47h)
 424+ A403              // take lower bits of H and L as an offset from E000h
 425+ A403              // then return address  a  between E000h-FFFFh
 426+ A403              // and page number n  between 64-71 (40h-47h)
 427+ A403              // For example, in hex:
 428+ A403              //   0000 >FAR  gives  40.E000
 429+ A403              //   1FFF >FAR  gives  40.FFFF
 430+ A403              //   2000 >FAR  gives  41.E000
 431+ A403              //   3FFF >FAR  gives  41.FFFF
 432+ A403              //   EFFF >FAR  gives  47.EFFF
 433+ A403              //   FFFF >FAR  gives  47.FFFF
 434+ A403                              New_Def TO_FAR, ">FAR", is_code, is_normal
 434+ A403             >
 434+ A403             >Dict_Ptr        defl    $
 434+ A403             >
 434+ A403             >//              ______________________________________________________________________
 434+ A403             >//              Heap part
 434+ A403             >
 434+ A403             >
 434+ A403             >                org     (Heap_Ptr & $1FFF) + $E000
 434+ E6B7             >
 434+ E6B7             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 434+ E6B7             >Latest_Definition defl  Heap_Ptr
 434+ E6B7             >
 434+ E6B7             >                // dummy db directives used to calculate length of namec
 434+ E6B7 3E 46 41 52 >                db      ">FAR"
 434+ E6BB             >len_NFA         defl    $ - temp_NFA
 434+ E6BB             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 434+ E6B7             >
 434+ E6B7 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 434+ E6B8 3E 46 41 52 >                db      ">FAR"               // name string in 7-bit ascii, but
 434+ E6BC             >                org     $-1                 // alter last byte of Name just above to set
 434+ E6BB D2          >                db      {b $} | END_BIT     // msb as name end
 434+ E6BC             >
 434+ E6BC AD 06       >                dw      Prev_Ptr            // Link to previous definition Name
 434+ E6BE             >Prev_Ptr        defl    Heap_Ptr
 434+ E6BE             >
 434+ E6BE             >mirror_Ptr      defl    $
 434+ E6BE             >
 434+ E6BE 05 A4       >                dw      Dict_Ptr + 2        // xt
 434+ E6C0             >Heap_Ptr        defl    $ - $E000           // save current HP
 434+ E6C0             >
 434+ E6C0             >Current_HP      defl  $ - $E000             // used to set HP once!
 434+ E6C0             >
 434+ E6C0             >//              ______________________________________________________________________
 434+ E6C0             >//              Dictionary part
 434+ E6C0             >
 434+ E6C0             >                org     Dict_Ptr
 434+ A403             >
 434+ A403 BE 25       >                dw      mirror_Ptr - $E000 + $1F00
 434+ A405             >
 434+ A405             >TO_FAR:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 434+ A405 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 434+ A405 ~           >
 434+ A405 ~           >
 434+ A405             >                endif           ; ok        // for other definitions it "points" the correct handler
 434+ A405             >                // Use of "; ok" to suppress "warning[fwdref]"
 434+ A405             >
 434+ A405             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 435+ A405 E1                           pop     hl
 436+ A406 CD FA 9B                     call    TO_FAR_rout
 437+ A409 E5                           push    hl
 438+ A40A 6F                           ld      l, a
 439+ A40B 26 00                        ld      h, 0
 440+ A40D E5                           push    hl
 441+ A40E                              next
 441+ A40E DD E9       >                jp      (ix)
 442+ A410
 443+ A410              //  ______________________________________________________________________
 444+ A410              //
 445+ A410              // <far         a n  -- ha
 446+ A410              // given an address E000-FFFF and a page number n (64-71 or 40h-47h)
 447+ A410              // reverse of >FAR: encodes a FAR address compressing
 448+ A410              // to bits 765 of H, lower bits of HL address offset from E000h
 449+ A410                              New_Def FROM_FAR, "<FAR", is_code, is_normal
 449+ A410             >
 449+ A410             >Dict_Ptr        defl    $
 449+ A410             >
 449+ A410             >//              ______________________________________________________________________
 449+ A410             >//              Heap part
 449+ A410             >
 449+ A410             >
 449+ A410             >                org     (Heap_Ptr & $1FFF) + $E000
 449+ E6C0             >
 449+ E6C0             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 449+ E6C0             >Latest_Definition defl  Heap_Ptr
 449+ E6C0             >
 449+ E6C0             >                // dummy db directives used to calculate length of namec
 449+ E6C0 3C 46 41 52 >                db      "<FAR"
 449+ E6C4             >len_NFA         defl    $ - temp_NFA
 449+ E6C4             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 449+ E6C0             >
 449+ E6C0 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 449+ E6C1 3C 46 41 52 >                db      "<FAR"               // name string in 7-bit ascii, but
 449+ E6C5             >                org     $-1                 // alter last byte of Name just above to set
 449+ E6C4 D2          >                db      {b $} | END_BIT     // msb as name end
 449+ E6C5             >
 449+ E6C5 B7 06       >                dw      Prev_Ptr            // Link to previous definition Name
 449+ E6C7             >Prev_Ptr        defl    Heap_Ptr
 449+ E6C7             >
 449+ E6C7             >mirror_Ptr      defl    $
 449+ E6C7             >
 449+ E6C7 12 A4       >                dw      Dict_Ptr + 2        // xt
 449+ E6C9             >Heap_Ptr        defl    $ - $E000           // save current HP
 449+ E6C9             >
 449+ E6C9             >Current_HP      defl  $ - $E000             // used to set HP once!
 449+ E6C9             >
 449+ E6C9             >//              ______________________________________________________________________
 449+ E6C9             >//              Dictionary part
 449+ E6C9             >
 449+ E6C9             >                org     Dict_Ptr
 449+ A410             >
 449+ A410 C7 25       >                dw      mirror_Ptr - $E000 + $1F00
 449+ A412             >
 449+ A412             >FROM_FAR:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 449+ A412 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 449+ A412 ~           >
 449+ A412 ~           >
 449+ A412             >                endif           ; ok        // for other definitions it "points" the correct handler
 449+ A412             >                // Use of "; ok" to suppress "warning[fwdref]"
 449+ A412             >
 449+ A412             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 450+ A412 E1                           pop     hl                  // page number in e
 451+ A413 7D                           ld      a, l
 452+ A414 E6 07                        and     07
 453+ A416 0F                           rrca
 454+ A417 0F                           rrca
 455+ A418 0F                           rrca
 456+ A419 08                           ex      af, af
 457+ A41A E1                           pop     hl                  // address in hl
 458+ A41B 7C                           ld      a, h
 459+ A41C E6 1F                        and     $1F
 460+ A41E 67                           ld      h, a
 461+ A41F 08                           ex      af, af
 462+ A420 B4                           or      h
 463+ A421 67                           ld      h, a
 464+ A422                              psh1
 464+ A422 E5          >                push    hl
 464+ A423 DD E9       >                jp      (ix)
 465+ A425
 466+ A425              //  ______________________________________________________________________
 467+ A425              //
 468+ A425              // ?mmu7        a -- f
 469+ A425              // query current page in MMU7 8K-RAM : 0 and 223
 470+ A425                              Colon_Def QMMU7, "?MMU7", is_normal
 470+ A425             >                New_Def  QMMU7, "?MMU7", Enter_Ptr, is_normal ; ok
 470+ A425             >
 470+ A425             >Dict_Ptr        defl    $
 470+ A425             >
 470+ A425             >//              ______________________________________________________________________
 470+ A425             >//              Heap part
 470+ A425             >
 470+ A425             >
 470+ A425             >                org     (Heap_Ptr & $1FFF) + $E000
 470+ E6C9             >
 470+ E6C9             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 470+ E6C9             >Latest_Definition defl  Heap_Ptr
 470+ E6C9             >
 470+ E6C9             >                // dummy db directives used to calculate length of namec
 470+ E6C9 3F 4D 4D 55 >                db      "?MMU7"
 470+ E6CD 37          >
 470+ E6CE             >len_NFA         defl    $ - temp_NFA
 470+ E6CE             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 470+ E6C9             >
 470+ E6C9 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 470+ E6CA 3F 4D 4D 55 >                db      "?MMU7"               // name string in 7-bit ascii, but
 470+ E6CE 37          >
 470+ E6CF             >                org     $-1                 // alter last byte of Name just above to set
 470+ E6CE B7          >                db      {b $} | END_BIT     // msb as name end
 470+ E6CF             >
 470+ E6CF C0 06       >                dw      Prev_Ptr            // Link to previous definition Name
 470+ E6D1             >Prev_Ptr        defl    Heap_Ptr
 470+ E6D1             >
 470+ E6D1             >mirror_Ptr      defl    $
 470+ E6D1             >
 470+ E6D1 27 A4       >                dw      Dict_Ptr + 2        // xt
 470+ E6D3             >Heap_Ptr        defl    $ - $E000           // save current HP
 470+ E6D3             >
 470+ E6D3             >Current_HP      defl  $ - $E000             // used to set HP once!
 470+ E6D3             >
 470+ E6D3             >//              ______________________________________________________________________
 470+ E6D3             >//              Dictionary part
 470+ E6D3             >
 470+ E6D3             >                org     Dict_Ptr
 470+ A425             >
 470+ A425 D1 25       >                dw      mirror_Ptr - $E000 + $1F00
 470+ A427             >
 470+ A427             >QMMU7:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 470+ A427 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 470+ A42A             >
 470+ A42A             >
 470+ A42A             >                endif           ; ok        // for other definitions it "points" the correct handler
 470+ A42A             >                // Use of "; ok" to suppress "warning[fwdref]"
 470+ A42A             >
 470+ A42A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 471+ A42A 7B A0                        dw      DUP
 472+ A42C F3 9A 00 E0                  dw      LIT, $E000
 473+ A430 4C A3                        dw      ULESS
 474+ A432 D5 9F                        dw      NOT_OP
 475+ A434 A2 9F                        dw      EXIT
 476+ A436
 477+ A436              //  ______________________________________________________________________
 478+ A436              //
 479+ A436              // far          hp -- ha
 480+ A436              // query current page in MMU7 8K-RAM : 0 and 223
 481+ A436                              Colon_Def FAR, "FAR", is_normal
 481+ A436             >                New_Def  FAR, "FAR", Enter_Ptr, is_normal ; ok
 481+ A436             >
 481+ A436             >Dict_Ptr        defl    $
 481+ A436             >
 481+ A436             >//              ______________________________________________________________________
 481+ A436             >//              Heap part
 481+ A436             >
 481+ A436             >
 481+ A436             >                org     (Heap_Ptr & $1FFF) + $E000
 481+ E6D3             >
 481+ E6D3             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 481+ E6D3             >Latest_Definition defl  Heap_Ptr
 481+ E6D3             >
 481+ E6D3             >                // dummy db directives used to calculate length of namec
 481+ E6D3 46 41 52    >                db      "FAR"
 481+ E6D6             >len_NFA         defl    $ - temp_NFA
 481+ E6D6             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 481+ E6D3             >
 481+ E6D3 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 481+ E6D4 46 41 52    >                db      "FAR"               // name string in 7-bit ascii, but
 481+ E6D7             >                org     $-1                 // alter last byte of Name just above to set
 481+ E6D6 D2          >                db      {b $} | END_BIT     // msb as name end
 481+ E6D7             >
 481+ E6D7 C9 06       >                dw      Prev_Ptr            // Link to previous definition Name
 481+ E6D9             >Prev_Ptr        defl    Heap_Ptr
 481+ E6D9             >
 481+ E6D9             >mirror_Ptr      defl    $
 481+ E6D9             >
 481+ E6D9 38 A4       >                dw      Dict_Ptr + 2        // xt
 481+ E6DB             >Heap_Ptr        defl    $ - $E000           // save current HP
 481+ E6DB             >
 481+ E6DB             >Current_HP      defl  $ - $E000             // used to set HP once!
 481+ E6DB             >
 481+ E6DB             >//              ______________________________________________________________________
 481+ E6DB             >//              Dictionary part
 481+ E6DB             >
 481+ E6DB             >                org     Dict_Ptr
 481+ A436             >
 481+ A436 D9 25       >                dw      mirror_Ptr - $E000 + $1F00
 481+ A438             >
 481+ A438             >FAR:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 481+ A438 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 481+ A43B             >
 481+ A43B             >
 481+ A43B             >                endif           ; ok        // for other definitions it "points" the correct handler
 481+ A43B             >                // Use of "; ok" to suppress "warning[fwdref]"
 481+ A43B             >
 481+ A43B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 482+ A43B 05 A4                        dw      TO_FAR
 483+ A43D FC A3                        dw      MMU7_STORE
 484+ A43F A2 9F                        dw      EXIT
 485+ A441
 486+ A441              //  ______________________________________________________________________
 487+ A441              //
 488+ A441              // ?heapp       n -- n f
 489+ A441              // query current page in MMU7 8K-RAM : 0 and 223
 490+ A441                              Colon_Def QHEAPP, "?HEAPP", is_normal
 490+ A441             >                New_Def  QHEAPP, "?HEAPP", Enter_Ptr, is_normal ; ok
 490+ A441             >
 490+ A441             >Dict_Ptr        defl    $
 490+ A441             >
 490+ A441             >//              ______________________________________________________________________
 490+ A441             >//              Heap part
 490+ A441             >
 490+ A441             >
 490+ A441             >                org     (Heap_Ptr & $1FFF) + $E000
 490+ E6DB             >
 490+ E6DB             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 490+ E6DB             >Latest_Definition defl  Heap_Ptr
 490+ E6DB             >
 490+ E6DB             >                // dummy db directives used to calculate length of namec
 490+ E6DB 3F 48 45 41 >                db      "?HEAPP"
 490+ E6DF 50 50       >
 490+ E6E1             >len_NFA         defl    $ - temp_NFA
 490+ E6E1             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 490+ E6DB             >
 490+ E6DB 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 490+ E6DC 3F 48 45 41 >                db      "?HEAPP"               // name string in 7-bit ascii, but
 490+ E6E0 50 50       >
 490+ E6E2             >                org     $-1                 // alter last byte of Name just above to set
 490+ E6E1 D0          >                db      {b $} | END_BIT     // msb as name end
 490+ E6E2             >
 490+ E6E2 D3 06       >                dw      Prev_Ptr            // Link to previous definition Name
 490+ E6E4             >Prev_Ptr        defl    Heap_Ptr
 490+ E6E4             >
 490+ E6E4             >mirror_Ptr      defl    $
 490+ E6E4             >
 490+ E6E4 43 A4       >                dw      Dict_Ptr + 2        // xt
 490+ E6E6             >Heap_Ptr        defl    $ - $E000           // save current HP
 490+ E6E6             >
 490+ E6E6             >Current_HP      defl  $ - $E000             // used to set HP once!
 490+ E6E6             >
 490+ E6E6             >//              ______________________________________________________________________
 490+ E6E6             >//              Dictionary part
 490+ E6E6             >
 490+ E6E6             >                org     Dict_Ptr
 490+ A441             >
 490+ A441 E4 25       >                dw      mirror_Ptr - $E000 + $1F00
 490+ A443             >
 490+ A443             >QHEAPP:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 490+ A443 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 490+ A446             >
 490+ A446             >
 490+ A446             >                endif           ; ok        // for other definitions it "points" the correct handler
 490+ A446             >                // Use of "; ok" to suppress "warning[fwdref]"
 490+ A446             >
 490+ A446             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 491+ A446 7B A0                        dw      DUP
 492+ A448 45 9B                        dw      ZBRANCH
 493+ A44A 08 00                        dw      QHeap_Skip - $
 494+ A44C F3 9A 00 60                  dw          LIT, $6000
 495+ A450 4C A3                        dw          ULESS
 496+ A452              QHeap_Skip:                                          // endif
 497+ A452 A2 9F                        dw      EXIT                        // ;
 498+ A454
 499+ A454              //  ______________________________________________________________________
 500+ A454              //
 501+ A454              // ?>heap       n1 -- n2
 502+ A454              // query current page in MMU7 8K-RAM : 0 and 223
 503+ A454                              Colon_Def QTOHEAP, "?>HEAP", is_normal
 503+ A454             >                New_Def  QTOHEAP, "?>HEAP", Enter_Ptr, is_normal ; ok
 503+ A454             >
 503+ A454             >Dict_Ptr        defl    $
 503+ A454             >
 503+ A454             >//              ______________________________________________________________________
 503+ A454             >//              Heap part
 503+ A454             >
 503+ A454             >
 503+ A454             >                org     (Heap_Ptr & $1FFF) + $E000
 503+ E6E6             >
 503+ E6E6             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 503+ E6E6             >Latest_Definition defl  Heap_Ptr
 503+ E6E6             >
 503+ E6E6             >                // dummy db directives used to calculate length of namec
 503+ E6E6 3F 3E 48 45 >                db      "?>HEAP"
 503+ E6EA 41 50       >
 503+ E6EC             >len_NFA         defl    $ - temp_NFA
 503+ E6EC             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 503+ E6E6             >
 503+ E6E6 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 503+ E6E7 3F 3E 48 45 >                db      "?>HEAP"               // name string in 7-bit ascii, but
 503+ E6EB 41 50       >
 503+ E6ED             >                org     $-1                 // alter last byte of Name just above to set
 503+ E6EC D0          >                db      {b $} | END_BIT     // msb as name end
 503+ E6ED             >
 503+ E6ED DB 06       >                dw      Prev_Ptr            // Link to previous definition Name
 503+ E6EF             >Prev_Ptr        defl    Heap_Ptr
 503+ E6EF             >
 503+ E6EF             >mirror_Ptr      defl    $
 503+ E6EF             >
 503+ E6EF 56 A4       >                dw      Dict_Ptr + 2        // xt
 503+ E6F1             >Heap_Ptr        defl    $ - $E000           // save current HP
 503+ E6F1             >
 503+ E6F1             >Current_HP      defl  $ - $E000             // used to set HP once!
 503+ E6F1             >
 503+ E6F1             >//              ______________________________________________________________________
 503+ E6F1             >//              Dictionary part
 503+ E6F1             >
 503+ E6F1             >                org     Dict_Ptr
 503+ A454             >
 503+ A454 EF 25       >                dw      mirror_Ptr - $E000 + $1F00
 503+ A456             >
 503+ A456             >QTOHEAP:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 503+ A456 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 503+ A459             >
 503+ A459             >
 503+ A459             >                endif           ; ok        // for other definitions it "points" the correct handler
 503+ A459             >                // Use of "; ok" to suppress "warning[fwdref]"
 503+ A459             >
 503+ A459             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 504+ A459 7B A0                        dw      DUP
 505+ A45B 43 A4                        dw      QHEAPP
 506+ A45D 45 9B                        dw      ZBRANCH
 507+ A45F 04 00                        dw      Q2Heap_Skip - $
 508+ A461 38 A4                        dw          FAR
 509+ A463              Q2Heap_Skip:                                          // endif
 510+ A463 A2 9F                        dw      EXIT                        // ;
 511+ A465
 512+ A465              //  ______________________________________________________________________
 513+ A465              //
 514+ A465              // hp_fetch     -- a
 515+ A465                              Colon_Def HP_FETCH, "HP@", is_normal
 515+ A465             >                New_Def  HP_FETCH, "HP@", Enter_Ptr, is_normal ; ok
 515+ A465             >
 515+ A465             >Dict_Ptr        defl    $
 515+ A465             >
 515+ A465             >//              ______________________________________________________________________
 515+ A465             >//              Heap part
 515+ A465             >
 515+ A465             >
 515+ A465             >                org     (Heap_Ptr & $1FFF) + $E000
 515+ E6F1             >
 515+ E6F1             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 515+ E6F1             >Latest_Definition defl  Heap_Ptr
 515+ E6F1             >
 515+ E6F1             >                // dummy db directives used to calculate length of namec
 515+ E6F1 48 50 40    >                db      "HP@"
 515+ E6F4             >len_NFA         defl    $ - temp_NFA
 515+ E6F4             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 515+ E6F1             >
 515+ E6F1 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 515+ E6F2 48 50 40    >                db      "HP@"               // name string in 7-bit ascii, but
 515+ E6F5             >                org     $-1                 // alter last byte of Name just above to set
 515+ E6F4 C0          >                db      {b $} | END_BIT     // msb as name end
 515+ E6F5             >
 515+ E6F5 E6 06       >                dw      Prev_Ptr            // Link to previous definition Name
 515+ E6F7             >Prev_Ptr        defl    Heap_Ptr
 515+ E6F7             >
 515+ E6F7             >mirror_Ptr      defl    $
 515+ E6F7             >
 515+ E6F7 67 A4       >                dw      Dict_Ptr + 2        // xt
 515+ E6F9             >Heap_Ptr        defl    $ - $E000           // save current HP
 515+ E6F9             >
 515+ E6F9             >Current_HP      defl  $ - $E000             // used to set HP once!
 515+ E6F9             >
 515+ E6F9             >//              ______________________________________________________________________
 515+ E6F9             >//              Dictionary part
 515+ E6F9             >
 515+ E6F9             >                org     Dict_Ptr
 515+ A465             >
 515+ A465 F7 25       >                dw      mirror_Ptr - $E000 + $1F00
 515+ A467             >
 515+ A467             >HP_FETCH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 515+ A467 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 515+ A46A             >
 515+ A46A             >
 515+ A46A             >                endif           ; ok        // for other definitions it "points" the correct handler
 515+ A46A             >                // Use of "; ok" to suppress "warning[fwdref]"
 515+ A46A             >
 515+ A46A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 516+ A46A 66 A2 D9 A0                  dw      HP, FETCH               // hp @
 517+ A46E A2 9F                        dw      EXIT                    // ;
 518+ A470
 519+ A470              //  ______________________________________________________________________
 520+ A470              //
 521+ A470              // page-watermark   -- n
 522+ A470              // number of buffers available. must be the difference between LIMIT and FIRST divided by 516
 523+ A470                              Constant_Def PAGE_WATERMARK,   "PAGE-WATERMARK", $1F80
 523+ A470             >                New_Def  PAGE_WATERMARK, "PAGE-WATERMARK", Constant_Ptr, is_normal
 523+ A470             >
 523+ A470             >Dict_Ptr        defl    $
 523+ A470             >
 523+ A470             >//              ______________________________________________________________________
 523+ A470             >//              Heap part
 523+ A470             >
 523+ A470             >
 523+ A470             >                org     (Heap_Ptr & $1FFF) + $E000
 523+ E6F9             >
 523+ E6F9             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 523+ E6F9             >Latest_Definition defl  Heap_Ptr
 523+ E6F9             >
 523+ E6F9             >                // dummy db directives used to calculate length of namec
 523+ E6F9 50 41 47 45 >                db      "PAGE-WATERMARK"
 523+ E6FD 2D 57 41 54 >
 523+ E701 45 52 4D 41 >
 523+ E705 52 4B       >
 523+ E707             >len_NFA         defl    $ - temp_NFA
 523+ E707             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 523+ E6F9             >
 523+ E6F9 8E          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 523+ E6FA 50 41 47 45 >                db      "PAGE-WATERMARK"               // name string in 7-bit ascii, but
 523+ E6FE 2D 57 41 54 >
 523+ E702 45 52 4D 41 >
 523+ E706 52 4B       >
 523+ E708             >                org     $-1                 // alter last byte of Name just above to set
 523+ E707 CB          >                db      {b $} | END_BIT     // msb as name end
 523+ E708             >
 523+ E708 F1 06       >                dw      Prev_Ptr            // Link to previous definition Name
 523+ E70A             >Prev_Ptr        defl    Heap_Ptr
 523+ E70A             >
 523+ E70A             >mirror_Ptr      defl    $
 523+ E70A             >
 523+ E70A 72 A4       >                dw      Dict_Ptr + 2        // xt
 523+ E70C             >Heap_Ptr        defl    $ - $E000           // save current HP
 523+ E70C             >
 523+ E70C             >Current_HP      defl  $ - $E000             // used to set HP once!
 523+ E70C             >
 523+ E70C             >//              ______________________________________________________________________
 523+ E70C             >//              Dictionary part
 523+ E70C             >
 523+ E70C             >                org     Dict_Ptr
 523+ A470             >
 523+ A470 0A 26       >                dw      mirror_Ptr - $E000 + $1F00
 523+ A472             >
 523+ A472             >PAGE_WATERMARK:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 523+ A472 CD A5 A1    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 523+ A475             >
 523+ A475             >
 523+ A475             >                endif           ; ok        // for other definitions it "points" the correct handler
 523+ A475             >                // Use of "; ok" to suppress "warning[fwdref]"
 523+ A475             >
 523+ A475             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 523+ A475 80 1F       >                dw      $1F80
 524+ A477
 525+ A477              //  ______________________________________________________________________
 526+ A477              //
 527+ A477              // skip-hp-page ha -- a
 528+ A477                              Colon_Def SKIP_HP_PAGE, "SKIP-HP-PAGE", is_normal
 528+ A477             >                New_Def  SKIP_HP_PAGE, "SKIP-HP-PAGE", Enter_Ptr, is_normal ; ok
 528+ A477             >
 528+ A477             >Dict_Ptr        defl    $
 528+ A477             >
 528+ A477             >//              ______________________________________________________________________
 528+ A477             >//              Heap part
 528+ A477             >
 528+ A477             >
 528+ A477             >                org     (Heap_Ptr & $1FFF) + $E000
 528+ E70C             >
 528+ E70C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 528+ E70C             >Latest_Definition defl  Heap_Ptr
 528+ E70C             >
 528+ E70C             >                // dummy db directives used to calculate length of namec
 528+ E70C 53 4B 49 50 >                db      "SKIP-HP-PAGE"
 528+ E710 2D 48 50 2D >
 528+ E714 50 41 47 45 >
 528+ E718             >len_NFA         defl    $ - temp_NFA
 528+ E718             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 528+ E70C             >
 528+ E70C 8C          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 528+ E70D 53 4B 49 50 >                db      "SKIP-HP-PAGE"               // name string in 7-bit ascii, but
 528+ E711 2D 48 50 2D >
 528+ E715 50 41 47 45 >
 528+ E719             >                org     $-1                 // alter last byte of Name just above to set
 528+ E718 C5          >                db      {b $} | END_BIT     // msb as name end
 528+ E719             >
 528+ E719 F9 06       >                dw      Prev_Ptr            // Link to previous definition Name
 528+ E71B             >Prev_Ptr        defl    Heap_Ptr
 528+ E71B             >
 528+ E71B             >mirror_Ptr      defl    $
 528+ E71B             >
 528+ E71B 79 A4       >                dw      Dict_Ptr + 2        // xt
 528+ E71D             >Heap_Ptr        defl    $ - $E000           // save current HP
 528+ E71D             >
 528+ E71D             >Current_HP      defl  $ - $E000             // used to set HP once!
 528+ E71D             >
 528+ E71D             >//              ______________________________________________________________________
 528+ E71D             >//              Dictionary part
 528+ E71D             >
 528+ E71D             >                org     Dict_Ptr
 528+ A477             >
 528+ A477 1B 26       >                dw      mirror_Ptr - $E000 + $1F00
 528+ A479             >
 528+ A479             >SKIP_HP_PAGE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 528+ A479 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 528+ A47C             >
 528+ A47C             >
 528+ A47C             >                endif           ; ok        // for other definitions it "points" the correct handler
 528+ A47C             >                // Use of "; ok" to suppress "warning[fwdref]"
 528+ A47C             >
 528+ A47C             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 529+ A47C 67 A4                        dw      HP_FETCH                // hp@
 530+ A47E F3 9A FF 1F                  dw      LIT, $1FFF, AND_OP      // 1FFF and
 530+ A482 5C 9F
 531+ A484 F5 9F                        dw      PLUS
 532+ A486 72 A4                        dw      PAGE_WATERMARK
 533+ A488 6F A3                        dw      GREATER
 534+ A48A 45 9B                        dw      ZBRANCH
 535+ A48C 12 00                        dw      Skip_Skip - $   // if
 536+ A48E 67 A4                        dw      HP_FETCH
 537+ A490 F3 9A FF 1F                  dw      LIT, $1FFF, OR_OP
 537+ A494 6B 9F
 538+ A496 0E A0 1C A0                  dw      ONE_PLUS, TWO_PLUS
 539+ A49A 66 A2 E3 A0                  dw      HP, STORE
 540+ A49E              Skip_Skip:
 541+ A49E A2 9F                        dw      EXIT                    // ;
 542+ A4A0              //  ______________________________________________________________________
 543+ A4A0              //
 544+ A4A0              // latest       -- nfa
 545+ A4A0                              Colon_Def LATEST, "LATEST", is_normal
 545+ A4A0             >                New_Def  LATEST, "LATEST", Enter_Ptr, is_normal ; ok
 545+ A4A0             >
 545+ A4A0             >Dict_Ptr        defl    $
 545+ A4A0             >
 545+ A4A0             >//              ______________________________________________________________________
 545+ A4A0             >//              Heap part
 545+ A4A0             >
 545+ A4A0             >
 545+ A4A0             >                org     (Heap_Ptr & $1FFF) + $E000
 545+ E71D             >
 545+ E71D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 545+ E71D             >Latest_Definition defl  Heap_Ptr
 545+ E71D             >
 545+ E71D             >                // dummy db directives used to calculate length of namec
 545+ E71D 4C 41 54 45 >                db      "LATEST"
 545+ E721 53 54       >
 545+ E723             >len_NFA         defl    $ - temp_NFA
 545+ E723             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 545+ E71D             >
 545+ E71D 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 545+ E71E 4C 41 54 45 >                db      "LATEST"               // name string in 7-bit ascii, but
 545+ E722 53 54       >
 545+ E724             >                org     $-1                 // alter last byte of Name just above to set
 545+ E723 D4          >                db      {b $} | END_BIT     // msb as name end
 545+ E724             >
 545+ E724 0C 07       >                dw      Prev_Ptr            // Link to previous definition Name
 545+ E726             >Prev_Ptr        defl    Heap_Ptr
 545+ E726             >
 545+ E726             >mirror_Ptr      defl    $
 545+ E726             >
 545+ E726 A2 A4       >                dw      Dict_Ptr + 2        // xt
 545+ E728             >Heap_Ptr        defl    $ - $E000           // save current HP
 545+ E728             >
 545+ E728             >Current_HP      defl  $ - $E000             // used to set HP once!
 545+ E728             >
 545+ E728             >//              ______________________________________________________________________
 545+ E728             >//              Dictionary part
 545+ E728             >
 545+ E728             >                org     Dict_Ptr
 545+ A4A0             >
 545+ A4A0 26 26       >                dw      mirror_Ptr - $E000 + $1F00
 545+ A4A2             >
 545+ A4A2             >LATEST:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 545+ A4A2 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 545+ A4A5             >
 545+ A4A5             >
 545+ A4A5             >                endif           ; ok        // for other definitions it "points" the correct handler
 545+ A4A5             >                // Use of "; ok" to suppress "warning[fwdref]"
 545+ A4A5             >
 545+ A4A5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 546+ A4A5 96 A2                        dw      CURRENT                 // current
 547+ A4A7 D9 A0 D9 A0                  dw      FETCH, FETCH            // @ @
 548+ A4AB 38 A4                        dw      FAR // Q TO HEAP
 549+ A4AD A2 9F                        dw      EXIT                    // ;
 550+ A4AF
 551+ A4AF              //  ______________________________________________________________________
 552+ A4AF              //
 553+ A4AF              // >body        cfa -- pfa
 554+ A4AF                              Colon_Def TO_BODY, ">BODY", is_normal
 554+ A4AF             >                New_Def  TO_BODY, ">BODY", Enter_Ptr, is_normal ; ok
 554+ A4AF             >
 554+ A4AF             >Dict_Ptr        defl    $
 554+ A4AF             >
 554+ A4AF             >//              ______________________________________________________________________
 554+ A4AF             >//              Heap part
 554+ A4AF             >
 554+ A4AF             >
 554+ A4AF             >                org     (Heap_Ptr & $1FFF) + $E000
 554+ E728             >
 554+ E728             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 554+ E728             >Latest_Definition defl  Heap_Ptr
 554+ E728             >
 554+ E728             >                // dummy db directives used to calculate length of namec
 554+ E728 3E 42 4F 44 >                db      ">BODY"
 554+ E72C 59          >
 554+ E72D             >len_NFA         defl    $ - temp_NFA
 554+ E72D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 554+ E728             >
 554+ E728 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 554+ E729 3E 42 4F 44 >                db      ">BODY"               // name string in 7-bit ascii, but
 554+ E72D 59          >
 554+ E72E             >                org     $-1                 // alter last byte of Name just above to set
 554+ E72D D9          >                db      {b $} | END_BIT     // msb as name end
 554+ E72E             >
 554+ E72E 1D 07       >                dw      Prev_Ptr            // Link to previous definition Name
 554+ E730             >Prev_Ptr        defl    Heap_Ptr
 554+ E730             >
 554+ E730             >mirror_Ptr      defl    $
 554+ E730             >
 554+ E730 B1 A4       >                dw      Dict_Ptr + 2        // xt
 554+ E732             >Heap_Ptr        defl    $ - $E000           // save current HP
 554+ E732             >
 554+ E732             >Current_HP      defl  $ - $E000             // used to set HP once!
 554+ E732             >
 554+ E732             >//              ______________________________________________________________________
 554+ E732             >//              Dictionary part
 554+ E732             >
 554+ E732             >                org     Dict_Ptr
 554+ A4AF             >
 554+ A4AF 30 26       >                dw      mirror_Ptr - $E000 + $1F00
 554+ A4B1             >
 554+ A4B1             >TO_BODY:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 554+ A4B1 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 554+ A4B4             >
 554+ A4B4             >
 554+ A4B4             >                endif           ; ok        // for other definitions it "points" the correct handler
 554+ A4B4             >                // Use of "; ok" to suppress "warning[fwdref]"
 554+ A4B4             >
 554+ A4B4             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 555+ A4B4 E6 A1 F5 9F                  dw      THREE, PLUS             // cell+ --> 3 +
 556+ A4B8 A2 9F                        dw      EXIT                    // ;
 557+ A4BA
 558+ A4BA              //  ______________________________________________________________________
 559+ A4BA              //
 560+ A4BA              // <name        cfa -- nfa
 561+ A4BA                              Colon_Def TO_NAME, "<NAME", is_normal
 561+ A4BA             >                New_Def  TO_NAME, "<NAME", Enter_Ptr, is_normal ; ok
 561+ A4BA             >
 561+ A4BA             >Dict_Ptr        defl    $
 561+ A4BA             >
 561+ A4BA             >//              ______________________________________________________________________
 561+ A4BA             >//              Heap part
 561+ A4BA             >
 561+ A4BA             >
 561+ A4BA             >                org     (Heap_Ptr & $1FFF) + $E000
 561+ E732             >
 561+ E732             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 561+ E732             >Latest_Definition defl  Heap_Ptr
 561+ E732             >
 561+ E732             >                // dummy db directives used to calculate length of namec
 561+ E732 3C 4E 41 4D >                db      "<NAME"
 561+ E736 45          >
 561+ E737             >len_NFA         defl    $ - temp_NFA
 561+ E737             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 561+ E732             >
 561+ E732 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 561+ E733 3C 4E 41 4D >                db      "<NAME"               // name string in 7-bit ascii, but
 561+ E737 45          >
 561+ E738             >                org     $-1                 // alter last byte of Name just above to set
 561+ E737 C5          >                db      {b $} | END_BIT     // msb as name end
 561+ E738             >
 561+ E738 28 07       >                dw      Prev_Ptr            // Link to previous definition Name
 561+ E73A             >Prev_Ptr        defl    Heap_Ptr
 561+ E73A             >
 561+ E73A             >mirror_Ptr      defl    $
 561+ E73A             >
 561+ E73A BC A4       >                dw      Dict_Ptr + 2        // xt
 561+ E73C             >Heap_Ptr        defl    $ - $E000           // save current HP
 561+ E73C             >
 561+ E73C             >Current_HP      defl  $ - $E000             // used to set HP once!
 561+ E73C             >
 561+ E73C             >//              ______________________________________________________________________
 561+ E73C             >//              Dictionary part
 561+ E73C             >
 561+ E73C             >                org     Dict_Ptr
 561+ A4BA             >
 561+ A4BA 3A 26       >                dw      mirror_Ptr - $E000 + $1F00
 561+ A4BC             >
 561+ A4BC             >TO_NAME:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 561+ A4BC CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 561+ A4BF             >
 561+ A4BF             >
 561+ A4BF             >                endif           ; ok        // for other definitions it "points" the correct handler
 561+ A4BF             >                // Use of "; ok" to suppress "warning[fwdref]"
 561+ A4BF             >
 561+ A4BF             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 562+ A4BF 29 A0                        dw      CELL_MINUS              // cell-
 563+ A4C1 7B A0 D9 A0                  dw      DUP, FETCH
 564+ A4C5 43 A4                        dw      QHEAPP
 565+ A4C7 45 9B                        dw      ZBRANCH
 566+ A4C9 08 00                        dw      ToName_Skip - $
 567+ A4CB D9 A0 38 A4                  dw          FETCH, FAR
 568+ A4CF 29 A0                        dw          CELL_MINUS
 569+ A4D1              ToName_Skip:                                    // endif
 570+ A4D1
 571+ A4D1 15 A0                        dw      ONE_SUBTRACT            // 1-
 572+ A4D3 ED A1                        dw      NEG_ONE                 // -1
 573+ A4D5 D2 A3                        dw      TRAVERSE                // traverse
 574+ A4D7 A2 9F                        dw      EXIT                    // ;
 575+ A4D9
 576+ A4D9              //  ______________________________________________________________________
 577+ A4D9              //
 578+ A4D9              // cfa          pfa -- cfa
 579+ A4D9                              Colon_Def CFA, "CFA", is_normal
 579+ A4D9             >                New_Def  CFA, "CFA", Enter_Ptr, is_normal ; ok
 579+ A4D9             >
 579+ A4D9             >Dict_Ptr        defl    $
 579+ A4D9             >
 579+ A4D9             >//              ______________________________________________________________________
 579+ A4D9             >//              Heap part
 579+ A4D9             >
 579+ A4D9             >
 579+ A4D9             >                org     (Heap_Ptr & $1FFF) + $E000
 579+ E73C             >
 579+ E73C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 579+ E73C             >Latest_Definition defl  Heap_Ptr
 579+ E73C             >
 579+ E73C             >                // dummy db directives used to calculate length of namec
 579+ E73C 43 46 41    >                db      "CFA"
 579+ E73F             >len_NFA         defl    $ - temp_NFA
 579+ E73F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 579+ E73C             >
 579+ E73C 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 579+ E73D 43 46 41    >                db      "CFA"               // name string in 7-bit ascii, but
 579+ E740             >                org     $-1                 // alter last byte of Name just above to set
 579+ E73F C1          >                db      {b $} | END_BIT     // msb as name end
 579+ E740             >
 579+ E740 32 07       >                dw      Prev_Ptr            // Link to previous definition Name
 579+ E742             >Prev_Ptr        defl    Heap_Ptr
 579+ E742             >
 579+ E742             >mirror_Ptr      defl    $
 579+ E742             >
 579+ E742 DB A4       >                dw      Dict_Ptr + 2        // xt
 579+ E744             >Heap_Ptr        defl    $ - $E000           // save current HP
 579+ E744             >
 579+ E744             >Current_HP      defl  $ - $E000             // used to set HP once!
 579+ E744             >
 579+ E744             >//              ______________________________________________________________________
 579+ E744             >//              Dictionary part
 579+ E744             >
 579+ E744             >                org     Dict_Ptr
 579+ A4D9             >
 579+ A4D9 42 26       >                dw      mirror_Ptr - $E000 + $1F00
 579+ A4DB             >
 579+ A4DB             >CFA:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 579+ A4DB CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 579+ A4DE             >
 579+ A4DE             >
 579+ A4DE             >                endif           ; ok        // for other definitions it "points" the correct handler
 579+ A4DE             >                // Use of "; ok" to suppress "warning[fwdref]"
 579+ A4DE             >
 579+ A4DE             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 580+ A4DE E6 A1 35 A3                  dw      THREE, SUBTRACT         // 3 -
 581+ A4E2 A2 9F                        dw      EXIT                    // ;
 582+ A4E4
 583+ A4E4              //  ______________________________________________________________________
 584+ A4E4              //
 585+ A4E4              // nfa          pfa -- nfa
 586+ A4E4                              Colon_Def NFA, "NFA", is_normal
 586+ A4E4             >                New_Def  NFA, "NFA", Enter_Ptr, is_normal ; ok
 586+ A4E4             >
 586+ A4E4             >Dict_Ptr        defl    $
 586+ A4E4             >
 586+ A4E4             >//              ______________________________________________________________________
 586+ A4E4             >//              Heap part
 586+ A4E4             >
 586+ A4E4             >
 586+ A4E4             >                org     (Heap_Ptr & $1FFF) + $E000
 586+ E744             >
 586+ E744             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 586+ E744             >Latest_Definition defl  Heap_Ptr
 586+ E744             >
 586+ E744             >                // dummy db directives used to calculate length of namec
 586+ E744 4E 46 41    >                db      "NFA"
 586+ E747             >len_NFA         defl    $ - temp_NFA
 586+ E747             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 586+ E744             >
 586+ E744 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 586+ E745 4E 46 41    >                db      "NFA"               // name string in 7-bit ascii, but
 586+ E748             >                org     $-1                 // alter last byte of Name just above to set
 586+ E747 C1          >                db      {b $} | END_BIT     // msb as name end
 586+ E748             >
 586+ E748 3C 07       >                dw      Prev_Ptr            // Link to previous definition Name
 586+ E74A             >Prev_Ptr        defl    Heap_Ptr
 586+ E74A             >
 586+ E74A             >mirror_Ptr      defl    $
 586+ E74A             >
 586+ E74A E6 A4       >                dw      Dict_Ptr + 2        // xt
 586+ E74C             >Heap_Ptr        defl    $ - $E000           // save current HP
 586+ E74C             >
 586+ E74C             >Current_HP      defl  $ - $E000             // used to set HP once!
 586+ E74C             >
 586+ E74C             >//              ______________________________________________________________________
 586+ E74C             >//              Dictionary part
 586+ E74C             >
 586+ E74C             >                org     Dict_Ptr
 586+ A4E4             >
 586+ A4E4 4A 26       >                dw      mirror_Ptr - $E000 + $1F00
 586+ A4E6             >
 586+ A4E6             >NFA:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 586+ A4E6 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 586+ A4E9             >
 586+ A4E9             >
 586+ A4E9             >                endif           ; ok        // for other definitions it "points" the correct handler
 586+ A4E9             >                // Use of "; ok" to suppress "warning[fwdref]"
 586+ A4E9             >
 586+ A4E9             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 587+ A4E9 DB A4                        dw      CFA                     // cfa
 588+ A4EB BC A4                        dw      TO_NAME                 // traverse
 589+ A4ED A2 9F                        dw      EXIT                    // ;
 590+ A4EF
 591+ A4EF              //  ______________________________________________________________________
 592+ A4EF              //
 593+ A4EF              // lfa          pfa -- lfa
 594+ A4EF                              Colon_Def LFA, "LFA", is_normal
 594+ A4EF             >                New_Def  LFA, "LFA", Enter_Ptr, is_normal ; ok
 594+ A4EF             >
 594+ A4EF             >Dict_Ptr        defl    $
 594+ A4EF             >
 594+ A4EF             >//              ______________________________________________________________________
 594+ A4EF             >//              Heap part
 594+ A4EF             >
 594+ A4EF             >
 594+ A4EF             >                org     (Heap_Ptr & $1FFF) + $E000
 594+ E74C             >
 594+ E74C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 594+ E74C             >Latest_Definition defl  Heap_Ptr
 594+ E74C             >
 594+ E74C             >                // dummy db directives used to calculate length of namec
 594+ E74C 4C 46 41    >                db      "LFA"
 594+ E74F             >len_NFA         defl    $ - temp_NFA
 594+ E74F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 594+ E74C             >
 594+ E74C 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 594+ E74D 4C 46 41    >                db      "LFA"               // name string in 7-bit ascii, but
 594+ E750             >                org     $-1                 // alter last byte of Name just above to set
 594+ E74F C1          >                db      {b $} | END_BIT     // msb as name end
 594+ E750             >
 594+ E750 44 07       >                dw      Prev_Ptr            // Link to previous definition Name
 594+ E752             >Prev_Ptr        defl    Heap_Ptr
 594+ E752             >
 594+ E752             >mirror_Ptr      defl    $
 594+ E752             >
 594+ E752 F1 A4       >                dw      Dict_Ptr + 2        // xt
 594+ E754             >Heap_Ptr        defl    $ - $E000           // save current HP
 594+ E754             >
 594+ E754             >Current_HP      defl  $ - $E000             // used to set HP once!
 594+ E754             >
 594+ E754             >//              ______________________________________________________________________
 594+ E754             >//              Dictionary part
 594+ E754             >
 594+ E754             >                org     Dict_Ptr
 594+ A4EF             >
 594+ A4EF 52 26       >                dw      mirror_Ptr - $E000 + $1F00
 594+ A4F1             >
 594+ A4F1             >LFA:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 594+ A4F1 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 594+ A4F4             >
 594+ A4F4             >
 594+ A4F4             >                endif           ; ok        // for other definitions it "points" the correct handler
 594+ A4F4             >                // Use of "; ok" to suppress "warning[fwdref]"
 594+ A4F4             >
 594+ A4F4             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 595+ A4F4 E6 A4                        dw      NFA                     // nfa
 596+ A4F6 D8 A1                        dw      ONE                     // 1
 597+ A4F8 D2 A3                        dw      TRAVERSE                // traverse
 598+ A4FA 0E A0                        dw      ONE_PLUS                // 1+
 599+ A4FC A2 9F                        dw      EXIT                    // ;
 600+ A4FE
 601+ A4FE              //  ______________________________________________________________________
 602+ A4FE              //
 603+ A4FE              // pfa          nfa -- pfa
 604+ A4FE                              Colon_Def PFA, "PFA", is_normal
 604+ A4FE             >                New_Def  PFA, "PFA", Enter_Ptr, is_normal ; ok
 604+ A4FE             >
 604+ A4FE             >Dict_Ptr        defl    $
 604+ A4FE             >
 604+ A4FE             >//              ______________________________________________________________________
 604+ A4FE             >//              Heap part
 604+ A4FE             >
 604+ A4FE             >
 604+ A4FE             >                org     (Heap_Ptr & $1FFF) + $E000
 604+ E754             >
 604+ E754             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 604+ E754             >Latest_Definition defl  Heap_Ptr
 604+ E754             >
 604+ E754             >                // dummy db directives used to calculate length of namec
 604+ E754 50 46 41    >                db      "PFA"
 604+ E757             >len_NFA         defl    $ - temp_NFA
 604+ E757             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 604+ E754             >
 604+ E754 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 604+ E755 50 46 41    >                db      "PFA"               // name string in 7-bit ascii, but
 604+ E758             >                org     $-1                 // alter last byte of Name just above to set
 604+ E757 C1          >                db      {b $} | END_BIT     // msb as name end
 604+ E758             >
 604+ E758 4C 07       >                dw      Prev_Ptr            // Link to previous definition Name
 604+ E75A             >Prev_Ptr        defl    Heap_Ptr
 604+ E75A             >
 604+ E75A             >mirror_Ptr      defl    $
 604+ E75A             >
 604+ E75A 00 A5       >                dw      Dict_Ptr + 2        // xt
 604+ E75C             >Heap_Ptr        defl    $ - $E000           // save current HP
 604+ E75C             >
 604+ E75C             >Current_HP      defl  $ - $E000             // used to set HP once!
 604+ E75C             >
 604+ E75C             >//              ______________________________________________________________________
 604+ E75C             >//              Dictionary part
 604+ E75C             >
 604+ E75C             >                org     Dict_Ptr
 604+ A4FE             >
 604+ A4FE 5A 26       >                dw      mirror_Ptr - $E000 + $1F00
 604+ A500             >
 604+ A500             >PFA:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 604+ A500 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 604+ A503             >
 604+ A503             >
 604+ A503             >                endif           ; ok        // for other definitions it "points" the correct handler
 604+ A503             >                // Use of "; ok" to suppress "warning[fwdref]"
 604+ A503             >
 604+ A503             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 605+ A503 56 A4                        dw      QTOHEAP
 606+ A505 D8 A1                        dw      ONE                     // 1
 607+ A507 D2 A3                        dw      TRAVERSE                // traverse
 608+ A509 0E A0                        dw      ONE_PLUS                // 1+
 609+ A50B 24 A0                        dw      CELL_PLUS               // cell+
 610+ A50D 27 A4                        dw      QMMU7
 611+ A50F 45 9B                        dw      ZBRANCH
 612+ A511 0E 00                        dw      PFA_Skip - $
 613+ A513 EF A3                        dw          MMU7_FETCH
 614+ A515 D8 A1 35 A3                  dw          ONE, SUBTRACT
 615+ A519 45 9B                        dw          ZBRANCH
 616+ A51B 04 00                        dw          PFA_Skip - $
 617+ A51D D9 A0                        dw              FETCH
 618+ A51F              PFA_Skip:                                    // endif
 619+ A51F B1 A4                        dw      TO_BODY                 // >body
 620+ A521 A2 9F                        dw      EXIT                    // ;
 621+ A523
 622+ A523              //  ______________________________________________________________________
 623+ A523              //
 624+ A523              // !csp         --
 625+ A523              // store in user variable CSP current value of SP. Used at compile-time for syntax checkng
 626+ A523                              Colon_Def STORE_CSP, "!CSP", is_normal
 626+ A523             >                New_Def  STORE_CSP, "!CSP", Enter_Ptr, is_normal ; ok
 626+ A523             >
 626+ A523             >Dict_Ptr        defl    $
 626+ A523             >
 626+ A523             >//              ______________________________________________________________________
 626+ A523             >//              Heap part
 626+ A523             >
 626+ A523             >
 626+ A523             >                org     (Heap_Ptr & $1FFF) + $E000
 626+ E75C             >
 626+ E75C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 626+ E75C             >Latest_Definition defl  Heap_Ptr
 626+ E75C             >
 626+ E75C             >                // dummy db directives used to calculate length of namec
 626+ E75C 21 43 53 50 >                db      "!CSP"
 626+ E760             >len_NFA         defl    $ - temp_NFA
 626+ E760             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 626+ E75C             >
 626+ E75C 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 626+ E75D 21 43 53 50 >                db      "!CSP"               // name string in 7-bit ascii, but
 626+ E761             >                org     $-1                 // alter last byte of Name just above to set
 626+ E760 D0          >                db      {b $} | END_BIT     // msb as name end
 626+ E761             >
 626+ E761 54 07       >                dw      Prev_Ptr            // Link to previous definition Name
 626+ E763             >Prev_Ptr        defl    Heap_Ptr
 626+ E763             >
 626+ E763             >mirror_Ptr      defl    $
 626+ E763             >
 626+ E763 25 A5       >                dw      Dict_Ptr + 2        // xt
 626+ E765             >Heap_Ptr        defl    $ - $E000           // save current HP
 626+ E765             >
 626+ E765             >Current_HP      defl  $ - $E000             // used to set HP once!
 626+ E765             >
 626+ E765             >//              ______________________________________________________________________
 626+ E765             >//              Dictionary part
 626+ E765             >
 626+ E765             >                org     Dict_Ptr
 626+ A523             >
 626+ A523 63 26       >                dw      mirror_Ptr - $E000 + $1F00
 626+ A525             >
 626+ A525             >STORE_CSP:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 626+ A525 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 626+ A528             >
 626+ A528             >
 626+ A528             >                endif           ; ok        // for other definitions it "points" the correct handler
 626+ A528             >                // Use of "; ok" to suppress "warning[fwdref]"
 626+ A528             >
 626+ A528             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 627+ A528 89 9F                        dw      SPFETCH                 // sp@
 628+ A52A B4 A2 E3 A0                  dw      CSP, STORE              // csp !
 629+ A52E A2 9F                        dw      EXIT                    // ;
 630+ A530
 631+ A530              //  ______________________________________________________________________
 632+ A530              //
 633+ A530              // ?error       f n --
 634+ A530              // rase error n if flag f it true
 635+ A530                              Colon_Def QERROR, "?ERROR", is_normal
 635+ A530             >                New_Def  QERROR, "?ERROR", Enter_Ptr, is_normal ; ok
 635+ A530             >
 635+ A530             >Dict_Ptr        defl    $
 635+ A530             >
 635+ A530             >//              ______________________________________________________________________
 635+ A530             >//              Heap part
 635+ A530             >
 635+ A530             >
 635+ A530             >                org     (Heap_Ptr & $1FFF) + $E000
 635+ E765             >
 635+ E765             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 635+ E765             >Latest_Definition defl  Heap_Ptr
 635+ E765             >
 635+ E765             >                // dummy db directives used to calculate length of namec
 635+ E765 3F 45 52 52 >                db      "?ERROR"
 635+ E769 4F 52       >
 635+ E76B             >len_NFA         defl    $ - temp_NFA
 635+ E76B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 635+ E765             >
 635+ E765 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 635+ E766 3F 45 52 52 >                db      "?ERROR"               // name string in 7-bit ascii, but
 635+ E76A 4F 52       >
 635+ E76C             >                org     $-1                 // alter last byte of Name just above to set
 635+ E76B D2          >                db      {b $} | END_BIT     // msb as name end
 635+ E76C             >
 635+ E76C 5C 07       >                dw      Prev_Ptr            // Link to previous definition Name
 635+ E76E             >Prev_Ptr        defl    Heap_Ptr
 635+ E76E             >
 635+ E76E             >mirror_Ptr      defl    $
 635+ E76E             >
 635+ E76E 32 A5       >                dw      Dict_Ptr + 2        // xt
 635+ E770             >Heap_Ptr        defl    $ - $E000           // save current HP
 635+ E770             >
 635+ E770             >Current_HP      defl  $ - $E000             // used to set HP once!
 635+ E770             >
 635+ E770             >//              ______________________________________________________________________
 635+ E770             >//              Dictionary part
 635+ E770             >
 635+ E770             >                org     Dict_Ptr
 635+ A530             >
 635+ A530 6E 26       >                dw      mirror_Ptr - $E000 + $1F00
 635+ A532             >
 635+ A532             >QERROR:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 635+ A532 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 635+ A535             >
 635+ A535             >
 635+ A535             >                endif           ; ok        // for other definitions it "points" the correct handler
 635+ A535             >                // Use of "; ok" to suppress "warning[fwdref]"
 635+ A535             >
 635+ A535             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 636+ A535 74 A0                        dw      SWAP                    // swap
 637+ A537                                                              // if
 638+ A537 45 9B                        dw      ZBRANCH
 639+ A539 08 00                        dw      QError_Else - $
 640+ A53B DD A9                        dw          ERROR               //      error  ( is a forward-ref )
 641+ A53D                                                              // else
 642+ A53D 38 9B                        dw      BRANCH
 643+ A53F 04 00                        dw      QError_Endif - $
 644+ A541              QError_Else:
 645+ A541 60 A0                        dw          DROP                //      drop
 646+ A543              QError_Endif:                                   // endif
 647+ A543 A2 9F                        dw      EXIT                    // ;
 648+ A545
 649+ A545              //  ______________________________________________________________________
 650+ A545              //
 651+ A545              // ?comp       --
 652+ A545              // raise msg #17 if not compiling
 653+ A545                              Colon_Def QCOMP, "?COMP", is_normal
 653+ A545             >                New_Def  QCOMP, "?COMP", Enter_Ptr, is_normal ; ok
 653+ A545             >
 653+ A545             >Dict_Ptr        defl    $
 653+ A545             >
 653+ A545             >//              ______________________________________________________________________
 653+ A545             >//              Heap part
 653+ A545             >
 653+ A545             >
 653+ A545             >                org     (Heap_Ptr & $1FFF) + $E000
 653+ E770             >
 653+ E770             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 653+ E770             >Latest_Definition defl  Heap_Ptr
 653+ E770             >
 653+ E770             >                // dummy db directives used to calculate length of namec
 653+ E770 3F 43 4F 4D >                db      "?COMP"
 653+ E774 50          >
 653+ E775             >len_NFA         defl    $ - temp_NFA
 653+ E775             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 653+ E770             >
 653+ E770 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 653+ E771 3F 43 4F 4D >                db      "?COMP"               // name string in 7-bit ascii, but
 653+ E775 50          >
 653+ E776             >                org     $-1                 // alter last byte of Name just above to set
 653+ E775 D0          >                db      {b $} | END_BIT     // msb as name end
 653+ E776             >
 653+ E776 65 07       >                dw      Prev_Ptr            // Link to previous definition Name
 653+ E778             >Prev_Ptr        defl    Heap_Ptr
 653+ E778             >
 653+ E778             >mirror_Ptr      defl    $
 653+ E778             >
 653+ E778 47 A5       >                dw      Dict_Ptr + 2        // xt
 653+ E77A             >Heap_Ptr        defl    $ - $E000           // save current HP
 653+ E77A             >
 653+ E77A             >Current_HP      defl  $ - $E000             // used to set HP once!
 653+ E77A             >
 653+ E77A             >//              ______________________________________________________________________
 653+ E77A             >//              Dictionary part
 653+ E77A             >
 653+ E77A             >                org     Dict_Ptr
 653+ A545             >
 653+ A545 78 26       >                dw      mirror_Ptr - $E000 + $1F00
 653+ A547             >
 653+ A547             >QCOMP:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 653+ A547 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 653+ A54A             >
 653+ A54A             >
 653+ A54A             >                endif           ; ok        // for other definitions it "points" the correct handler
 653+ A54A             >                // Use of "; ok" to suppress "warning[fwdref]"
 653+ A54A             >
 653+ A54A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 654+ A54A 9C A2 D9 A0                  dw      STATE, FETCH            // state @
 655+ A54E C7 9F                        dw      ZEQUAL                  // 0=
 656+ A550 F3 9A 11 00                  dw      LIT, 17                 // 17  ( can't be executed )
 657+ A554 32 A5                        dw      QERROR                  // ?error
 658+ A556 A2 9F                        dw      EXIT                    // ;
 659+ A558
 660+ A558              //  ______________________________________________________________________
 661+ A558              //
 662+ A558              // ?exec       --
 663+ A558              // raise msg #18 if compiling
 664+ A558                              Colon_Def QEXEC, "?EXEC", is_normal
 664+ A558             >                New_Def  QEXEC, "?EXEC", Enter_Ptr, is_normal ; ok
 664+ A558             >
 664+ A558             >Dict_Ptr        defl    $
 664+ A558             >
 664+ A558             >//              ______________________________________________________________________
 664+ A558             >//              Heap part
 664+ A558             >
 664+ A558             >
 664+ A558             >                org     (Heap_Ptr & $1FFF) + $E000
 664+ E77A             >
 664+ E77A             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 664+ E77A             >Latest_Definition defl  Heap_Ptr
 664+ E77A             >
 664+ E77A             >                // dummy db directives used to calculate length of namec
 664+ E77A 3F 45 58 45 >                db      "?EXEC"
 664+ E77E 43          >
 664+ E77F             >len_NFA         defl    $ - temp_NFA
 664+ E77F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 664+ E77A             >
 664+ E77A 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 664+ E77B 3F 45 58 45 >                db      "?EXEC"               // name string in 7-bit ascii, but
 664+ E77F 43          >
 664+ E780             >                org     $-1                 // alter last byte of Name just above to set
 664+ E77F C3          >                db      {b $} | END_BIT     // msb as name end
 664+ E780             >
 664+ E780 70 07       >                dw      Prev_Ptr            // Link to previous definition Name
 664+ E782             >Prev_Ptr        defl    Heap_Ptr
 664+ E782             >
 664+ E782             >mirror_Ptr      defl    $
 664+ E782             >
 664+ E782 5A A5       >                dw      Dict_Ptr + 2        // xt
 664+ E784             >Heap_Ptr        defl    $ - $E000           // save current HP
 664+ E784             >
 664+ E784             >Current_HP      defl  $ - $E000             // used to set HP once!
 664+ E784             >
 664+ E784             >//              ______________________________________________________________________
 664+ E784             >//              Dictionary part
 664+ E784             >
 664+ E784             >                org     Dict_Ptr
 664+ A558             >
 664+ A558 82 26       >                dw      mirror_Ptr - $E000 + $1F00
 664+ A55A             >
 664+ A55A             >QEXEC:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 664+ A55A CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 664+ A55D             >
 664+ A55D             >
 664+ A55D             >                endif           ; ok        // for other definitions it "points" the correct handler
 664+ A55D             >                // Use of "; ok" to suppress "warning[fwdref]"
 664+ A55D             >
 664+ A55D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 665+ A55D 9C A2 D9 A0                  dw      STATE, FETCH            // state @
 666+ A561 F3 9A 12 00                  dw      LIT, 18                 // 18  ( can't be compiled )
 667+ A565 32 A5                        dw      QERROR                  // ?error
 668+ A567 A2 9F                        dw      EXIT                    // ;
 669+ A569
 670+ A569              //  ______________________________________________________________________
 671+ A569              //
 672+ A569              // ?pairs       n1 n2 --
 673+ A569              // raise msg #19 if n1 != n2. Compiler pushes some placeholder to stack for syntax checking
 674+ A569                              Colon_Def QPAIRS, "?PAIRS", is_normal
 674+ A569             >                New_Def  QPAIRS, "?PAIRS", Enter_Ptr, is_normal ; ok
 674+ A569             >
 674+ A569             >Dict_Ptr        defl    $
 674+ A569             >
 674+ A569             >//              ______________________________________________________________________
 674+ A569             >//              Heap part
 674+ A569             >
 674+ A569             >
 674+ A569             >                org     (Heap_Ptr & $1FFF) + $E000
 674+ E784             >
 674+ E784             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 674+ E784             >Latest_Definition defl  Heap_Ptr
 674+ E784             >
 674+ E784             >                // dummy db directives used to calculate length of namec
 674+ E784 3F 50 41 49 >                db      "?PAIRS"
 674+ E788 52 53       >
 674+ E78A             >len_NFA         defl    $ - temp_NFA
 674+ E78A             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 674+ E784             >
 674+ E784 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 674+ E785 3F 50 41 49 >                db      "?PAIRS"               // name string in 7-bit ascii, but
 674+ E789 52 53       >
 674+ E78B             >                org     $-1                 // alter last byte of Name just above to set
 674+ E78A D3          >                db      {b $} | END_BIT     // msb as name end
 674+ E78B             >
 674+ E78B 7A 07       >                dw      Prev_Ptr            // Link to previous definition Name
 674+ E78D             >Prev_Ptr        defl    Heap_Ptr
 674+ E78D             >
 674+ E78D             >mirror_Ptr      defl    $
 674+ E78D             >
 674+ E78D 6B A5       >                dw      Dict_Ptr + 2        // xt
 674+ E78F             >Heap_Ptr        defl    $ - $E000           // save current HP
 674+ E78F             >
 674+ E78F             >Current_HP      defl  $ - $E000             // used to set HP once!
 674+ E78F             >
 674+ E78F             >//              ______________________________________________________________________
 674+ E78F             >//              Dictionary part
 674+ E78F             >
 674+ E78F             >                org     Dict_Ptr
 674+ A569             >
 674+ A569 8D 26       >                dw      mirror_Ptr - $E000 + $1F00
 674+ A56B             >
 674+ A56B             >QPAIRS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 674+ A56B CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 674+ A56E             >
 674+ A56E             >
 674+ A56E             >                endif           ; ok        // for other definitions it "points" the correct handler
 674+ A56E             >                // Use of "; ok" to suppress "warning[fwdref]"
 674+ A56E             >
 674+ A56E             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 675+ A56E 35 A3                        dw      SUBTRACT                // -
 676+ A570 F3 9A 13 00                  dw      LIT, 19                 // 18  ( syntax error )
 677+ A574 32 A5                        dw      QERROR                  // ?error
 678+ A576 A2 9F                        dw      EXIT                    // ;
 679+ A578
 680+ A578              //  ______________________________________________________________________
 681+ A578              //
 682+ A578              // ?csp       --
 683+ A578              // raise msg #20 if surrent SP in not what previously saved in CSP.
 684+ A578              // Compiler relies on that for  syntax checking of structures
 685+ A578                              Colon_Def QCSP, "?CSP", is_normal
 685+ A578             >                New_Def  QCSP, "?CSP", Enter_Ptr, is_normal ; ok
 685+ A578             >
 685+ A578             >Dict_Ptr        defl    $
 685+ A578             >
 685+ A578             >//              ______________________________________________________________________
 685+ A578             >//              Heap part
 685+ A578             >
 685+ A578             >
 685+ A578             >                org     (Heap_Ptr & $1FFF) + $E000
 685+ E78F             >
 685+ E78F             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 685+ E78F             >Latest_Definition defl  Heap_Ptr
 685+ E78F             >
 685+ E78F             >                // dummy db directives used to calculate length of namec
 685+ E78F 3F 43 53 50 >                db      "?CSP"
 685+ E793             >len_NFA         defl    $ - temp_NFA
 685+ E793             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 685+ E78F             >
 685+ E78F 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 685+ E790 3F 43 53 50 >                db      "?CSP"               // name string in 7-bit ascii, but
 685+ E794             >                org     $-1                 // alter last byte of Name just above to set
 685+ E793 D0          >                db      {b $} | END_BIT     // msb as name end
 685+ E794             >
 685+ E794 84 07       >                dw      Prev_Ptr            // Link to previous definition Name
 685+ E796             >Prev_Ptr        defl    Heap_Ptr
 685+ E796             >
 685+ E796             >mirror_Ptr      defl    $
 685+ E796             >
 685+ E796 7A A5       >                dw      Dict_Ptr + 2        // xt
 685+ E798             >Heap_Ptr        defl    $ - $E000           // save current HP
 685+ E798             >
 685+ E798             >Current_HP      defl  $ - $E000             // used to set HP once!
 685+ E798             >
 685+ E798             >//              ______________________________________________________________________
 685+ E798             >//              Dictionary part
 685+ E798             >
 685+ E798             >                org     Dict_Ptr
 685+ A578             >
 685+ A578 96 26       >                dw      mirror_Ptr - $E000 + $1F00
 685+ A57A             >
 685+ A57A             >QCSP:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 685+ A57A CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 685+ A57D             >
 685+ A57D             >
 685+ A57D             >                endif           ; ok        // for other definitions it "points" the correct handler
 685+ A57D             >                // Use of "; ok" to suppress "warning[fwdref]"
 685+ A57D             >
 685+ A57D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 686+ A57D 89 9F                        dw      SPFETCH                 // sp@
 687+ A57F B4 A2 D9 A0                  dw      CSP, FETCH              // csp @
 688+ A583 35 A3                        dw      SUBTRACT                // -
 689+ A585 F3 9A 14 00                  dw      LIT, 20                 // 20  ( bad definition end )
 690+ A589 32 A5                        dw      QERROR                  // ?error
 691+ A58B A2 9F                        dw      EXIT                    // ;
 692+ A58D
 693+ A58D              //  ______________________________________________________________________
 694+ A58D              //
 695+ A58D              // ?loading      --
 696+ A58D              // raise msg #22 if not loading
 697+ A58D                              Colon_Def QLOADING, "?LOADING", is_normal
 697+ A58D             >                New_Def  QLOADING, "?LOADING", Enter_Ptr, is_normal ; ok
 697+ A58D             >
 697+ A58D             >Dict_Ptr        defl    $
 697+ A58D             >
 697+ A58D             >//              ______________________________________________________________________
 697+ A58D             >//              Heap part
 697+ A58D             >
 697+ A58D             >
 697+ A58D             >                org     (Heap_Ptr & $1FFF) + $E000
 697+ E798             >
 697+ E798             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 697+ E798             >Latest_Definition defl  Heap_Ptr
 697+ E798             >
 697+ E798             >                // dummy db directives used to calculate length of namec
 697+ E798 3F 4C 4F 41 >                db      "?LOADING"
 697+ E79C 44 49 4E 47 >
 697+ E7A0             >len_NFA         defl    $ - temp_NFA
 697+ E7A0             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 697+ E798             >
 697+ E798 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 697+ E799 3F 4C 4F 41 >                db      "?LOADING"               // name string in 7-bit ascii, but
 697+ E79D 44 49 4E 47 >
 697+ E7A1             >                org     $-1                 // alter last byte of Name just above to set
 697+ E7A0 C7          >                db      {b $} | END_BIT     // msb as name end
 697+ E7A1             >
 697+ E7A1 8F 07       >                dw      Prev_Ptr            // Link to previous definition Name
 697+ E7A3             >Prev_Ptr        defl    Heap_Ptr
 697+ E7A3             >
 697+ E7A3             >mirror_Ptr      defl    $
 697+ E7A3             >
 697+ E7A3 8F A5       >                dw      Dict_Ptr + 2        // xt
 697+ E7A5             >Heap_Ptr        defl    $ - $E000           // save current HP
 697+ E7A5             >
 697+ E7A5             >Current_HP      defl  $ - $E000             // used to set HP once!
 697+ E7A5             >
 697+ E7A5             >//              ______________________________________________________________________
 697+ E7A5             >//              Dictionary part
 697+ E7A5             >
 697+ E7A5             >                org     Dict_Ptr
 697+ A58D             >
 697+ A58D A3 26       >                dw      mirror_Ptr - $E000 + $1F00
 697+ A58F             >
 697+ A58F             >QLOADING:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 697+ A58F CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 697+ A592             >
 697+ A592             >
 697+ A592             >                endif           ; ok        // for other definitions it "points" the correct handler
 697+ A592             >                // Use of "; ok" to suppress "warning[fwdref]"
 697+ A592             >
 697+ A592             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 698+ A592 72 A2 D9 A0                  dw      BLK, FETCH              // blk @
 699+ A596 C7 9F                        dw      ZEQUAL                  // 0=
 700+ A598 F3 9A 16 00                  dw      LIT, 22                 // 22  ( aren't loading now )
 701+ A59C 32 A5                        dw      QERROR                  // ?error
 702+ A59E A2 9F                        dw      EXIT                    // ;
 703+ A5A0
 704+ A5A0              //  ______________________________________________________________________
 705+ A5A0              //
 706+ A5A0              // compile      --
 707+ A5A0              // compiles the following word
 708+ A5A0                              Colon_Def COMPILE, "COMPILE", is_normal
 708+ A5A0             >                New_Def  COMPILE, "COMPILE", Enter_Ptr, is_normal ; ok
 708+ A5A0             >
 708+ A5A0             >Dict_Ptr        defl    $
 708+ A5A0             >
 708+ A5A0             >//              ______________________________________________________________________
 708+ A5A0             >//              Heap part
 708+ A5A0             >
 708+ A5A0             >
 708+ A5A0             >                org     (Heap_Ptr & $1FFF) + $E000
 708+ E7A5             >
 708+ E7A5             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 708+ E7A5             >Latest_Definition defl  Heap_Ptr
 708+ E7A5             >
 708+ E7A5             >                // dummy db directives used to calculate length of namec
 708+ E7A5 43 4F 4D 50 >                db      "COMPILE"
 708+ E7A9 49 4C 45    >
 708+ E7AC             >len_NFA         defl    $ - temp_NFA
 708+ E7AC             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 708+ E7A5             >
 708+ E7A5 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 708+ E7A6 43 4F 4D 50 >                db      "COMPILE"               // name string in 7-bit ascii, but
 708+ E7AA 49 4C 45    >
 708+ E7AD             >                org     $-1                 // alter last byte of Name just above to set
 708+ E7AC C5          >                db      {b $} | END_BIT     // msb as name end
 708+ E7AD             >
 708+ E7AD 98 07       >                dw      Prev_Ptr            // Link to previous definition Name
 708+ E7AF             >Prev_Ptr        defl    Heap_Ptr
 708+ E7AF             >
 708+ E7AF             >mirror_Ptr      defl    $
 708+ E7AF             >
 708+ E7AF A2 A5       >                dw      Dict_Ptr + 2        // xt
 708+ E7B1             >Heap_Ptr        defl    $ - $E000           // save current HP
 708+ E7B1             >
 708+ E7B1             >Current_HP      defl  $ - $E000             // used to set HP once!
 708+ E7B1             >
 708+ E7B1             >//              ______________________________________________________________________
 708+ E7B1             >//              Dictionary part
 708+ E7B1             >
 708+ E7B1             >                org     Dict_Ptr
 708+ A5A0             >
 708+ A5A0 AF 26       >                dw      mirror_Ptr - $E000 + $1F00
 708+ A5A2             >
 708+ A5A2             >COMPILE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 708+ A5A2 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 708+ A5A5             >
 708+ A5A5             >
 708+ A5A5             >                endif           ; ok        // for other definitions it "points" the correct handler
 708+ A5A5             >                // Use of "; ok" to suppress "warning[fwdref]"
 708+ A5A5             >
 708+ A5A5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 709+ A5A5 47 A5                        dw      QCOMP                   // ?comp
 710+ A5A7 B7 9F                        dw      R_TO                    // r>
 711+ A5A9 7B A0 24 A0                  dw      DUP, CELL_PLUS          // dup, cell+
 712+ A5AD AC 9F                        dw      TO_R                    // >r
 713+ A5AF D9 A0 0C A3                  dw      FETCH, COMMA            // @ ,
 714+ A5B3 A2 9F                        dw      EXIT                    // ;
 715+ A5B5
 716+ A5B5              //  ______________________________________________________________________
 717+ A5B5              //
 718+ A5B5              // compile,     --
 719+ A5B5              // compiles the following word
 720+ A5B5                              Colon_Def COMPILE_XT, "COMPILE,", is_normal
 720+ A5B5             >                New_Def  COMPILE_XT, "COMPILE,", Enter_Ptr, is_normal ; ok
 720+ A5B5             >
 720+ A5B5             >Dict_Ptr        defl    $
 720+ A5B5             >
 720+ A5B5             >//              ______________________________________________________________________
 720+ A5B5             >//              Heap part
 720+ A5B5             >
 720+ A5B5             >
 720+ A5B5             >                org     (Heap_Ptr & $1FFF) + $E000
 720+ E7B1             >
 720+ E7B1             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 720+ E7B1             >Latest_Definition defl  Heap_Ptr
 720+ E7B1             >
 720+ E7B1             >                // dummy db directives used to calculate length of namec
 720+ E7B1 43 4F 4D 50 >                db      "COMPILE,"
 720+ E7B5 49 4C 45 2C >
 720+ E7B9             >len_NFA         defl    $ - temp_NFA
 720+ E7B9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 720+ E7B1             >
 720+ E7B1 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 720+ E7B2 43 4F 4D 50 >                db      "COMPILE,"               // name string in 7-bit ascii, but
 720+ E7B6 49 4C 45 2C >
 720+ E7BA             >                org     $-1                 // alter last byte of Name just above to set
 720+ E7B9 AC          >                db      {b $} | END_BIT     // msb as name end
 720+ E7BA             >
 720+ E7BA A5 07       >                dw      Prev_Ptr            // Link to previous definition Name
 720+ E7BC             >Prev_Ptr        defl    Heap_Ptr
 720+ E7BC             >
 720+ E7BC             >mirror_Ptr      defl    $
 720+ E7BC             >
 720+ E7BC B7 A5       >                dw      Dict_Ptr + 2        // xt
 720+ E7BE             >Heap_Ptr        defl    $ - $E000           // save current HP
 720+ E7BE             >
 720+ E7BE             >Current_HP      defl  $ - $E000             // used to set HP once!
 720+ E7BE             >
 720+ E7BE             >//              ______________________________________________________________________
 720+ E7BE             >//              Dictionary part
 720+ E7BE             >
 720+ E7BE             >                org     Dict_Ptr
 720+ A5B5             >
 720+ A5B5 BC 26       >                dw      mirror_Ptr - $E000 + $1F00
 720+ A5B7             >
 720+ A5B7             >COMPILE_XT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 720+ A5B7 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 720+ A5BA             >
 720+ A5BA             >
 720+ A5BA             >                endif           ; ok        // for other definitions it "points" the correct handler
 720+ A5BA             >                // Use of "; ok" to suppress "warning[fwdref]"
 720+ A5BA             >
 720+ A5BA             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 721+ A5BA 47 A5                        dw      QCOMP                   // ?comp
 722+ A5BC 0C A3                        dw      COMMA                   // ,
 723+ A5BE A2 9F                        dw      EXIT                    // ;
 724+ A5C0
 725+ A5C0              //  ______________________________________________________________________
 726+ A5C0              //
 727+ A5C0              // [            --
 728+ A5C0              // stop compilation
 729+ A5C0                              Colon_Def SQUARED_OPEN, "[", is_immediate
 729+ A5C0             >                New_Def  SQUARED_OPEN, "[", Enter_Ptr, is_immediate ; ok
 729+ A5C0             >
 729+ A5C0             >Dict_Ptr        defl    $
 729+ A5C0             >
 729+ A5C0             >//              ______________________________________________________________________
 729+ A5C0             >//              Heap part
 729+ A5C0             >
 729+ A5C0             >
 729+ A5C0             >                org     (Heap_Ptr & $1FFF) + $E000
 729+ E7BE             >
 729+ E7BE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 729+ E7BE             >Latest_Definition defl  Heap_Ptr
 729+ E7BE             >
 729+ E7BE             >                // dummy db directives used to calculate length of namec
 729+ E7BE 5B          >                db      "["
 729+ E7BF             >len_NFA         defl    $ - temp_NFA
 729+ E7BF             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 729+ E7BE             >
 729+ E7BE C1          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 729+ E7BF 5B          >                db      "["               // name string in 7-bit ascii, but
 729+ E7C0             >                org     $-1                 // alter last byte of Name just above to set
 729+ E7BF DB          >                db      {b $} | END_BIT     // msb as name end
 729+ E7C0             >
 729+ E7C0 B1 07       >                dw      Prev_Ptr            // Link to previous definition Name
 729+ E7C2             >Prev_Ptr        defl    Heap_Ptr
 729+ E7C2             >
 729+ E7C2             >mirror_Ptr      defl    $
 729+ E7C2             >
 729+ E7C2 C2 A5       >                dw      Dict_Ptr + 2        // xt
 729+ E7C4             >Heap_Ptr        defl    $ - $E000           // save current HP
 729+ E7C4             >
 729+ E7C4             >Current_HP      defl  $ - $E000             // used to set HP once!
 729+ E7C4             >
 729+ E7C4             >//              ______________________________________________________________________
 729+ E7C4             >//              Dictionary part
 729+ E7C4             >
 729+ E7C4             >                org     Dict_Ptr
 729+ A5C0             >
 729+ A5C0 C2 26       >                dw      mirror_Ptr - $E000 + $1F00
 729+ A5C2             >
 729+ A5C2             >SQUARED_OPEN:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 729+ A5C2 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 729+ A5C5             >
 729+ A5C5             >
 729+ A5C5             >                endif           ; ok        // for other definitions it "points" the correct handler
 729+ A5C5             >                // Use of "; ok" to suppress "warning[fwdref]"
 729+ A5C5             >
 729+ A5C5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 730+ A5C5 D1 A1                        dw      ZERO                    // 0
 731+ A5C7 9C A2 E3 A0                  dw      STATE, STORE            // state !
 732+ A5CB A2 9F                        dw      EXIT                    // ; immediate
 733+ A5CD
 734+ A5CD              //  ______________________________________________________________________
 735+ A5CD              //
 736+ A5CD              // ]            --
 737+ A5CD              // start compilation
 738+ A5CD                              Colon_Def SQUARED_CLOSE, "]", is_normal
 738+ A5CD             >                New_Def  SQUARED_CLOSE, "]", Enter_Ptr, is_normal ; ok
 738+ A5CD             >
 738+ A5CD             >Dict_Ptr        defl    $
 738+ A5CD             >
 738+ A5CD             >//              ______________________________________________________________________
 738+ A5CD             >//              Heap part
 738+ A5CD             >
 738+ A5CD             >
 738+ A5CD             >                org     (Heap_Ptr & $1FFF) + $E000
 738+ E7C4             >
 738+ E7C4             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 738+ E7C4             >Latest_Definition defl  Heap_Ptr
 738+ E7C4             >
 738+ E7C4             >                // dummy db directives used to calculate length of namec
 738+ E7C4 5D          >                db      "]"
 738+ E7C5             >len_NFA         defl    $ - temp_NFA
 738+ E7C5             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 738+ E7C4             >
 738+ E7C4 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 738+ E7C5 5D          >                db      "]"               // name string in 7-bit ascii, but
 738+ E7C6             >                org     $-1                 // alter last byte of Name just above to set
 738+ E7C5 DD          >                db      {b $} | END_BIT     // msb as name end
 738+ E7C6             >
 738+ E7C6 BE 07       >                dw      Prev_Ptr            // Link to previous definition Name
 738+ E7C8             >Prev_Ptr        defl    Heap_Ptr
 738+ E7C8             >
 738+ E7C8             >mirror_Ptr      defl    $
 738+ E7C8             >
 738+ E7C8 CF A5       >                dw      Dict_Ptr + 2        // xt
 738+ E7CA             >Heap_Ptr        defl    $ - $E000           // save current HP
 738+ E7CA             >
 738+ E7CA             >Current_HP      defl  $ - $E000             // used to set HP once!
 738+ E7CA             >
 738+ E7CA             >//              ______________________________________________________________________
 738+ E7CA             >//              Dictionary part
 738+ E7CA             >
 738+ E7CA             >                org     Dict_Ptr
 738+ A5CD             >
 738+ A5CD C8 26       >                dw      mirror_Ptr - $E000 + $1F00
 738+ A5CF             >
 738+ A5CF             >SQUARED_CLOSE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 738+ A5CF CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 738+ A5D2             >
 738+ A5D2             >
 738+ A5D2             >                endif           ; ok        // for other definitions it "points" the correct handler
 738+ A5D2             >                // Use of "; ok" to suppress "warning[fwdref]"
 738+ A5D2             >
 738+ A5D2             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 739+ A5D2 F3 9A C0 00                  dw      LIT, $C0                // 192
 740+ A5D6 9C A2 E3 A0                  dw      STATE, STORE            // state !
 741+ A5DA A2 9F                        dw      EXIT                    // ;
 742+ A5DC
 743+ A5DC              //  ______________________________________________________________________
 744+ A5DC              //
 745+ A5DC              // smudge       --
 746+ A5DC              // toggle smudge bit of latest definition
 747+ A5DC                              Colon_Def SMUDGE, "SMUDGE", is_normal
 747+ A5DC             >                New_Def  SMUDGE, "SMUDGE", Enter_Ptr, is_normal ; ok
 747+ A5DC             >
 747+ A5DC             >Dict_Ptr        defl    $
 747+ A5DC             >
 747+ A5DC             >//              ______________________________________________________________________
 747+ A5DC             >//              Heap part
 747+ A5DC             >
 747+ A5DC             >
 747+ A5DC             >                org     (Heap_Ptr & $1FFF) + $E000
 747+ E7CA             >
 747+ E7CA             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 747+ E7CA             >Latest_Definition defl  Heap_Ptr
 747+ E7CA             >
 747+ E7CA             >                // dummy db directives used to calculate length of namec
 747+ E7CA 53 4D 55 44 >                db      "SMUDGE"
 747+ E7CE 47 45       >
 747+ E7D0             >len_NFA         defl    $ - temp_NFA
 747+ E7D0             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 747+ E7CA             >
 747+ E7CA 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 747+ E7CB 53 4D 55 44 >                db      "SMUDGE"               // name string in 7-bit ascii, but
 747+ E7CF 47 45       >
 747+ E7D1             >                org     $-1                 // alter last byte of Name just above to set
 747+ E7D0 C5          >                db      {b $} | END_BIT     // msb as name end
 747+ E7D1             >
 747+ E7D1 C4 07       >                dw      Prev_Ptr            // Link to previous definition Name
 747+ E7D3             >Prev_Ptr        defl    Heap_Ptr
 747+ E7D3             >
 747+ E7D3             >mirror_Ptr      defl    $
 747+ E7D3             >
 747+ E7D3 DE A5       >                dw      Dict_Ptr + 2        // xt
 747+ E7D5             >Heap_Ptr        defl    $ - $E000           // save current HP
 747+ E7D5             >
 747+ E7D5             >Current_HP      defl  $ - $E000             // used to set HP once!
 747+ E7D5             >
 747+ E7D5             >//              ______________________________________________________________________
 747+ E7D5             >//              Dictionary part
 747+ E7D5             >
 747+ E7D5             >                org     Dict_Ptr
 747+ A5DC             >
 747+ A5DC D3 26       >                dw      mirror_Ptr - $E000 + $1F00
 747+ A5DE             >
 747+ A5DE             >SMUDGE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 747+ A5DE CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 747+ A5E1             >
 747+ A5E1             >
 747+ A5E1             >                endif           ; ok        // for other definitions it "points" the correct handler
 747+ A5E1             >                // Use of "; ok" to suppress "warning[fwdref]"
 747+ A5E1             >
 747+ A5E1             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 748+ A5E1 A2 A4                        dw      LATEST                  // latest
 749+ A5E3 F3 9A 20 00                  dw      LIT, SMUDGE_BIT         // 32
 750+ A5E7 D0 A0                        dw      TOGGLE                  // toggle
 751+ A5E9 A2 9F                        dw      EXIT                    // ;
 752+ A5EB
 753+ A5EB              //  ______________________________________________________________________
 754+ A5EB              //
 755+ A5EB              // immediate    --
 756+ A5EB              // make immediate the latest definition
 757+ A5EB                              Colon_Def IMMEDIATE, "IMMEDIATE", is_normal
 757+ A5EB             >                New_Def  IMMEDIATE, "IMMEDIATE", Enter_Ptr, is_normal ; ok
 757+ A5EB             >
 757+ A5EB             >Dict_Ptr        defl    $
 757+ A5EB             >
 757+ A5EB             >//              ______________________________________________________________________
 757+ A5EB             >//              Heap part
 757+ A5EB             >
 757+ A5EB             >
 757+ A5EB             >                org     (Heap_Ptr & $1FFF) + $E000
 757+ E7D5             >
 757+ E7D5             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 757+ E7D5             >Latest_Definition defl  Heap_Ptr
 757+ E7D5             >
 757+ E7D5             >                // dummy db directives used to calculate length of namec
 757+ E7D5 49 4D 4D 45 >                db      "IMMEDIATE"
 757+ E7D9 44 49 41 54 >
 757+ E7DD 45          >
 757+ E7DE             >len_NFA         defl    $ - temp_NFA
 757+ E7DE             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 757+ E7D5             >
 757+ E7D5 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 757+ E7D6 49 4D 4D 45 >                db      "IMMEDIATE"               // name string in 7-bit ascii, but
 757+ E7DA 44 49 41 54 >
 757+ E7DE 45          >
 757+ E7DF             >                org     $-1                 // alter last byte of Name just above to set
 757+ E7DE C5          >                db      {b $} | END_BIT     // msb as name end
 757+ E7DF             >
 757+ E7DF CA 07       >                dw      Prev_Ptr            // Link to previous definition Name
 757+ E7E1             >Prev_Ptr        defl    Heap_Ptr
 757+ E7E1             >
 757+ E7E1             >mirror_Ptr      defl    $
 757+ E7E1             >
 757+ E7E1 ED A5       >                dw      Dict_Ptr + 2        // xt
 757+ E7E3             >Heap_Ptr        defl    $ - $E000           // save current HP
 757+ E7E3             >
 757+ E7E3             >Current_HP      defl  $ - $E000             // used to set HP once!
 757+ E7E3             >
 757+ E7E3             >//              ______________________________________________________________________
 757+ E7E3             >//              Dictionary part
 757+ E7E3             >
 757+ E7E3             >                org     Dict_Ptr
 757+ A5EB             >
 757+ A5EB E1 26       >                dw      mirror_Ptr - $E000 + $1F00
 757+ A5ED             >
 757+ A5ED             >IMMEDIATE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 757+ A5ED CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 757+ A5F0             >
 757+ A5F0             >
 757+ A5F0             >                endif           ; ok        // for other definitions it "points" the correct handler
 757+ A5F0             >                // Use of "; ok" to suppress "warning[fwdref]"
 757+ A5F0             >
 757+ A5F0             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 758+ A5F0 A2 A4                        dw      LATEST                  // latest
 759+ A5F2 F3 9A 40 00                  dw      LIT, $40                // 64
 760+ A5F6 D0 A0                        dw      TOGGLE                  // toggle
 761+ A5F8 A2 9F                        dw      EXIT                    // ;
 762+ A5FA
 763+ A5FA              //  ______________________________________________________________________
 764+ A5FA              //
 765+ A5FA              // hex          --
 766+ A5FA              // change numeration base
 767+ A5FA                              Colon_Def HEX, "HEX", is_normal
 767+ A5FA             >                New_Def  HEX, "HEX", Enter_Ptr, is_normal ; ok
 767+ A5FA             >
 767+ A5FA             >Dict_Ptr        defl    $
 767+ A5FA             >
 767+ A5FA             >//              ______________________________________________________________________
 767+ A5FA             >//              Heap part
 767+ A5FA             >
 767+ A5FA             >
 767+ A5FA             >                org     (Heap_Ptr & $1FFF) + $E000
 767+ E7E3             >
 767+ E7E3             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 767+ E7E3             >Latest_Definition defl  Heap_Ptr
 767+ E7E3             >
 767+ E7E3             >                // dummy db directives used to calculate length of namec
 767+ E7E3 48 45 58    >                db      "HEX"
 767+ E7E6             >len_NFA         defl    $ - temp_NFA
 767+ E7E6             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 767+ E7E3             >
 767+ E7E3 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 767+ E7E4 48 45 58    >                db      "HEX"               // name string in 7-bit ascii, but
 767+ E7E7             >                org     $-1                 // alter last byte of Name just above to set
 767+ E7E6 D8          >                db      {b $} | END_BIT     // msb as name end
 767+ E7E7             >
 767+ E7E7 D5 07       >                dw      Prev_Ptr            // Link to previous definition Name
 767+ E7E9             >Prev_Ptr        defl    Heap_Ptr
 767+ E7E9             >
 767+ E7E9             >mirror_Ptr      defl    $
 767+ E7E9             >
 767+ E7E9 FC A5       >                dw      Dict_Ptr + 2        // xt
 767+ E7EB             >Heap_Ptr        defl    $ - $E000           // save current HP
 767+ E7EB             >
 767+ E7EB             >Current_HP      defl  $ - $E000             // used to set HP once!
 767+ E7EB             >
 767+ E7EB             >//              ______________________________________________________________________
 767+ E7EB             >//              Dictionary part
 767+ E7EB             >
 767+ E7EB             >                org     Dict_Ptr
 767+ A5FA             >
 767+ A5FA E9 26       >                dw      mirror_Ptr - $E000 + $1F00
 767+ A5FC             >
 767+ A5FC             >HEX:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 767+ A5FC CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 767+ A5FF             >
 767+ A5FF             >
 767+ A5FF             >                endif           ; ok        // for other definitions it "points" the correct handler
 767+ A5FF             >                // Use of "; ok" to suppress "warning[fwdref]"
 767+ A5FF             >
 767+ A5FF             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 768+ A5FF F3 9A 10 00                  dw      LIT, 16                 // 16
 769+ A603 A2 A2 E3 A0                  dw      BASE, STORE             // base !
 770+ A607 A2 9F                        dw      EXIT                    // ;
 771+ A609
 772+ A609              //  ______________________________________________________________________
 773+ A609              //
 774+ A609              // decimal      --
 775+ A609              // change numeration base
 776+ A609                              Colon_Def DECIMAL, "DECIMAL", is_normal
 776+ A609             >                New_Def  DECIMAL, "DECIMAL", Enter_Ptr, is_normal ; ok
 776+ A609             >
 776+ A609             >Dict_Ptr        defl    $
 776+ A609             >
 776+ A609             >//              ______________________________________________________________________
 776+ A609             >//              Heap part
 776+ A609             >
 776+ A609             >
 776+ A609             >                org     (Heap_Ptr & $1FFF) + $E000
 776+ E7EB             >
 776+ E7EB             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 776+ E7EB             >Latest_Definition defl  Heap_Ptr
 776+ E7EB             >
 776+ E7EB             >                // dummy db directives used to calculate length of namec
 776+ E7EB 44 45 43 49 >                db      "DECIMAL"
 776+ E7EF 4D 41 4C    >
 776+ E7F2             >len_NFA         defl    $ - temp_NFA
 776+ E7F2             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 776+ E7EB             >
 776+ E7EB 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 776+ E7EC 44 45 43 49 >                db      "DECIMAL"               // name string in 7-bit ascii, but
 776+ E7F0 4D 41 4C    >
 776+ E7F3             >                org     $-1                 // alter last byte of Name just above to set
 776+ E7F2 CC          >                db      {b $} | END_BIT     // msb as name end
 776+ E7F3             >
 776+ E7F3 E3 07       >                dw      Prev_Ptr            // Link to previous definition Name
 776+ E7F5             >Prev_Ptr        defl    Heap_Ptr
 776+ E7F5             >
 776+ E7F5             >mirror_Ptr      defl    $
 776+ E7F5             >
 776+ E7F5 0B A6       >                dw      Dict_Ptr + 2        // xt
 776+ E7F7             >Heap_Ptr        defl    $ - $E000           // save current HP
 776+ E7F7             >
 776+ E7F7             >Current_HP      defl  $ - $E000             // used to set HP once!
 776+ E7F7             >
 776+ E7F7             >//              ______________________________________________________________________
 776+ E7F7             >//              Dictionary part
 776+ E7F7             >
 776+ E7F7             >                org     Dict_Ptr
 776+ A609             >
 776+ A609 F5 26       >                dw      mirror_Ptr - $E000 + $1F00
 776+ A60B             >
 776+ A60B             >DECIMAL:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 776+ A60B CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 776+ A60E             >
 776+ A60E             >
 776+ A60E             >                endif           ; ok        // for other definitions it "points" the correct handler
 776+ A60E             >                // Use of "; ok" to suppress "warning[fwdref]"
 776+ A60E             >
 776+ A60E             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 777+ A60E F3 9A 0A 00                  dw      LIT, 10                 // 10
 778+ A612 A2 A2 E3 A0                  dw      BASE, STORE             // base !
 779+ A616 A2 9F                        dw      EXIT                    // ;
 780+ A618
 781+ A618              //  ______________________________________________________________________
 782+ A618              //
 783+ A618              // (;code)       --
 784+ A618              // patch to CFA to call/jump to the "following code"
 785+ A618                              Colon_Def C_SEMICOLON_CODE, "(;CODE)", is_normal
 785+ A618             >                New_Def  C_SEMICOLON_CODE, "(;CODE)", Enter_Ptr, is_normal ; ok
 785+ A618             >
 785+ A618             >Dict_Ptr        defl    $
 785+ A618             >
 785+ A618             >//              ______________________________________________________________________
 785+ A618             >//              Heap part
 785+ A618             >
 785+ A618             >
 785+ A618             >                org     (Heap_Ptr & $1FFF) + $E000
 785+ E7F7             >
 785+ E7F7             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 785+ E7F7             >Latest_Definition defl  Heap_Ptr
 785+ E7F7             >
 785+ E7F7             >                // dummy db directives used to calculate length of namec
 785+ E7F7 28 3B 43 4F >                db      "(;CODE)"
 785+ E7FB 44 45 29    >
 785+ E7FE             >len_NFA         defl    $ - temp_NFA
 785+ E7FE             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 785+ E7F7             >
 785+ E7F7 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 785+ E7F8 28 3B 43 4F >                db      "(;CODE)"               // name string in 7-bit ascii, but
 785+ E7FC 44 45 29    >
 785+ E7FF             >                org     $-1                 // alter last byte of Name just above to set
 785+ E7FE A9          >                db      {b $} | END_BIT     // msb as name end
 785+ E7FF             >
 785+ E7FF EB 07       >                dw      Prev_Ptr            // Link to previous definition Name
 785+ E801             >Prev_Ptr        defl    Heap_Ptr
 785+ E801             >
 785+ E801             >mirror_Ptr      defl    $
 785+ E801             >
 785+ E801 1A A6       >                dw      Dict_Ptr + 2        // xt
 785+ E803             >Heap_Ptr        defl    $ - $E000           // save current HP
 785+ E803             >
 785+ E803             >Current_HP      defl  $ - $E000             // used to set HP once!
 785+ E803             >
 785+ E803             >//              ______________________________________________________________________
 785+ E803             >//              Dictionary part
 785+ E803             >
 785+ E803             >                org     Dict_Ptr
 785+ A618             >
 785+ A618 01 27       >                dw      mirror_Ptr - $E000 + $1F00
 785+ A61A             >
 785+ A61A             >C_SEMICOLON_CODE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 785+ A61A CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 785+ A61D             >
 785+ A61D             >
 785+ A61D             >                endif           ; ok        // for other definitions it "points" the correct handler
 785+ A61D             >                // Use of "; ok" to suppress "warning[fwdref]"
 785+ A61D             >
 785+ A61D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 786+ A61D B7 9F                        dw      R_TO                    // r>       ( Return Stack has IP to caller's next cell )
 787+ A61F A2 A4                        dw      LATEST                  // latest   ( Word being defined in this moment )
 788+ A621 00 A5 DB A4                  dw      PFA, CFA                // pfa cfa  ( cfa of latest word )
 789+ A625
 790+ A625 F3 9A CD 00                  dw      LIT, $CD                // $CD      ( At Latest CFA put "call" op-code )
 791+ A629 57 A0 F7 A0                  dw      OVER, CSTORE            // over c!  ( why can't use comma? because CFA was already ALLOTted by create? )
 792+ A62D 0E A0                        dw      ONE_PLUS                // 1+       ( At Latest CFA+1 put address for call. )
 793+ A62F
 794+ A62F E3 A0                        dw      STORE                   // !
 795+ A631 A2 9F                        dw      EXIT                    // ;
 796+ A633
 797+ A633              //  ______________________________________________________________________
 798+ A633              //
 799+ A633              // ;code        --
 800+ A633                              Colon_Def SEMICOLON_CODE, ";CODE", is_immediate
 800+ A633             >                New_Def  SEMICOLON_CODE, ";CODE", Enter_Ptr, is_immediate ; ok
 800+ A633             >
 800+ A633             >Dict_Ptr        defl    $
 800+ A633             >
 800+ A633             >//              ______________________________________________________________________
 800+ A633             >//              Heap part
 800+ A633             >
 800+ A633             >
 800+ A633             >                org     (Heap_Ptr & $1FFF) + $E000
 800+ E803             >
 800+ E803             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 800+ E803             >Latest_Definition defl  Heap_Ptr
 800+ E803             >
 800+ E803             >                // dummy db directives used to calculate length of namec
 800+ E803 3B 43 4F 44 >                db      ";CODE"
 800+ E807 45          >
 800+ E808             >len_NFA         defl    $ - temp_NFA
 800+ E808             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 800+ E803             >
 800+ E803 C5          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 800+ E804 3B 43 4F 44 >                db      ";CODE"               // name string in 7-bit ascii, but
 800+ E808 45          >
 800+ E809             >                org     $-1                 // alter last byte of Name just above to set
 800+ E808 C5          >                db      {b $} | END_BIT     // msb as name end
 800+ E809             >
 800+ E809 F7 07       >                dw      Prev_Ptr            // Link to previous definition Name
 800+ E80B             >Prev_Ptr        defl    Heap_Ptr
 800+ E80B             >
 800+ E80B             >mirror_Ptr      defl    $
 800+ E80B             >
 800+ E80B 35 A6       >                dw      Dict_Ptr + 2        // xt
 800+ E80D             >Heap_Ptr        defl    $ - $E000           // save current HP
 800+ E80D             >
 800+ E80D             >Current_HP      defl  $ - $E000             // used to set HP once!
 800+ E80D             >
 800+ E80D             >//              ______________________________________________________________________
 800+ E80D             >//              Dictionary part
 800+ E80D             >
 800+ E80D             >                org     Dict_Ptr
 800+ A633             >
 800+ A633 0B 27       >                dw      mirror_Ptr - $E000 + $1F00
 800+ A635             >
 800+ A635             >SEMICOLON_CODE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 800+ A635 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 800+ A638             >
 800+ A638             >
 800+ A638             >                endif           ; ok        // for other definitions it "points" the correct handler
 800+ A638             >                // Use of "; ok" to suppress "warning[fwdref]"
 800+ A638             >
 800+ A638             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 801+ A638 7A A5                        dw      QCSP                    // ?csp
 802+ A63A A2 A5                        dw      COMPILE                 // compile
 803+ A63C 1A A6                        dw      C_SEMICOLON_CODE        // (;code)
 804+ A63E C2 A5                        dw      SQUARED_OPEN            // [
 805+ A640 98 A1                        dw      NOOP                    // noop () can be patched later to ASSEMBLER... )
 806+ A642 A2 9F                        dw      EXIT                    // ; immediate
 807+ A644
 808+ A644              //  ______________________________________________________________________
 809+ A644              //
 810+ A644              // <builds      --
 811+ A644                              Colon_Def CBUILDS, "<BUILDS", is_normal
 811+ A644             >                New_Def  CBUILDS, "<BUILDS", Enter_Ptr, is_normal ; ok
 811+ A644             >
 811+ A644             >Dict_Ptr        defl    $
 811+ A644             >
 811+ A644             >//              ______________________________________________________________________
 811+ A644             >//              Heap part
 811+ A644             >
 811+ A644             >
 811+ A644             >                org     (Heap_Ptr & $1FFF) + $E000
 811+ E80D             >
 811+ E80D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 811+ E80D             >Latest_Definition defl  Heap_Ptr
 811+ E80D             >
 811+ E80D             >                // dummy db directives used to calculate length of namec
 811+ E80D 3C 42 55 49 >                db      "<BUILDS"
 811+ E811 4C 44 53    >
 811+ E814             >len_NFA         defl    $ - temp_NFA
 811+ E814             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 811+ E80D             >
 811+ E80D 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 811+ E80E 3C 42 55 49 >                db      "<BUILDS"               // name string in 7-bit ascii, but
 811+ E812 4C 44 53    >
 811+ E815             >                org     $-1                 // alter last byte of Name just above to set
 811+ E814 D3          >                db      {b $} | END_BIT     // msb as name end
 811+ E815             >
 811+ E815 03 08       >                dw      Prev_Ptr            // Link to previous definition Name
 811+ E817             >Prev_Ptr        defl    Heap_Ptr
 811+ E817             >
 811+ E817             >mirror_Ptr      defl    $
 811+ E817             >
 811+ E817 46 A6       >                dw      Dict_Ptr + 2        // xt
 811+ E819             >Heap_Ptr        defl    $ - $E000           // save current HP
 811+ E819             >
 811+ E819             >Current_HP      defl  $ - $E000             // used to set HP once!
 811+ E819             >
 811+ E819             >//              ______________________________________________________________________
 811+ E819             >//              Dictionary part
 811+ E819             >
 811+ E819             >                org     Dict_Ptr
 811+ A644             >
 811+ A644 17 27       >                dw      mirror_Ptr - $E000 + $1F00
 811+ A646             >
 811+ A646             >CBUILDS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 811+ A646 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 811+ A649             >
 811+ A649             >
 811+ A649             >                endif           ; ok        // for other definitions it "points" the correct handler
 811+ A649             >                // Use of "; ok" to suppress "warning[fwdref]"
 811+ A649             >
 811+ A649             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 812+ A649 D1 A1                        dw      ZERO                    // 0
 813+ A64B 9C A1                        dw      CONSTANT                // constant
 814+ A64D A2 9F                        dw      EXIT                    // ;
 815+ A64F
 816+ A64F              //  ______________________________________________________________________
 817+ A64F              //
 818+ A64F              // recurse      --
 819+ A64F              //              Colon_Def RECURSE, "RECURSE", is_immediate
 820+ A64F              //              dw      QCOMP                   // ?comp
 821+ A64F              //              dw      LATEST                  // latest
 822+ A64F              //              dw      PFA, CFA                // pfa cfa
 823+ A64F              //              dw      COMMA                   // ,
 824+ A64F              //              dw      EXIT                    // ; immediate
 825+ A64F
 826+ A64F              //  ______________________________________________________________________
 827+ A64F              //
 828+ A64F              // does>     --
 829+ A64F                              Colon_Def DOES_TO, "DOES>", is_normal
 829+ A64F             >                New_Def  DOES_TO, "DOES>", Enter_Ptr, is_normal ; ok
 829+ A64F             >
 829+ A64F             >Dict_Ptr        defl    $
 829+ A64F             >
 829+ A64F             >//              ______________________________________________________________________
 829+ A64F             >//              Heap part
 829+ A64F             >
 829+ A64F             >
 829+ A64F             >                org     (Heap_Ptr & $1FFF) + $E000
 829+ E819             >
 829+ E819             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 829+ E819             >Latest_Definition defl  Heap_Ptr
 829+ E819             >
 829+ E819             >                // dummy db directives used to calculate length of namec
 829+ E819 44 4F 45 53 >                db      "DOES>"
 829+ E81D 3E          >
 829+ E81E             >len_NFA         defl    $ - temp_NFA
 829+ E81E             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 829+ E819             >
 829+ E819 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 829+ E81A 44 4F 45 53 >                db      "DOES>"               // name string in 7-bit ascii, but
 829+ E81E 3E          >
 829+ E81F             >                org     $-1                 // alter last byte of Name just above to set
 829+ E81E BE          >                db      {b $} | END_BIT     // msb as name end
 829+ E81F             >
 829+ E81F 0D 08       >                dw      Prev_Ptr            // Link to previous definition Name
 829+ E821             >Prev_Ptr        defl    Heap_Ptr
 829+ E821             >
 829+ E821             >mirror_Ptr      defl    $
 829+ E821             >
 829+ E821 51 A6       >                dw      Dict_Ptr + 2        // xt
 829+ E823             >Heap_Ptr        defl    $ - $E000           // save current HP
 829+ E823             >
 829+ E823             >Current_HP      defl  $ - $E000             // used to set HP once!
 829+ E823             >
 829+ E823             >//              ______________________________________________________________________
 829+ E823             >//              Dictionary part
 829+ E823             >
 829+ E823             >                org     Dict_Ptr
 829+ A64F             >
 829+ A64F 21 27       >                dw      mirror_Ptr - $E000 + $1F00
 829+ A651             >
 829+ A651             >DOES_TO:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 829+ A651 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 829+ A654             >
 829+ A654             >
 829+ A654             >                endif           ; ok        // for other definitions it "points" the correct handler
 829+ A654             >                // Use of "; ok" to suppress "warning[fwdref]"
 829+ A654             >
 829+ A654             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 830+ A654 B7 9F                        dw      R_TO                    // r>
 831+ A656 A2 A4                        dw      LATEST                  // latest
 832+ A658 00 A5                        dw      PFA                     // pfa
 833+ A65A E3 A0                        dw      STORE                   // !
 834+ A65C 1A A6                        dw      C_SEMICOLON_CODE        // ;code
 835+ A65E              Does_Ptr:
 836+ A65E                              // via call coded in CFA
 837+ A65E EB                           ex      de, hl //**
 838+ A65F                              // *** ldhlrp
 839+ A65F 2B                           dec     hl                  // push on Return-Stack current Instruction-Pointer
 840+ A660 70                           ld      (hl), b
 841+ A661 2B                           dec     hl
 842+ A662 71                           ld      (hl), c
 843+ A663                              // *** ldrphl
 844+ A663 EB                           ex      de, hl //**
 845+ A664 E1                           pop     hl                  // CFA has a call to this, so PFA -> IP
 846+ A665
 847+ A665 4E                           ld      c, (hl)
 848+ A666 23                           inc     hl
 849+ A667 46                           ld      b, (hl)
 850+ A668 23                           inc     hl
 851+ A669
 852+ A669                              psh1
 852+ A669 E5          >                push    hl
 852+ A66A DD E9       >                jp      (ix)
 853+ A66C                              // SMUDGE !
 854+ A66C
 855+ A66C              //  ______________________________________________________________________
 856+ A66C              //
 857+ A66C              // count        a -- a2 n
 858+ A66C              // expects a counted string at address a, returns string address and counter
 859+ A66C                              New_Def COUNT, "COUNT", is_code, is_normal
 859+ A66C             >
 859+ A66C             >Dict_Ptr        defl    $
 859+ A66C             >
 859+ A66C             >//              ______________________________________________________________________
 859+ A66C             >//              Heap part
 859+ A66C             >
 859+ A66C             >
 859+ A66C             >                org     (Heap_Ptr & $1FFF) + $E000
 859+ E823             >
 859+ E823             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 859+ E823             >Latest_Definition defl  Heap_Ptr
 859+ E823             >
 859+ E823             >                // dummy db directives used to calculate length of namec
 859+ E823 43 4F 55 4E >                db      "COUNT"
 859+ E827 54          >
 859+ E828             >len_NFA         defl    $ - temp_NFA
 859+ E828             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 859+ E823             >
 859+ E823 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 859+ E824 43 4F 55 4E >                db      "COUNT"               // name string in 7-bit ascii, but
 859+ E828 54          >
 859+ E829             >                org     $-1                 // alter last byte of Name just above to set
 859+ E828 D4          >                db      {b $} | END_BIT     // msb as name end
 859+ E829             >
 859+ E829 19 08       >                dw      Prev_Ptr            // Link to previous definition Name
 859+ E82B             >Prev_Ptr        defl    Heap_Ptr
 859+ E82B             >
 859+ E82B             >mirror_Ptr      defl    $
 859+ E82B             >
 859+ E82B 6E A6       >                dw      Dict_Ptr + 2        // xt
 859+ E82D             >Heap_Ptr        defl    $ - $E000           // save current HP
 859+ E82D             >
 859+ E82D             >Current_HP      defl  $ - $E000             // used to set HP once!
 859+ E82D             >
 859+ E82D             >//              ______________________________________________________________________
 859+ E82D             >//              Dictionary part
 859+ E82D             >
 859+ E82D             >                org     Dict_Ptr
 859+ A66C             >
 859+ A66C 2B 27       >                dw      mirror_Ptr - $E000 + $1F00
 859+ A66E             >
 859+ A66E             >COUNT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 859+ A66E ~           >                call    runcode ; ok        // for primitive definitions  actual code
 859+ A66E ~           >
 859+ A66E ~           >
 859+ A66E             >                endif           ; ok        // for other definitions it "points" the correct handler
 859+ A66E             >                // Use of "; ok" to suppress "warning[fwdref]"
 859+ A66E             >
 859+ A66E             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 860+ A66E D9                           exx
 861+ A66F E1                           pop     hl
 862+ A670 5E                           ld      e, (hl)
 863+ A671 16 00                        ld      d, 0
 864+ A673 23                           inc     hl
 865+ A674              Count_Here:
 866+ A674 E5                           push    hl
 867+ A675 D5                           push    de
 868+ A676 D9                           exx
 869+ A677                              next
 869+ A677 DD E9       >                jp      (ix)
 870+ A679              //                pop     hl
 871+ A679              //                ld      a, (hl)
 872+ A679              //                inc     hl
 873+ A679              //                push    hl
 874+ A679              //                ld      h, 0
 875+ A679              //                ld      l, a
 876+ A679              //                push    hl
 877+ A679              //                next
 878+ A679
 879+ A679              //  ______________________________________________________________________
 880+ A679              //
 881+ A679              // bounds       a n -- a+n n
 882+ A679              // given an address and a length ( a n ) calculate the bound addresses
 883+ A679              // suitable for DO-LOOP
 884+ A679                              New_Def BOUNDS, "BOUNDS", is_code, is_normal
 884+ A679             >
 884+ A679             >Dict_Ptr        defl    $
 884+ A679             >
 884+ A679             >//              ______________________________________________________________________
 884+ A679             >//              Heap part
 884+ A679             >
 884+ A679             >
 884+ A679             >                org     (Heap_Ptr & $1FFF) + $E000
 884+ E82D             >
 884+ E82D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 884+ E82D             >Latest_Definition defl  Heap_Ptr
 884+ E82D             >
 884+ E82D             >                // dummy db directives used to calculate length of namec
 884+ E82D 42 4F 55 4E >                db      "BOUNDS"
 884+ E831 44 53       >
 884+ E833             >len_NFA         defl    $ - temp_NFA
 884+ E833             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 884+ E82D             >
 884+ E82D 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 884+ E82E 42 4F 55 4E >                db      "BOUNDS"               // name string in 7-bit ascii, but
 884+ E832 44 53       >
 884+ E834             >                org     $-1                 // alter last byte of Name just above to set
 884+ E833 D3          >                db      {b $} | END_BIT     // msb as name end
 884+ E834             >
 884+ E834 23 08       >                dw      Prev_Ptr            // Link to previous definition Name
 884+ E836             >Prev_Ptr        defl    Heap_Ptr
 884+ E836             >
 884+ E836             >mirror_Ptr      defl    $
 884+ E836             >
 884+ E836 7B A6       >                dw      Dict_Ptr + 2        // xt
 884+ E838             >Heap_Ptr        defl    $ - $E000           // save current HP
 884+ E838             >
 884+ E838             >Current_HP      defl  $ - $E000             // used to set HP once!
 884+ E838             >
 884+ E838             >//              ______________________________________________________________________
 884+ E838             >//              Dictionary part
 884+ E838             >
 884+ E838             >                org     Dict_Ptr
 884+ A679             >
 884+ A679 36 27       >                dw      mirror_Ptr - $E000 + $1F00
 884+ A67B             >
 884+ A67B             >BOUNDS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 884+ A67B ~           >                call    runcode ; ok        // for primitive definitions  actual code
 884+ A67B ~           >
 884+ A67B ~           >
 884+ A67B             >                endif           ; ok        // for other definitions it "points" the correct handler
 884+ A67B             >                // Use of "; ok" to suppress "warning[fwdref]"
 884+ A67B             >
 884+ A67B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 885+ A67B D9                           exx
 886+ A67C E1                           pop     hl
 887+ A67D D1                           pop     de
 888+ A67E 19                           add     hl, de
 889+ A67F 18 F3                        jr      Count_Here
 890+ A681                              // push    hl
 891+ A681                              // push    de
 892+ A681                              // exx
 893+ A681                              // next
 894+ A681
 895+ A681              //  ______________________________________________________________________
 896+ A681              //
 897+ A681              // leave        --
 898+ A681              // Compile (leave) to leave current LOOP and jump just after it
 899+ A681                              Colon_Def LEAVE, "LEAVE", is_immediate
 899+ A681             >                New_Def  LEAVE, "LEAVE", Enter_Ptr, is_immediate ; ok
 899+ A681             >
 899+ A681             >Dict_Ptr        defl    $
 899+ A681             >
 899+ A681             >//              ______________________________________________________________________
 899+ A681             >//              Heap part
 899+ A681             >
 899+ A681             >
 899+ A681             >                org     (Heap_Ptr & $1FFF) + $E000
 899+ E838             >
 899+ E838             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 899+ E838             >Latest_Definition defl  Heap_Ptr
 899+ E838             >
 899+ E838             >                // dummy db directives used to calculate length of namec
 899+ E838 4C 45 41 56 >                db      "LEAVE"
 899+ E83C 45          >
 899+ E83D             >len_NFA         defl    $ - temp_NFA
 899+ E83D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 899+ E838             >
 899+ E838 C5          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 899+ E839 4C 45 41 56 >                db      "LEAVE"               // name string in 7-bit ascii, but
 899+ E83D 45          >
 899+ E83E             >                org     $-1                 // alter last byte of Name just above to set
 899+ E83D C5          >                db      {b $} | END_BIT     // msb as name end
 899+ E83E             >
 899+ E83E 2D 08       >                dw      Prev_Ptr            // Link to previous definition Name
 899+ E840             >Prev_Ptr        defl    Heap_Ptr
 899+ E840             >
 899+ E840             >mirror_Ptr      defl    $
 899+ E840             >
 899+ E840 83 A6       >                dw      Dict_Ptr + 2        // xt
 899+ E842             >Heap_Ptr        defl    $ - $E000           // save current HP
 899+ E842             >
 899+ E842             >Current_HP      defl  $ - $E000             // used to set HP once!
 899+ E842             >
 899+ E842             >//              ______________________________________________________________________
 899+ E842             >//              Dictionary part
 899+ E842             >
 899+ E842             >                org     Dict_Ptr
 899+ A681             >
 899+ A681 40 27       >                dw      mirror_Ptr - $E000 + $1F00
 899+ A683             >
 899+ A683             >LEAVE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 899+ A683 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 899+ A686             >
 899+ A686             >
 899+ A686             >                endif           ; ok        // for other definitions it "points" the correct handler
 899+ A686             >                // Use of "; ok" to suppress "warning[fwdref]"
 899+ A686             >
 899+ A686             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 900+ A686 A2 A5 50 9B                  dw      COMPILE, C_LEAVE       // compile (leave)     \ unloop and branch
 901+ A68A F6 A2 AC 9F                  dw      HERE, TO_R, ZERO, COMMA // here >r 0 ,
 901+ A68E D1 A1 0C A3
 902+ A692 D1 A1 D1 A1                  dw      ZERO, ZERO
 903+ A696 89 9F 7B A0                  dw      SPFETCH, DUP
 904+ A69A 24 A0 24 A0                  dw      CELL_PLUS, CELL_PLUS
 905+ A69E 6B A0                        dw      TUCK
 906+ A6A0 B4 A2 D9 A0                  dw      CSP, FETCH
 907+ A6A4 74 A0 35 A3                  dw      SWAP, SUBTRACT
 908+ A6A8 DD 9E                        dw      CMOVE
 909+ A6AA B4 A2 D9 A0                  dw      CSP, FETCH, CELL_MINUS
 909+ A6AE 29 A0
 910+ A6B0 B7 9F 57 A0                  dw      R_TO, OVER, STORE
 910+ A6B4 E3 A0
 911+ A6B6 29 A0 D1 A1                  dw      CELL_MINUS, ZERO
 912+ A6BA 74 A0 E3 A0                  dw      SWAP, STORE
 913+ A6BE A2 9F                        dw      EXIT                    // ;
 914+ A6C0
 915+ A6C0              //  ______________________________________________________________________
 916+ A6C0              //
 917+ A6C0              // type         a n --
 918+ A6C0              // Sends to current output channel n characters starting at address a.
 919+ A6C0                              Colon_Def TYPE, "TYPE", is_normal
 919+ A6C0             >                New_Def  TYPE, "TYPE", Enter_Ptr, is_normal ; ok
 919+ A6C0             >
 919+ A6C0             >Dict_Ptr        defl    $
 919+ A6C0             >
 919+ A6C0             >//              ______________________________________________________________________
 919+ A6C0             >//              Heap part
 919+ A6C0             >
 919+ A6C0             >
 919+ A6C0             >                org     (Heap_Ptr & $1FFF) + $E000
 919+ E842             >
 919+ E842             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 919+ E842             >Latest_Definition defl  Heap_Ptr
 919+ E842             >
 919+ E842             >                // dummy db directives used to calculate length of namec
 919+ E842 54 59 50 45 >                db      "TYPE"
 919+ E846             >len_NFA         defl    $ - temp_NFA
 919+ E846             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 919+ E842             >
 919+ E842 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 919+ E843 54 59 50 45 >                db      "TYPE"               // name string in 7-bit ascii, but
 919+ E847             >                org     $-1                 // alter last byte of Name just above to set
 919+ E846 C5          >                db      {b $} | END_BIT     // msb as name end
 919+ E847             >
 919+ E847 38 08       >                dw      Prev_Ptr            // Link to previous definition Name
 919+ E849             >Prev_Ptr        defl    Heap_Ptr
 919+ E849             >
 919+ E849             >mirror_Ptr      defl    $
 919+ E849             >
 919+ E849 C2 A6       >                dw      Dict_Ptr + 2        // xt
 919+ E84B             >Heap_Ptr        defl    $ - $E000           // save current HP
 919+ E84B             >
 919+ E84B             >Current_HP      defl  $ - $E000             // used to set HP once!
 919+ E84B             >
 919+ E84B             >//              ______________________________________________________________________
 919+ E84B             >//              Dictionary part
 919+ E84B             >
 919+ E84B             >                org     Dict_Ptr
 919+ A6C0             >
 919+ A6C0 49 27       >                dw      mirror_Ptr - $E000 + $1F00
 919+ A6C2             >
 919+ A6C2             >TYPE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 919+ A6C2 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 919+ A6C5             >
 919+ A6C5             >
 919+ A6C5             >                endif           ; ok        // for other definitions it "points" the correct handler
 919+ A6C5             >                // Use of "; ok" to suppress "warning[fwdref]"
 919+ A6C5             >
 919+ A6C5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 920+ A6C5 7B A6                        dw      BOUNDS                  // bounds
 921+ A6C7 5C 9B                        dw      C_Q_DO                  // ?do
 922+ A6C9 0C 00                        dw      Type_Skip - $
 923+ A6CB              Type_Loop:
 924+ A6CB 8A 9B EE A0                  dw          I, CFETCH           //      i c@
 925+ A6CF B0 A3                        dw          EMIT                //      emit
 926+ A6D1 30 9B                        dw      C_LOOP                  // loop
 927+ A6D3 F8 FF                        dw      Type_Loop - $
 928+ A6D5              Type_Skip:
 929+ A6D5 A2 9F                        dw      EXIT                    // ;
 930+ A6D7
 931+ A6D7              //  ______________________________________________________________________
 932+ A6D7              //
 933+ A6D7              // -trailing    a n1 -- a n2
 934+ A6D7              // Assumes that an n1 bytes-long string is stored at address a
 935+ A6D7              // and the string contains a space delimited word,
 936+ A6D7              // Finds n2 as the position of the first character after the word.
 937+ A6D7                              Colon_Def LTRAILING, "-TRAILING", is_normal
 937+ A6D7             >                New_Def  LTRAILING, "-TRAILING", Enter_Ptr, is_normal ; ok
 937+ A6D7             >
 937+ A6D7             >Dict_Ptr        defl    $
 937+ A6D7             >
 937+ A6D7             >//              ______________________________________________________________________
 937+ A6D7             >//              Heap part
 937+ A6D7             >
 937+ A6D7             >
 937+ A6D7             >                org     (Heap_Ptr & $1FFF) + $E000
 937+ E84B             >
 937+ E84B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 937+ E84B             >Latest_Definition defl  Heap_Ptr
 937+ E84B             >
 937+ E84B             >                // dummy db directives used to calculate length of namec
 937+ E84B 2D 54 52 41 >                db      "-TRAILING"
 937+ E84F 49 4C 49 4E >
 937+ E853 47          >
 937+ E854             >len_NFA         defl    $ - temp_NFA
 937+ E854             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 937+ E84B             >
 937+ E84B 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 937+ E84C 2D 54 52 41 >                db      "-TRAILING"               // name string in 7-bit ascii, but
 937+ E850 49 4C 49 4E >
 937+ E854 47          >
 937+ E855             >                org     $-1                 // alter last byte of Name just above to set
 937+ E854 C7          >                db      {b $} | END_BIT     // msb as name end
 937+ E855             >
 937+ E855 42 08       >                dw      Prev_Ptr            // Link to previous definition Name
 937+ E857             >Prev_Ptr        defl    Heap_Ptr
 937+ E857             >
 937+ E857             >mirror_Ptr      defl    $
 937+ E857             >
 937+ E857 D9 A6       >                dw      Dict_Ptr + 2        // xt
 937+ E859             >Heap_Ptr        defl    $ - $E000           // save current HP
 937+ E859             >
 937+ E859             >Current_HP      defl  $ - $E000             // used to set HP once!
 937+ E859             >
 937+ E859             >//              ______________________________________________________________________
 937+ E859             >//              Dictionary part
 937+ E859             >
 937+ E859             >                org     Dict_Ptr
 937+ A6D7             >
 937+ A6D7 57 27       >                dw      mirror_Ptr - $E000 + $1F00
 937+ A6D9             >
 937+ A6D9             >LTRAILING:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 937+ A6D9 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 937+ A6DC             >
 937+ A6DC             >
 937+ A6DC             >                endif           ; ok        // for other definitions it "points" the correct handler
 937+ A6DC             >                // Use of "; ok" to suppress "warning[fwdref]"
 937+ A6DC             >
 937+ A6DC             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 938+ A6DC 7B A0 D1 A1                  dw      DUP, ZERO               // dup 0
 939+ A6E0                                                              // do
 940+ A6E0 5C 9B                        dw      C_Q_DO
 941+ A6E2 20 00                        dw      LTrailing_Leave - $
 942+ A6E4              LTrailing_Loop:
 943+ A6E4 B7 A0 F5 9F                  dw          TWO_DUP, PLUS       //      2dup +
 944+ A6E8 15 A0                        dw          ONE_SUBTRACT        //      1-
 945+ A6EA EE A0                        dw          CFETCH              //      c@
 946+ A6EC F4 A1 35 A3                  dw          BL, SUBTRACT        //      bl -
 947+ A6F0                                                              //      if
 948+ A6F0 45 9B                        dw          ZBRANCH
 949+ A6F2 0A 00                        dw          LTrailing_Else - $
 950+ A6F4 50 9B                        dw              C_LEAVE         //          leave
 951+ A6F6 0C 00                        dw              LTrailing_Leave - $
 952+ A6F8 38 9B                        dw          BRANCH              //      else
 953+ A6FA 04 00                        dw          LTrailing_Endif - $
 954+ A6FC              LTrailing_Else:
 955+ A6FC 15 A0                        dw              ONE_SUBTRACT    //          1-
 956+ A6FE              LTrailing_Endif:                                //      endif
 957+ A6FE                                                              // loop
 958+ A6FE 30 9B                        dw      C_LOOP
 959+ A700 E4 FF                        dw      LTrailing_Loop - $
 960+ A702              LTrailing_Leave:
 961+ A702 A2 9F                        dw      EXIT                    // ;
 962+ A704
 963+ A704              //  ______________________________________________________________________
 964+ A704              //
 965+ A704              // accept       a n1 -- n2
 966+ A704              // Accepts at most n1 characters from terminal and stores them at address a
 967+ A704              // CR stops input. A 'nul' is added as trailer.
 968+ A704              // n2 is the string length. n2 is kept in span user variable also.
 969+ A704                              Colon_Def ACCEPT, "ACCEPT", is_normal
 969+ A704             >                New_Def  ACCEPT, "ACCEPT", Enter_Ptr, is_normal ; ok
 969+ A704             >
 969+ A704             >Dict_Ptr        defl    $
 969+ A704             >
 969+ A704             >//              ______________________________________________________________________
 969+ A704             >//              Heap part
 969+ A704             >
 969+ A704             >
 969+ A704             >                org     (Heap_Ptr & $1FFF) + $E000
 969+ E859             >
 969+ E859             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 969+ E859             >Latest_Definition defl  Heap_Ptr
 969+ E859             >
 969+ E859             >                // dummy db directives used to calculate length of namec
 969+ E859 41 43 43 45 >                db      "ACCEPT"
 969+ E85D 50 54       >
 969+ E85F             >len_NFA         defl    $ - temp_NFA
 969+ E85F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 969+ E859             >
 969+ E859 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 969+ E85A 41 43 43 45 >                db      "ACCEPT"               // name string in 7-bit ascii, but
 969+ E85E 50 54       >
 969+ E860             >                org     $-1                 // alter last byte of Name just above to set
 969+ E85F D4          >                db      {b $} | END_BIT     // msb as name end
 969+ E860             >
 969+ E860 4B 08       >                dw      Prev_Ptr            // Link to previous definition Name
 969+ E862             >Prev_Ptr        defl    Heap_Ptr
 969+ E862             >
 969+ E862             >mirror_Ptr      defl    $
 969+ E862             >
 969+ E862 06 A7       >                dw      Dict_Ptr + 2        // xt
 969+ E864             >Heap_Ptr        defl    $ - $E000           // save current HP
 969+ E864             >
 969+ E864             >Current_HP      defl  $ - $E000             // used to set HP once!
 969+ E864             >
 969+ E864             >//              ______________________________________________________________________
 969+ E864             >//              Dictionary part
 969+ E864             >
 969+ E864             >                org     Dict_Ptr
 969+ A704             >
 969+ A704 62 27       >                dw      mirror_Ptr - $E000 + $1F00
 969+ A706             >
 969+ A706             >ACCEPT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 969+ A706 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 969+ A709             >
 969+ A709             >
 969+ A709             >                endif           ; ok        // for other definitions it "points" the correct handler
 969+ A709             >                // Use of "; ok" to suppress "warning[fwdref]"
 969+ A709             >
 969+ A709             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 970+ A709 57 A0 F5 9F                  dw      OVER, PLUS, OVER        //                      ( a  n1+a  a )
 970+ A70D 57 A0
 971+ A70F D1 A1 8D A0                  dw      ZERO, DASH_ROT          //                      ( a  0     a+n1  a )
 972+ A713                                                              // do
 973+ A713 5C 9B                        dw      C_Q_DO
 974+ A715 8C 00                        dw      Accept_Leave - $
 975+ A717              Accept_Loop:
 976+ A717 88 9D                        dw          CUR
 977+ A719 60 A0 D0 9D                  dw          DROP, KEY           //      drop key        ( a  c )
 978+ A71D 7B A0                        dw          DUP                 //      dup             ( a  c  c )
 979+ A71F F3 9A 0E 00                  dw          LIT, $0E            //      0E
 980+ A723 17 A2                        dw          PLUS_ORIGIN         //      +origin
 981+ A725 D9 A0                        dw          FETCH               //      @               ( a  c  c  del )
 982+ A727 41 A3                        dw          EQUALS              //      =               ( a  c  c==del )
 983+ A729                                                              //      if
 984+ A729 45 9B                        dw          ZBRANCH
 985+ A72B 2C 00                        dw          Accept_Else_0 - $
 986+ A72D 60 A0                        dw              DROP            //          drop        ( a  )
 987+ A72F 7B A0 8A 9B                  dw              DUP, I, EQUALS  //          dup i =     ( a  a==i )
 987+ A733 41 A3
 988+ A735 D8 A1 5C 9F                  dw              ONE, AND_OP     //          1 and
 989+ A739 7B A0                        dw              DUP             //          dup         ( a  a==i  a==i )
 990+ A73B B7 9F                        dw              R_TO            //          r> 2 - + r>
 991+ A73D 31 A0 F5 9F                  dw              TWO_MINUS, PLUS //      ( decrement index by 1 or 2 )
 992+ A741 AC 9F                        dw              TO_R            //
 993+ A743                                                              //          if
 994+ A743 45 9B                        dw              ZBRANCH
 995+ A745 0A 00                        dw              Accept_Else_1 - $
 996+ A747 F3 9A 07 00                  dw                  LIT, 7      //              7       ( a  7 )
 997+ A74B                                                              //          else
 998+ A74B 38 9B                        dw              BRANCH
 999+ A74D 06 00                        dw              Accept_Endif_1 - $
1000+ A74F              Accept_Else_1:
1001+ A74F F3 9A 08 00                  dw                  LIT, 8      //              8       ( a  8 )
1002+ A753              Accept_Endif_1:                                 //          endif
1003+ A753 38 9B                        dw          BRANCH
1004+ A755 2E 00                        dw          Accept_Endif_0 - $
1005+ A757              Accept_Else_0:                                  //      else
1006+ A757 7B A0                        dw              DUP             //          dup         ( a  c  c )
1007+ A759 F3 9A 0D 00                  dw              LIT, 13         //          13
1008+ A75D 41 A3                        dw              EQUALS          //          =           ( a  c  c==CR )
1009+ A75F                                                              //          if
1010+ A75F 45 9B                        dw              ZBRANCH
1011+ A761 0C 00                        dw              Accept_Else_2 - $
1012+ A763 60 A0 F4 A1                  dw                  DROP, BL    //              drop bl ( a  bl )
1013+ A767 D1 A1                        dw                  ZERO        //              0       ( a  c  0 )
1014+ A769                                                              //          else
1015+ A769 38 9B                        dw              BRANCH
1016+ A76B 04 00                        dw              Accept_Endif_2 - $
1017+ A76D              Accept_Else_2:
1018+ A76D 7B A0                        dw                  DUP         //              dup     ( a  c  c )
1019+ A76F                                                              //          endif
1020+ A76F              Accept_Endif_2:
1021+ A76F 8A 9B F7 A0                  dw              I, CSTORE       //          i           ( a  c )
1022+ A773 7B A0 F4 A1                  dw              DUP, BL, LESS   //          dup bl <    ( a  c  c<BL )
1022+ A777 5A A3
1023+ A779                                                              //          if
1024+ A779 45 9B                        dw              ZBRANCH
1025+ A77B 08 00                        dw              Accept_Endif_3 - $
1026+ A77D B7 9F                        dw                  R_TO        //              r>
1027+ A77F 15 A0                        dw                  ONE_SUBTRACT//              1-
1028+ A781 AC 9F                        dw                  TO_R        //              >r
1029+ A783                                                              //          endif
1030+ A783              Accept_Endif_3:
1031+ A783              Accept_Endif_0:                                 //      endif
1032+ A783 B0 A3                        dw          EMIT                //      emit
1033+ A785
1034+ A785 D1 A1 8A 9B                  dw          ZERO, I, ONE_PLUS   //      0 i 1+ !
1034+ A789 0E A0
1035+ A78B E3 A0                        dw          STORE               //          ( zero pad )
1036+ A78D 8A 9B                        dw          I                   //      i
1037+ A78F 8A 9B EE A0                  dw          I, CFETCH, ZEQUAL   //      i 0= if
1037+ A793 C7 9F
1038+ A795 45 9B                        dw          ZBRANCH             //
1039+ A797 06 00                        dw              Accept_Endif_4 - $
1040+ A799 50 9B                        dw                  C_LEAVE     //              leave
1041+ A79B 06 00                        dw                  Accept_Leave - $
1042+ A79D              Accept_Endif_4:                                 //      endif
1043+ A79D                                                              // loop
1044+ A79D 30 9B                        dw      C_LOOP
1045+ A79F 78 FF                        dw      Accept_Loop - $
1046+ A7A1              Accept_Leave:
1047+ A7A1 74 A0 35 A3                  dw      SWAP, SUBTRACT          // swap -
1048+ A7A5 0E A0                        dw      ONE_PLUS                // 1+
1049+ A7A7 7B A0 E4 A2                  dw      DUP, SPAN, STORE        // dup span !
1049+ A7AB E3 A0
1050+ A7AD A2 9F                        dw      EXIT                    // ;
1051+ A7AF
1052+ A7AF              //  ______________________________________________________________________
1053+ A7AF              //
1054+ A7AF              // expect      a n --
1055+ A7AF              // Accepts at most n1 characters from terminal and stores them at address a
1056+ A7AF              // CR stops input. A 'nul' is added as trailer.
1057+ A7AF              // n2 is the string length. n2 is kept in span user variable also.
1058+ A7AF              //              Colon_Def EXPECT, "EXPECT", is_normal
1059+ A7AF              //              dw      ACCEPT, DROP            // accept drop
1060+ A7AF              //              dw      EXIT                    // ;
1061+ A7AF
1062+ A7AF              //  ______________________________________________________________________
1063+ A7AF              //
1064+ A7AF              // query        --
1065+ A7AF              // Accept at most 80 character from console. CR stops.
1066+ A7AF              // Text is stored in TIB. Variable IN is zeroed.
1067+ A7AF                              Colon_Def QUERY, "QUERY", is_normal
1067+ A7AF             >                New_Def  QUERY, "QUERY", Enter_Ptr, is_normal ; ok
1067+ A7AF             >
1067+ A7AF             >Dict_Ptr        defl    $
1067+ A7AF             >
1067+ A7AF             >//              ______________________________________________________________________
1067+ A7AF             >//              Heap part
1067+ A7AF             >
1067+ A7AF             >
1067+ A7AF             >                org     (Heap_Ptr & $1FFF) + $E000
1067+ E864             >
1067+ E864             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1067+ E864             >Latest_Definition defl  Heap_Ptr
1067+ E864             >
1067+ E864             >                // dummy db directives used to calculate length of namec
1067+ E864 51 55 45 52 >                db      "QUERY"
1067+ E868 59          >
1067+ E869             >len_NFA         defl    $ - temp_NFA
1067+ E869             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1067+ E864             >
1067+ E864 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1067+ E865 51 55 45 52 >                db      "QUERY"               // name string in 7-bit ascii, but
1067+ E869 59          >
1067+ E86A             >                org     $-1                 // alter last byte of Name just above to set
1067+ E869 D9          >                db      {b $} | END_BIT     // msb as name end
1067+ E86A             >
1067+ E86A 59 08       >                dw      Prev_Ptr            // Link to previous definition Name
1067+ E86C             >Prev_Ptr        defl    Heap_Ptr
1067+ E86C             >
1067+ E86C             >mirror_Ptr      defl    $
1067+ E86C             >
1067+ E86C B1 A7       >                dw      Dict_Ptr + 2        // xt
1067+ E86E             >Heap_Ptr        defl    $ - $E000           // save current HP
1067+ E86E             >
1067+ E86E             >Current_HP      defl  $ - $E000             // used to set HP once!
1067+ E86E             >
1067+ E86E             >//              ______________________________________________________________________
1067+ E86E             >//              Dictionary part
1067+ E86E             >
1067+ E86E             >                org     Dict_Ptr
1067+ A7AF             >
1067+ A7AF 6C 27       >                dw      mirror_Ptr - $E000 + $1F00
1067+ A7B1             >
1067+ A7B1             >QUERY:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1067+ A7B1 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1067+ A7B4             >
1067+ A7B4             >
1067+ A7B4             >                endif           ; ok        // for other definitions it "points" the correct handler
1067+ A7B4             >                // Use of "; ok" to suppress "warning[fwdref]"
1067+ A7B4             >
1067+ A7B4             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1068+ A7B4 36 A2 D9 A0                  dw      TIB, FETCH              // tib @
1069+ A7B8 F3 9A 50 00                  dw      LIT, 80                 // 80
1070+ A7BC 06 A7 60 A0                  dw      ACCEPT, DROP            // accept drop
1071+ A7C0 D1 A1 78 A2                  dw      ZERO, TO_IN, STORE      // 0 >in !
1071+ A7C4 E3 A0
1072+ A7C6 A2 9F                        dw      EXIT                    // ;
1073+ A7C8
1074+ A7C8              //  ______________________________________________________________________
1075+ A7C8              //
1076+ A7C8              // fill        a n c --
1077+ A7C8              // If n > 0, fills n locations starting from address a with the value c.
1078+ A7C8                              New_Def FILL, "FILL", is_code, is_normal
1078+ A7C8             >
1078+ A7C8             >Dict_Ptr        defl    $
1078+ A7C8             >
1078+ A7C8             >//              ______________________________________________________________________
1078+ A7C8             >//              Heap part
1078+ A7C8             >
1078+ A7C8             >
1078+ A7C8             >                org     (Heap_Ptr & $1FFF) + $E000
1078+ E86E             >
1078+ E86E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1078+ E86E             >Latest_Definition defl  Heap_Ptr
1078+ E86E             >
1078+ E86E             >                // dummy db directives used to calculate length of namec
1078+ E86E 46 49 4C 4C >                db      "FILL"
1078+ E872             >len_NFA         defl    $ - temp_NFA
1078+ E872             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1078+ E86E             >
1078+ E86E 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1078+ E86F 46 49 4C 4C >                db      "FILL"               // name string in 7-bit ascii, but
1078+ E873             >                org     $-1                 // alter last byte of Name just above to set
1078+ E872 CC          >                db      {b $} | END_BIT     // msb as name end
1078+ E873             >
1078+ E873 64 08       >                dw      Prev_Ptr            // Link to previous definition Name
1078+ E875             >Prev_Ptr        defl    Heap_Ptr
1078+ E875             >
1078+ E875             >mirror_Ptr      defl    $
1078+ E875             >
1078+ E875 CA A7       >                dw      Dict_Ptr + 2        // xt
1078+ E877             >Heap_Ptr        defl    $ - $E000           // save current HP
1078+ E877             >
1078+ E877             >Current_HP      defl  $ - $E000             // used to set HP once!
1078+ E877             >
1078+ E877             >//              ______________________________________________________________________
1078+ E877             >//              Dictionary part
1078+ E877             >
1078+ E877             >                org     Dict_Ptr
1078+ A7C8             >
1078+ A7C8 75 27       >                dw      mirror_Ptr - $E000 + $1F00
1078+ A7CA             >
1078+ A7CA             >FILL:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1078+ A7CA ~           >                call    runcode ; ok        // for primitive definitions  actual code
1078+ A7CA ~           >
1078+ A7CA ~           >
1078+ A7CA             >                endif           ; ok        // for other definitions it "points" the correct handler
1078+ A7CA             >                // Use of "; ok" to suppress "warning[fwdref]"
1078+ A7CA             >
1078+ A7CA             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1079+ A7CA D9                           exx
1080+ A7CB D1                           pop     de                  // de has character
1081+ A7CC C1                           pop     bc                  // bc has counter
1082+ A7CD E1                           pop     hl                  // hl has address, save Instruction Pointer
1083+ A7CE              Fill_Loop:
1084+ A7CE 78                               ld      a, b
1085+ A7CF B1                               or      c
1086+ A7D0 28 05                        jr      z, Fill_While_End
1087+ A7D2 73                               ld      (hl), e
1088+ A7D3 0B                               dec     bc
1089+ A7D4 23                               inc     hl
1090+ A7D5 18 F7                        jr      Fill_Loop
1091+ A7D7              Fill_While_End:
1092+ A7D7 D9                           exx
1093+ A7D8                              next
1093+ A7D8 DD E9       >                jp      (ix)
1094+ A7DA
1095+ A7DA              //  ______________________________________________________________________
1096+ A7DA              //
1097+ A7DA              // erase        a n --
1098+ A7DA              // If n > 0, fills n locations starting from address a with 'nul' characters.
1099+ A7DA                              Colon_Def ERASE, "ERASE", is_normal
1099+ A7DA             >                New_Def  ERASE, "ERASE", Enter_Ptr, is_normal ; ok
1099+ A7DA             >
1099+ A7DA             >Dict_Ptr        defl    $
1099+ A7DA             >
1099+ A7DA             >//              ______________________________________________________________________
1099+ A7DA             >//              Heap part
1099+ A7DA             >
1099+ A7DA             >
1099+ A7DA             >                org     (Heap_Ptr & $1FFF) + $E000
1099+ E877             >
1099+ E877             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1099+ E877             >Latest_Definition defl  Heap_Ptr
1099+ E877             >
1099+ E877             >                // dummy db directives used to calculate length of namec
1099+ E877 45 52 41 53 >                db      "ERASE"
1099+ E87B 45          >
1099+ E87C             >len_NFA         defl    $ - temp_NFA
1099+ E87C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1099+ E877             >
1099+ E877 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1099+ E878 45 52 41 53 >                db      "ERASE"               // name string in 7-bit ascii, but
1099+ E87C 45          >
1099+ E87D             >                org     $-1                 // alter last byte of Name just above to set
1099+ E87C C5          >                db      {b $} | END_BIT     // msb as name end
1099+ E87D             >
1099+ E87D 6E 08       >                dw      Prev_Ptr            // Link to previous definition Name
1099+ E87F             >Prev_Ptr        defl    Heap_Ptr
1099+ E87F             >
1099+ E87F             >mirror_Ptr      defl    $
1099+ E87F             >
1099+ E87F DC A7       >                dw      Dict_Ptr + 2        // xt
1099+ E881             >Heap_Ptr        defl    $ - $E000           // save current HP
1099+ E881             >
1099+ E881             >Current_HP      defl  $ - $E000             // used to set HP once!
1099+ E881             >
1099+ E881             >//              ______________________________________________________________________
1099+ E881             >//              Dictionary part
1099+ E881             >
1099+ E881             >                org     Dict_Ptr
1099+ A7DA             >
1099+ A7DA 7F 27       >                dw      mirror_Ptr - $E000 + $1F00
1099+ A7DC             >
1099+ A7DC             >ERASE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1099+ A7DC CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1099+ A7DF             >
1099+ A7DF             >
1099+ A7DF             >                endif           ; ok        // for other definitions it "points" the correct handler
1099+ A7DF             >                // Use of "; ok" to suppress "warning[fwdref]"
1099+ A7DF             >
1099+ A7DF             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1100+ A7DF D1 A1 CA A7                  dw      ZERO, FILL              // 0 fill
1101+ A7E3 A2 9F                        dw      EXIT                    // ;
1102+ A7E5
1103+ A7E5              //  ______________________________________________________________________
1104+ A7E5              //
1105+ A7E5              // blank        a n --
1106+ A7E5              // If n > 0, fills n locations starting from address a with 'nul' characters.
1107+ A7E5                              Colon_Def BLANK, "BLANK", is_normal
1107+ A7E5             >                New_Def  BLANK, "BLANK", Enter_Ptr, is_normal ; ok
1107+ A7E5             >
1107+ A7E5             >Dict_Ptr        defl    $
1107+ A7E5             >
1107+ A7E5             >//              ______________________________________________________________________
1107+ A7E5             >//              Heap part
1107+ A7E5             >
1107+ A7E5             >
1107+ A7E5             >                org     (Heap_Ptr & $1FFF) + $E000
1107+ E881             >
1107+ E881             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1107+ E881             >Latest_Definition defl  Heap_Ptr
1107+ E881             >
1107+ E881             >                // dummy db directives used to calculate length of namec
1107+ E881 42 4C 41 4E >                db      "BLANK"
1107+ E885 4B          >
1107+ E886             >len_NFA         defl    $ - temp_NFA
1107+ E886             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1107+ E881             >
1107+ E881 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1107+ E882 42 4C 41 4E >                db      "BLANK"               // name string in 7-bit ascii, but
1107+ E886 4B          >
1107+ E887             >                org     $-1                 // alter last byte of Name just above to set
1107+ E886 CB          >                db      {b $} | END_BIT     // msb as name end
1107+ E887             >
1107+ E887 77 08       >                dw      Prev_Ptr            // Link to previous definition Name
1107+ E889             >Prev_Ptr        defl    Heap_Ptr
1107+ E889             >
1107+ E889             >mirror_Ptr      defl    $
1107+ E889             >
1107+ E889 E7 A7       >                dw      Dict_Ptr + 2        // xt
1107+ E88B             >Heap_Ptr        defl    $ - $E000           // save current HP
1107+ E88B             >
1107+ E88B             >Current_HP      defl  $ - $E000             // used to set HP once!
1107+ E88B             >
1107+ E88B             >//              ______________________________________________________________________
1107+ E88B             >//              Dictionary part
1107+ E88B             >
1107+ E88B             >                org     Dict_Ptr
1107+ A7E5             >
1107+ A7E5 89 27       >                dw      mirror_Ptr - $E000 + $1F00
1107+ A7E7             >
1107+ A7E7             >BLANK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1107+ A7E7 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1107+ A7EA             >
1107+ A7EA             >
1107+ A7EA             >                endif           ; ok        // for other definitions it "points" the correct handler
1107+ A7EA             >                // Use of "; ok" to suppress "warning[fwdref]"
1107+ A7EA             >
1107+ A7EA             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1108+ A7EA F4 A1 CA A7                  dw      BL, FILL                // bl fill
1109+ A7EE A2 9F                        dw      EXIT                    // ;
1110+ A7F0
1111+ A7F0              //  ______________________________________________________________________
1112+ A7F0              //
1113+ A7F0              // hold         c --
1114+ A7F0              // Used between <# and #> to insert a character c in numeric formatting.
1115+ A7F0                              Colon_Def HOLD, "HOLD", is_normal
1115+ A7F0             >                New_Def  HOLD, "HOLD", Enter_Ptr, is_normal ; ok
1115+ A7F0             >
1115+ A7F0             >Dict_Ptr        defl    $
1115+ A7F0             >
1115+ A7F0             >//              ______________________________________________________________________
1115+ A7F0             >//              Heap part
1115+ A7F0             >
1115+ A7F0             >
1115+ A7F0             >                org     (Heap_Ptr & $1FFF) + $E000
1115+ E88B             >
1115+ E88B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1115+ E88B             >Latest_Definition defl  Heap_Ptr
1115+ E88B             >
1115+ E88B             >                // dummy db directives used to calculate length of namec
1115+ E88B 48 4F 4C 44 >                db      "HOLD"
1115+ E88F             >len_NFA         defl    $ - temp_NFA
1115+ E88F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1115+ E88B             >
1115+ E88B 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1115+ E88C 48 4F 4C 44 >                db      "HOLD"               // name string in 7-bit ascii, but
1115+ E890             >                org     $-1                 // alter last byte of Name just above to set
1115+ E88F C4          >                db      {b $} | END_BIT     // msb as name end
1115+ E890             >
1115+ E890 81 08       >                dw      Prev_Ptr            // Link to previous definition Name
1115+ E892             >Prev_Ptr        defl    Heap_Ptr
1115+ E892             >
1115+ E892             >mirror_Ptr      defl    $
1115+ E892             >
1115+ E892 F2 A7       >                dw      Dict_Ptr + 2        // xt
1115+ E894             >Heap_Ptr        defl    $ - $E000           // save current HP
1115+ E894             >
1115+ E894             >Current_HP      defl  $ - $E000             // used to set HP once!
1115+ E894             >
1115+ E894             >//              ______________________________________________________________________
1115+ E894             >//              Dictionary part
1115+ E894             >
1115+ E894             >                org     Dict_Ptr
1115+ A7F0             >
1115+ A7F0 92 27       >                dw      mirror_Ptr - $E000 + $1F00
1115+ A7F2             >
1115+ A7F2             >HOLD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1115+ A7F2 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1115+ A7F5             >
1115+ A7F5             >
1115+ A7F5             >                endif           ; ok        // for other definitions it "points" the correct handler
1115+ A7F5             >                // Use of "; ok" to suppress "warning[fwdref]"
1115+ A7F5             >
1115+ A7F5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1116+ A7F5 ED A1                        dw      NEG_ONE                 // -1
1117+ A7F7 C0 A2 C1 A0                  dw      HLD, PLUSSTORE          // hld +!
1118+ A7FB C0 A2 D9 A0                  dw      HLD, FETCH, CSTORE      // hld @ c!
1118+ A7FF F7 A0
1119+ A801 A2 9F                        dw      EXIT                    // ;
1120+ A803
1121+ A803              //  ______________________________________________________________________
1122+ A803              //
1123+ A803              // pad         -- a
1124+ A803              // leaves the buffer text address. This is at a fixed distance over HERE.
1125+ A803                              Colon_Def PAD, "PAD", is_normal
1125+ A803             >                New_Def  PAD, "PAD", Enter_Ptr, is_normal ; ok
1125+ A803             >
1125+ A803             >Dict_Ptr        defl    $
1125+ A803             >
1125+ A803             >//              ______________________________________________________________________
1125+ A803             >//              Heap part
1125+ A803             >
1125+ A803             >
1125+ A803             >                org     (Heap_Ptr & $1FFF) + $E000
1125+ E894             >
1125+ E894             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1125+ E894             >Latest_Definition defl  Heap_Ptr
1125+ E894             >
1125+ E894             >                // dummy db directives used to calculate length of namec
1125+ E894 50 41 44    >                db      "PAD"
1125+ E897             >len_NFA         defl    $ - temp_NFA
1125+ E897             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1125+ E894             >
1125+ E894 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1125+ E895 50 41 44    >                db      "PAD"               // name string in 7-bit ascii, but
1125+ E898             >                org     $-1                 // alter last byte of Name just above to set
1125+ E897 C4          >                db      {b $} | END_BIT     // msb as name end
1125+ E898             >
1125+ E898 8B 08       >                dw      Prev_Ptr            // Link to previous definition Name
1125+ E89A             >Prev_Ptr        defl    Heap_Ptr
1125+ E89A             >
1125+ E89A             >mirror_Ptr      defl    $
1125+ E89A             >
1125+ E89A 05 A8       >                dw      Dict_Ptr + 2        // xt
1125+ E89C             >Heap_Ptr        defl    $ - $E000           // save current HP
1125+ E89C             >
1125+ E89C             >Current_HP      defl  $ - $E000             // used to set HP once!
1125+ E89C             >
1125+ E89C             >//              ______________________________________________________________________
1125+ E89C             >//              Dictionary part
1125+ E89C             >
1125+ E89C             >                org     Dict_Ptr
1125+ A803             >
1125+ A803 9A 27       >                dw      mirror_Ptr - $E000 + $1F00
1125+ A805             >
1125+ A805             >PAD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1125+ A805 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1125+ A808             >
1125+ A808             >
1125+ A808             >                endif           ; ok        // for other definitions it "points" the correct handler
1125+ A808             >                // Use of "; ok" to suppress "warning[fwdref]"
1125+ A808             >
1125+ A808             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1126+ A808 F6 A2                        dw      HERE                    // here
1127+ A80A F3 9A 44 00                  dw      LIT, 68                 // 68
1128+ A80E F5 9F                        dw      PLUS                    // +
1129+ A810 A2 9F                        dw      EXIT                    // ;
1130+ A812
1131+ A812              //  ______________________________________________________________________
1132+ A812              //
1133+ A812              // word         c -- a
1134+ A812              // reads characters from input streams until it encouners a c delimiter.
1135+ A812              // Stores that packet so it starts from HERE
1136+ A812              // WORD leaves a counter as first byte and ends the packet with two spaces.
1137+ A812              // Other occurrences of c are ignored.
1138+ A812              // If BLK is zero, text is taken from terminal buffer TIB.
1139+ A812              // Otherwise text is taken from the disk-block given by BLK.
1140+ A812              // "in" variable is incremented of the number of character read.
1141+ A812              // The number of characters read is given by ENCLOSE.
1142+ A812                              Colon_Def WORD, "WORD", is_normal
1142+ A812             >                New_Def  WORD, "WORD", Enter_Ptr, is_normal ; ok
1142+ A812             >
1142+ A812             >Dict_Ptr        defl    $
1142+ A812             >
1142+ A812             >//              ______________________________________________________________________
1142+ A812             >//              Heap part
1142+ A812             >
1142+ A812             >
1142+ A812             >                org     (Heap_Ptr & $1FFF) + $E000
1142+ E89C             >
1142+ E89C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1142+ E89C             >Latest_Definition defl  Heap_Ptr
1142+ E89C             >
1142+ E89C             >                // dummy db directives used to calculate length of namec
1142+ E89C 57 4F 52 44 >                db      "WORD"
1142+ E8A0             >len_NFA         defl    $ - temp_NFA
1142+ E8A0             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1142+ E89C             >
1142+ E89C 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1142+ E89D 57 4F 52 44 >                db      "WORD"               // name string in 7-bit ascii, but
1142+ E8A1             >                org     $-1                 // alter last byte of Name just above to set
1142+ E8A0 C4          >                db      {b $} | END_BIT     // msb as name end
1142+ E8A1             >
1142+ E8A1 94 08       >                dw      Prev_Ptr            // Link to previous definition Name
1142+ E8A3             >Prev_Ptr        defl    Heap_Ptr
1142+ E8A3             >
1142+ E8A3             >mirror_Ptr      defl    $
1142+ E8A3             >
1142+ E8A3 14 A8       >                dw      Dict_Ptr + 2        // xt
1142+ E8A5             >Heap_Ptr        defl    $ - $E000           // save current HP
1142+ E8A5             >
1142+ E8A5             >Current_HP      defl  $ - $E000             // used to set HP once!
1142+ E8A5             >
1142+ E8A5             >//              ______________________________________________________________________
1142+ E8A5             >//              Dictionary part
1142+ E8A5             >
1142+ E8A5             >                org     Dict_Ptr
1142+ A812             >
1142+ A812 A3 27       >                dw      mirror_Ptr - $E000 + $1F00
1142+ A814             >
1142+ A814             >WORD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1142+ A814 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1142+ A817             >
1142+ A817             >
1142+ A817             >                endif           ; ok        // for other definitions it "points" the correct handler
1142+ A817             >                // Use of "; ok" to suppress "warning[fwdref]"
1142+ A817             >
1142+ A817             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1143+ A817 72 A2 D9 A0                  dw      BLK, FETCH              // blk @
1144+ A81B                                                              // if
1145+ A81B 45 9B                        dw      ZBRANCH
1146+ A81D 0C 00                        dw      Word_Else - $
1147+ A81F 72 A2 D9 A0                  dw          BLK, FETCH          //      blk @
1148+ A823 29 B0                        dw          BLOCK               //      block ( forward )
1149+ A825                                                              // else
1150+ A825 38 9B                        dw      BRANCH
1151+ A827 06 00                        dw      Word_Endif - $
1152+ A829              Word_Else:
1153+ A829 36 A2 D9 A0                  dw         TIB, FETCH           //      tib @
1154+ A82D              Word_Endif:                                     // endif
1155+ A82D 78 A2 D9 A0                  dw      TO_IN, FETCH, PLUS      // >in @ +
1155+ A831 F5 9F
1156+ A833 74 A0 79 9C                  dw      SWAP, ENCLOSE           // swap enclose
1157+ A837 F6 A2 F3 9A                  dw      HERE, LIT, 34, BLANK    // here 34 blank
1157+ A83B 22 00 E7 A7
1158+ A83F 78 A2 C1 A0                  dw      TO_IN, PLUSSTORE        // >in @ +
1159+ A843 57 A0 35 A3                  dw      OVER, SUBTRACT, TO_R    // over - >r
1159+ A847 AC 9F
1160+ A849 C2 9F F6 A2                  dw      R_OP, HERE, CSTORE      // r here c!
1160+ A84D F7 A0
1161+ A84F F5 9F                        dw      PLUS                    // +
1162+ A851 F6 A2 0E A0                  dw      HERE, ONE_PLUS, R_TO    // here 1+ r>
1162+ A855 B7 9F
1163+ A857 DD 9E                        dw      CMOVE                   // cmove
1164+ A859 F6 A2                        dw      HERE                    // here
1165+ A85B A2 9F                        dw      EXIT                    // ;
1166+ A85D
1167+ A85D              //  ______________________________________________________________________
1168+ A85D              //
1169+ A85D              // (.")         --
1170+ A85D              // Direct procedure compiled by ." and  .(  It executes TYPE.
1171+ A85D                              Colon_Def C_DOT_QUOTE, '(.")', is_normal
1171+ A85D             >                New_Def  C_DOT_QUOTE, '(.")', Enter_Ptr, is_normal ; ok
1171+ A85D             >
1171+ A85D             >Dict_Ptr        defl    $
1171+ A85D             >
1171+ A85D             >//              ______________________________________________________________________
1171+ A85D             >//              Heap part
1171+ A85D             >
1171+ A85D             >
1171+ A85D             >                org     (Heap_Ptr & $1FFF) + $E000
1171+ E8A5             >
1171+ E8A5             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1171+ E8A5             >Latest_Definition defl  Heap_Ptr
1171+ E8A5             >
1171+ E8A5             >                // dummy db directives used to calculate length of namec
1171+ E8A5 28 2E 22 29 >                db      '(.")'
1171+ E8A9             >len_NFA         defl    $ - temp_NFA
1171+ E8A9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1171+ E8A5             >
1171+ E8A5 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1171+ E8A6 28 2E 22 29 >                db      '(.")'               // name string in 7-bit ascii, but
1171+ E8AA             >                org     $-1                 // alter last byte of Name just above to set
1171+ E8A9 A9          >                db      {b $} | END_BIT     // msb as name end
1171+ E8AA             >
1171+ E8AA 9C 08       >                dw      Prev_Ptr            // Link to previous definition Name
1171+ E8AC             >Prev_Ptr        defl    Heap_Ptr
1171+ E8AC             >
1171+ E8AC             >mirror_Ptr      defl    $
1171+ E8AC             >
1171+ E8AC 5F A8       >                dw      Dict_Ptr + 2        // xt
1171+ E8AE             >Heap_Ptr        defl    $ - $E000           // save current HP
1171+ E8AE             >
1171+ E8AE             >Current_HP      defl  $ - $E000             // used to set HP once!
1171+ E8AE             >
1171+ E8AE             >//              ______________________________________________________________________
1171+ E8AE             >//              Dictionary part
1171+ E8AE             >
1171+ E8AE             >                org     Dict_Ptr
1171+ A85D             >
1171+ A85D AC 27       >                dw      mirror_Ptr - $E000 + $1F00
1171+ A85F             >
1171+ A85F             >C_DOT_QUOTE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1171+ A85F CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1171+ A862             >
1171+ A862             >
1171+ A862             >                endif           ; ok        // for other definitions it "points" the correct handler
1171+ A862             >                // Use of "; ok" to suppress "warning[fwdref]"
1171+ A862             >
1171+ A862             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1172+ A862 C2 9F 6E A6                  dw      R_OP, COUNT             // r count
1173+ A866 7B A0 0E A0                  dw      DUP, ONE_PLUS           // dup 1+
1174+ A86A B7 9F F5 9F                  dw      R_TO, PLUS, TO_R        // r> + >r  ( advance IP )
1174+ A86E AC 9F
1175+ A870 C2 A6                        dw      TYPE                    // type
1176+ A872 A2 9F                        dw      EXIT                    // ;
1177+ A874
1178+ A874              //  ______________________________________________________________________
1179+ A874              //
1180+ A874              // char         -- c
1181+ A874              // get first character from next input word
1182+ A874                              Colon_Def CHAR,  "CHAR", is_normal
1182+ A874             >                New_Def  CHAR, "CHAR", Enter_Ptr, is_normal ; ok
1182+ A874             >
1182+ A874             >Dict_Ptr        defl    $
1182+ A874             >
1182+ A874             >//              ______________________________________________________________________
1182+ A874             >//              Heap part
1182+ A874             >
1182+ A874             >
1182+ A874             >                org     (Heap_Ptr & $1FFF) + $E000
1182+ E8AE             >
1182+ E8AE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1182+ E8AE             >Latest_Definition defl  Heap_Ptr
1182+ E8AE             >
1182+ E8AE             >                // dummy db directives used to calculate length of namec
1182+ E8AE 43 48 41 52 >                db      "CHAR"
1182+ E8B2             >len_NFA         defl    $ - temp_NFA
1182+ E8B2             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1182+ E8AE             >
1182+ E8AE 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1182+ E8AF 43 48 41 52 >                db      "CHAR"               // name string in 7-bit ascii, but
1182+ E8B3             >                org     $-1                 // alter last byte of Name just above to set
1182+ E8B2 D2          >                db      {b $} | END_BIT     // msb as name end
1182+ E8B3             >
1182+ E8B3 A5 08       >                dw      Prev_Ptr            // Link to previous definition Name
1182+ E8B5             >Prev_Ptr        defl    Heap_Ptr
1182+ E8B5             >
1182+ E8B5             >mirror_Ptr      defl    $
1182+ E8B5             >
1182+ E8B5 76 A8       >                dw      Dict_Ptr + 2        // xt
1182+ E8B7             >Heap_Ptr        defl    $ - $E000           // save current HP
1182+ E8B7             >
1182+ E8B7             >Current_HP      defl  $ - $E000             // used to set HP once!
1182+ E8B7             >
1182+ E8B7             >//              ______________________________________________________________________
1182+ E8B7             >//              Dictionary part
1182+ E8B7             >
1182+ E8B7             >                org     Dict_Ptr
1182+ A874             >
1182+ A874 B5 27       >                dw      mirror_Ptr - $E000 + $1F00
1182+ A876             >
1182+ A876             >CHAR:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1182+ A876 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1182+ A879             >
1182+ A879             >
1182+ A879             >                endif           ; ok        // for other definitions it "points" the correct handler
1182+ A879             >                // Use of "; ok" to suppress "warning[fwdref]"
1182+ A879             >
1182+ A879             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1183+ A879 F4 A1 14 A8                  dw      BL, WORD                // bl word
1184+ A87D 0E A0 EE A0                  dw      ONE_PLUS, CFETCH        // 1+ c@
1185+ A881 A2 9F                        dw      EXIT                    // ;
1186+ A883
1187+ A883              //  ______________________________________________________________________
1188+ A883              //
1189+ A883              // ,"           --
1190+ A883              // compiles a string terminated by " as a counted string from next input stream
1191+ A883                              Colon_Def COMMA_QUOTE,  ',"', is_normal
1191+ A883             >                New_Def  COMMA_QUOTE, ',"', Enter_Ptr, is_normal ; ok
1191+ A883             >
1191+ A883             >Dict_Ptr        defl    $
1191+ A883             >
1191+ A883             >//              ______________________________________________________________________
1191+ A883             >//              Heap part
1191+ A883             >
1191+ A883             >
1191+ A883             >                org     (Heap_Ptr & $1FFF) + $E000
1191+ E8B7             >
1191+ E8B7             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1191+ E8B7             >Latest_Definition defl  Heap_Ptr
1191+ E8B7             >
1191+ E8B7             >                // dummy db directives used to calculate length of namec
1191+ E8B7 2C 22       >                db      ',"'
1191+ E8B9             >len_NFA         defl    $ - temp_NFA
1191+ E8B9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1191+ E8B7             >
1191+ E8B7 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1191+ E8B8 2C 22       >                db      ',"'               // name string in 7-bit ascii, but
1191+ E8BA             >                org     $-1                 // alter last byte of Name just above to set
1191+ E8B9 A2          >                db      {b $} | END_BIT     // msb as name end
1191+ E8BA             >
1191+ E8BA AE 08       >                dw      Prev_Ptr            // Link to previous definition Name
1191+ E8BC             >Prev_Ptr        defl    Heap_Ptr
1191+ E8BC             >
1191+ E8BC             >mirror_Ptr      defl    $
1191+ E8BC             >
1191+ E8BC 85 A8       >                dw      Dict_Ptr + 2        // xt
1191+ E8BE             >Heap_Ptr        defl    $ - $E000           // save current HP
1191+ E8BE             >
1191+ E8BE             >Current_HP      defl  $ - $E000             // used to set HP once!
1191+ E8BE             >
1191+ E8BE             >//              ______________________________________________________________________
1191+ E8BE             >//              Dictionary part
1191+ E8BE             >
1191+ E8BE             >                org     Dict_Ptr
1191+ A883             >
1191+ A883 BC 27       >                dw      mirror_Ptr - $E000 + $1F00
1191+ A885             >
1191+ A885             >COMMA_QUOTE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1191+ A885 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1191+ A888             >
1191+ A888             >
1191+ A888             >                endif           ; ok        // for other definitions it "points" the correct handler
1191+ A888             >                // Use of "; ok" to suppress "warning[fwdref]"
1191+ A888             >
1191+ A888             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1192+ A888 F3 9A 22 00                  dw      LIT, DQUOTE_CHAR        // [char] "
1193+ A88C 14 A8                        dw      WORD                    // word
1194+ A88E EE A0 0E A0                  dw      CFETCH, ONE_PLUS        // c@ 1+
1195+ A892 01 A3                        dw      ALLOT                   // allot
1196+ A894 D1 A1 1B A3                  dw      ZERO, CCOMMA            // 0 c,  ( nul-terminated string - useful anyway )
1197+ A898 A2 9F                        dw      EXIT
1198+ A89A
1199+ A89A              //  ______________________________________________________________________
1200+ A89A              //
1201+ A89A              // .c           c --
1202+ A89A              // intermediate general purpose string builder, used by ." and .(
1203+ A89A                              Colon_Def DOT_C,  ".C", is_immediate
1203+ A89A             >                New_Def  DOT_C, ".C", Enter_Ptr, is_immediate ; ok
1203+ A89A             >
1203+ A89A             >Dict_Ptr        defl    $
1203+ A89A             >
1203+ A89A             >//              ______________________________________________________________________
1203+ A89A             >//              Heap part
1203+ A89A             >
1203+ A89A             >
1203+ A89A             >                org     (Heap_Ptr & $1FFF) + $E000
1203+ E8BE             >
1203+ E8BE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1203+ E8BE             >Latest_Definition defl  Heap_Ptr
1203+ E8BE             >
1203+ E8BE             >                // dummy db directives used to calculate length of namec
1203+ E8BE 2E 43       >                db      ".C"
1203+ E8C0             >len_NFA         defl    $ - temp_NFA
1203+ E8C0             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1203+ E8BE             >
1203+ E8BE C2          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
1203+ E8BF 2E 43       >                db      ".C"               // name string in 7-bit ascii, but
1203+ E8C1             >                org     $-1                 // alter last byte of Name just above to set
1203+ E8C0 C3          >                db      {b $} | END_BIT     // msb as name end
1203+ E8C1             >
1203+ E8C1 B7 08       >                dw      Prev_Ptr            // Link to previous definition Name
1203+ E8C3             >Prev_Ptr        defl    Heap_Ptr
1203+ E8C3             >
1203+ E8C3             >mirror_Ptr      defl    $
1203+ E8C3             >
1203+ E8C3 9C A8       >                dw      Dict_Ptr + 2        // xt
1203+ E8C5             >Heap_Ptr        defl    $ - $E000           // save current HP
1203+ E8C5             >
1203+ E8C5             >Current_HP      defl  $ - $E000             // used to set HP once!
1203+ E8C5             >
1203+ E8C5             >//              ______________________________________________________________________
1203+ E8C5             >//              Dictionary part
1203+ E8C5             >
1203+ E8C5             >                org     Dict_Ptr
1203+ A89A             >
1203+ A89A C3 27       >                dw      mirror_Ptr - $E000 + $1F00
1203+ A89C             >
1203+ A89C             >DOT_C:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1203+ A89C CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1203+ A89F             >
1203+ A89F             >
1203+ A89F             >                endif           ; ok        // for other definitions it "points" the correct handler
1203+ A89F             >                // Use of "; ok" to suppress "warning[fwdref]"
1203+ A89F             >
1203+ A89F             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1204+ A89F 9C A2 D9 A0                  dw      STATE, FETCH            // state @
1205+ A8A3                                                              // if
1206+ A8A3 45 9B                        dw      ZBRANCH
1207+ A8A5 12 00                        dw      Dot_C_Else - $
1208+ A8A7 A2 A5 5F A8                  dw          COMPILE, C_DOT_QUOTE //     compile (.")
1209+ A8AB 14 A8 EE A0                  dw          WORD, CFETCH        //      word c@
1210+ A8AF 0E A0 01 A3                  dw          ONE_PLUS, ALLOT     //      1+ allot
1211+ A8B3                                                              // else
1212+ A8B3 38 9B                        dw      BRANCH
1213+ A8B5 08 00                        dw      Dot_C_Endif - $
1214+ A8B7              Dot_C_Else:
1215+ A8B7 14 A8 6E A6                  dw          WORD, COUNT, TYPE   //      word count type
1215+ A8BB C2 A6
1216+ A8BD              Dot_C_Endif:                                    // endif
1217+ A8BD A2 9F                        dw      EXIT                    ;
1218+ A8BF
1219+ A8BF              //  ______________________________________________________________________
1220+ A8BF              //
1221+ A8BF              // ."           c --
1222+ A8BF                              Colon_Def DOT_QUOTE,  '."', is_immediate
1222+ A8BF             >                New_Def  DOT_QUOTE, '."', Enter_Ptr, is_immediate ; ok
1222+ A8BF             >
1222+ A8BF             >Dict_Ptr        defl    $
1222+ A8BF             >
1222+ A8BF             >//              ______________________________________________________________________
1222+ A8BF             >//              Heap part
1222+ A8BF             >
1222+ A8BF             >
1222+ A8BF             >                org     (Heap_Ptr & $1FFF) + $E000
1222+ E8C5             >
1222+ E8C5             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1222+ E8C5             >Latest_Definition defl  Heap_Ptr
1222+ E8C5             >
1222+ E8C5             >                // dummy db directives used to calculate length of namec
1222+ E8C5 2E 22       >                db      '."'
1222+ E8C7             >len_NFA         defl    $ - temp_NFA
1222+ E8C7             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1222+ E8C5             >
1222+ E8C5 C2          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
1222+ E8C6 2E 22       >                db      '."'               // name string in 7-bit ascii, but
1222+ E8C8             >                org     $-1                 // alter last byte of Name just above to set
1222+ E8C7 A2          >                db      {b $} | END_BIT     // msb as name end
1222+ E8C8             >
1222+ E8C8 BE 08       >                dw      Prev_Ptr            // Link to previous definition Name
1222+ E8CA             >Prev_Ptr        defl    Heap_Ptr
1222+ E8CA             >
1222+ E8CA             >mirror_Ptr      defl    $
1222+ E8CA             >
1222+ E8CA C1 A8       >                dw      Dict_Ptr + 2        // xt
1222+ E8CC             >Heap_Ptr        defl    $ - $E000           // save current HP
1222+ E8CC             >
1222+ E8CC             >Current_HP      defl  $ - $E000             // used to set HP once!
1222+ E8CC             >
1222+ E8CC             >//              ______________________________________________________________________
1222+ E8CC             >//              Dictionary part
1222+ E8CC             >
1222+ E8CC             >                org     Dict_Ptr
1222+ A8BF             >
1222+ A8BF CA 27       >                dw      mirror_Ptr - $E000 + $1F00
1222+ A8C1             >
1222+ A8C1             >DOT_QUOTE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1222+ A8C1 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1222+ A8C4             >
1222+ A8C4             >
1222+ A8C4             >                endif           ; ok        // for other definitions it "points" the correct handler
1222+ A8C4             >                // Use of "; ok" to suppress "warning[fwdref]"
1222+ A8C4             >
1222+ A8C4             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1223+ A8C4 F3 9A 22 00                  dw      LIT, DQUOTE_CHAR        // [char] "
1224+ A8C8 9C A8                        dw      DOT_C                   // [compile] .c
1225+ A8CA A2 9F                        dw      EXIT                    // ; immediate
1226+ A8CC
1227+ A8CC              //  ______________________________________________________________________
1228+ A8CC              //
1229+ A8CC              // .(           c --
1230+ A8CC                              Colon_Def DOT_BRACKET,  ".(", is_immediate
1230+ A8CC             >                New_Def  DOT_BRACKET, ".(", Enter_Ptr, is_immediate ; ok
1230+ A8CC             >
1230+ A8CC             >Dict_Ptr        defl    $
1230+ A8CC             >
1230+ A8CC             >//              ______________________________________________________________________
1230+ A8CC             >//              Heap part
1230+ A8CC             >
1230+ A8CC             >
1230+ A8CC             >                org     (Heap_Ptr & $1FFF) + $E000
1230+ E8CC             >
1230+ E8CC             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1230+ E8CC             >Latest_Definition defl  Heap_Ptr
1230+ E8CC             >
1230+ E8CC             >                // dummy db directives used to calculate length of namec
1230+ E8CC 2E 28       >                db      ".("
1230+ E8CE             >len_NFA         defl    $ - temp_NFA
1230+ E8CE             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1230+ E8CC             >
1230+ E8CC C2          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
1230+ E8CD 2E 28       >                db      ".("               // name string in 7-bit ascii, but
1230+ E8CF             >                org     $-1                 // alter last byte of Name just above to set
1230+ E8CE A8          >                db      {b $} | END_BIT     // msb as name end
1230+ E8CF             >
1230+ E8CF C5 08       >                dw      Prev_Ptr            // Link to previous definition Name
1230+ E8D1             >Prev_Ptr        defl    Heap_Ptr
1230+ E8D1             >
1230+ E8D1             >mirror_Ptr      defl    $
1230+ E8D1             >
1230+ E8D1 CE A8       >                dw      Dict_Ptr + 2        // xt
1230+ E8D3             >Heap_Ptr        defl    $ - $E000           // save current HP
1230+ E8D3             >
1230+ E8D3             >Current_HP      defl  $ - $E000             // used to set HP once!
1230+ E8D3             >
1230+ E8D3             >//              ______________________________________________________________________
1230+ E8D3             >//              Dictionary part
1230+ E8D3             >
1230+ E8D3             >                org     Dict_Ptr
1230+ A8CC             >
1230+ A8CC D1 27       >                dw      mirror_Ptr - $E000 + $1F00
1230+ A8CE             >
1230+ A8CE             >DOT_BRACKET:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1230+ A8CE CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1230+ A8D1             >
1230+ A8D1             >
1230+ A8D1             >                endif           ; ok        // for other definitions it "points" the correct handler
1230+ A8D1             >                // Use of "; ok" to suppress "warning[fwdref]"
1230+ A8D1             >
1230+ A8D1             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1231+ A8D1 F3 9A 29 00                  dw      LIT, ")"                // [char] )
1232+ A8D5 9C A8                        dw      DOT_C                   // [compile] .c
1233+ A8D7 A2 9F                        dw      EXIT                    // ; immediate
1234+ A8D9
1235+ A8D9              //  ______________________________________________________________________
1236+ A8D9              //
1237+ A8D9              // (sgn)        a -- a f
1238+ A8D9              // determines if char in addr a is a sign (+ or -), and in that case increments
1239+ A8D9              // a flag. Returns f as the sign, true for negative, false for positive.
1240+ A8D9              // called by NUMBER and (EXP)
1241+ A8D9                              Colon_Def CSGN,  "(SGN)", is_normal
1241+ A8D9             >                New_Def  CSGN, "(SGN)", Enter_Ptr, is_normal ; ok
1241+ A8D9             >
1241+ A8D9             >Dict_Ptr        defl    $
1241+ A8D9             >
1241+ A8D9             >//              ______________________________________________________________________
1241+ A8D9             >//              Heap part
1241+ A8D9             >
1241+ A8D9             >
1241+ A8D9             >                org     (Heap_Ptr & $1FFF) + $E000
1241+ E8D3             >
1241+ E8D3             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1241+ E8D3             >Latest_Definition defl  Heap_Ptr
1241+ E8D3             >
1241+ E8D3             >                // dummy db directives used to calculate length of namec
1241+ E8D3 28 53 47 4E >                db      "(SGN)"
1241+ E8D7 29          >
1241+ E8D8             >len_NFA         defl    $ - temp_NFA
1241+ E8D8             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1241+ E8D3             >
1241+ E8D3 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1241+ E8D4 28 53 47 4E >                db      "(SGN)"               // name string in 7-bit ascii, but
1241+ E8D8 29          >
1241+ E8D9             >                org     $-1                 // alter last byte of Name just above to set
1241+ E8D8 A9          >                db      {b $} | END_BIT     // msb as name end
1241+ E8D9             >
1241+ E8D9 CC 08       >                dw      Prev_Ptr            // Link to previous definition Name
1241+ E8DB             >Prev_Ptr        defl    Heap_Ptr
1241+ E8DB             >
1241+ E8DB             >mirror_Ptr      defl    $
1241+ E8DB             >
1241+ E8DB DB A8       >                dw      Dict_Ptr + 2        // xt
1241+ E8DD             >Heap_Ptr        defl    $ - $E000           // save current HP
1241+ E8DD             >
1241+ E8DD             >Current_HP      defl  $ - $E000             // used to set HP once!
1241+ E8DD             >
1241+ E8DD             >//              ______________________________________________________________________
1241+ E8DD             >//              Dictionary part
1241+ E8DD             >
1241+ E8DD             >                org     Dict_Ptr
1241+ A8D9             >
1241+ A8D9 DB 27       >                dw      mirror_Ptr - $E000 + $1F00
1241+ A8DB             >
1241+ A8DB             >CSGN:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1241+ A8DB CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1241+ A8DE             >
1241+ A8DE             >
1241+ A8DE             >                endif           ; ok        // for other definitions it "points" the correct handler
1241+ A8DE             >                // Use of "; ok" to suppress "warning[fwdref]"
1241+ A8DE             >
1241+ A8DE             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1242+ A8DE 7B A0 0E A0                  dw      DUP, ONE_PLUS, CFETCH   // dup 1+ c@
1242+ A8E2 EE A0
1243+ A8E4 7B A0 F3 9A                  dw      DUP, LIT, "-", EQUALS   // dup [char] - =
1243+ A8E8 2D 00 41 A3
1244+ A8EC                                                              // if
1245+ A8EC 45 9B                        dw      ZBRANCH
1246+ A8EE 12 00                        dw      CSgn_Else_0 - $
1247+ A8F0 60 A0                        dw          DROP                //      drop
1248+ A8F2 0E A0                        dw          ONE_PLUS            //      1+
1249+ A8F4 D8 A1 A8 A2                  dw          ONE, DPL, PLUSSTORE //      1 dpl +!
1249+ A8F8 C1 A0
1250+ A8FA D8 A1                        dw          ONE                 //      1
1251+ A8FC                                                              // else
1252+ A8FC 38 9B                        dw      BRANCH
1253+ A8FE 16 00                        dw      CSgn_Endif_0 - $
1254+ A900              CSgn_Else_0:
1255+ A900 F3 9A 2B 00                  dw          LIT, "+", EQUALS    //      [char] + =
1255+ A904 41 A3
1256+ A906                                                              //      if
1257+ A906 45 9B                        dw          ZBRANCH
1258+ A908 0A 00                        dw          CSgn_Endif_1 - $
1259+ A90A 0E A0                        dw              ONE_PLUS        //          1+
1260+ A90C D8 A1 A8 A2                  dw              ONE, DPL        //          1 dpl
1261+ A910 C1 A0                        dw              PLUSSTORE       //          +!
1262+ A912              CSgn_Endif_1                                    //      endif
1263+ A912 D1 A1                        dw          ZERO                //      0
1264+ A914              CSgn_Endif_0:                                   // endif
1265+ A914 A2 9F                        dw      EXIT
1266+ A916
1267+ A916              //  ______________________________________________________________________
1268+ A916              //
1269+ A916              // (number)     d a -- d1 a1
1270+ A916              // using the current BASE parse characters stored in address a
1271+ A916              // accumulating a double precision integer d
1272+ A916              // the process stops at the first not-convertible character
1273+ A916              // A double-number is kept in CPU registers as HLDE.
1274+ A916              // On the stack a double number is treated as two single numbers
1275+ A916              // where HL is on the top of the stack and DE is the second from top,
1276+ A916              // so in the stack memory it appears as LHED.
1277+ A916              // Instead, in 2VARIABLE a double number is stored as EDLH.
1278+ A916                              Colon_Def CNUMBER,  "(NUMBER)", is_normal
1278+ A916             >                New_Def  CNUMBER, "(NUMBER)", Enter_Ptr, is_normal ; ok
1278+ A916             >
1278+ A916             >Dict_Ptr        defl    $
1278+ A916             >
1278+ A916             >//              ______________________________________________________________________
1278+ A916             >//              Heap part
1278+ A916             >
1278+ A916             >
1278+ A916             >                org     (Heap_Ptr & $1FFF) + $E000
1278+ E8DD             >
1278+ E8DD             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1278+ E8DD             >Latest_Definition defl  Heap_Ptr
1278+ E8DD             >
1278+ E8DD             >                // dummy db directives used to calculate length of namec
1278+ E8DD 28 4E 55 4D >                db      "(NUMBER)"
1278+ E8E1 42 45 52 29 >
1278+ E8E5             >len_NFA         defl    $ - temp_NFA
1278+ E8E5             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1278+ E8DD             >
1278+ E8DD 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1278+ E8DE 28 4E 55 4D >                db      "(NUMBER)"               // name string in 7-bit ascii, but
1278+ E8E2 42 45 52 29 >
1278+ E8E6             >                org     $-1                 // alter last byte of Name just above to set
1278+ E8E5 A9          >                db      {b $} | END_BIT     // msb as name end
1278+ E8E6             >
1278+ E8E6 D3 08       >                dw      Prev_Ptr            // Link to previous definition Name
1278+ E8E8             >Prev_Ptr        defl    Heap_Ptr
1278+ E8E8             >
1278+ E8E8             >mirror_Ptr      defl    $
1278+ E8E8             >
1278+ E8E8 18 A9       >                dw      Dict_Ptr + 2        // xt
1278+ E8EA             >Heap_Ptr        defl    $ - $E000           // save current HP
1278+ E8EA             >
1278+ E8EA             >Current_HP      defl  $ - $E000             // used to set HP once!
1278+ E8EA             >
1278+ E8EA             >//              ______________________________________________________________________
1278+ E8EA             >//              Dictionary part
1278+ E8EA             >
1278+ E8EA             >                org     Dict_Ptr
1278+ A916             >
1278+ A916 E8 27       >                dw      mirror_Ptr - $E000 + $1F00
1278+ A918             >
1278+ A918             >CNUMBER:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1278+ A918 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1278+ A91B             >
1278+ A91B             >
1278+ A91B             >                endif           ; ok        // for other definitions it "points" the correct handler
1278+ A91B             >                // Use of "; ok" to suppress "warning[fwdref]"
1278+ A91B             >
1278+ A91B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1279+ A91B                                                              // begin
1280+ A91B              CNumber_Begin:
1281+ A91B 0E A0                        dw          ONE_PLUS            //      1+
1282+ A91D 7B A0 AC 9F                  dw          DUP, TO_R           //      dup >r
1283+ A921 EE A0                        dw          CFETCH              //      @
1284+ A923 A2 A2 D9 A0                  dw          BASE, FETCH         //      base @
1285+ A927 9D 9B                        dw          DIGIT               //      digit
1286+ A929                                                              // while
1287+ A929 45 9B                        dw      ZBRANCH
1288+ A92B 2C 00                        dw      CNumber_While_end - $
1289+ A92D 74 A0                        dw          SWAP                //      swap
1290+ A92F A2 A2 D9 A0                  dw          BASE, FETCH         //      base @
1291+ A933 01 9F                        dw          UM_MUL              //      um*
1292+ A935 60 A0 82 A0                  dw          DROP, ROT           //      drop rot
1293+ A939 A2 A2 D9 A0                  dw          BASE, FETCH         //      base @
1294+ A93D 01 9F                        dw          UM_MUL              //      um*
1295+ A93F FF 9F                        dw          DPLUS               //      d+
1296+ A941 A8 A2 D9 A0                  dw          DPL, FETCH          //      dpl @
1297+ A945 0E A0                        dw          ONE_PLUS            //      1+
1298+ A947                                                              //      if
1299+ A947 45 9B                        dw          ZBRANCH
1300+ A949 08 00                        dw          CNumber_Endif - $
1301+ A94B D8 A1 A8 A2                  dw              ONE, DPL        //          1 dpl
1302+ A94F C1 A0                        dw              PLUSSTORE       //          +!
1303+ A951              CNumber_Endif:                                  //      endif
1304+ A951 B7 9F                        dw             R_TO             //      r>  ( balance rp )
1305+ A953 38 9B                        dw      BRANCH
1306+ A955 C6 FF                        dw      CNumber_Begin - $
1307+ A957              CNumber_While_end:                              // repeat
1308+ A957 B7 9F                        dw      R_TO                    // r>  ( balance rp on exit while-repeat )
1309+ A959 A2 9F                        dw      EXIT                    // ;
1310+ A95B
1311+ A95B              //  ______________________________________________________________________
1312+ A95B              //
1313+ A95B              // number       a -- d
1314+ A95B                              Colon_Def NUMBER,  "NUMBER", is_normal
1314+ A95B             >                New_Def  NUMBER, "NUMBER", Enter_Ptr, is_normal ; ok
1314+ A95B             >
1314+ A95B             >Dict_Ptr        defl    $
1314+ A95B             >
1314+ A95B             >//              ______________________________________________________________________
1314+ A95B             >//              Heap part
1314+ A95B             >
1314+ A95B             >
1314+ A95B             >                org     (Heap_Ptr & $1FFF) + $E000
1314+ E8EA             >
1314+ E8EA             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1314+ E8EA             >Latest_Definition defl  Heap_Ptr
1314+ E8EA             >
1314+ E8EA             >                // dummy db directives used to calculate length of namec
1314+ E8EA 4E 55 4D 42 >                db      "NUMBER"
1314+ E8EE 45 52       >
1314+ E8F0             >len_NFA         defl    $ - temp_NFA
1314+ E8F0             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1314+ E8EA             >
1314+ E8EA 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1314+ E8EB 4E 55 4D 42 >                db      "NUMBER"               // name string in 7-bit ascii, but
1314+ E8EF 45 52       >
1314+ E8F1             >                org     $-1                 // alter last byte of Name just above to set
1314+ E8F0 D2          >                db      {b $} | END_BIT     // msb as name end
1314+ E8F1             >
1314+ E8F1 DD 08       >                dw      Prev_Ptr            // Link to previous definition Name
1314+ E8F3             >Prev_Ptr        defl    Heap_Ptr
1314+ E8F3             >
1314+ E8F3             >mirror_Ptr      defl    $
1314+ E8F3             >
1314+ E8F3 5D A9       >                dw      Dict_Ptr + 2        // xt
1314+ E8F5             >Heap_Ptr        defl    $ - $E000           // save current HP
1314+ E8F5             >
1314+ E8F5             >Current_HP      defl  $ - $E000             // used to set HP once!
1314+ E8F5             >
1314+ E8F5             >//              ______________________________________________________________________
1314+ E8F5             >//              Dictionary part
1314+ E8F5             >
1314+ E8F5             >                org     Dict_Ptr
1314+ A95B             >
1314+ A95B F3 27       >                dw      mirror_Ptr - $E000 + $1F00
1314+ A95D             >
1314+ A95D             >NUMBER:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1314+ A95D CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1314+ A960             >
1314+ A960             >
1314+ A960             >                endif           ; ok        // for other definitions it "points" the correct handler
1314+ A960             >                // Use of "; ok" to suppress "warning[fwdref]"
1314+ A960             >
1314+ A960             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1315+ A960 D1 A1 D1 A1                  dw      ZERO, ZERO              // 0 0
1316+ A964 82 A0                        dw      ROT                     // rot
1317+ A966 DB A8 AC 9F                  dw      CSGN, TO_R              // (sgn) >r
1318+ A96A ED A1 A8 A2                  dw      NEG_ONE, DPL, STORE     // -1 dpl !
1318+ A96E E3 A0
1319+ A970 18 A9                        dw      CNUMBER                 // (number)
1320+ A972 7B A0 EE A0                  dw      DUP, CFETCH             // dup c@
1321+ A976 F3 9A 2E 00                  dw      LIT, 46, EQUALS         // [char] . =  ( decimal point )
1321+ A97A 41 A3
1322+ A97C                                                              // if
1323+ A97C 45 9B                        dw      ZBRANCH
1324+ A97E 0A 00                        dw      Number_Endif_1 - $
1325+ A980 D1 A1 A8 A2                  dw          ZERO, DPL, STORE    //      0 dpl !
1325+ A984 E3 A0
1326+ A986 18 A9                        dw          CNUMBER             //      (number)
1327+ A988              Number_Endif_1:                                 // endif
1328+ A988 EE A0 F4 A1                  dw      CFETCH, BL              // c@ bl
1329+ A98C 35 A3 D1 A1                  dw      SUBTRACT, ZERO, QERROR  // - 0 ?error
1329+ A990 32 A5
1330+ A992 B7 9F                        dw      R_TO                    // r>
1331+ A994                                                              // if
1332+ A994 45 9B                        dw      ZBRANCH
1333+ A996 04 00                        dw      Number_Endif_2 - $
1334+ A998 44 A0                        dw          DMINUS              //      dminus
1335+ A99A              Number_Endif_2:                                 // endif
1336+ A99A A2 9F                        dw      EXIT                    // ;
1337+ A99C
1338+ A99C              //  ______________________________________________________________________
1339+ A99C              //
1340+ A99C              // twofind      a -- d
1341+ A99C                              Colon_Def TWOFIND,  "2FIND", is_normal
1341+ A99C             >                New_Def  TWOFIND, "2FIND", Enter_Ptr, is_normal ; ok
1341+ A99C             >
1341+ A99C             >Dict_Ptr        defl    $
1341+ A99C             >
1341+ A99C             >//              ______________________________________________________________________
1341+ A99C             >//              Heap part
1341+ A99C             >
1341+ A99C             >
1341+ A99C             >                org     (Heap_Ptr & $1FFF) + $E000
1341+ E8F5             >
1341+ E8F5             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1341+ E8F5             >Latest_Definition defl  Heap_Ptr
1341+ E8F5             >
1341+ E8F5             >                // dummy db directives used to calculate length of namec
1341+ E8F5 32 46 49 4E >                db      "2FIND"
1341+ E8F9 44          >
1341+ E8FA             >len_NFA         defl    $ - temp_NFA
1341+ E8FA             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1341+ E8F5             >
1341+ E8F5 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1341+ E8F6 32 46 49 4E >                db      "2FIND"               // name string in 7-bit ascii, but
1341+ E8FA 44          >
1341+ E8FB             >                org     $-1                 // alter last byte of Name just above to set
1341+ E8FA C4          >                db      {b $} | END_BIT     // msb as name end
1341+ E8FB             >
1341+ E8FB EA 08       >                dw      Prev_Ptr            // Link to previous definition Name
1341+ E8FD             >Prev_Ptr        defl    Heap_Ptr
1341+ E8FD             >
1341+ E8FD             >mirror_Ptr      defl    $
1341+ E8FD             >
1341+ E8FD 9E A9       >                dw      Dict_Ptr + 2        // xt
1341+ E8FF             >Heap_Ptr        defl    $ - $E000           // save current HP
1341+ E8FF             >
1341+ E8FF             >Current_HP      defl  $ - $E000             // used to set HP once!
1341+ E8FF             >
1341+ E8FF             >//              ______________________________________________________________________
1341+ E8FF             >//              Dictionary part
1341+ E8FF             >
1341+ E8FF             >                org     Dict_Ptr
1341+ A99C             >
1341+ A99C FD 27       >                dw      mirror_Ptr - $E000 + $1F00
1341+ A99E             >
1341+ A99E             >TWOFIND:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1341+ A99E CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1341+ A9A1             >
1341+ A9A1             >
1341+ A9A1             >                endif           ; ok        // for other definitions it "points" the correct handler
1341+ A9A1             >                // Use of "; ok" to suppress "warning[fwdref]"
1341+ A9A1             >
1341+ A9A1             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1342+ A9A1 AC 9F C2 9F                  dw      TO_R, R_OP              // >r r@
1343+ A9A5 90 A2 D9 A0                  dw      CONTEXT, FETCH, FETCH   // context @ @
1343+ A9A9 D9 A0
1344+ A9AB 0B 9C                        dw      C_FIND                  // (find)
1345+ A9AD A0 A3                        dw      QDUP                    // ?dup
1346+ A9AF C7 9F                        dw      ZEQUAL                  // 0=
1347+ A9B1                                                              // if
1348+ A9B1 45 9B                        dw      ZBRANCH
1349+ A9B3 0C 00                        dw      LFind_Endif - $
1350+ A9B5 C2 9F                        dw          R_OP                //      r@
1351+ A9B7                              // dw          LATEST               //      latest
1352+ A9B7 96 A2 D9 A0                  dw          CURRENT, FETCH, FETCH   // context @ @
1352+ A9BB D9 A0
1353+ A9BD 0B 9C                        dw          C_FIND              //      (find)
1354+ A9BF              LFind_Endif:                                    // endif
1355+ A9BF B7 9F 60 A0                  dw      R_TO, DROP              // r> drop
1356+ A9C3 A2 9F                        dw      EXIT                    // ;
1357+ A9C5
1358+ A9C5              //  ______________________________________________________________________
1359+ A9C5              //
1360+ A9C5              // -find        a -- d
1361+ A9C5                              Colon_Def LFIND,  "-FIND", is_normal
1361+ A9C5             >                New_Def  LFIND, "-FIND", Enter_Ptr, is_normal ; ok
1361+ A9C5             >
1361+ A9C5             >Dict_Ptr        defl    $
1361+ A9C5             >
1361+ A9C5             >//              ______________________________________________________________________
1361+ A9C5             >//              Heap part
1361+ A9C5             >
1361+ A9C5             >
1361+ A9C5             >                org     (Heap_Ptr & $1FFF) + $E000
1361+ E8FF             >
1361+ E8FF             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1361+ E8FF             >Latest_Definition defl  Heap_Ptr
1361+ E8FF             >
1361+ E8FF             >                // dummy db directives used to calculate length of namec
1361+ E8FF 2D 46 49 4E >                db      "-FIND"
1361+ E903 44          >
1361+ E904             >len_NFA         defl    $ - temp_NFA
1361+ E904             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1361+ E8FF             >
1361+ E8FF 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1361+ E900 2D 46 49 4E >                db      "-FIND"               // name string in 7-bit ascii, but
1361+ E904 44          >
1361+ E905             >                org     $-1                 // alter last byte of Name just above to set
1361+ E904 C4          >                db      {b $} | END_BIT     // msb as name end
1361+ E905             >
1361+ E905 F5 08       >                dw      Prev_Ptr            // Link to previous definition Name
1361+ E907             >Prev_Ptr        defl    Heap_Ptr
1361+ E907             >
1361+ E907             >mirror_Ptr      defl    $
1361+ E907             >
1361+ E907 C7 A9       >                dw      Dict_Ptr + 2        // xt
1361+ E909             >Heap_Ptr        defl    $ - $E000           // save current HP
1361+ E909             >
1361+ E909             >Current_HP      defl  $ - $E000             // used to set HP once!
1361+ E909             >
1361+ E909             >//              ______________________________________________________________________
1361+ E909             >//              Dictionary part
1361+ E909             >
1361+ E909             >                org     Dict_Ptr
1361+ A9C5             >
1361+ A9C5 07 28       >                dw      mirror_Ptr - $E000 + $1F00
1361+ A9C7             >
1361+ A9C7             >LFIND:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1361+ A9C7 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1361+ A9CA             >
1361+ A9CA             >
1361+ A9CA             >                endif           ; ok        // for other definitions it "points" the correct handler
1361+ A9CA             >                // Use of "; ok" to suppress "warning[fwdref]"
1361+ A9CA             >
1361+ A9CA             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1362+ A9CA F4 A1 14 A8                  dw      BL, WORD                // bl word
1363+ A9CE 9E A9                        dw      TWOFIND                 // 2find
1364+ A9D0 A2 9F                        dw      EXIT                    // ;
1365+ A9D2
1366+ A9D2              //  ______________________________________________________________________
1367+ A9D2              //
1368+ A9D2              // (abort)      --
1369+ A9D2                              Colon_Def CABORT,  "(ABORT)", is_normal
1369+ A9D2             >                New_Def  CABORT, "(ABORT)", Enter_Ptr, is_normal ; ok
1369+ A9D2             >
1369+ A9D2             >Dict_Ptr        defl    $
1369+ A9D2             >
1369+ A9D2             >//              ______________________________________________________________________
1369+ A9D2             >//              Heap part
1369+ A9D2             >
1369+ A9D2             >
1369+ A9D2             >                org     (Heap_Ptr & $1FFF) + $E000
1369+ E909             >
1369+ E909             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1369+ E909             >Latest_Definition defl  Heap_Ptr
1369+ E909             >
1369+ E909             >                // dummy db directives used to calculate length of namec
1369+ E909 28 41 42 4F >                db      "(ABORT)"
1369+ E90D 52 54 29    >
1369+ E910             >len_NFA         defl    $ - temp_NFA
1369+ E910             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1369+ E909             >
1369+ E909 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1369+ E90A 28 41 42 4F >                db      "(ABORT)"               // name string in 7-bit ascii, but
1369+ E90E 52 54 29    >
1369+ E911             >                org     $-1                 // alter last byte of Name just above to set
1369+ E910 A9          >                db      {b $} | END_BIT     // msb as name end
1369+ E911             >
1369+ E911 FF 08       >                dw      Prev_Ptr            // Link to previous definition Name
1369+ E913             >Prev_Ptr        defl    Heap_Ptr
1369+ E913             >
1369+ E913             >mirror_Ptr      defl    $
1369+ E913             >
1369+ E913 D4 A9       >                dw      Dict_Ptr + 2        // xt
1369+ E915             >Heap_Ptr        defl    $ - $E000           // save current HP
1369+ E915             >
1369+ E915             >Current_HP      defl  $ - $E000             // used to set HP once!
1369+ E915             >
1369+ E915             >//              ______________________________________________________________________
1369+ E915             >//              Dictionary part
1369+ E915             >
1369+ E915             >                org     Dict_Ptr
1369+ A9D2             >
1369+ A9D2 13 28       >                dw      mirror_Ptr - $E000 + $1F00
1369+ A9D4             >
1369+ A9D4             >CABORT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1369+ A9D4 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1369+ A9D7             >
1369+ A9D7             >
1369+ A9D7             >                endif           ; ok        // for other definitions it "points" the correct handler
1369+ A9D7             >                // Use of "; ok" to suppress "warning[fwdref]"
1369+ A9D7             >
1369+ A9D7             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1370+ A9D7 67 AC                        dw      ABORT                   // abort
1371+ A9D9 A2 9F                        dw      EXIT                    // ;
1372+ A9DB
1373+ A9DB              //  ______________________________________________________________________
1374+ A9DB              //
1375+ A9DB              // error        n --
1376+ A9DB              // raise an error
1377+ A9DB              // if WARNING is 0, prints "MSG#n".
1378+ A9DB              // if WARNING is 1, prints line n of screen 4.
1379+ A9DB              // if WARNING is -1 does (ABORT) that normally does ABORT
1380+ A9DB              // value can be negative or beyond block 4.
1381+ A9DB                              Colon_Def ERROR,  "ERROR", is_normal
1381+ A9DB             >                New_Def  ERROR, "ERROR", Enter_Ptr, is_normal ; ok
1381+ A9DB             >
1381+ A9DB             >Dict_Ptr        defl    $
1381+ A9DB             >
1381+ A9DB             >//              ______________________________________________________________________
1381+ A9DB             >//              Heap part
1381+ A9DB             >
1381+ A9DB             >
1381+ A9DB             >                org     (Heap_Ptr & $1FFF) + $E000
1381+ E915             >
1381+ E915             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1381+ E915             >Latest_Definition defl  Heap_Ptr
1381+ E915             >
1381+ E915             >                // dummy db directives used to calculate length of namec
1381+ E915 45 52 52 4F >                db      "ERROR"
1381+ E919 52          >
1381+ E91A             >len_NFA         defl    $ - temp_NFA
1381+ E91A             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1381+ E915             >
1381+ E915 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1381+ E916 45 52 52 4F >                db      "ERROR"               // name string in 7-bit ascii, but
1381+ E91A 52          >
1381+ E91B             >                org     $-1                 // alter last byte of Name just above to set
1381+ E91A D2          >                db      {b $} | END_BIT     // msb as name end
1381+ E91B             >
1381+ E91B 09 09       >                dw      Prev_Ptr            // Link to previous definition Name
1381+ E91D             >Prev_Ptr        defl    Heap_Ptr
1381+ E91D             >
1381+ E91D             >mirror_Ptr      defl    $
1381+ E91D             >
1381+ E91D DD A9       >                dw      Dict_Ptr + 2        // xt
1381+ E91F             >Heap_Ptr        defl    $ - $E000           // save current HP
1381+ E91F             >
1381+ E91F             >Current_HP      defl  $ - $E000             // used to set HP once!
1381+ E91F             >
1381+ E91F             >//              ______________________________________________________________________
1381+ E91F             >//              Dictionary part
1381+ E91F             >
1381+ E91F             >                org     Dict_Ptr
1381+ A9DB             >
1381+ A9DB 1D 28       >                dw      mirror_Ptr - $E000 + $1F00
1381+ A9DD             >
1381+ A9DD             >ERROR:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1381+ A9DD CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1381+ A9E0             >
1381+ A9E0             >
1381+ A9E0             >                endif           ; ok        // for other definitions it "points" the correct handler
1381+ A9E0             >                // Use of "; ok" to suppress "warning[fwdref]"
1381+ A9E0             >
1381+ A9E0             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1382+ A9E0 42 A2 D9 A0                  dw      WARNING, FETCH, ZLESS   // warning @ 0<
1382+ A9E4 DA 9F
1383+ A9E6                                                              // if
1384+ A9E6 45 9B                        dw      ZBRANCH
1385+ A9E8 04 00                        dw      Error_Endif_1 - $
1386+ A9EA D4 A9                        dw          CABORT              //      (abort)
1387+ A9EC              Error_Endif_1:                                  // endif
1388+ A9EC F6 A2 6E A6                  dw      HERE, COUNT, TYPE       // here count type
1388+ A9F0 C2 A6
1389+ A9F2 5F A8                        dw      C_DOT_QUOTE             // .( ? )
1390+ A9F4 02 3F 20                     db      2, "? "
1391+ A9F7 3C AE                        dw      MESSAGE                 // message  ( forward )
1392+ A9F9 2A A2 D9 A0                  dw      S0, FETCH, SPSTORE      // s0 @ sp!
1392+ A9FD 92 9F
1393+ A9FF 72 A2 D9 A0                  dw      BLK, FETCH, QDUP        // blk @ ?dup
1393+ AA03 A0 A3
1394+ AA05                                                              // if
1395+ AA05 45 9B                        dw      ZBRANCH
1396+ AA07 08 00                        dw      Error_Endif_2 - $
1397+ AA09 78 A2 D9 A0                  dw          TO_IN, FETCH, SWAP  //      >in @ swap
1397+ AA0D 74 A0
1398+ AA0F              Error_Endif_2:                                  // endif
1399+ AA0F 2B AC                        dw      QUIT                    // quit ( forward )
1400+ AA11 A2 9F                        dw      EXIT                    // ;
1401+ AA13              //  ______________________________________________________________________
1402+ AA13              //
1403+ AA13              // id.          nfa --
1404+ AA13                              Colon_Def ID_DOT,  "ID.", is_normal
1404+ AA13             >                New_Def  ID_DOT, "ID.", Enter_Ptr, is_normal ; ok
1404+ AA13             >
1404+ AA13             >Dict_Ptr        defl    $
1404+ AA13             >
1404+ AA13             >//              ______________________________________________________________________
1404+ AA13             >//              Heap part
1404+ AA13             >
1404+ AA13             >
1404+ AA13             >                org     (Heap_Ptr & $1FFF) + $E000
1404+ E91F             >
1404+ E91F             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1404+ E91F             >Latest_Definition defl  Heap_Ptr
1404+ E91F             >
1404+ E91F             >                // dummy db directives used to calculate length of namec
1404+ E91F 49 44 2E    >                db      "ID."
1404+ E922             >len_NFA         defl    $ - temp_NFA
1404+ E922             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1404+ E91F             >
1404+ E91F 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1404+ E920 49 44 2E    >                db      "ID."               // name string in 7-bit ascii, but
1404+ E923             >                org     $-1                 // alter last byte of Name just above to set
1404+ E922 AE          >                db      {b $} | END_BIT     // msb as name end
1404+ E923             >
1404+ E923 15 09       >                dw      Prev_Ptr            // Link to previous definition Name
1404+ E925             >Prev_Ptr        defl    Heap_Ptr
1404+ E925             >
1404+ E925             >mirror_Ptr      defl    $
1404+ E925             >
1404+ E925 15 AA       >                dw      Dict_Ptr + 2        // xt
1404+ E927             >Heap_Ptr        defl    $ - $E000           // save current HP
1404+ E927             >
1404+ E927             >Current_HP      defl  $ - $E000             // used to set HP once!
1404+ E927             >
1404+ E927             >//              ______________________________________________________________________
1404+ E927             >//              Dictionary part
1404+ E927             >
1404+ E927             >                org     Dict_Ptr
1404+ AA13             >
1404+ AA13 25 28       >                dw      mirror_Ptr - $E000 + $1F00
1404+ AA15             >
1404+ AA15             >ID_DOT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1404+ AA15 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1404+ AA18             >
1404+ AA18             >
1404+ AA18             >                endif           ; ok        // for other definitions it "points" the correct handler
1404+ AA18             >                // Use of "; ok" to suppress "warning[fwdref]"
1404+ AA18             >
1404+ AA18             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1405+ AA18 56 A4                        dw      QTOHEAP
1406+ AA1A 7B A0 D8 A1                  dw      DUP, ONE, TRAVERSE      // dup 1 traverse
1406+ AA1E D2 A3
1407+ AA20 0E A0                        dw      ONE_PLUS                // 1+
1408+ AA22 57 A0 35 A3                  dw      OVER, SUBTRACT          // over -
1409+ AA26 7B A0 AC 9F                  dw      DUP, TO_R               // >r
1410+ AA2A 05 A8 74 A0                  dw      PAD, SWAP               // pad swap
1411+ AA2E DD 9E                        dw      CMOVE                   // cmove
1412+ AA30 05 A8 0E A0                  dw      PAD, ONE_PLUS           // pad 1+
1413+ AA34 B7 9F 15 A0                  dw      R_TO, ONE_SUBTRACT      // R> 1-
1414+ AA38 C2 A6 C7 A3                  dw      TYPE, SPACE             // type
1415+ AA3C A2 9F                        dw      EXIT                    // ;
1416+ AA3E
1417+ AA3E              //  ______________________________________________________________________
1418+ AA3E              //
1419+ AA3E              // code         -- cccc
1420+ AA3E                              Colon_Def CODE,  "CODE", is_normal
1420+ AA3E             >                New_Def  CODE, "CODE", Enter_Ptr, is_normal ; ok
1420+ AA3E             >
1420+ AA3E             >Dict_Ptr        defl    $
1420+ AA3E             >
1420+ AA3E             >//              ______________________________________________________________________
1420+ AA3E             >//              Heap part
1420+ AA3E             >
1420+ AA3E             >
1420+ AA3E             >                org     (Heap_Ptr & $1FFF) + $E000
1420+ E927             >
1420+ E927             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1420+ E927             >Latest_Definition defl  Heap_Ptr
1420+ E927             >
1420+ E927             >                // dummy db directives used to calculate length of namec
1420+ E927 43 4F 44 45 >                db      "CODE"
1420+ E92B             >len_NFA         defl    $ - temp_NFA
1420+ E92B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1420+ E927             >
1420+ E927 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1420+ E928 43 4F 44 45 >                db      "CODE"               // name string in 7-bit ascii, but
1420+ E92C             >                org     $-1                 // alter last byte of Name just above to set
1420+ E92B C5          >                db      {b $} | END_BIT     // msb as name end
1420+ E92C             >
1420+ E92C 1F 09       >                dw      Prev_Ptr            // Link to previous definition Name
1420+ E92E             >Prev_Ptr        defl    Heap_Ptr
1420+ E92E             >
1420+ E92E             >mirror_Ptr      defl    $
1420+ E92E             >
1420+ E92E 40 AA       >                dw      Dict_Ptr + 2        // xt
1420+ E930             >Heap_Ptr        defl    $ - $E000           // save current HP
1420+ E930             >
1420+ E930             >Current_HP      defl  $ - $E000             // used to set HP once!
1420+ E930             >
1420+ E930             >//              ______________________________________________________________________
1420+ E930             >//              Dictionary part
1420+ E930             >
1420+ E930             >                org     Dict_Ptr
1420+ AA3E             >
1420+ AA3E 2E 28       >                dw      mirror_Ptr - $E000 + $1F00
1420+ AA40             >
1420+ AA40             >CODE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1420+ AA40 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1420+ AA43             >
1420+ AA43             >
1420+ AA43             >                endif           ; ok        // for other definitions it "points" the correct handler
1420+ AA43             >                // Use of "; ok" to suppress "warning[fwdref]"
1420+ AA43             >
1420+ AA43             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1421+ AA43 C7 A9                        dw      LFIND                   // -find
1422+ AA45                                                              // if
1423+ AA45 45 9B                        dw      ZBRANCH
1424+ AA47 10 00                        dw      Code_Endif - $
1425+ AA49 60 A0                        dw          DROP                //      drop
1426+ AA4B BC A4 15 AA                  dw          TO_NAME, ID_DOT     //      >name id.
1427+ AA4F F3 9A 04 00                  dw          LIT, 4, MESSAGE     //      4 message
1427+ AA53 3C AE
1428+ AA55 C7 A3                        dw          SPACE               //      space
1429+ AA57              Code_Endif:                                     // endif
1430+ AA57 F6 A2                        dw      HERE                    // here
1431+ AA59                                                              // ( ---- here begins NFA ---- )
1432+ AA59 7B A0 EE A0                  dw      DUP, CFETCH             // dup c@
1433+ AA5D 3C A2 D9 A0                  dw      WIDTH, FETCH, MIN       // width @ min  ( max 31 character length )
1433+ AA61 7A A3
1434+ AA63 0E A0                        dw      ONE_PLUS                // 1+
1435+ AA65 7B A0 01 A3                  dw      DUP, ALLOT              // dup allot
1436+ AA69 24 A0 24 A0                  dw      CELL_PLUS, CELL_PLUS    // cell+ cell+
1437+ AA6D AC 9F                        dw      TO_R                    // >r
1438+ AA6F 7B A0                        dw      DUP                     // dup
1439+ AA71 F3 9A                        dw      LIT
1440+ AA73 A0 00                        dw      SMUDGE_BIT | END_BIT    // 160
1441+ AA75 D0 A0                        dw      TOGGLE                  // toggle
1442+ AA77 F6 A2 15 A0                  dw      HERE, ONE_SUBTRACT      // here 1- ( last character )
1443+ AA7B F3 9A 80 00                  dw      LIT, END_BIT, TOGGLE    // 128 toggle
1443+ AA7F D0 A0
1444+ AA81                                                              // ( ---- here is LFA ---- )
1445+ AA81 96 A2 D9 A0                  dw      CURRENT, FETCH, FETCH   // current @ @ , \ latest ,
1445+ AA85 D9 A0
1446+ AA87 0C A3                        dw      COMMA
1447+ AA89 7B A0 24 A0                  dw      DUP, CELL_PLUS, COMMA   // dup cell+ ,
1447+ AA8D 0C A3
1448+ AA8F 67 A4                        dw      HP_FETCH                // hp@
1449+ AA91 96 A2 D9 A0                  dw      CURRENT, FETCH, STORE   // current @ ! ( save this word as the latest )
1449+ AA95 E3 A0
1450+ AA97 67 A4 38 A4                  dw      HP_FETCH, FAR           // hp@ far R@ cmove
1451+ AA9B C2 9F DD 9E                  dw      R_OP, CMOVE
1452+ AA9F C2 9F 36 A0                  dw      R_OP, MINUS, ALLOT      // r@ negate allot
1452+ AAA3 01 A3
1453+ AAA5 B7 9F 66 A2                  dw      R_TO, HP, PLUSSTORE     // r> hp +!
1453+ AAA9 C1 A0
1454+ AAAB 67 A4 29 A0                  dw      HP_FETCH, CELL_MINUS    // hp@ cell- ,
1455+ AAAF 0C A3                        dw      COMMA
1456+ AAB1 D1 A1 79 A4                  dw      ZERO, SKIP_HP_PAGE
1457+ AAB5                                                              // ( ---- here is LFA ---- )
1458+ AAB5 A2 9F                        dw      EXIT                    // ;
1459+ AAB7
1460+ AAB7              //  ______________________________________________________________________
1461+ AAB7              //
1462+ AAB7              // create       -- cccc     ( compile time )
1463+ AAB7              //              -- a        ( run time )
1464+ AAB7                              Colon_Def CREATE,  "CREATE", is_normal
1464+ AAB7             >                New_Def  CREATE, "CREATE", Enter_Ptr, is_normal ; ok
1464+ AAB7             >
1464+ AAB7             >Dict_Ptr        defl    $
1464+ AAB7             >
1464+ AAB7             >//              ______________________________________________________________________
1464+ AAB7             >//              Heap part
1464+ AAB7             >
1464+ AAB7             >
1464+ AAB7             >                org     (Heap_Ptr & $1FFF) + $E000
1464+ E930             >
1464+ E930             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1464+ E930             >Latest_Definition defl  Heap_Ptr
1464+ E930             >
1464+ E930             >                // dummy db directives used to calculate length of namec
1464+ E930 43 52 45 41 >                db      "CREATE"
1464+ E934 54 45       >
1464+ E936             >len_NFA         defl    $ - temp_NFA
1464+ E936             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1464+ E930             >
1464+ E930 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1464+ E931 43 52 45 41 >                db      "CREATE"               // name string in 7-bit ascii, but
1464+ E935 54 45       >
1464+ E937             >                org     $-1                 // alter last byte of Name just above to set
1464+ E936 C5          >                db      {b $} | END_BIT     // msb as name end
1464+ E937             >
1464+ E937 27 09       >                dw      Prev_Ptr            // Link to previous definition Name
1464+ E939             >Prev_Ptr        defl    Heap_Ptr
1464+ E939             >
1464+ E939             >mirror_Ptr      defl    $
1464+ E939             >
1464+ E939 B9 AA       >                dw      Dict_Ptr + 2        // xt
1464+ E93B             >Heap_Ptr        defl    $ - $E000           // save current HP
1464+ E93B             >
1464+ E93B             >Current_HP      defl  $ - $E000             // used to set HP once!
1464+ E93B             >
1464+ E93B             >//              ______________________________________________________________________
1464+ E93B             >//              Dictionary part
1464+ E93B             >
1464+ E93B             >                org     Dict_Ptr
1464+ AAB7             >
1464+ AAB7 39 28       >                dw      mirror_Ptr - $E000 + $1F00
1464+ AAB9             >
1464+ AAB9             >CREATE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1464+ AAB9 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1464+ AABC             >
1464+ AABC             >
1464+ AABC             >                endif           ; ok        // for other definitions it "points" the correct handler
1464+ AABC             >                // Use of "; ok" to suppress "warning[fwdref]"
1464+ AABC             >
1464+ AABC             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1465+ AABC 40 AA DE A5                  dw      CODE, SMUDGE            // code smudge
1466+ AAC0 F3 9A CD 00                  dw      LIT, $CD, CCOMMA        // 00CD c,
1466+ AAC4 1B A3
1467+ AAC6 F3 9A B8 A1                  dw      LIT, Variable_Ptr, COMMA// Variable_Ptr ,
1467+ AACA 0C A3
1468+ AACC 1A A6                        dw      C_SEMICOLON_CODE
1469+ AACE                              // this routine is called from the call coded in CFA
1470+ AACE              Create_Ptr:
1471+ AACE
1472+ AACE
1473+ AACE
1474+ AACE                              next
1474+ AACE DD E9       >                jp      (ix)
1475+ AAD0
1476+ AAD0              //  ______________________________________________________________________
1477+ AAD0              //
1478+ AAD0              // [compile]    -- cccc     ( compile time )
1479+ AAD0                              Colon_Def COMPILE_IMMEDIATE,  "[COMPILE]", is_immediate
1479+ AAD0             >                New_Def  COMPILE_IMMEDIATE, "[COMPILE]", Enter_Ptr, is_immediate ; ok
1479+ AAD0             >
1479+ AAD0             >Dict_Ptr        defl    $
1479+ AAD0             >
1479+ AAD0             >//              ______________________________________________________________________
1479+ AAD0             >//              Heap part
1479+ AAD0             >
1479+ AAD0             >
1479+ AAD0             >                org     (Heap_Ptr & $1FFF) + $E000
1479+ E93B             >
1479+ E93B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1479+ E93B             >Latest_Definition defl  Heap_Ptr
1479+ E93B             >
1479+ E93B             >                // dummy db directives used to calculate length of namec
1479+ E93B 5B 43 4F 4D >                db      "[COMPILE]"
1479+ E93F 50 49 4C 45 >
1479+ E943 5D          >
1479+ E944             >len_NFA         defl    $ - temp_NFA
1479+ E944             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1479+ E93B             >
1479+ E93B C9          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
1479+ E93C 5B 43 4F 4D >                db      "[COMPILE]"               // name string in 7-bit ascii, but
1479+ E940 50 49 4C 45 >
1479+ E944 5D          >
1479+ E945             >                org     $-1                 // alter last byte of Name just above to set
1479+ E944 DD          >                db      {b $} | END_BIT     // msb as name end
1479+ E945             >
1479+ E945 30 09       >                dw      Prev_Ptr            // Link to previous definition Name
1479+ E947             >Prev_Ptr        defl    Heap_Ptr
1479+ E947             >
1479+ E947             >mirror_Ptr      defl    $
1479+ E947             >
1479+ E947 D2 AA       >                dw      Dict_Ptr + 2        // xt
1479+ E949             >Heap_Ptr        defl    $ - $E000           // save current HP
1479+ E949             >
1479+ E949             >Current_HP      defl  $ - $E000             // used to set HP once!
1479+ E949             >
1479+ E949             >//              ______________________________________________________________________
1479+ E949             >//              Dictionary part
1479+ E949             >
1479+ E949             >                org     Dict_Ptr
1479+ AAD0             >
1479+ AAD0 47 28       >                dw      mirror_Ptr - $E000 + $1F00
1479+ AAD2             >
1479+ AAD2             >COMPILE_IMMEDIATE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1479+ AAD2 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1479+ AAD5             >
1479+ AAD5             >
1479+ AAD5             >                endif           ; ok        // for other definitions it "points" the correct handler
1479+ AAD5             >                // Use of "; ok" to suppress "warning[fwdref]"
1479+ AAD5             >
1479+ AAD5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1480+ AAD5 C7 A9                        dw      LFIND                   // -find      (  cfa  b  f  )
1481+ AAD7 C7 9F                        dw      ZEQUAL                  // 0=         (  cfa  b  )
1482+ AAD9 D1 A1 32 A5                  dw      ZERO, QERROR            // 0 ?error
1483+ AADD 60 A0                        dw      DROP                    // drop       (  cfa  )
1484+ AADF 0C A3                        dw      COMMA                   // ,
1485+ AAE1 A2 9F                        dw      EXIT                    // ; immediate
1486+ AAE3
1487+ AAE3              //  ______________________________________________________________________
1488+ AAE3              //
1489+ AAE3              // literal      n --      ( compile time )
1490+ AAE3                              Colon_Def LITERAL,  "LITERAL", is_immediate
1490+ AAE3             >                New_Def  LITERAL, "LITERAL", Enter_Ptr, is_immediate ; ok
1490+ AAE3             >
1490+ AAE3             >Dict_Ptr        defl    $
1490+ AAE3             >
1490+ AAE3             >//              ______________________________________________________________________
1490+ AAE3             >//              Heap part
1490+ AAE3             >
1490+ AAE3             >
1490+ AAE3             >                org     (Heap_Ptr & $1FFF) + $E000
1490+ E949             >
1490+ E949             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1490+ E949             >Latest_Definition defl  Heap_Ptr
1490+ E949             >
1490+ E949             >                // dummy db directives used to calculate length of namec
1490+ E949 4C 49 54 45 >                db      "LITERAL"
1490+ E94D 52 41 4C    >
1490+ E950             >len_NFA         defl    $ - temp_NFA
1490+ E950             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1490+ E949             >
1490+ E949 C7          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
1490+ E94A 4C 49 54 45 >                db      "LITERAL"               // name string in 7-bit ascii, but
1490+ E94E 52 41 4C    >
1490+ E951             >                org     $-1                 // alter last byte of Name just above to set
1490+ E950 CC          >                db      {b $} | END_BIT     // msb as name end
1490+ E951             >
1490+ E951 3B 09       >                dw      Prev_Ptr            // Link to previous definition Name
1490+ E953             >Prev_Ptr        defl    Heap_Ptr
1490+ E953             >
1490+ E953             >mirror_Ptr      defl    $
1490+ E953             >
1490+ E953 E5 AA       >                dw      Dict_Ptr + 2        // xt
1490+ E955             >Heap_Ptr        defl    $ - $E000           // save current HP
1490+ E955             >
1490+ E955             >Current_HP      defl  $ - $E000             // used to set HP once!
1490+ E955             >
1490+ E955             >//              ______________________________________________________________________
1490+ E955             >//              Dictionary part
1490+ E955             >
1490+ E955             >                org     Dict_Ptr
1490+ AAE3             >
1490+ AAE3 53 28       >                dw      mirror_Ptr - $E000 + $1F00
1490+ AAE5             >
1490+ AAE5             >LITERAL:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1490+ AAE5 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1490+ AAE8             >
1490+ AAE8             >
1490+ AAE8             >                endif           ; ok        // for other definitions it "points" the correct handler
1490+ AAE8             >                // Use of "; ok" to suppress "warning[fwdref]"
1490+ AAE8             >
1490+ AAE8             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1491+ AAE8 9C A2 D9 A0                  dw      STATE, FETCH            // state @
1492+ AAEC                                                              // if
1493+ AAEC 45 9B                        dw      ZBRANCH
1494+ AAEE 08 00                        dw      Literal_Endif - $
1495+ AAF0 A2 A5 F3 9A                  dw          COMPILE, LIT        //      compile lit
1496+ AAF4 0C A3                        dw          COMMA               //      ,
1497+ AAF6              Literal_Endif:                                  // endif
1498+ AAF6 A2 9F                        dw      EXIT                    // ; immediate
1499+ AAF8
1500+ AAF8              //  ______________________________________________________________________
1501+ AAF8              //
1502+ AAF8              // dliteral     n --      ( compile time )
1503+ AAF8                              Colon_Def DLITERAL,  "DLITERAL", is_immediate
1503+ AAF8             >                New_Def  DLITERAL, "DLITERAL", Enter_Ptr, is_immediate ; ok
1503+ AAF8             >
1503+ AAF8             >Dict_Ptr        defl    $
1503+ AAF8             >
1503+ AAF8             >//              ______________________________________________________________________
1503+ AAF8             >//              Heap part
1503+ AAF8             >
1503+ AAF8             >
1503+ AAF8             >                org     (Heap_Ptr & $1FFF) + $E000
1503+ E955             >
1503+ E955             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1503+ E955             >Latest_Definition defl  Heap_Ptr
1503+ E955             >
1503+ E955             >                // dummy db directives used to calculate length of namec
1503+ E955 44 4C 49 54 >                db      "DLITERAL"
1503+ E959 45 52 41 4C >
1503+ E95D             >len_NFA         defl    $ - temp_NFA
1503+ E95D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1503+ E955             >
1503+ E955 C8          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
1503+ E956 44 4C 49 54 >                db      "DLITERAL"               // name string in 7-bit ascii, but
1503+ E95A 45 52 41 4C >
1503+ E95E             >                org     $-1                 // alter last byte of Name just above to set
1503+ E95D CC          >                db      {b $} | END_BIT     // msb as name end
1503+ E95E             >
1503+ E95E 49 09       >                dw      Prev_Ptr            // Link to previous definition Name
1503+ E960             >Prev_Ptr        defl    Heap_Ptr
1503+ E960             >
1503+ E960             >mirror_Ptr      defl    $
1503+ E960             >
1503+ E960 FA AA       >                dw      Dict_Ptr + 2        // xt
1503+ E962             >Heap_Ptr        defl    $ - $E000           // save current HP
1503+ E962             >
1503+ E962             >Current_HP      defl  $ - $E000             // used to set HP once!
1503+ E962             >
1503+ E962             >//              ______________________________________________________________________
1503+ E962             >//              Dictionary part
1503+ E962             >
1503+ E962             >                org     Dict_Ptr
1503+ AAF8             >
1503+ AAF8 60 28       >                dw      mirror_Ptr - $E000 + $1F00
1503+ AAFA             >
1503+ AAFA             >DLITERAL:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1503+ AAFA CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1503+ AAFD             >
1503+ AAFD             >
1503+ AAFD             >                endif           ; ok        // for other definitions it "points" the correct handler
1503+ AAFD             >                // Use of "; ok" to suppress "warning[fwdref]"
1503+ AAFD             >
1503+ AAFD             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1504+ AAFD 9C A2 D9 A0                  dw      STATE, FETCH            // state @
1505+ AB01                                                              // if
1506+ AB01 45 9B                        dw      ZBRANCH
1507+ AB03 08 00                        dw      DLiteral_Endif - $
1508+ AB05 74 A0                        dw          SWAP                //      swap
1509+ AB07 E5 AA E5 AA                  dw          LITERAL,  LITERAL   //      [compile] literal [compile] literal
1510+ AB0B              DLiteral_Endif:                                 // endif
1511+ AB0B A2 9F                        dw      EXIT                    // ; immediate
1512+ AB0D
1513+ AB0D              //  ______________________________________________________________________
1514+ AB0D              //
1515+ AB0D              // [char]       n --      ( compile time )
1516+ AB0D              // inside colon definition, gets first character from next input word
1517+ AB0D              // and compiles it as literal.
1518+ AB0D                              Colon_Def COMPILE_CHAR,  "[CHAR]", is_immediate
1518+ AB0D             >                New_Def  COMPILE_CHAR, "[CHAR]", Enter_Ptr, is_immediate ; ok
1518+ AB0D             >
1518+ AB0D             >Dict_Ptr        defl    $
1518+ AB0D             >
1518+ AB0D             >//              ______________________________________________________________________
1518+ AB0D             >//              Heap part
1518+ AB0D             >
1518+ AB0D             >
1518+ AB0D             >                org     (Heap_Ptr & $1FFF) + $E000
1518+ E962             >
1518+ E962             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1518+ E962             >Latest_Definition defl  Heap_Ptr
1518+ E962             >
1518+ E962             >                // dummy db directives used to calculate length of namec
1518+ E962 5B 43 48 41 >                db      "[CHAR]"
1518+ E966 52 5D       >
1518+ E968             >len_NFA         defl    $ - temp_NFA
1518+ E968             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1518+ E962             >
1518+ E962 C6          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
1518+ E963 5B 43 48 41 >                db      "[CHAR]"               // name string in 7-bit ascii, but
1518+ E967 52 5D       >
1518+ E969             >                org     $-1                 // alter last byte of Name just above to set
1518+ E968 DD          >                db      {b $} | END_BIT     // msb as name end
1518+ E969             >
1518+ E969 55 09       >                dw      Prev_Ptr            // Link to previous definition Name
1518+ E96B             >Prev_Ptr        defl    Heap_Ptr
1518+ E96B             >
1518+ E96B             >mirror_Ptr      defl    $
1518+ E96B             >
1518+ E96B 0F AB       >                dw      Dict_Ptr + 2        // xt
1518+ E96D             >Heap_Ptr        defl    $ - $E000           // save current HP
1518+ E96D             >
1518+ E96D             >Current_HP      defl  $ - $E000             // used to set HP once!
1518+ E96D             >
1518+ E96D             >//              ______________________________________________________________________
1518+ E96D             >//              Dictionary part
1518+ E96D             >
1518+ E96D             >                org     Dict_Ptr
1518+ AB0D             >
1518+ AB0D 6B 28       >                dw      mirror_Ptr - $E000 + $1F00
1518+ AB0F             >
1518+ AB0F             >COMPILE_CHAR:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1518+ AB0F CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1518+ AB12             >
1518+ AB12             >
1518+ AB12             >                endif           ; ok        // for other definitions it "points" the correct handler
1518+ AB12             >                // Use of "; ok" to suppress "warning[fwdref]"
1518+ AB12             >
1518+ AB12             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1519+ AB12 76 A8 E5 AA                  dw      CHAR, LITERAL           // char [compile] literal
1520+ AB16 A2 9F                        dw      EXIT                    // ; immediate
1521+ AB18
1522+ AB18              //  ______________________________________________________________________
1523+ AB18              //
1524+ AB18              // 0x00         n --      ( compile time )
1525+ AB18                              Colon_Def NUL_WORD,  $00, is_immediate
1525+ AB18             >                New_Def  NUL_WORD, $00, Enter_Ptr, is_immediate ; ok
1525+ AB18             >
1525+ AB18             >Dict_Ptr        defl    $
1525+ AB18             >
1525+ AB18             >//              ______________________________________________________________________
1525+ AB18             >//              Heap part
1525+ AB18             >
1525+ AB18             >
1525+ AB18             >                org     (Heap_Ptr & $1FFF) + $E000
1525+ E96D             >
1525+ E96D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1525+ E96D             >Latest_Definition defl  Heap_Ptr
1525+ E96D             >
1525+ E96D             >                // dummy db directives used to calculate length of namec
1525+ E96D 00          >                db      $00
1525+ E96E             >len_NFA         defl    $ - temp_NFA
1525+ E96E             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1525+ E96D             >
1525+ E96D C1          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
1525+ E96E 00          >                db      $00               // name string in 7-bit ascii, but
1525+ E96F             >                org     $-1                 // alter last byte of Name just above to set
1525+ E96E 80          >                db      {b $} | END_BIT     // msb as name end
1525+ E96F             >
1525+ E96F 62 09       >                dw      Prev_Ptr            // Link to previous definition Name
1525+ E971             >Prev_Ptr        defl    Heap_Ptr
1525+ E971             >
1525+ E971             >mirror_Ptr      defl    $
1525+ E971             >
1525+ E971 1A AB       >                dw      Dict_Ptr + 2        // xt
1525+ E973             >Heap_Ptr        defl    $ - $E000           // save current HP
1525+ E973             >
1525+ E973             >Current_HP      defl  $ - $E000             // used to set HP once!
1525+ E973             >
1525+ E973             >//              ______________________________________________________________________
1525+ E973             >//              Dictionary part
1525+ E973             >
1525+ E973             >                org     Dict_Ptr
1525+ AB18             >
1525+ AB18 71 28       >                dw      mirror_Ptr - $E000 + $1F00
1525+ AB1A             >
1525+ AB1A             >NUL_WORD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1525+ AB1A CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1525+ AB1D             >
1525+ AB1D             >
1525+ AB1D             >                endif           ; ok        // for other definitions it "points" the correct handler
1525+ AB1D             >                // Use of "; ok" to suppress "warning[fwdref]"
1525+ AB1D             >
1525+ AB1D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1526+ AB1D 72 A2 D9 A0                  dw      BLK, FETCH, ONE         // blk @ 1
1526+ AB21 D8 A1
1527+ AB23 6F A3                        dw      GREATER                 // > if
1528+ AB25                                                              // if
1529+ AB25 45 9B                        dw      ZBRANCH
1530+ AB27 28 00                        dw      Nul_Else_1 - $
1531+ AB29 D8 A1 72 A2                  dw          ONE, BLK, PLUSSTORE //      1 blk +!
1531+ AB2D C1 A0
1532+ AB2F D1 A1 78 A2                  dw          ZERO, TO_IN, STORE  //      0 >in !
1532+ AB33 E3 A0
1533+ AB35 72 A2 D9 A0                  dw          BLK, FETCH          //      blk @
1534+ AB39 09 A2                        dw          BSCR                //      b/scr
1535+ AB3B 15 A0                        dw          ONE_SUBTRACT        //      1 -
1536+ AB3D 5C 9F                        dw          AND_OP              //      and  ( this is tricky )
1537+ AB3F C7 9F                        dw          ZEQUAL              //      0=
1538+ AB41                                                              //      if
1539+ AB41 45 9B                        dw          ZBRANCH
1540+ AB43 08 00                        dw          Nul_Endif_2 - $
1541+ AB45 5A A5                        dw              QEXEC           //          ?exec
1542+ AB47 B7 9F 60 A0                  dw              R_TO, DROP      //          r> drop
1543+ AB4B              Nul_Endif_2:                                    //      endif
1544+ AB4B 38 9B                        dw      BRANCH
1545+ AB4D 06 00                        dw      Nul_Endif_1 - $
1546+ AB4F              Nul_Else_1:                                     // else
1547+ AB4F B7 9F 60 A0                  dw          R_TO, DROP          //      r> drop
1548+ AB53              Nul_Endif_1:                                    // endif
1549+ AB53 A2 9F                        dw      EXIT                    // ;
1550+ AB55
1551+ AB55              //  ______________________________________________________________________
1552+ AB55              //
1553+ AB55              // ?stack       --
1554+ AB55              // Raise error #1 if stack is empty and you pop it
1555+ AB55              // Raise error #7 if stack is full.
1556+ AB55              // This means SP must always stay between HERE and FFFF
1557+ AB55              // For 128K BANK paging purpose SP must be <= BFE0 and 50 words room
1558+ AB55              // for Next 8K MMU paging this is $DOE8
1559+ AB55                              Colon_Def QSTACK, "?STACK", is_normal
1559+ AB55             >                New_Def  QSTACK, "?STACK", Enter_Ptr, is_normal ; ok
1559+ AB55             >
1559+ AB55             >Dict_Ptr        defl    $
1559+ AB55             >
1559+ AB55             >//              ______________________________________________________________________
1559+ AB55             >//              Heap part
1559+ AB55             >
1559+ AB55             >
1559+ AB55             >                org     (Heap_Ptr & $1FFF) + $E000
1559+ E973             >
1559+ E973             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1559+ E973             >Latest_Definition defl  Heap_Ptr
1559+ E973             >
1559+ E973             >                // dummy db directives used to calculate length of namec
1559+ E973 3F 53 54 41 >                db      "?STACK"
1559+ E977 43 4B       >
1559+ E979             >len_NFA         defl    $ - temp_NFA
1559+ E979             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1559+ E973             >
1559+ E973 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1559+ E974 3F 53 54 41 >                db      "?STACK"               // name string in 7-bit ascii, but
1559+ E978 43 4B       >
1559+ E97A             >                org     $-1                 // alter last byte of Name just above to set
1559+ E979 CB          >                db      {b $} | END_BIT     // msb as name end
1559+ E97A             >
1559+ E97A 6D 09       >                dw      Prev_Ptr            // Link to previous definition Name
1559+ E97C             >Prev_Ptr        defl    Heap_Ptr
1559+ E97C             >
1559+ E97C             >mirror_Ptr      defl    $
1559+ E97C             >
1559+ E97C 57 AB       >                dw      Dict_Ptr + 2        // xt
1559+ E97E             >Heap_Ptr        defl    $ - $E000           // save current HP
1559+ E97E             >
1559+ E97E             >Current_HP      defl  $ - $E000             // used to set HP once!
1559+ E97E             >
1559+ E97E             >//              ______________________________________________________________________
1559+ E97E             >//              Dictionary part
1559+ E97E             >
1559+ E97E             >                org     Dict_Ptr
1559+ AB55             >
1559+ AB55 7C 28       >                dw      mirror_Ptr - $E000 + $1F00
1559+ AB57             >
1559+ AB57             >QSTACK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1559+ AB57 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1559+ AB5A             >
1559+ AB5A             >
1559+ AB5A             >                endif           ; ok        // for other definitions it "points" the correct handler
1559+ AB5A             >                // Use of "; ok" to suppress "warning[fwdref]"
1559+ AB5A             >
1559+ AB5A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1560+ AB5A 89 9F                        dw      SPFETCH                 // sp@
1561+ AB5C 2A A2 D9 A0                  dw      S0, FETCH               // s0 @
1562+ AB60 74 A0 4C A3                  dw      SWAP, ULESS             // swap u<
1563+ AB64 D8 A1 32 A5                  dw      ONE, QERROR             // 1 ?error
1564+ AB68 F6 A2                        dw      HERE                    // here
1565+ AB6A 2A A2 D9 A0                  dw      S0, FETCH, LESS         // s0 @ <
1565+ AB6E 5A A3
1566+ AB70                                                              // if
1567+ AB70 45 9B                        dw      ZBRANCH
1568+ AB72 14 00                        dw      QStack_Endif - $
1569+ AB74 89 9F                        dw          SPFETCH             //      sp@
1570+ AB76 F6 A2 F3 9A                  dw          HERE, LIT, 128      //      here 128
1570+ AB7A 80 00
1571+ AB7C F5 9F 4C A3                  dw          PLUS, ULESS         //      plus u<
1572+ AB80 F3 9A 07 00                  dw          LIT, 7, QERROR      //      7 Cerror
1572+ AB84 32 A5
1573+ AB86              QStack_Endif:                                   // endif
1574+ AB86 A2 9F                        dw      EXIT                    // ;
1575+ AB88
1576+ AB88
# file closed: C:\Zx\CSpect\Projects\vForth17_MMU7/source/L1.asm
 113  AB88                              include "L2.asm"
# file opened: C:\Zx\CSpect\Projects\vForth17_MMU7/source/L2.asm
   1+ AB88              //  ______________________________________________________________________
   2+ AB88              //
   3+ AB88              //  L2.asm
   4+ AB88              //
   5+ AB88              //  Level-2 3dos
   6+ AB88              //  the Forth interpreter, vocabulary, cold/warm start and quit from Forth.
   7+ AB88              //  ______________________________________________________________________
   8+ AB88
   9+ AB88
  10+ AB88              //  ______________________________________________________________________
  11+ AB88              //
  12+ AB88              // interpret    --
  13+ AB88              // This is the text interpreter.
  14+ AB88              // It executes or compiles, depending on STATE, the text coming from
  15+ AB88              // current input stream.
  16+ AB88              // If the word search fails after parsing CONTEXT and CURRENT vocabulary,
  17+ AB88              // the word is interpreted as numeric and converted, using current BASE,
  18+ AB88              // leaving on top of stack a single or double precision number, depending
  19+ AB88              // on the presence of a decimal point.
  20+ AB88              // If the number conversion fails, the terminal is notified with ? followed
  21+ AB88              // by the offending word.
  22+ AB88                              Colon_Def INTERPRET, "INTERPRET", is_normal
  22+ AB88             >                New_Def  INTERPRET, "INTERPRET", Enter_Ptr, is_normal ; ok
  22+ AB88             >
  22+ AB88             >Dict_Ptr        defl    $
  22+ AB88             >
  22+ AB88             >//              ______________________________________________________________________
  22+ AB88             >//              Heap part
  22+ AB88             >
  22+ AB88             >
  22+ AB88             >                org     (Heap_Ptr & $1FFF) + $E000
  22+ E97E             >
  22+ E97E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  22+ E97E             >Latest_Definition defl  Heap_Ptr
  22+ E97E             >
  22+ E97E             >                // dummy db directives used to calculate length of namec
  22+ E97E 49 4E 54 45 >                db      "INTERPRET"
  22+ E982 52 50 52 45 >
  22+ E986 54          >
  22+ E987             >len_NFA         defl    $ - temp_NFA
  22+ E987             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  22+ E97E             >
  22+ E97E 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  22+ E97F 49 4E 54 45 >                db      "INTERPRET"               // name string in 7-bit ascii, but
  22+ E983 52 50 52 45 >
  22+ E987 54          >
  22+ E988             >                org     $-1                 // alter last byte of Name just above to set
  22+ E987 D4          >                db      {b $} | END_BIT     // msb as name end
  22+ E988             >
  22+ E988 73 09       >                dw      Prev_Ptr            // Link to previous definition Name
  22+ E98A             >Prev_Ptr        defl    Heap_Ptr
  22+ E98A             >
  22+ E98A             >mirror_Ptr      defl    $
  22+ E98A             >
  22+ E98A 8A AB       >                dw      Dict_Ptr + 2        // xt
  22+ E98C             >Heap_Ptr        defl    $ - $E000           // save current HP
  22+ E98C             >
  22+ E98C             >Current_HP      defl  $ - $E000             // used to set HP once!
  22+ E98C             >
  22+ E98C             >//              ______________________________________________________________________
  22+ E98C             >//              Dictionary part
  22+ E98C             >
  22+ E98C             >                org     Dict_Ptr
  22+ AB88             >
  22+ AB88 8A 28       >                dw      mirror_Ptr - $E000 + $1F00
  22+ AB8A             >
  22+ AB8A             >INTERPRET:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
  22+ AB8A CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
  22+ AB8D             >
  22+ AB8D             >
  22+ AB8D             >                endif           ; ok        // for other definitions it "points" the correct handler
  22+ AB8D             >                // Use of "; ok" to suppress "warning[fwdref]"
  22+ AB8D             >
  22+ AB8D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  23+ AB8D
  24+ AB8D              Interpret_Begin:                                        // begin
  25+ AB8D C7 A9                        dw          LFIND                       //      -find
  26+ AB8F                                                                      //      if
  27+ AB8F 45 9B                        dw          ZBRANCH
  28+ AB91 1A 00                        dw          Interpret_Else_1 - $
  29+ AB93 9C A2 D9 A0                  dw              STATE, FETCH, LESS      //          state @ <
  29+ AB97 5A A3
  30+ AB99                                                                      //          if
  31+ AB99 45 9B                        dw              ZBRANCH
  32+ AB9B 08 00                        dw              Interpret_Else_2 - $
  33+ AB9D B7 A5                        dw                  COMPILE_XT          //              compile,
  34+ AB9F                                                                      //          else
  35+ AB9F 38 9B                        dw              BRANCH
  36+ ABA1 06 00                        dw              Interpret_Endif_2 - $
  37+ ABA3              Interpret_Else_2:
  38+ ABA3 FE 9A 98 A1                  dw                  EXECUTE, NOOP       //              execute nooop
  39+ ABA7              Interpret_Endif_2:                                      //          endif
  40+ ABA7                                                                      //      else
  41+ ABA7 38 9B                        dw          BRANCH
  42+ ABA9 1A 00                        dw          Interpret_Endif_1 - $
  43+ ABAB              Interpret_Else_1:
  44+ ABAB F6 A2 5D A9                  dw              HERE, NUMBER            //          here number
  45+ ABAF A8 A2 D9 A0                  dw              DPL, FETCH, ONE_PLUS    //          dpl @ 1+
  45+ ABB3 0E A0
  46+ ABB5                                                                      //          if
  47+ ABB5 45 9B                        dw              ZBRANCH
  48+ ABB7 08 00                        dw              Interpret_Else_3 - $
  49+ ABB9              //              dw                  NMODE, FETCH        //              nmode @
  50+ ABB9              //                                                      //              if
  51+ ABB9              //              dw                  ZBRANCH
  52+ ABB9              //              dw                  Interpret_Endif_4 - $
  53+ ABB9              //              dw                      ONE, ZERO       //                  1 0
  54+ ABB9              //              dw                      TWO_DROP        //                  2drop
  55+ ABB9              //Interpret_Endif_4:                                      //              endif
  56+ ABB9 FA AA                        dw                  DLITERAL            //              [compile] dliteral
  57+ ABBB                                                                      //          else
  58+ ABBB 38 9B                        dw              BRANCH
  59+ ABBD 06 00                        dw              Interpret_Endif_3 - $
  60+ ABBF              Interpret_Else_3:
  61+ ABBF 60 A0                        dw                  DROP                //              drop
  62+ ABC1 E5 AA                        dw                  LITERAL             //              [compile]  literal
  63+ ABC3              Interpret_Endif_3:                                      //          endif
  64+ ABC3              Interpret_Endif_1:                                      //      endif
  65+ ABC3 57 AB                        dw          QSTACK                      //      ?stack
  66+ ABC5 03 9E                        dw          QTERMINAL                   //      ?terminal
  67+ ABC7                                                                      //      if
  68+ ABC7 45 9B                        dw          ZBRANCH
  69+ ABC9 04 00                        dw          Interpret_Endif_5 - $
  70+ ABCB 2B AC                        dw              QUIT                    //          quit
  71+ ABCD              Interpret_Endif_5:                                      //      endif
  72+ ABCD 38 9B                        dw      BRANCH
  73+ ABCF BE FF                        dw      Interpret_Begin - $
  74+ ABD1 A2 9F                        dw      EXIT                            // ;
  75+ ABD3
  76+ ABD3              //  ______________________________________________________________________
  77+ ABD3              //
  78+ ABD3              // vocabulary   -- cccc     ( compile time )
  79+ ABD3              // Defining word used in the form   VOCABULARY cccc
  80+ ABD3              // creates the word  cccc  that gives the name to the vocabulary.
  81+ ABD3              // Giving  cccc  makes the vocabulary CONTEXT so its words are executed first
  82+ ABD3              // Giving  cccc DEFINITIONS makes  the vocabulary  CURRENT
  83+ ABD3              // so new definitions can be inserted in that vocabulary.
  84+ ABD3                              Colon_Def VOCABULARY, "VOCABULARY", is_normal
  84+ ABD3             >                New_Def  VOCABULARY, "VOCABULARY", Enter_Ptr, is_normal ; ok
  84+ ABD3             >
  84+ ABD3             >Dict_Ptr        defl    $
  84+ ABD3             >
  84+ ABD3             >//              ______________________________________________________________________
  84+ ABD3             >//              Heap part
  84+ ABD3             >
  84+ ABD3             >
  84+ ABD3             >                org     (Heap_Ptr & $1FFF) + $E000
  84+ E98C             >
  84+ E98C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  84+ E98C             >Latest_Definition defl  Heap_Ptr
  84+ E98C             >
  84+ E98C             >                // dummy db directives used to calculate length of namec
  84+ E98C 56 4F 43 41 >                db      "VOCABULARY"
  84+ E990 42 55 4C 41 >
  84+ E994 52 59       >
  84+ E996             >len_NFA         defl    $ - temp_NFA
  84+ E996             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  84+ E98C             >
  84+ E98C 8A          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  84+ E98D 56 4F 43 41 >                db      "VOCABULARY"               // name string in 7-bit ascii, but
  84+ E991 42 55 4C 41 >
  84+ E995 52 59       >
  84+ E997             >                org     $-1                 // alter last byte of Name just above to set
  84+ E996 D9          >                db      {b $} | END_BIT     // msb as name end
  84+ E997             >
  84+ E997 7E 09       >                dw      Prev_Ptr            // Link to previous definition Name
  84+ E999             >Prev_Ptr        defl    Heap_Ptr
  84+ E999             >
  84+ E999             >mirror_Ptr      defl    $
  84+ E999             >
  84+ E999 D5 AB       >                dw      Dict_Ptr + 2        // xt
  84+ E99B             >Heap_Ptr        defl    $ - $E000           // save current HP
  84+ E99B             >
  84+ E99B             >Current_HP      defl  $ - $E000             // used to set HP once!
  84+ E99B             >
  84+ E99B             >//              ______________________________________________________________________
  84+ E99B             >//              Dictionary part
  84+ E99B             >
  84+ E99B             >                org     Dict_Ptr
  84+ ABD3             >
  84+ ABD3 99 28       >                dw      mirror_Ptr - $E000 + $1F00
  84+ ABD5             >
  84+ ABD5             >VOCABULARY:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
  84+ ABD5 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
  84+ ABD8             >
  84+ ABD8             >
  84+ ABD8             >                endif           ; ok        // for other definitions it "points" the correct handler
  84+ ABD8             >                // Use of "; ok" to suppress "warning[fwdref]"
  84+ ABD8             >
  84+ ABD8             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  85+ ABD8
  86+ ABD8 46 A6                        dw      CBUILDS
  87+ ABDA
  88+ ABDA F3 9A 81 A0                  dw      LIT, $A081, COMMA       // $81A0 ,
  88+ ABDE 0C A3
  89+ ABE0 96 A2 D9 A0                  dw      CURRENT, FETCH          // current @
  90+ ABE4 29 A0 0C A3                  dw      CELL_MINUS, COMMA       // cell- ,
  91+ ABE8 F6 A2                        dw      HERE                    // here
  92+ ABEA 54 A2 D9 A0                  dw      VOC_LINK, FETCH, COMMA  // voc-link @ ,
  92+ ABEE 0C A3
  93+ ABF0 54 A2 E3 A0                  dw      VOC_LINK, STORE         // voc-link !
  94+ ABF4
  95+ ABF4 51 A6                        dw      DOES_TO                 // does>
  96+ ABF6              Vocabulary_Does:
  97+ ABF6 24 A0                        dw      CELL_PLUS               // cell+
  98+ ABF8 90 A2 E3 A0                  dw      CONTEXT, STORE          // context !
  99+ ABFC A2 9F                        dw      EXIT                    // ;
 100+ ABFE
 101+ ABFE              //  ______________________________________________________________________
 102+ ABFE              //
 103+ ABFE              // forth        --
 104+ ABFE              // Name of the first vocabulary.
 105+ ABFE              // It makes FORTH the CONTEXT vocabulary.
 106+ ABFE              // Until new user vocabulary are defined, new colon-definitions becomes
 107+ ABFE              // part of FORTH. It is immediate, so it will executed during the creation
 108+ ABFE              // of a colon definition to be able to select the vocabulary.
 109+ ABFE
 110+ ABFE                              New_Def FORTH, "FORTH", Does_Ptr, is_immediate
 110+ ABFE             >
 110+ ABFE             >Dict_Ptr        defl    $
 110+ ABFE             >
 110+ ABFE             >//              ______________________________________________________________________
 110+ ABFE             >//              Heap part
 110+ ABFE             >
 110+ ABFE             >
 110+ ABFE             >                org     (Heap_Ptr & $1FFF) + $E000
 110+ E99B             >
 110+ E99B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 110+ E99B             >Latest_Definition defl  Heap_Ptr
 110+ E99B             >
 110+ E99B             >                // dummy db directives used to calculate length of namec
 110+ E99B 46 4F 52 54 >                db      "FORTH"
 110+ E99F 48          >
 110+ E9A0             >len_NFA         defl    $ - temp_NFA
 110+ E9A0             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 110+ E99B             >
 110+ E99B C5          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 110+ E99C 46 4F 52 54 >                db      "FORTH"               // name string in 7-bit ascii, but
 110+ E9A0 48          >
 110+ E9A1             >                org     $-1                 // alter last byte of Name just above to set
 110+ E9A0 C8          >                db      {b $} | END_BIT     // msb as name end
 110+ E9A1             >
 110+ E9A1 8C 09       >                dw      Prev_Ptr            // Link to previous definition Name
 110+ E9A3             >Prev_Ptr        defl    Heap_Ptr
 110+ E9A3             >
 110+ E9A3             >mirror_Ptr      defl    $
 110+ E9A3             >
 110+ E9A3 00 AC       >                dw      Dict_Ptr + 2        // xt
 110+ E9A5             >Heap_Ptr        defl    $ - $E000           // save current HP
 110+ E9A5             >
 110+ E9A5             >Current_HP      defl  $ - $E000             // used to set HP once!
 110+ E9A5             >
 110+ E9A5             >//              ______________________________________________________________________
 110+ E9A5             >//              Dictionary part
 110+ E9A5             >
 110+ E9A5             >                org     Dict_Ptr
 110+ ABFE             >
 110+ ABFE A3 28       >                dw      mirror_Ptr - $E000 + $1F00
 110+ AC00             >
 110+ AC00             >FORTH:          if Does_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 110+ AC00 CD 5E A6    >                call    Does_Ptr ; ok        // for primitive definitions  actual code
 110+ AC03             >
 110+ AC03             >
 110+ AC03             >                endif           ; ok        // for other definitions it "points" the correct handler
 110+ AC03             >                // Use of "; ok" to suppress "warning[fwdref]"
 110+ AC03             >
 110+ AC03             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 111+ AC03 F6 AB                        dw      Vocabulary_Does
 112+ AC05 81 A0                        db      $81, $A0
 113+ AC07              Forth_Latest_Ptr:
 114+ AC07 9B 09                        dw      Latest_Definition
 115+ AC09              Voclink_Ptr:
 116+ AC09 00 00                        dw      0
 117+ AC0B              // Any new vocabulary is structured as follow:
 118+ AC0B              // PFA+0 points to DOES> part of VOCABULARY to perform CELL+ CONTEXT !
 119+ AC0B              // PFA+2 is 81,A0 i.e. a null-word used as LATEST in the new vocabulary
 120+ AC0B              // PFA+4 always contains the LATEST word of this VOCABULARY.
 121+ AC0B              //       at creations it points to the null-word of its parent vocabulary
 122+ AC0B              //       that is normally FORTH, For example ASSEMBLER points FORTH's null-word
 123+ AC0B              // PFA+6 is the pointer that builds up the vocabulary linked list.
 124+ AC0B              //       FORTH has 0 here to signal the end of the list and user's variable
 125+ AC0B              //       VOC-LINK points to PFA+6 of the newest vocabulary created.
 126+ AC0B              //       While FORTH is the only vocabulary, VOC-LINK points to FORTH's PFA+6
 127+ AC0B              //       When ASSEMBLER is created, its PFA+6 points to FORTH's PFA+6, and so on
 128+ AC0B
 129+ AC0B              //  ______________________________________________________________________
 130+ AC0B              //
 131+ AC0B              // definitions  --
 132+ AC0B              // Used in the form  cccc DEFINITIONS
 133+ AC0B              // set the CURRENT vocabulary at CONTEXT to insert new definitions in
 134+ AC0B              // vocabulary cccc.
 135+ AC0B                              Colon_Def DEFINITIONS, "DEFINITIONS", is_normal
 135+ AC0B             >                New_Def  DEFINITIONS, "DEFINITIONS", Enter_Ptr, is_normal ; ok
 135+ AC0B             >
 135+ AC0B             >Dict_Ptr        defl    $
 135+ AC0B             >
 135+ AC0B             >//              ______________________________________________________________________
 135+ AC0B             >//              Heap part
 135+ AC0B             >
 135+ AC0B             >
 135+ AC0B             >                org     (Heap_Ptr & $1FFF) + $E000
 135+ E9A5             >
 135+ E9A5             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 135+ E9A5             >Latest_Definition defl  Heap_Ptr
 135+ E9A5             >
 135+ E9A5             >                // dummy db directives used to calculate length of namec
 135+ E9A5 44 45 46 49 >                db      "DEFINITIONS"
 135+ E9A9 4E 49 54 49 >
 135+ E9AD 4F 4E 53    >
 135+ E9B0             >len_NFA         defl    $ - temp_NFA
 135+ E9B0             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 135+ E9A5             >
 135+ E9A5 8B          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 135+ E9A6 44 45 46 49 >                db      "DEFINITIONS"               // name string in 7-bit ascii, but
 135+ E9AA 4E 49 54 49 >
 135+ E9AE 4F 4E 53    >
 135+ E9B1             >                org     $-1                 // alter last byte of Name just above to set
 135+ E9B0 D3          >                db      {b $} | END_BIT     // msb as name end
 135+ E9B1             >
 135+ E9B1 9B 09       >                dw      Prev_Ptr            // Link to previous definition Name
 135+ E9B3             >Prev_Ptr        defl    Heap_Ptr
 135+ E9B3             >
 135+ E9B3             >mirror_Ptr      defl    $
 135+ E9B3             >
 135+ E9B3 0D AC       >                dw      Dict_Ptr + 2        // xt
 135+ E9B5             >Heap_Ptr        defl    $ - $E000           // save current HP
 135+ E9B5             >
 135+ E9B5             >Current_HP      defl  $ - $E000             // used to set HP once!
 135+ E9B5             >
 135+ E9B5             >//              ______________________________________________________________________
 135+ E9B5             >//              Dictionary part
 135+ E9B5             >
 135+ E9B5             >                org     Dict_Ptr
 135+ AC0B             >
 135+ AC0B B3 28       >                dw      mirror_Ptr - $E000 + $1F00
 135+ AC0D             >
 135+ AC0D             >DEFINITIONS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 135+ AC0D CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 135+ AC10             >
 135+ AC10             >
 135+ AC10             >                endif           ; ok        // for other definitions it "points" the correct handler
 135+ AC10             >                // Use of "; ok" to suppress "warning[fwdref]"
 135+ AC10             >
 135+ AC10             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 136+ AC10 90 A2 D9 A0                  dw      CONTEXT, FETCH          // context @
 137+ AC14 96 A2 E3 A0                  dw      CURRENT, STORE          // current !
 138+ AC18 A2 9F                        dw      EXIT                    // ;
 139+ AC1A
 140+ AC1A              //  ______________________________________________________________________
 141+ AC1A              //
 142+ AC1A              // (            -- cccc )
 143+ AC1A              // the following text is interpreted as a comment until a closing )
 144+ AC1A                              Colon_Def COMMENT_BRAKET, "(", is_immediate
 144+ AC1A             >                New_Def  COMMENT_BRAKET, "(", Enter_Ptr, is_immediate ; ok
 144+ AC1A             >
 144+ AC1A             >Dict_Ptr        defl    $
 144+ AC1A             >
 144+ AC1A             >//              ______________________________________________________________________
 144+ AC1A             >//              Heap part
 144+ AC1A             >
 144+ AC1A             >
 144+ AC1A             >                org     (Heap_Ptr & $1FFF) + $E000
 144+ E9B5             >
 144+ E9B5             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 144+ E9B5             >Latest_Definition defl  Heap_Ptr
 144+ E9B5             >
 144+ E9B5             >                // dummy db directives used to calculate length of namec
 144+ E9B5 28          >                db      "("
 144+ E9B6             >len_NFA         defl    $ - temp_NFA
 144+ E9B6             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 144+ E9B5             >
 144+ E9B5 C1          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 144+ E9B6 28          >                db      "("               // name string in 7-bit ascii, but
 144+ E9B7             >                org     $-1                 // alter last byte of Name just above to set
 144+ E9B6 A8          >                db      {b $} | END_BIT     // msb as name end
 144+ E9B7             >
 144+ E9B7 A5 09       >                dw      Prev_Ptr            // Link to previous definition Name
 144+ E9B9             >Prev_Ptr        defl    Heap_Ptr
 144+ E9B9             >
 144+ E9B9             >mirror_Ptr      defl    $
 144+ E9B9             >
 144+ E9B9 1C AC       >                dw      Dict_Ptr + 2        // xt
 144+ E9BB             >Heap_Ptr        defl    $ - $E000           // save current HP
 144+ E9BB             >
 144+ E9BB             >Current_HP      defl  $ - $E000             // used to set HP once!
 144+ E9BB             >
 144+ E9BB             >//              ______________________________________________________________________
 144+ E9BB             >//              Dictionary part
 144+ E9BB             >
 144+ E9BB             >                org     Dict_Ptr
 144+ AC1A             >
 144+ AC1A B9 28       >                dw      mirror_Ptr - $E000 + $1F00
 144+ AC1C             >
 144+ AC1C             >COMMENT_BRAKET:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 144+ AC1C CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 144+ AC1F             >
 144+ AC1F             >
 144+ AC1F             >                endif           ; ok        // for other definitions it "points" the correct handler
 144+ AC1F             >                // Use of "; ok" to suppress "warning[fwdref]"
 144+ AC1F             >
 144+ AC1F             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 145+ AC1F F3 9A 29 00                  dw      LIT, ")"                // [char] )
 146+ AC23 14 A8 60 A0                  dw      WORD, DROP              // word drop
 147+ AC27 A2 9F                        dw      EXIT                    // ;
 148+ AC29
 149+ AC29              //  ______________________________________________________________________
 150+ AC29              //
 151+ AC29              // quit         --
 152+ AC29              // \ Erase the return-stack, stop any compilation and give controlo to the console. No message is issued.
 153+ AC29                              Colon_Def QUIT, "QUIT", is_normal
 153+ AC29             >                New_Def  QUIT, "QUIT", Enter_Ptr, is_normal ; ok
 153+ AC29             >
 153+ AC29             >Dict_Ptr        defl    $
 153+ AC29             >
 153+ AC29             >//              ______________________________________________________________________
 153+ AC29             >//              Heap part
 153+ AC29             >
 153+ AC29             >
 153+ AC29             >                org     (Heap_Ptr & $1FFF) + $E000
 153+ E9BB             >
 153+ E9BB             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 153+ E9BB             >Latest_Definition defl  Heap_Ptr
 153+ E9BB             >
 153+ E9BB             >                // dummy db directives used to calculate length of namec
 153+ E9BB 51 55 49 54 >                db      "QUIT"
 153+ E9BF             >len_NFA         defl    $ - temp_NFA
 153+ E9BF             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 153+ E9BB             >
 153+ E9BB 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 153+ E9BC 51 55 49 54 >                db      "QUIT"               // name string in 7-bit ascii, but
 153+ E9C0             >                org     $-1                 // alter last byte of Name just above to set
 153+ E9BF D4          >                db      {b $} | END_BIT     // msb as name end
 153+ E9C0             >
 153+ E9C0 B5 09       >                dw      Prev_Ptr            // Link to previous definition Name
 153+ E9C2             >Prev_Ptr        defl    Heap_Ptr
 153+ E9C2             >
 153+ E9C2             >mirror_Ptr      defl    $
 153+ E9C2             >
 153+ E9C2 2B AC       >                dw      Dict_Ptr + 2        // xt
 153+ E9C4             >Heap_Ptr        defl    $ - $E000           // save current HP
 153+ E9C4             >
 153+ E9C4             >Current_HP      defl  $ - $E000             // used to set HP once!
 153+ E9C4             >
 153+ E9C4             >//              ______________________________________________________________________
 153+ E9C4             >//              Dictionary part
 153+ E9C4             >
 153+ E9C4             >                org     Dict_Ptr
 153+ AC29             >
 153+ AC29 C2 28       >                dw      mirror_Ptr - $E000 + $1F00
 153+ AC2B             >
 153+ AC2B             >QUIT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 153+ AC2B CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 153+ AC2E             >
 153+ AC2E             >
 153+ AC2E             >                endif           ; ok        // for other definitions it "points" the correct handler
 153+ AC2E             >                // Use of "; ok" to suppress "warning[fwdref]"
 153+ AC2E             >
 153+ AC2E             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 154+ AC2E
 155+ AC2E DE A2 D9 A0                  dw      SOURCE_ID, FETCH        // source-id @
 156+ AC32 4F 9E 60 A0                  dw      F_CLOSE, DROP           // f_close drop
 157+ AC36 D1 A1 DE A2                  dw      ZERO, SOURCE_ID, STORE  // 0 source-id !
 157+ AC3A E3 A0
 158+ AC3C D1 A1 72 A2                  dw      ZERO, BLK, STORE        // 0 blk !
 158+ AC40 E3 A0
 159+ AC42 C2 A5                        dw      SQUARED_OPEN            // [compile] [
 160+ AC44                                                              // begin
 161+ AC44              Quit_Begin:
 162+ AC44 30 A2 D9 A0                  dw      R0, FETCH, RPSTORE      //      r0 @ rp!
 162+ AC48 9D 9F
 163+ AC4A 06 9D                        dw      CR                      //      cr
 164+ AC4C B1 A7                        dw      QUERY                   //      query
 165+ AC4E              Next_Breakpoint_1:
 166+ AC4E 8A AB                        dw      INTERPRET               //      interpret
 167+ AC50 9C A2 D9 A0                  dw      STATE, FETCH, ZEQUAL    //      state @ 0=
 167+ AC54 C7 9F
 168+ AC56                                                              //      if
 169+ AC56 45 9B                        dw      ZBRANCH
 170+ AC58 07 00                        dw      Quit_Endif - $
 171+ AC5A 5F A8                        dw          C_DOT_QUOTE
 172+ AC5C 02 6F 6B                     db          2, "ok"             //          .( ok)
 173+ AC5F              Quit_Endif:                                     //      else
 174+ AC5F                                                              // again
 175+ AC5F 38 9B                        dw      BRANCH
 176+ AC61 E3 FF                        dw      Quit_Begin - $
 177+ AC63 A2 9F                        dw      EXIT                    // ;
 178+ AC65
 179+ AC65              //  ______________________________________________________________________
 180+ AC65              //
 181+ AC65              // abort        --
 182+ AC65                              Colon_Def ABORT, "ABORT", is_normal
 182+ AC65             >                New_Def  ABORT, "ABORT", Enter_Ptr, is_normal ; ok
 182+ AC65             >
 182+ AC65             >Dict_Ptr        defl    $
 182+ AC65             >
 182+ AC65             >//              ______________________________________________________________________
 182+ AC65             >//              Heap part
 182+ AC65             >
 182+ AC65             >
 182+ AC65             >                org     (Heap_Ptr & $1FFF) + $E000
 182+ E9C4             >
 182+ E9C4             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 182+ E9C4             >Latest_Definition defl  Heap_Ptr
 182+ E9C4             >
 182+ E9C4             >                // dummy db directives used to calculate length of namec
 182+ E9C4 41 42 4F 52 >                db      "ABORT"
 182+ E9C8 54          >
 182+ E9C9             >len_NFA         defl    $ - temp_NFA
 182+ E9C9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 182+ E9C4             >
 182+ E9C4 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 182+ E9C5 41 42 4F 52 >                db      "ABORT"               // name string in 7-bit ascii, but
 182+ E9C9 54          >
 182+ E9CA             >                org     $-1                 // alter last byte of Name just above to set
 182+ E9C9 D4          >                db      {b $} | END_BIT     // msb as name end
 182+ E9CA             >
 182+ E9CA BB 09       >                dw      Prev_Ptr            // Link to previous definition Name
 182+ E9CC             >Prev_Ptr        defl    Heap_Ptr
 182+ E9CC             >
 182+ E9CC             >mirror_Ptr      defl    $
 182+ E9CC             >
 182+ E9CC 67 AC       >                dw      Dict_Ptr + 2        // xt
 182+ E9CE             >Heap_Ptr        defl    $ - $E000           // save current HP
 182+ E9CE             >
 182+ E9CE             >Current_HP      defl  $ - $E000             // used to set HP once!
 182+ E9CE             >
 182+ E9CE             >//              ______________________________________________________________________
 182+ E9CE             >//              Dictionary part
 182+ E9CE             >
 182+ E9CE             >                org     Dict_Ptr
 182+ AC65             >
 182+ AC65 CC 28       >                dw      mirror_Ptr - $E000 + $1F00
 182+ AC67             >
 182+ AC67             >ABORT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 182+ AC67 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 182+ AC6A             >
 182+ AC6A             >
 182+ AC6A             >                endif           ; ok        // for other definitions it "points" the correct handler
 182+ AC6A             >                // Use of "; ok" to suppress "warning[fwdref]"
 182+ AC6A             >
 182+ AC6A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 183+ AC6A 2A A2 D9 A0                  dw      S0, FETCH, SPSTORE      // s0 @ sp!
 183+ AC6E 92 9F
 184+ AC70 0B A6                        dw      DECIMAL                 // decimal
 185+ AC72 00 AC                        dw      FORTH                   // [compile] forth
 186+ AC74 0D AC                        dw      DEFINITIONS             // definitions
 187+ AC76              Autoexec_Ptr:
 188+ AC76 D2 B6                        dw      AUTOEXEC                // autoexec, patched to noop
 189+ AC78 2B AC                        dw      QUIT                    // quit
 190+ AC7A A2 9F                        dw      EXIT                    // ;
 191+ AC7C
 192+ AC7C              //  ______________________________________________________________________
 193+ AC7C              //
 194+ AC7C              // warm         --
 195+ AC7C                              Colon_Def WARM, "WARM", is_normal
 195+ AC7C             >                New_Def  WARM, "WARM", Enter_Ptr, is_normal ; ok
 195+ AC7C             >
 195+ AC7C             >Dict_Ptr        defl    $
 195+ AC7C             >
 195+ AC7C             >//              ______________________________________________________________________
 195+ AC7C             >//              Heap part
 195+ AC7C             >
 195+ AC7C             >
 195+ AC7C             >                org     (Heap_Ptr & $1FFF) + $E000
 195+ E9CE             >
 195+ E9CE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 195+ E9CE             >Latest_Definition defl  Heap_Ptr
 195+ E9CE             >
 195+ E9CE             >                // dummy db directives used to calculate length of namec
 195+ E9CE 57 41 52 4D >                db      "WARM"
 195+ E9D2             >len_NFA         defl    $ - temp_NFA
 195+ E9D2             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 195+ E9CE             >
 195+ E9CE 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 195+ E9CF 57 41 52 4D >                db      "WARM"               // name string in 7-bit ascii, but
 195+ E9D3             >                org     $-1                 // alter last byte of Name just above to set
 195+ E9D2 CD          >                db      {b $} | END_BIT     // msb as name end
 195+ E9D3             >
 195+ E9D3 C4 09       >                dw      Prev_Ptr            // Link to previous definition Name
 195+ E9D5             >Prev_Ptr        defl    Heap_Ptr
 195+ E9D5             >
 195+ E9D5             >mirror_Ptr      defl    $
 195+ E9D5             >
 195+ E9D5 7E AC       >                dw      Dict_Ptr + 2        // xt
 195+ E9D7             >Heap_Ptr        defl    $ - $E000           // save current HP
 195+ E9D7             >
 195+ E9D7             >Current_HP      defl  $ - $E000             // used to set HP once!
 195+ E9D7             >
 195+ E9D7             >//              ______________________________________________________________________
 195+ E9D7             >//              Dictionary part
 195+ E9D7             >
 195+ E9D7             >                org     Dict_Ptr
 195+ AC7C             >
 195+ AC7C D5 28       >                dw      mirror_Ptr - $E000 + $1F00
 195+ AC7E             >
 195+ AC7E             >WARM:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 195+ AC7E CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 195+ AC81             >
 195+ AC81             >
 195+ AC81             >                endif           ; ok        // for other definitions it "points" the correct handler
 195+ AC81             >                // Use of "; ok" to suppress "warning[fwdref]"
 195+ AC81             >
 195+ AC81             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 196+ AC81 3A AF                        dw      BLK_INIT                // blk-init
 197+ AC83 5E B6                        dw      SPLASH                  // splash
 198+ AC85 F3 9A 07 00                  dw      LIT, 7, EMIT            // 7 emit
 198+ AC89 B0 A3
 199+ AC8B 67 AC                        dw      ABORT                   // abort
 200+ AC8D A2 9F                        dw      EXIT                    // exit
 201+ AC8F
 202+ AC8F              //  ______________________________________________________________________
 203+ AC8F              //
 204+ AC8F              // cold         --
 205+ AC8F                              Colon_Def COLD, "COLD", is_normal
 205+ AC8F             >                New_Def  COLD, "COLD", Enter_Ptr, is_normal ; ok
 205+ AC8F             >
 205+ AC8F             >Dict_Ptr        defl    $
 205+ AC8F             >
 205+ AC8F             >//              ______________________________________________________________________
 205+ AC8F             >//              Heap part
 205+ AC8F             >
 205+ AC8F             >
 205+ AC8F             >                org     (Heap_Ptr & $1FFF) + $E000
 205+ E9D7             >
 205+ E9D7             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 205+ E9D7             >Latest_Definition defl  Heap_Ptr
 205+ E9D7             >
 205+ E9D7             >                // dummy db directives used to calculate length of namec
 205+ E9D7 43 4F 4C 44 >                db      "COLD"
 205+ E9DB             >len_NFA         defl    $ - temp_NFA
 205+ E9DB             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 205+ E9D7             >
 205+ E9D7 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 205+ E9D8 43 4F 4C 44 >                db      "COLD"               // name string in 7-bit ascii, but
 205+ E9DC             >                org     $-1                 // alter last byte of Name just above to set
 205+ E9DB C4          >                db      {b $} | END_BIT     // msb as name end
 205+ E9DC             >
 205+ E9DC CE 09       >                dw      Prev_Ptr            // Link to previous definition Name
 205+ E9DE             >Prev_Ptr        defl    Heap_Ptr
 205+ E9DE             >
 205+ E9DE             >mirror_Ptr      defl    $
 205+ E9DE             >
 205+ E9DE 91 AC       >                dw      Dict_Ptr + 2        // xt
 205+ E9E0             >Heap_Ptr        defl    $ - $E000           // save current HP
 205+ E9E0             >
 205+ E9E0             >Current_HP      defl  $ - $E000             // used to set HP once!
 205+ E9E0             >
 205+ E9E0             >//              ______________________________________________________________________
 205+ E9E0             >//              Dictionary part
 205+ E9E0             >
 205+ E9E0             >                org     Dict_Ptr
 205+ AC8F             >
 205+ AC8F DE 28       >                dw      mirror_Ptr - $E000 + $1F00
 205+ AC91             >
 205+ AC91             >COLD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 205+ AC91 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 205+ AC94             >
 205+ AC94             >
 205+ AC94             >                endif           ; ok        // for other definitions it "points" the correct handler
 205+ AC94             >                // Use of "; ok" to suppress "warning[fwdref]"
 205+ AC94             >
 205+ AC94             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 206+ AC94 F3 9A C8 9A                  dw      LIT, S0_origin          // [ hex $12 +origin ] Literal
 207+ AC98 F3 9A E4 9A                  dw      LIT, USER_Pointer       // [ hex $3E +origin ] literal
 208+ AC9C D9 A0                        dw      FETCH                   // @
 209+ AC9E F3 9A 06 00                  dw      LIT, 6, PLUS            // 6 +
 209+ ACA2 F5 9F
 210+ ACA4 F3 9A 16 00                  dw      LIT, 22                 // 22
 211+ ACA8 DD 9E                        dw      CMOVE
 212+ ACAA F3 9A C2 9A                  dw      LIT, Latest_origin      // [ hex 0C +origin ] literal
 213+ ACAE D9 A0                        dw      FETCH                   // @
 214+ ACB0 F3 9A 07 AC                  dw      LIT, Forth_Latest_Ptr   // [ ' forth >body 4 + ] Literal
 215+ ACB4 E3 A0                        dw      STORE                   // !
 216+ ACB6 D1 A1 6C A2                  dw      ZERO, NMODE, STORE      // 0 nmode !
 216+ ACBA E3 A0
 217+ ACBC 5A A2 D9 A0                  dw      FIRST, FETCH, DUP       // first @ dup
 217+ ACC0 7B A0
 218+ ACC2 C6 A2 E3 A0                  dw      USE, STORE              // use !
 219+ ACC6 CC A2 E3 A0                  dw      PREV, STORE             // prev !
 220+ ACCA F3 9A 04 00                  dw      LIT, 4, PLACE, STORE    // 4 place !
 220+ ACCE D8 A2 E3 A0
 221+ ACD2              //              dw      LIT, 8
 222+ ACD2              //              dw      LIT, FLAGS2, CSTORE     // 8 5C6A c!
 223+ ACD2
 224+ ACD2 7E AC        Warm_Start:     dw      WARM
 225+ ACD4 91 AC        Cold_Start:     dw      COLD
 226+ ACD6 A2 9F                        dw      EXIT
 227+ ACD8
 228+ ACD8              //  ______________________________________________________________________
 229+ ACD8              WarmRoutine:
 230+ ACD8              ColdRoutine:
 231+ ACD8 DD 21 EA 9A                  ld      ix, Next_Ptr            // Inner Interpreter Pointer
 232+ ACDC
 233+ ACDC D9                           exx
 234+ ACDD E5                           push    hl                      // save Basic's return address
 235+ ACDE D9                           exx
 236+ ACDF ED 73 BE 9A                  ld      (SP_Basic), sp
 237+ ACE3
 238+ ACE3                              // pre-set the four main 16-bit registers
 239+ ACE3 ED 7B C8 9A                  ld      sp, (S0_origin)         // Calculator Stack Pointer
 240+ ACE7 2A CA 9A                     ld      hl, (R0_origin)         // Return Stack Pointer
 241+ ACEA                              // ld      de, (R0_origin)         // Return Stack Pointer
 242+ ACEA                              ldrphl
 242+ ACEA 22 E6 9A    >                ld      (RP_Pointer),hl
 243+ ACED EB                           ex      de, hl
 244+ ACEE 01 D2 AC                     ld      bc, Warm_Start          // Instruction Pointer
 245+ ACF1
 246+ ACF1 38 02                        jr      c, Warm_Skip
 247+ ACF3 03                           inc     bc
 248+ ACF4 03                           inc     bc
 249+ ACF5              Warm_Skip:
 250+ ACF5                              next
 250+ ACF5 DD E9       >                jp      (ix)
 251+ ACF7
 252+ ACF7              //  ______________________________________________________________________
 253+ ACF7              //
 254+ ACF7              // basic        --
 255+ ACF7                              New_Def BASIC, "BASIC", is_code, is_normal
 255+ ACF7             >
 255+ ACF7             >Dict_Ptr        defl    $
 255+ ACF7             >
 255+ ACF7             >//              ______________________________________________________________________
 255+ ACF7             >//              Heap part
 255+ ACF7             >
 255+ ACF7             >
 255+ ACF7             >                org     (Heap_Ptr & $1FFF) + $E000
 255+ E9E0             >
 255+ E9E0             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 255+ E9E0             >Latest_Definition defl  Heap_Ptr
 255+ E9E0             >
 255+ E9E0             >                // dummy db directives used to calculate length of namec
 255+ E9E0 42 41 53 49 >                db      "BASIC"
 255+ E9E4 43          >
 255+ E9E5             >len_NFA         defl    $ - temp_NFA
 255+ E9E5             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 255+ E9E0             >
 255+ E9E0 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 255+ E9E1 42 41 53 49 >                db      "BASIC"               // name string in 7-bit ascii, but
 255+ E9E5 43          >
 255+ E9E6             >                org     $-1                 // alter last byte of Name just above to set
 255+ E9E5 C3          >                db      {b $} | END_BIT     // msb as name end
 255+ E9E6             >
 255+ E9E6 D7 09       >                dw      Prev_Ptr            // Link to previous definition Name
 255+ E9E8             >Prev_Ptr        defl    Heap_Ptr
 255+ E9E8             >
 255+ E9E8             >mirror_Ptr      defl    $
 255+ E9E8             >
 255+ E9E8 F9 AC       >                dw      Dict_Ptr + 2        // xt
 255+ E9EA             >Heap_Ptr        defl    $ - $E000           // save current HP
 255+ E9EA             >
 255+ E9EA             >Current_HP      defl  $ - $E000             // used to set HP once!
 255+ E9EA             >
 255+ E9EA             >//              ______________________________________________________________________
 255+ E9EA             >//              Dictionary part
 255+ E9EA             >
 255+ E9EA             >                org     Dict_Ptr
 255+ ACF7             >
 255+ ACF7 E8 28       >                dw      mirror_Ptr - $E000 + $1F00
 255+ ACF9             >
 255+ ACF9             >BASIC:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 255+ ACF9 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 255+ ACF9 ~           >
 255+ ACF9 ~           >
 255+ ACF9             >                endif           ; ok        // for other definitions it "points" the correct handler
 255+ ACF9             >                // Use of "; ok" to suppress "warning[fwdref]"
 255+ ACF9             >
 255+ ACF9             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 256+ ACF9 C1                           pop     bc                      // return  TOS  value to Basic
 257+ ACFA 21 00 00                     ld      hl, 0
 258+ ACFD 39                           add     hl, sp
 259+ ACFE ED 7B BE 9A                  ld      sp, (SP_Basic)          // restore Basic's SP
 260+ AD02              //              nop
 261+ AD02 22 BE 9A                     ld      (SP_Basic),hl           // but also save Forth's
 262+ AD05 D9                           exx
 263+ AD06 E1                           pop     hl                      // restore h'l'
 264+ AD07 D9                           exx
 265+ AD08 C9                           ret                             // to where USR Basic was left
 266+ AD09
 267+ AD09              //  ______________________________________________________________________
 268+ AD09              //
 269+ AD09              // +-           n1 n2 -- n3
 270+ AD09              // leaves n1 with the sign of n2 as n3.
 271+ AD09                              Colon_Def PLUS_MINUS, "+-", is_normal
 271+ AD09             >                New_Def  PLUS_MINUS, "+-", Enter_Ptr, is_normal ; ok
 271+ AD09             >
 271+ AD09             >Dict_Ptr        defl    $
 271+ AD09             >
 271+ AD09             >//              ______________________________________________________________________
 271+ AD09             >//              Heap part
 271+ AD09             >
 271+ AD09             >
 271+ AD09             >                org     (Heap_Ptr & $1FFF) + $E000
 271+ E9EA             >
 271+ E9EA             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 271+ E9EA             >Latest_Definition defl  Heap_Ptr
 271+ E9EA             >
 271+ E9EA             >                // dummy db directives used to calculate length of namec
 271+ E9EA 2B 2D       >                db      "+-"
 271+ E9EC             >len_NFA         defl    $ - temp_NFA
 271+ E9EC             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 271+ E9EA             >
 271+ E9EA 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 271+ E9EB 2B 2D       >                db      "+-"               // name string in 7-bit ascii, but
 271+ E9ED             >                org     $-1                 // alter last byte of Name just above to set
 271+ E9EC AD          >                db      {b $} | END_BIT     // msb as name end
 271+ E9ED             >
 271+ E9ED E0 09       >                dw      Prev_Ptr            // Link to previous definition Name
 271+ E9EF             >Prev_Ptr        defl    Heap_Ptr
 271+ E9EF             >
 271+ E9EF             >mirror_Ptr      defl    $
 271+ E9EF             >
 271+ E9EF 0B AD       >                dw      Dict_Ptr + 2        // xt
 271+ E9F1             >Heap_Ptr        defl    $ - $E000           // save current HP
 271+ E9F1             >
 271+ E9F1             >Current_HP      defl  $ - $E000             // used to set HP once!
 271+ E9F1             >
 271+ E9F1             >//              ______________________________________________________________________
 271+ E9F1             >//              Dictionary part
 271+ E9F1             >
 271+ E9F1             >                org     Dict_Ptr
 271+ AD09             >
 271+ AD09 EF 28       >                dw      mirror_Ptr - $E000 + $1F00
 271+ AD0B             >
 271+ AD0B             >PLUS_MINUS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 271+ AD0B CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 271+ AD0E             >
 271+ AD0E             >
 271+ AD0E             >                endif           ; ok        // for other definitions it "points" the correct handler
 271+ AD0E             >                // Use of "; ok" to suppress "warning[fwdref]"
 271+ AD0E             >
 271+ AD0E             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 272+ AD0E DA 9F                        dw      ZLESS                   // 0<
 273+ AD10                                                              // if
 274+ AD10 45 9B                        dw      ZBRANCH
 275+ AD12 04 00                        dw      Plus_Minus_Endif - $
 276+ AD14 36 A0                        dw          MINUS               //      minus
 277+ AD16              Plus_Minus_Endif:                               // endif
 278+ AD16 A2 9F                        dw      EXIT                    // ;
 279+ AD18
 280+ AD18              //  ______________________________________________________________________
 281+ AD18              //
 282+ AD18              // d+-          d1 n -- d2
 283+ AD18              // leaves d1 with the sign of n as d2.
 284+ AD18                              Colon_Def DPLUS_MINUS, "D+-", is_normal
 284+ AD18             >                New_Def  DPLUS_MINUS, "D+-", Enter_Ptr, is_normal ; ok
 284+ AD18             >
 284+ AD18             >Dict_Ptr        defl    $
 284+ AD18             >
 284+ AD18             >//              ______________________________________________________________________
 284+ AD18             >//              Heap part
 284+ AD18             >
 284+ AD18             >
 284+ AD18             >                org     (Heap_Ptr & $1FFF) + $E000
 284+ E9F1             >
 284+ E9F1             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 284+ E9F1             >Latest_Definition defl  Heap_Ptr
 284+ E9F1             >
 284+ E9F1             >                // dummy db directives used to calculate length of namec
 284+ E9F1 44 2B 2D    >                db      "D+-"
 284+ E9F4             >len_NFA         defl    $ - temp_NFA
 284+ E9F4             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 284+ E9F1             >
 284+ E9F1 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 284+ E9F2 44 2B 2D    >                db      "D+-"               // name string in 7-bit ascii, but
 284+ E9F5             >                org     $-1                 // alter last byte of Name just above to set
 284+ E9F4 AD          >                db      {b $} | END_BIT     // msb as name end
 284+ E9F5             >
 284+ E9F5 EA 09       >                dw      Prev_Ptr            // Link to previous definition Name
 284+ E9F7             >Prev_Ptr        defl    Heap_Ptr
 284+ E9F7             >
 284+ E9F7             >mirror_Ptr      defl    $
 284+ E9F7             >
 284+ E9F7 1A AD       >                dw      Dict_Ptr + 2        // xt
 284+ E9F9             >Heap_Ptr        defl    $ - $E000           // save current HP
 284+ E9F9             >
 284+ E9F9             >Current_HP      defl  $ - $E000             // used to set HP once!
 284+ E9F9             >
 284+ E9F9             >//              ______________________________________________________________________
 284+ E9F9             >//              Dictionary part
 284+ E9F9             >
 284+ E9F9             >                org     Dict_Ptr
 284+ AD18             >
 284+ AD18 F7 28       >                dw      mirror_Ptr - $E000 + $1F00
 284+ AD1A             >
 284+ AD1A             >DPLUS_MINUS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 284+ AD1A CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 284+ AD1D             >
 284+ AD1D             >
 284+ AD1D             >                endif           ; ok        // for other definitions it "points" the correct handler
 284+ AD1D             >                // Use of "; ok" to suppress "warning[fwdref]"
 284+ AD1D             >
 284+ AD1D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 285+ AD1D DA 9F                        dw      ZLESS                   // 0<
 286+ AD1F                                                              // if
 287+ AD1F 45 9B                        dw      ZBRANCH
 288+ AD21 04 00                        dw      DPlus_Minus_Endif - $
 289+ AD23 44 A0                        dw          DMINUS              //      dminus
 290+ AD25              DPlus_Minus_Endif:                              // endif
 291+ AD25 A2 9F                        dw      EXIT                    // ;
 292+ AD27
 293+ AD27              //  ______________________________________________________________________
 294+ AD27              //
 295+ AD27              // abs          n1 -- n2
 296+ AD27                              Colon_Def ABS_OP, "ABS", is_normal
 296+ AD27             >                New_Def  ABS_OP, "ABS", Enter_Ptr, is_normal ; ok
 296+ AD27             >
 296+ AD27             >Dict_Ptr        defl    $
 296+ AD27             >
 296+ AD27             >//              ______________________________________________________________________
 296+ AD27             >//              Heap part
 296+ AD27             >
 296+ AD27             >
 296+ AD27             >                org     (Heap_Ptr & $1FFF) + $E000
 296+ E9F9             >
 296+ E9F9             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 296+ E9F9             >Latest_Definition defl  Heap_Ptr
 296+ E9F9             >
 296+ E9F9             >                // dummy db directives used to calculate length of namec
 296+ E9F9 41 42 53    >                db      "ABS"
 296+ E9FC             >len_NFA         defl    $ - temp_NFA
 296+ E9FC             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 296+ E9F9             >
 296+ E9F9 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 296+ E9FA 41 42 53    >                db      "ABS"               // name string in 7-bit ascii, but
 296+ E9FD             >                org     $-1                 // alter last byte of Name just above to set
 296+ E9FC D3          >                db      {b $} | END_BIT     // msb as name end
 296+ E9FD             >
 296+ E9FD F1 09       >                dw      Prev_Ptr            // Link to previous definition Name
 296+ E9FF             >Prev_Ptr        defl    Heap_Ptr
 296+ E9FF             >
 296+ E9FF             >mirror_Ptr      defl    $
 296+ E9FF             >
 296+ E9FF 29 AD       >                dw      Dict_Ptr + 2        // xt
 296+ EA01             >Heap_Ptr        defl    $ - $E000           // save current HP
 296+ EA01             >
 296+ EA01             >Current_HP      defl  $ - $E000             // used to set HP once!
 296+ EA01             >
 296+ EA01             >//              ______________________________________________________________________
 296+ EA01             >//              Dictionary part
 296+ EA01             >
 296+ EA01             >                org     Dict_Ptr
 296+ AD27             >
 296+ AD27 FF 28       >                dw      mirror_Ptr - $E000 + $1F00
 296+ AD29             >
 296+ AD29             >ABS_OP:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 296+ AD29 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 296+ AD2C             >
 296+ AD2C             >
 296+ AD2C             >                endif           ; ok        // for other definitions it "points" the correct handler
 296+ AD2C             >                // Use of "; ok" to suppress "warning[fwdref]"
 296+ AD2C             >
 296+ AD2C             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 297+ AD2C 7B A0                        dw      DUP                     // dup
 298+ AD2E 0B AD                        dw      PLUS_MINUS              // +-
 299+ AD30 A2 9F                        dw      EXIT                    // ;
 300+ AD32
 301+ AD32              //  ______________________________________________________________________
 302+ AD32              //
 303+ AD32              // dabs         d1 -- d2
 304+ AD32                              Colon_Def DABS, "DABS", is_normal
 304+ AD32             >                New_Def  DABS, "DABS", Enter_Ptr, is_normal ; ok
 304+ AD32             >
 304+ AD32             >Dict_Ptr        defl    $
 304+ AD32             >
 304+ AD32             >//              ______________________________________________________________________
 304+ AD32             >//              Heap part
 304+ AD32             >
 304+ AD32             >
 304+ AD32             >                org     (Heap_Ptr & $1FFF) + $E000
 304+ EA01             >
 304+ EA01             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 304+ EA01             >Latest_Definition defl  Heap_Ptr
 304+ EA01             >
 304+ EA01             >                // dummy db directives used to calculate length of namec
 304+ EA01 44 41 42 53 >                db      "DABS"
 304+ EA05             >len_NFA         defl    $ - temp_NFA
 304+ EA05             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 304+ EA01             >
 304+ EA01 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 304+ EA02 44 41 42 53 >                db      "DABS"               // name string in 7-bit ascii, but
 304+ EA06             >                org     $-1                 // alter last byte of Name just above to set
 304+ EA05 D3          >                db      {b $} | END_BIT     // msb as name end
 304+ EA06             >
 304+ EA06 F9 09       >                dw      Prev_Ptr            // Link to previous definition Name
 304+ EA08             >Prev_Ptr        defl    Heap_Ptr
 304+ EA08             >
 304+ EA08             >mirror_Ptr      defl    $
 304+ EA08             >
 304+ EA08 34 AD       >                dw      Dict_Ptr + 2        // xt
 304+ EA0A             >Heap_Ptr        defl    $ - $E000           // save current HP
 304+ EA0A             >
 304+ EA0A             >Current_HP      defl  $ - $E000             // used to set HP once!
 304+ EA0A             >
 304+ EA0A             >//              ______________________________________________________________________
 304+ EA0A             >//              Dictionary part
 304+ EA0A             >
 304+ EA0A             >                org     Dict_Ptr
 304+ AD32             >
 304+ AD32 08 29       >                dw      mirror_Ptr - $E000 + $1F00
 304+ AD34             >
 304+ AD34             >DABS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 304+ AD34 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 304+ AD37             >
 304+ AD37             >
 304+ AD37             >                endif           ; ok        // for other definitions it "points" the correct handler
 304+ AD37             >                // Use of "; ok" to suppress "warning[fwdref]"
 304+ AD37             >
 304+ AD37             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 305+ AD37 7B A0                        dw      DUP                     // dup
 306+ AD39 1A AD                        dw      DPLUS_MINUS             // d+-
 307+ AD3B A2 9F                        dw      EXIT                    // ;
 308+ AD3D
 309+ AD3D              //  ______________________________________________________________________
 310+ AD3D              //
 311+ AD3D              // m*           n1 n2 -- d
 312+ AD3D              // multiply two integer giving a double
 313+ AD3D                              Colon_Def MMUL, "M*", is_normal
 313+ AD3D             >                New_Def  MMUL, "M*", Enter_Ptr, is_normal ; ok
 313+ AD3D             >
 313+ AD3D             >Dict_Ptr        defl    $
 313+ AD3D             >
 313+ AD3D             >//              ______________________________________________________________________
 313+ AD3D             >//              Heap part
 313+ AD3D             >
 313+ AD3D             >
 313+ AD3D             >                org     (Heap_Ptr & $1FFF) + $E000
 313+ EA0A             >
 313+ EA0A             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 313+ EA0A             >Latest_Definition defl  Heap_Ptr
 313+ EA0A             >
 313+ EA0A             >                // dummy db directives used to calculate length of namec
 313+ EA0A 4D 2A       >                db      "M*"
 313+ EA0C             >len_NFA         defl    $ - temp_NFA
 313+ EA0C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 313+ EA0A             >
 313+ EA0A 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 313+ EA0B 4D 2A       >                db      "M*"               // name string in 7-bit ascii, but
 313+ EA0D             >                org     $-1                 // alter last byte of Name just above to set
 313+ EA0C AA          >                db      {b $} | END_BIT     // msb as name end
 313+ EA0D             >
 313+ EA0D 01 0A       >                dw      Prev_Ptr            // Link to previous definition Name
 313+ EA0F             >Prev_Ptr        defl    Heap_Ptr
 313+ EA0F             >
 313+ EA0F             >mirror_Ptr      defl    $
 313+ EA0F             >
 313+ EA0F 3F AD       >                dw      Dict_Ptr + 2        // xt
 313+ EA11             >Heap_Ptr        defl    $ - $E000           // save current HP
 313+ EA11             >
 313+ EA11             >Current_HP      defl  $ - $E000             // used to set HP once!
 313+ EA11             >
 313+ EA11             >//              ______________________________________________________________________
 313+ EA11             >//              Dictionary part
 313+ EA11             >
 313+ EA11             >                org     Dict_Ptr
 313+ AD3D             >
 313+ AD3D 0F 29       >                dw      mirror_Ptr - $E000 + $1F00
 313+ AD3F             >
 313+ AD3F             >MMUL:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 313+ AD3F CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 313+ AD42             >
 313+ AD42             >
 313+ AD42             >                endif           ; ok        // for other definitions it "points" the correct handler
 313+ AD42             >                // Use of "; ok" to suppress "warning[fwdref]"
 313+ AD42             >
 313+ AD42             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 314+ AD42 B7 A0 7A 9F                  dw      TWO_DUP, XOR_OP, TO_R   // 2dup xor >r
 314+ AD46 AC 9F
 315+ AD48 29 AD 74 A0                  dw      ABS_OP, SWAP            // abs swap
 316+ AD4C 29 AD 01 9F                  dw      ABS_OP, UM_MUL          // abs um*
 317+ AD50 B7 9F 1A AD                  dw      R_TO, DPLUS_MINUS       // r> d+-
 318+ AD54 A2 9F                        dw      EXIT                    // ;
 319+ AD56
 320+ AD56              //  ______________________________________________________________________
 321+ AD56              //
 322+ AD56              // sm/rem       d n -- q r
 323+ AD56              // Symmetric division: divides a double into n giving quotient q and remainder r
 324+ AD56              // the remainder has the sign of d.
 325+ AD56                              Colon_Def SMDIVM, "SM/REM", is_normal
 325+ AD56             >                New_Def  SMDIVM, "SM/REM", Enter_Ptr, is_normal ; ok
 325+ AD56             >
 325+ AD56             >Dict_Ptr        defl    $
 325+ AD56             >
 325+ AD56             >//              ______________________________________________________________________
 325+ AD56             >//              Heap part
 325+ AD56             >
 325+ AD56             >
 325+ AD56             >                org     (Heap_Ptr & $1FFF) + $E000
 325+ EA11             >
 325+ EA11             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 325+ EA11             >Latest_Definition defl  Heap_Ptr
 325+ EA11             >
 325+ EA11             >                // dummy db directives used to calculate length of namec
 325+ EA11 53 4D 2F 52 >                db      "SM/REM"
 325+ EA15 45 4D       >
 325+ EA17             >len_NFA         defl    $ - temp_NFA
 325+ EA17             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 325+ EA11             >
 325+ EA11 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 325+ EA12 53 4D 2F 52 >                db      "SM/REM"               // name string in 7-bit ascii, but
 325+ EA16 45 4D       >
 325+ EA18             >                org     $-1                 // alter last byte of Name just above to set
 325+ EA17 CD          >                db      {b $} | END_BIT     // msb as name end
 325+ EA18             >
 325+ EA18 0A 0A       >                dw      Prev_Ptr            // Link to previous definition Name
 325+ EA1A             >Prev_Ptr        defl    Heap_Ptr
 325+ EA1A             >
 325+ EA1A             >mirror_Ptr      defl    $
 325+ EA1A             >
 325+ EA1A 58 AD       >                dw      Dict_Ptr + 2        // xt
 325+ EA1C             >Heap_Ptr        defl    $ - $E000           // save current HP
 325+ EA1C             >
 325+ EA1C             >Current_HP      defl  $ - $E000             // used to set HP once!
 325+ EA1C             >
 325+ EA1C             >//              ______________________________________________________________________
 325+ EA1C             >//              Dictionary part
 325+ EA1C             >
 325+ EA1C             >                org     Dict_Ptr
 325+ AD56             >
 325+ AD56 1A 29       >                dw      mirror_Ptr - $E000 + $1F00
 325+ AD58             >
 325+ AD58             >SMDIVM:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 325+ AD58 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 325+ AD5B             >
 325+ AD5B             >
 325+ AD5B             >                endif           ; ok        // for other definitions it "points" the correct handler
 325+ AD5B             >                // Use of "; ok" to suppress "warning[fwdref]"
 325+ AD5B             >
 325+ AD5B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 326+ AD5B 57 A0 AC 9F                  dw      OVER, TO_R, TO_R        // over >r >r
 326+ AD5F AC 9F
 327+ AD61 34 AD C2 9F                  dw      DABS, R_OP, ABS_OP      // dabs r abs
 327+ AD65 29 AD
 328+ AD67 29 9F                        dw      UMDIVMOD                // um/mod
 329+ AD69 B7 9F                        dw      R_TO                    // r>
 330+ AD6B C2 9F 7A 9F                  dw      R_OP, XOR_OP            // r xor
 331+ AD6F 0B AD 74 A0                  dw      PLUS_MINUS, SWAP        // +- swap
 332+ AD73 B7 9F                        dw      R_TO                    // r>
 333+ AD75 0B AD 74 A0                  dw      PLUS_MINUS, SWAP        // +- swap
 334+ AD79 A2 9F                        dw      EXIT                    // ;
 335+ AD7B
 336+ AD7B              //  ______________________________________________________________________
 337+ AD7B              //
 338+ AD7B              // fm/mod       d n -- q r
 339+ AD7B              // Floored division: divides a double into n giving quotient q and remainder r
 340+ AD7B              // the remainder has the sign of d.
 341+ AD7B                              Colon_Def FMDIVM, "FM/MOD", is_normal
 341+ AD7B             >                New_Def  FMDIVM, "FM/MOD", Enter_Ptr, is_normal ; ok
 341+ AD7B             >
 341+ AD7B             >Dict_Ptr        defl    $
 341+ AD7B             >
 341+ AD7B             >//              ______________________________________________________________________
 341+ AD7B             >//              Heap part
 341+ AD7B             >
 341+ AD7B             >
 341+ AD7B             >                org     (Heap_Ptr & $1FFF) + $E000
 341+ EA1C             >
 341+ EA1C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 341+ EA1C             >Latest_Definition defl  Heap_Ptr
 341+ EA1C             >
 341+ EA1C             >                // dummy db directives used to calculate length of namec
 341+ EA1C 46 4D 2F 4D >                db      "FM/MOD"
 341+ EA20 4F 44       >
 341+ EA22             >len_NFA         defl    $ - temp_NFA
 341+ EA22             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 341+ EA1C             >
 341+ EA1C 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 341+ EA1D 46 4D 2F 4D >                db      "FM/MOD"               // name string in 7-bit ascii, but
 341+ EA21 4F 44       >
 341+ EA23             >                org     $-1                 // alter last byte of Name just above to set
 341+ EA22 C4          >                db      {b $} | END_BIT     // msb as name end
 341+ EA23             >
 341+ EA23 11 0A       >                dw      Prev_Ptr            // Link to previous definition Name
 341+ EA25             >Prev_Ptr        defl    Heap_Ptr
 341+ EA25             >
 341+ EA25             >mirror_Ptr      defl    $
 341+ EA25             >
 341+ EA25 7D AD       >                dw      Dict_Ptr + 2        // xt
 341+ EA27             >Heap_Ptr        defl    $ - $E000           // save current HP
 341+ EA27             >
 341+ EA27             >Current_HP      defl  $ - $E000             // used to set HP once!
 341+ EA27             >
 341+ EA27             >//              ______________________________________________________________________
 341+ EA27             >//              Dictionary part
 341+ EA27             >
 341+ EA27             >                org     Dict_Ptr
 341+ AD7B             >
 341+ AD7B 25 29       >                dw      mirror_Ptr - $E000 + $1F00
 341+ AD7D             >
 341+ AD7D             >FMDIVM:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 341+ AD7D CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 341+ AD80             >
 341+ AD80             >
 341+ AD80             >                endif           ; ok        // for other definitions it "points" the correct handler
 341+ AD80             >                // Use of "; ok" to suppress "warning[fwdref]"
 341+ AD80             >
 341+ AD80             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 342+ AD80 7B A0 AC 9F                  dw      DUP, TO_R               // dup >r
 343+ AD84 58 AD                        dw      SMDIVM
 344+ AD86 57 A0 7B A0                  dw      OVER, DUP
 345+ AD8A C7 9F C7 9F                  dw      ZEQUAL, ZEQUAL
 346+ AD8E 74 A0 DA 9F                  dw      SWAP, ZLESS
 347+ AD92 C2 9F DA 9F                  dw      R_OP, ZLESS
 348+ AD96 7A 9F 5C 9F                  dw      XOR_OP, AND_OP
 349+ AD9A 45 9B                        dw      ZBRANCH
 350+ AD9C 10 00                        dw      Fm_Mod_Else - $
 351+ AD9E 15 A0                        dw          ONE_SUBTRACT
 352+ ADA0 74 A0 B7 9F                  dw          SWAP, R_TO
 353+ ADA4 F5 9F 74 A0                  dw          PLUS, SWAP
 354+ ADA8 38 9B                        dw      BRANCH
 355+ ADAA 06 00                        dw      Fm_Mod_Endif - $
 356+ ADAC              Fm_Mod_Else:
 357+ ADAC B7 9F 60 A0                  dw          R_TO, DROP
 358+ ADB0              Fm_Mod_Endif:
 359+ ADB0 A2 9F                        dw      EXIT
 360+ ADB2              //              dw      TWO_DUP                 // 2dup
 361+ ADB2              //              dw      XOR_OP, TO_R, TO_R      // xor >r >r
 362+ ADB2              //              dw      DABS, R_OP, ABS_OP      // dabs r abs
 363+ ADB2              //              dw      UMDIVMOD                // um/mod
 364+ ADB2              //              dw      SWAP                    // swap
 365+ ADB2              //              dw      II, ZLESS               // i'
 366+ ADB2              //              dw      ONE, AND_OP, PLUS       // 0< 1 and +
 367+ ADB2              //              dw      R_TO                    // r>
 368+ ADB2              //              dw      PLUS_MINUS, SWAP        // +- swap
 369+ ADB2              //              dw      R_OP                    // r@
 370+ ADB2              //              dw      ZLESS                   // i'
 371+ ADB2              //              dw      ONE, AND_OP, PLUS       // 0< 1 and +
 372+ ADB2              //              dw      R_TO                    // r>
 373+ ADB2              //              dw      PLUS_MINUS              // +- swap
 374+ ADB2              //              dw      EXIT                    // ;
 375+ ADB2
 376+ ADB2              //  ______________________________________________________________________
 377+ ADB2              //
 378+ ADB2              // m/mod        d n -- q r
 379+ ADB2              // multiply two integer giving a double
 380+ ADB2                              Colon_Def MDIVM, "M/MOD", is_normal
 380+ ADB2             >                New_Def  MDIVM, "M/MOD", Enter_Ptr, is_normal ; ok
 380+ ADB2             >
 380+ ADB2             >Dict_Ptr        defl    $
 380+ ADB2             >
 380+ ADB2             >//              ______________________________________________________________________
 380+ ADB2             >//              Heap part
 380+ ADB2             >
 380+ ADB2             >
 380+ ADB2             >                org     (Heap_Ptr & $1FFF) + $E000
 380+ EA27             >
 380+ EA27             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 380+ EA27             >Latest_Definition defl  Heap_Ptr
 380+ EA27             >
 380+ EA27             >                // dummy db directives used to calculate length of namec
 380+ EA27 4D 2F 4D 4F >                db      "M/MOD"
 380+ EA2B 44          >
 380+ EA2C             >len_NFA         defl    $ - temp_NFA
 380+ EA2C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 380+ EA27             >
 380+ EA27 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 380+ EA28 4D 2F 4D 4F >                db      "M/MOD"               // name string in 7-bit ascii, but
 380+ EA2C 44          >
 380+ EA2D             >                org     $-1                 // alter last byte of Name just above to set
 380+ EA2C C4          >                db      {b $} | END_BIT     // msb as name end
 380+ EA2D             >
 380+ EA2D 1C 0A       >                dw      Prev_Ptr            // Link to previous definition Name
 380+ EA2F             >Prev_Ptr        defl    Heap_Ptr
 380+ EA2F             >
 380+ EA2F             >mirror_Ptr      defl    $
 380+ EA2F             >
 380+ EA2F B4 AD       >                dw      Dict_Ptr + 2        // xt
 380+ EA31             >Heap_Ptr        defl    $ - $E000           // save current HP
 380+ EA31             >
 380+ EA31             >Current_HP      defl  $ - $E000             // used to set HP once!
 380+ EA31             >
 380+ EA31             >//              ______________________________________________________________________
 380+ EA31             >//              Dictionary part
 380+ EA31             >
 380+ EA31             >                org     Dict_Ptr
 380+ ADB2             >
 380+ ADB2 2F 29       >                dw      mirror_Ptr - $E000 + $1F00
 380+ ADB4             >
 380+ ADB4             >MDIVM:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 380+ ADB4 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 380+ ADB7             >
 380+ ADB7             >
 380+ ADB7             >                endif           ; ok        // for other definitions it "points" the correct handler
 380+ ADB7             >                // Use of "; ok" to suppress "warning[fwdref]"
 380+ ADB7             >
 380+ ADB7             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 381+ ADB7 58 AD                        dw      SMDIVM
 382+ ADB9 A2 9F                        dw      EXIT                    // ;
 383+ ADBB
 384+ ADBB              //  ______________________________________________________________________
 385+ ADBB              //
 386+ ADBB              // m/           d n -- q
 387+ ADBB              // multiply two integer giving a double
 388+ ADBB                              Colon_Def MDIV, "M/", is_normal
 388+ ADBB             >                New_Def  MDIV, "M/", Enter_Ptr, is_normal ; ok
 388+ ADBB             >
 388+ ADBB             >Dict_Ptr        defl    $
 388+ ADBB             >
 388+ ADBB             >//              ______________________________________________________________________
 388+ ADBB             >//              Heap part
 388+ ADBB             >
 388+ ADBB             >
 388+ ADBB             >                org     (Heap_Ptr & $1FFF) + $E000
 388+ EA31             >
 388+ EA31             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 388+ EA31             >Latest_Definition defl  Heap_Ptr
 388+ EA31             >
 388+ EA31             >                // dummy db directives used to calculate length of namec
 388+ EA31 4D 2F       >                db      "M/"
 388+ EA33             >len_NFA         defl    $ - temp_NFA
 388+ EA33             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 388+ EA31             >
 388+ EA31 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 388+ EA32 4D 2F       >                db      "M/"               // name string in 7-bit ascii, but
 388+ EA34             >                org     $-1                 // alter last byte of Name just above to set
 388+ EA33 AF          >                db      {b $} | END_BIT     // msb as name end
 388+ EA34             >
 388+ EA34 27 0A       >                dw      Prev_Ptr            // Link to previous definition Name
 388+ EA36             >Prev_Ptr        defl    Heap_Ptr
 388+ EA36             >
 388+ EA36             >mirror_Ptr      defl    $
 388+ EA36             >
 388+ EA36 BD AD       >                dw      Dict_Ptr + 2        // xt
 388+ EA38             >Heap_Ptr        defl    $ - $E000           // save current HP
 388+ EA38             >
 388+ EA38             >Current_HP      defl  $ - $E000             // used to set HP once!
 388+ EA38             >
 388+ EA38             >//              ______________________________________________________________________
 388+ EA38             >//              Dictionary part
 388+ EA38             >
 388+ EA38             >                org     Dict_Ptr
 388+ ADBB             >
 388+ ADBB 36 29       >                dw      mirror_Ptr - $E000 + $1F00
 388+ ADBD             >
 388+ ADBD             >MDIV:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 388+ ADBD CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 388+ ADC0             >
 388+ ADC0             >
 388+ ADC0             >                endif           ; ok        // for other definitions it "points" the correct handler
 388+ ADC0             >                // Use of "; ok" to suppress "warning[fwdref]"
 388+ ADC0             >
 388+ ADC0             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 389+ ADC0 B4 AD 65 A0                  dw      MDIVM, NIP
 390+ ADC4 A2 9F                        dw      EXIT                    // ;
 391+ ADC6
 392+ ADC6              //  ______________________________________________________________________
 393+ ADC6              //
 394+ ADC6              // *            n1 n2 -- n3
 395+ ADC6              // multiply two integer
 396+ ADC6                              Colon_Def MUL, "*", is_normal
 396+ ADC6             >                New_Def  MUL, "*", Enter_Ptr, is_normal ; ok
 396+ ADC6             >
 396+ ADC6             >Dict_Ptr        defl    $
 396+ ADC6             >
 396+ ADC6             >//              ______________________________________________________________________
 396+ ADC6             >//              Heap part
 396+ ADC6             >
 396+ ADC6             >
 396+ ADC6             >                org     (Heap_Ptr & $1FFF) + $E000
 396+ EA38             >
 396+ EA38             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 396+ EA38             >Latest_Definition defl  Heap_Ptr
 396+ EA38             >
 396+ EA38             >                // dummy db directives used to calculate length of namec
 396+ EA38 2A          >                db      "*"
 396+ EA39             >len_NFA         defl    $ - temp_NFA
 396+ EA39             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 396+ EA38             >
 396+ EA38 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 396+ EA39 2A          >                db      "*"               // name string in 7-bit ascii, but
 396+ EA3A             >                org     $-1                 // alter last byte of Name just above to set
 396+ EA39 AA          >                db      {b $} | END_BIT     // msb as name end
 396+ EA3A             >
 396+ EA3A 31 0A       >                dw      Prev_Ptr            // Link to previous definition Name
 396+ EA3C             >Prev_Ptr        defl    Heap_Ptr
 396+ EA3C             >
 396+ EA3C             >mirror_Ptr      defl    $
 396+ EA3C             >
 396+ EA3C C8 AD       >                dw      Dict_Ptr + 2        // xt
 396+ EA3E             >Heap_Ptr        defl    $ - $E000           // save current HP
 396+ EA3E             >
 396+ EA3E             >Current_HP      defl  $ - $E000             // used to set HP once!
 396+ EA3E             >
 396+ EA3E             >//              ______________________________________________________________________
 396+ EA3E             >//              Dictionary part
 396+ EA3E             >
 396+ EA3E             >                org     Dict_Ptr
 396+ ADC6             >
 396+ ADC6 3C 29       >                dw      mirror_Ptr - $E000 + $1F00
 396+ ADC8             >
 396+ ADC8             >MUL:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 396+ ADC8 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 396+ ADCB             >
 396+ ADCB             >
 396+ ADCB             >                endif           ; ok        // for other definitions it "points" the correct handler
 396+ ADCB             >                // Use of "; ok" to suppress "warning[fwdref]"
 396+ ADCB             >
 396+ ADCB             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 397+ ADCB 3F AD 60 A0                  dw      MMUL, DROP              // m* drop
 398+ ADCF A2 9F                        dw      EXIT                    // ;
 399+ ADD1
 400+ ADD1              //  ______________________________________________________________________
 401+ ADD1              //
 402+ ADD1              // /mod         n1 n2 -- n3 n4
 403+ ADD1              // leaves quotient n4 and remainder n3 of the integer division n1 / n2.
 404+ ADD1              // The remainder has the sign of n1
 405+ ADD1                              Colon_Def DIVMOD, "/MOD", is_normal
 405+ ADD1             >                New_Def  DIVMOD, "/MOD", Enter_Ptr, is_normal ; ok
 405+ ADD1             >
 405+ ADD1             >Dict_Ptr        defl    $
 405+ ADD1             >
 405+ ADD1             >//              ______________________________________________________________________
 405+ ADD1             >//              Heap part
 405+ ADD1             >
 405+ ADD1             >
 405+ ADD1             >                org     (Heap_Ptr & $1FFF) + $E000
 405+ EA3E             >
 405+ EA3E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 405+ EA3E             >Latest_Definition defl  Heap_Ptr
 405+ EA3E             >
 405+ EA3E             >                // dummy db directives used to calculate length of namec
 405+ EA3E 2F 4D 4F 44 >                db      "/MOD"
 405+ EA42             >len_NFA         defl    $ - temp_NFA
 405+ EA42             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 405+ EA3E             >
 405+ EA3E 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 405+ EA3F 2F 4D 4F 44 >                db      "/MOD"               // name string in 7-bit ascii, but
 405+ EA43             >                org     $-1                 // alter last byte of Name just above to set
 405+ EA42 C4          >                db      {b $} | END_BIT     // msb as name end
 405+ EA43             >
 405+ EA43 38 0A       >                dw      Prev_Ptr            // Link to previous definition Name
 405+ EA45             >Prev_Ptr        defl    Heap_Ptr
 405+ EA45             >
 405+ EA45             >mirror_Ptr      defl    $
 405+ EA45             >
 405+ EA45 D3 AD       >                dw      Dict_Ptr + 2        // xt
 405+ EA47             >Heap_Ptr        defl    $ - $E000           // save current HP
 405+ EA47             >
 405+ EA47             >Current_HP      defl  $ - $E000             // used to set HP once!
 405+ EA47             >
 405+ EA47             >//              ______________________________________________________________________
 405+ EA47             >//              Dictionary part
 405+ EA47             >
 405+ EA47             >                org     Dict_Ptr
 405+ ADD1             >
 405+ ADD1 45 29       >                dw      mirror_Ptr - $E000 + $1F00
 405+ ADD3             >
 405+ ADD3             >DIVMOD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 405+ ADD3 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 405+ ADD6             >
 405+ ADD6             >
 405+ ADD6             >                endif           ; ok        // for other definitions it "points" the correct handler
 405+ ADD6             >                // Use of "; ok" to suppress "warning[fwdref]"
 405+ ADD6             >
 405+ ADD6             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 406+ ADD6 AC 9F 2A A3                  dw      TO_R, S_TO_D, R_TO      // >r s->d r>
 406+ ADDA B7 9F
 407+ ADDC B4 AD                        dw      MDIVM                   // m/mod
 408+ ADDE A2 9F                        dw      EXIT                    // ;
 409+ ADE0
 410+ ADE0              //  ______________________________________________________________________
 411+ ADE0              //
 412+ ADE0              // /            n1 n2 -- n3
 413+ ADE0              // division
 414+ ADE0                              Colon_Def DIV, "/", is_normal
 414+ ADE0             >                New_Def  DIV, "/", Enter_Ptr, is_normal ; ok
 414+ ADE0             >
 414+ ADE0             >Dict_Ptr        defl    $
 414+ ADE0             >
 414+ ADE0             >//              ______________________________________________________________________
 414+ ADE0             >//              Heap part
 414+ ADE0             >
 414+ ADE0             >
 414+ ADE0             >                org     (Heap_Ptr & $1FFF) + $E000
 414+ EA47             >
 414+ EA47             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 414+ EA47             >Latest_Definition defl  Heap_Ptr
 414+ EA47             >
 414+ EA47             >                // dummy db directives used to calculate length of namec
 414+ EA47 2F          >                db      "/"
 414+ EA48             >len_NFA         defl    $ - temp_NFA
 414+ EA48             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 414+ EA47             >
 414+ EA47 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 414+ EA48 2F          >                db      "/"               // name string in 7-bit ascii, but
 414+ EA49             >                org     $-1                 // alter last byte of Name just above to set
 414+ EA48 AF          >                db      {b $} | END_BIT     // msb as name end
 414+ EA49             >
 414+ EA49 3E 0A       >                dw      Prev_Ptr            // Link to previous definition Name
 414+ EA4B             >Prev_Ptr        defl    Heap_Ptr
 414+ EA4B             >
 414+ EA4B             >mirror_Ptr      defl    $
 414+ EA4B             >
 414+ EA4B E2 AD       >                dw      Dict_Ptr + 2        // xt
 414+ EA4D             >Heap_Ptr        defl    $ - $E000           // save current HP
 414+ EA4D             >
 414+ EA4D             >Current_HP      defl  $ - $E000             // used to set HP once!
 414+ EA4D             >
 414+ EA4D             >//              ______________________________________________________________________
 414+ EA4D             >//              Dictionary part
 414+ EA4D             >
 414+ EA4D             >                org     Dict_Ptr
 414+ ADE0             >
 414+ ADE0 4B 29       >                dw      mirror_Ptr - $E000 + $1F00
 414+ ADE2             >
 414+ ADE2             >DIV:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 414+ ADE2 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 414+ ADE5             >
 414+ ADE5             >
 414+ ADE5             >                endif           ; ok        // for other definitions it "points" the correct handler
 414+ ADE5             >                // Use of "; ok" to suppress "warning[fwdref]"
 414+ ADE5             >
 414+ ADE5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 415+ ADE5 D3 AD 65 A0                  dw      DIVMOD, NIP             // /mod nip
 416+ ADE9 A2 9F                        dw      EXIT                    // ;
 417+ ADEB
 418+ ADEB              //  ______________________________________________________________________
 419+ ADEB              //
 420+ ADEB              // mod          n1 n2 -- n3
 421+ ADEB                              Colon_Def MOD, "MOD", is_normal
 421+ ADEB             >                New_Def  MOD, "MOD", Enter_Ptr, is_normal ; ok
 421+ ADEB             >
 421+ ADEB             >Dict_Ptr        defl    $
 421+ ADEB             >
 421+ ADEB             >//              ______________________________________________________________________
 421+ ADEB             >//              Heap part
 421+ ADEB             >
 421+ ADEB             >
 421+ ADEB             >                org     (Heap_Ptr & $1FFF) + $E000
 421+ EA4D             >
 421+ EA4D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 421+ EA4D             >Latest_Definition defl  Heap_Ptr
 421+ EA4D             >
 421+ EA4D             >                // dummy db directives used to calculate length of namec
 421+ EA4D 4D 4F 44    >                db      "MOD"
 421+ EA50             >len_NFA         defl    $ - temp_NFA
 421+ EA50             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 421+ EA4D             >
 421+ EA4D 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 421+ EA4E 4D 4F 44    >                db      "MOD"               // name string in 7-bit ascii, but
 421+ EA51             >                org     $-1                 // alter last byte of Name just above to set
 421+ EA50 C4          >                db      {b $} | END_BIT     // msb as name end
 421+ EA51             >
 421+ EA51 47 0A       >                dw      Prev_Ptr            // Link to previous definition Name
 421+ EA53             >Prev_Ptr        defl    Heap_Ptr
 421+ EA53             >
 421+ EA53             >mirror_Ptr      defl    $
 421+ EA53             >
 421+ EA53 ED AD       >                dw      Dict_Ptr + 2        // xt
 421+ EA55             >Heap_Ptr        defl    $ - $E000           // save current HP
 421+ EA55             >
 421+ EA55             >Current_HP      defl  $ - $E000             // used to set HP once!
 421+ EA55             >
 421+ EA55             >//              ______________________________________________________________________
 421+ EA55             >//              Dictionary part
 421+ EA55             >
 421+ EA55             >                org     Dict_Ptr
 421+ ADEB             >
 421+ ADEB 53 29       >                dw      mirror_Ptr - $E000 + $1F00
 421+ ADED             >
 421+ ADED             >MOD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 421+ ADED CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 421+ ADF0             >
 421+ ADF0             >
 421+ ADF0             >                endif           ; ok        // for other definitions it "points" the correct handler
 421+ ADF0             >                // Use of "; ok" to suppress "warning[fwdref]"
 421+ ADF0             >
 421+ ADF0             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 422+ ADF0 D3 AD 60 A0                  dw      DIVMOD, DROP            // /mod drop
 423+ ADF4 A2 9F                        dw      EXIT                    // ;
 424+ ADF6
 425+ ADF6              //  ______________________________________________________________________
 426+ ADF6              //
 427+ ADF6              // */mod        n1 n2 n3 -- n4 n5
 428+ ADF6              // leaves the quotient n5 and the remainder n4 of the operation
 429+ ADF6              // (n1 * n2) / n3. The intermediate passage through a double number
 430+ ADF6              // avoids loss of precision
 431+ ADF6                              Colon_Def MUL_DIV_MOD, "*/MOD", is_normal
 431+ ADF6             >                New_Def  MUL_DIV_MOD, "*/MOD", Enter_Ptr, is_normal ; ok
 431+ ADF6             >
 431+ ADF6             >Dict_Ptr        defl    $
 431+ ADF6             >
 431+ ADF6             >//              ______________________________________________________________________
 431+ ADF6             >//              Heap part
 431+ ADF6             >
 431+ ADF6             >
 431+ ADF6             >                org     (Heap_Ptr & $1FFF) + $E000
 431+ EA55             >
 431+ EA55             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 431+ EA55             >Latest_Definition defl  Heap_Ptr
 431+ EA55             >
 431+ EA55             >                // dummy db directives used to calculate length of namec
 431+ EA55 2A 2F 4D 4F >                db      "*/MOD"
 431+ EA59 44          >
 431+ EA5A             >len_NFA         defl    $ - temp_NFA
 431+ EA5A             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 431+ EA55             >
 431+ EA55 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 431+ EA56 2A 2F 4D 4F >                db      "*/MOD"               // name string in 7-bit ascii, but
 431+ EA5A 44          >
 431+ EA5B             >                org     $-1                 // alter last byte of Name just above to set
 431+ EA5A C4          >                db      {b $} | END_BIT     // msb as name end
 431+ EA5B             >
 431+ EA5B 4D 0A       >                dw      Prev_Ptr            // Link to previous definition Name
 431+ EA5D             >Prev_Ptr        defl    Heap_Ptr
 431+ EA5D             >
 431+ EA5D             >mirror_Ptr      defl    $
 431+ EA5D             >
 431+ EA5D F8 AD       >                dw      Dict_Ptr + 2        // xt
 431+ EA5F             >Heap_Ptr        defl    $ - $E000           // save current HP
 431+ EA5F             >
 431+ EA5F             >Current_HP      defl  $ - $E000             // used to set HP once!
 431+ EA5F             >
 431+ EA5F             >//              ______________________________________________________________________
 431+ EA5F             >//              Dictionary part
 431+ EA5F             >
 431+ EA5F             >                org     Dict_Ptr
 431+ ADF6             >
 431+ ADF6 5D 29       >                dw      mirror_Ptr - $E000 + $1F00
 431+ ADF8             >
 431+ ADF8             >MUL_DIV_MOD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 431+ ADF8 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 431+ ADFB             >
 431+ ADFB             >
 431+ ADFB             >                endif           ; ok        // for other definitions it "points" the correct handler
 431+ ADFB             >                // Use of "; ok" to suppress "warning[fwdref]"
 431+ ADFB             >
 431+ ADFB             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 432+ ADFB AC 9F 3F AD                  dw      TO_R, MMUL              // >r  m*
 433+ ADFF B7 9F B4 AD                  dw      R_TO, MDIVM             // r>  m/mod
 434+ AE03 A2 9F                        dw      EXIT                    // ;
 435+ AE05
 436+ AE05              //  ______________________________________________________________________
 437+ AE05              //
 438+ AE05              // */          n1 n2 n3 -- n4
 439+ AE05              // (n1 * n2) / n3. The intermediate passage through a double number avoids loss of precision
 440+ AE05                              Colon_Def MUL_DIV, "*/", is_normal
 440+ AE05             >                New_Def  MUL_DIV, "*/", Enter_Ptr, is_normal ; ok
 440+ AE05             >
 440+ AE05             >Dict_Ptr        defl    $
 440+ AE05             >
 440+ AE05             >//              ______________________________________________________________________
 440+ AE05             >//              Heap part
 440+ AE05             >
 440+ AE05             >
 440+ AE05             >                org     (Heap_Ptr & $1FFF) + $E000
 440+ EA5F             >
 440+ EA5F             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 440+ EA5F             >Latest_Definition defl  Heap_Ptr
 440+ EA5F             >
 440+ EA5F             >                // dummy db directives used to calculate length of namec
 440+ EA5F 2A 2F       >                db      "*/"
 440+ EA61             >len_NFA         defl    $ - temp_NFA
 440+ EA61             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 440+ EA5F             >
 440+ EA5F 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 440+ EA60 2A 2F       >                db      "*/"               // name string in 7-bit ascii, but
 440+ EA62             >                org     $-1                 // alter last byte of Name just above to set
 440+ EA61 AF          >                db      {b $} | END_BIT     // msb as name end
 440+ EA62             >
 440+ EA62 55 0A       >                dw      Prev_Ptr            // Link to previous definition Name
 440+ EA64             >Prev_Ptr        defl    Heap_Ptr
 440+ EA64             >
 440+ EA64             >mirror_Ptr      defl    $
 440+ EA64             >
 440+ EA64 07 AE       >                dw      Dict_Ptr + 2        // xt
 440+ EA66             >Heap_Ptr        defl    $ - $E000           // save current HP
 440+ EA66             >
 440+ EA66             >Current_HP      defl  $ - $E000             // used to set HP once!
 440+ EA66             >
 440+ EA66             >//              ______________________________________________________________________
 440+ EA66             >//              Dictionary part
 440+ EA66             >
 440+ EA66             >                org     Dict_Ptr
 440+ AE05             >
 440+ AE05 64 29       >                dw      mirror_Ptr - $E000 + $1F00
 440+ AE07             >
 440+ AE07             >MUL_DIV:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 440+ AE07 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 440+ AE0A             >
 440+ AE0A             >
 440+ AE0A             >                endif           ; ok        // for other definitions it "points" the correct handler
 440+ AE0A             >                // Use of "; ok" to suppress "warning[fwdref]"
 440+ AE0A             >
 440+ AE0A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 441+ AE0A F8 AD                        dw     MUL_DIV_MOD              // */mod
 442+ AE0C 65 A0                        dw     NIP                      // nip
 443+ AE0E A2 9F                        dw     EXIT                     // ;
 444+ AE10
 445+ AE10
 446+ AE10              //  ______________________________________________________________________
 447+ AE10              //
 448+ AE10              // m/mod        ud1 u2 -- u3 ud4
 449+ AE10              // mixed operation: it leaves the remainder u3 and the quotient ud4 of ud1 / u1.
 450+ AE10              // All terms are unsigned.
 451+ AE10              //              Colon_Def MDIV_MOD, "M/MOD", is_normal
 452+ AE10              //              dw      TO_R                    // >r           ( ud1 )
 453+ AE10              //              dw      ZERO, R_OP, UMDIVMOD    // 0 r um/mod   ( l rem1 h/r )
 454+ AE10              //              dw      R_TO, SWAP, TO_R        // r> swap >r   ( l rem )
 455+ AE10              //              dw      UMDIVMOD                // um/mod       ( rem2 l/r )
 456+ AE10              //              dw      R_TO                    // r>           ( rem2 l/r h/r )
 457+ AE10              //              dw      EXIT                    // ;
 458+ AE10
 459+ AE10              //  ______________________________________________________________________
 460+ AE10              //
 461+ AE10              // (line)       n1 n2 -- a b
 462+ AE10              // sends the line n1 of block n2 to the disk buffer.
 463+ AE10              // it returns the address a and ca counter b = C/L meaning a whole line.
 464+ AE10                              Colon_Def CLINE, "(LINE)", is_normal
 464+ AE10             >                New_Def  CLINE, "(LINE)", Enter_Ptr, is_normal ; ok
 464+ AE10             >
 464+ AE10             >Dict_Ptr        defl    $
 464+ AE10             >
 464+ AE10             >//              ______________________________________________________________________
 464+ AE10             >//              Heap part
 464+ AE10             >
 464+ AE10             >
 464+ AE10             >                org     (Heap_Ptr & $1FFF) + $E000
 464+ EA66             >
 464+ EA66             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 464+ EA66             >Latest_Definition defl  Heap_Ptr
 464+ EA66             >
 464+ EA66             >                // dummy db directives used to calculate length of namec
 464+ EA66 28 4C 49 4E >                db      "(LINE)"
 464+ EA6A 45 29       >
 464+ EA6C             >len_NFA         defl    $ - temp_NFA
 464+ EA6C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 464+ EA66             >
 464+ EA66 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 464+ EA67 28 4C 49 4E >                db      "(LINE)"               // name string in 7-bit ascii, but
 464+ EA6B 45 29       >
 464+ EA6D             >                org     $-1                 // alter last byte of Name just above to set
 464+ EA6C A9          >                db      {b $} | END_BIT     // msb as name end
 464+ EA6D             >
 464+ EA6D 5F 0A       >                dw      Prev_Ptr            // Link to previous definition Name
 464+ EA6F             >Prev_Ptr        defl    Heap_Ptr
 464+ EA6F             >
 464+ EA6F             >mirror_Ptr      defl    $
 464+ EA6F             >
 464+ EA6F 12 AE       >                dw      Dict_Ptr + 2        // xt
 464+ EA71             >Heap_Ptr        defl    $ - $E000           // save current HP
 464+ EA71             >
 464+ EA71             >Current_HP      defl  $ - $E000             // used to set HP once!
 464+ EA71             >
 464+ EA71             >//              ______________________________________________________________________
 464+ EA71             >//              Dictionary part
 464+ EA71             >
 464+ EA71             >                org     Dict_Ptr
 464+ AE10             >
 464+ AE10 6F 29       >                dw      mirror_Ptr - $E000 + $1F00
 464+ AE12             >
 464+ AE12             >CLINE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 464+ AE12 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 464+ AE15             >
 464+ AE15             >
 464+ AE15             >                endif           ; ok        // for other definitions it "points" the correct handler
 464+ AE15             >                // Use of "; ok" to suppress "warning[fwdref]"
 464+ AE15             >
 464+ AE15             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 465+ AE15 AC 9F                        dw      TO_R                    // >r
 466+ AE17 FB A1                        dw      CL                      // c/l
 467+ AE19 02 A2 F8 AD                  dw      BBUF, MUL_DIV_MOD       // */mod
 468+ AE1D B7 9F                        dw      R_TO                    // r>
 469+ AE1F 09 A2 C8 AD                  dw      BSCR, MUL, PLUS         // b/scr * +
 469+ AE23 F5 9F
 470+ AE25 29 B0                        dw      BLOCK                   // block   ( forward )
 471+ AE27 F5 9F                        dw      PLUS                    // +
 472+ AE29 FB A1                        dw      CL                      // c/l
 473+ AE2B A2 9F                        dw      EXIT                    // ;
 474+ AE2D
 475+ AE2D              //  ______________________________________________________________________
 476+ AE2D              //
 477+ AE2D              // .line        n1 n2 --
 478+ AE2D              // Sends to output line  n1  of screen n2.
 479+ AE2D                              Colon_Def DOT_LINE, ".LINE", is_normal
 479+ AE2D             >                New_Def  DOT_LINE, ".LINE", Enter_Ptr, is_normal ; ok
 479+ AE2D             >
 479+ AE2D             >Dict_Ptr        defl    $
 479+ AE2D             >
 479+ AE2D             >//              ______________________________________________________________________
 479+ AE2D             >//              Heap part
 479+ AE2D             >
 479+ AE2D             >
 479+ AE2D             >                org     (Heap_Ptr & $1FFF) + $E000
 479+ EA71             >
 479+ EA71             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 479+ EA71             >Latest_Definition defl  Heap_Ptr
 479+ EA71             >
 479+ EA71             >                // dummy db directives used to calculate length of namec
 479+ EA71 2E 4C 49 4E >                db      ".LINE"
 479+ EA75 45          >
 479+ EA76             >len_NFA         defl    $ - temp_NFA
 479+ EA76             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 479+ EA71             >
 479+ EA71 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 479+ EA72 2E 4C 49 4E >                db      ".LINE"               // name string in 7-bit ascii, but
 479+ EA76 45          >
 479+ EA77             >                org     $-1                 // alter last byte of Name just above to set
 479+ EA76 C5          >                db      {b $} | END_BIT     // msb as name end
 479+ EA77             >
 479+ EA77 66 0A       >                dw      Prev_Ptr            // Link to previous definition Name
 479+ EA79             >Prev_Ptr        defl    Heap_Ptr
 479+ EA79             >
 479+ EA79             >mirror_Ptr      defl    $
 479+ EA79             >
 479+ EA79 2F AE       >                dw      Dict_Ptr + 2        // xt
 479+ EA7B             >Heap_Ptr        defl    $ - $E000           // save current HP
 479+ EA7B             >
 479+ EA7B             >Current_HP      defl  $ - $E000             // used to set HP once!
 479+ EA7B             >
 479+ EA7B             >//              ______________________________________________________________________
 479+ EA7B             >//              Dictionary part
 479+ EA7B             >
 479+ EA7B             >                org     Dict_Ptr
 479+ AE2D             >
 479+ AE2D 79 29       >                dw      mirror_Ptr - $E000 + $1F00
 479+ AE2F             >
 479+ AE2F             >DOT_LINE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 479+ AE2F CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 479+ AE32             >
 479+ AE32             >
 479+ AE32             >                endif           ; ok        // for other definitions it "points" the correct handler
 479+ AE32             >                // Use of "; ok" to suppress "warning[fwdref]"
 479+ AE32             >
 479+ AE32             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 480+ AE32 12 AE D9 A6                  dw      CLINE, LTRAILING, TYPE  // (line) -trailing type
 480+ AE36 C2 A6
 481+ AE38 A2 9F                        dw      EXIT                    // ;
 482+ AE3A
 483+ AE3A              //  ______________________________________________________________________
 484+ AE3A              //
 485+ AE3A              // message       n1 n2 --
 486+ AE3A              // prints error message to current channel.
 487+ AE3A              // if WARNING is 0, prints "MSG#n".
 488+ AE3A              // if WARNING is 1, prints line n of screen 4.
 489+ AE3A              // if WARNING is -1, see ERROR
 490+ AE3A              // value can be negative or beyond block 4.
 491+ AE3A                              Colon_Def MESSAGE, "MESSAGE", is_normal
 491+ AE3A             >                New_Def  MESSAGE, "MESSAGE", Enter_Ptr, is_normal ; ok
 491+ AE3A             >
 491+ AE3A             >Dict_Ptr        defl    $
 491+ AE3A             >
 491+ AE3A             >//              ______________________________________________________________________
 491+ AE3A             >//              Heap part
 491+ AE3A             >
 491+ AE3A             >
 491+ AE3A             >                org     (Heap_Ptr & $1FFF) + $E000
 491+ EA7B             >
 491+ EA7B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 491+ EA7B             >Latest_Definition defl  Heap_Ptr
 491+ EA7B             >
 491+ EA7B             >                // dummy db directives used to calculate length of namec
 491+ EA7B 4D 45 53 53 >                db      "MESSAGE"
 491+ EA7F 41 47 45    >
 491+ EA82             >len_NFA         defl    $ - temp_NFA
 491+ EA82             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 491+ EA7B             >
 491+ EA7B 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 491+ EA7C 4D 45 53 53 >                db      "MESSAGE"               // name string in 7-bit ascii, but
 491+ EA80 41 47 45    >
 491+ EA83             >                org     $-1                 // alter last byte of Name just above to set
 491+ EA82 C5          >                db      {b $} | END_BIT     // msb as name end
 491+ EA83             >
 491+ EA83 71 0A       >                dw      Prev_Ptr            // Link to previous definition Name
 491+ EA85             >Prev_Ptr        defl    Heap_Ptr
 491+ EA85             >
 491+ EA85             >mirror_Ptr      defl    $
 491+ EA85             >
 491+ EA85 3C AE       >                dw      Dict_Ptr + 2        // xt
 491+ EA87             >Heap_Ptr        defl    $ - $E000           // save current HP
 491+ EA87             >
 491+ EA87             >Current_HP      defl  $ - $E000             // used to set HP once!
 491+ EA87             >
 491+ EA87             >//              ______________________________________________________________________
 491+ EA87             >//              Dictionary part
 491+ EA87             >
 491+ EA87             >                org     Dict_Ptr
 491+ AE3A             >
 491+ AE3A 85 29       >                dw      mirror_Ptr - $E000 + $1F00
 491+ AE3C             >
 491+ AE3C             >MESSAGE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 491+ AE3C CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 491+ AE3F             >
 491+ AE3F             >
 491+ AE3F             >                endif           ; ok        // for other definitions it "points" the correct handler
 491+ AE3F             >                // Use of "; ok" to suppress "warning[fwdref]"
 491+ AE3F             >
 491+ AE3F             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 492+ AE3F 42 A2 D9 A0                  dw      WARNING, FETCH          // warning @
 493+ AE43                                                              // if
 494+ AE43 45 9B                        dw      ZBRANCH
 495+ AE45 18 00                        dw      Message_Else - $
 496+ AE47 F3 9A 04 00                  dw          LIT, 4              //      4
 497+ AE4B 8A A2 D9 A0                  dw          OFFSET, FETCH       //      offset @
 498+ AE4F 09 A2 E2 AD                  dw          BSCR, DIV, SUBTRACT //      b/scr / -
 498+ AE53 35 A3
 499+ AE55 2F AE                        dw          DOT_LINE            //      .line
 500+ AE57 C7 A3                        dw          SPACE               //      space
 501+ AE59                                                              // else
 502+ AE59
 503+ AE59 38 9B                        dw      BRANCH
 504+ AE5B 0B 00                        dw      Message_ENdif - $
 505+ AE5D              Message_Else:
 506+ AE5D 5F A8                        dw          C_DOT_QUOTE         //      .( msg#)
 507+ AE5F 04 6D 73 67                  db          4, "msg#"
 507+ AE63 23
 508+ AE64 6D B5                        dw          DOT                 //      .  ( forward )
 509+ AE66              Message_ENdif:                                  // endif
 510+ AE66 A2 9F                        dw      EXIT                    // ;
 511+ AE68
 512+ AE68
 513+ AE68              //  ______________________________________________________________________
 514+ AE68              //
 515+ AE68              // device
 516+ AE68                              Variable_Def DEVICE,   "DEVICE",   2
 516+ AE68             >                New_Def  DEVICE, "DEVICE", Variable_Ptr, is_normal
 516+ AE68             >
 516+ AE68             >Dict_Ptr        defl    $
 516+ AE68             >
 516+ AE68             >//              ______________________________________________________________________
 516+ AE68             >//              Heap part
 516+ AE68             >
 516+ AE68             >
 516+ AE68             >                org     (Heap_Ptr & $1FFF) + $E000
 516+ EA87             >
 516+ EA87             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 516+ EA87             >Latest_Definition defl  Heap_Ptr
 516+ EA87             >
 516+ EA87             >                // dummy db directives used to calculate length of namec
 516+ EA87 44 45 56 49 >                db      "DEVICE"
 516+ EA8B 43 45       >
 516+ EA8D             >len_NFA         defl    $ - temp_NFA
 516+ EA8D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 516+ EA87             >
 516+ EA87 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 516+ EA88 44 45 56 49 >                db      "DEVICE"               // name string in 7-bit ascii, but
 516+ EA8C 43 45       >
 516+ EA8E             >                org     $-1                 // alter last byte of Name just above to set
 516+ EA8D C5          >                db      {b $} | END_BIT     // msb as name end
 516+ EA8E             >
 516+ EA8E 7B 0A       >                dw      Prev_Ptr            // Link to previous definition Name
 516+ EA90             >Prev_Ptr        defl    Heap_Ptr
 516+ EA90             >
 516+ EA90             >mirror_Ptr      defl    $
 516+ EA90             >
 516+ EA90 6A AE       >                dw      Dict_Ptr + 2        // xt
 516+ EA92             >Heap_Ptr        defl    $ - $E000           // save current HP
 516+ EA92             >
 516+ EA92             >Current_HP      defl  $ - $E000             // used to set HP once!
 516+ EA92             >
 516+ EA92             >//              ______________________________________________________________________
 516+ EA92             >//              Dictionary part
 516+ EA92             >
 516+ EA92             >                org     Dict_Ptr
 516+ AE68             >
 516+ AE68 90 29       >                dw      mirror_Ptr - $E000 + $1F00
 516+ AE6A             >
 516+ AE6A             >DEVICE:          if Variable_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 516+ AE6A CD B8 A1    >                call    Variable_Ptr ; ok        // for primitive definitions  actual code
 516+ AE6D             >
 516+ AE6D             >
 516+ AE6D             >                endif           ; ok        // for other definitions it "points" the correct handler
 516+ AE6D             >                // Use of "; ok" to suppress "warning[fwdref]"
 516+ AE6D             >
 516+ AE6D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 516+ AE6D 02 00       >                dw      2
 517+ AE6F
 518+ AE6F              //  ______________________________________________________________________
 519+ AE6F
# file closed: C:\Zx\CSpect\Projects\vForth17_MMU7/source/L2.asm
 114  AE6F                              include "next-opt1.asm"
# file opened: C:\Zx\CSpect\Projects\vForth17_MMU7/source/next-opt1.asm
   1+ AE6F              //  ______________________________________________________________________
   2+ AE6F              //
   3+ AE6F              //  next-opt.asm
   4+ AE6F              //
   5+ AE6F              //  ZX Spectrum Next - peculiar definitions
   6+ AE6F              //  ______________________________________________________________________
   7+ AE6F
   8+ AE6F              //  ______________________________________________________________________
   9+ AE6F              //
  10+ AE6F              // reg@         n -- b
  11+ AE6F              // read Next REGister n giving byte b
  12+ AE6F              //
  13+ AE6F              //              Colon_Def REG_FETCH, "REG@", is_normal
  14+ AE6F              //              dw      LIT, $243B
  15+ AE6F              //              dw      PSTORE
  16+ AE6F              //              dw      LIT, $253B
  17+ AE6F              //              dw      PFETCH
  18+ AE6F              //              dw      EXIT
  19+ AE6F                              New_Def REG_FETCH, "REG@", is_code, is_normal
  19+ AE6F             >
  19+ AE6F             >Dict_Ptr        defl    $
  19+ AE6F             >
  19+ AE6F             >//              ______________________________________________________________________
  19+ AE6F             >//              Heap part
  19+ AE6F             >
  19+ AE6F             >
  19+ AE6F             >                org     (Heap_Ptr & $1FFF) + $E000
  19+ EA92             >
  19+ EA92             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  19+ EA92             >Latest_Definition defl  Heap_Ptr
  19+ EA92             >
  19+ EA92             >                // dummy db directives used to calculate length of namec
  19+ EA92 52 45 47 40 >                db      "REG@"
  19+ EA96             >len_NFA         defl    $ - temp_NFA
  19+ EA96             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  19+ EA92             >
  19+ EA92 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  19+ EA93 52 45 47 40 >                db      "REG@"               // name string in 7-bit ascii, but
  19+ EA97             >                org     $-1                 // alter last byte of Name just above to set
  19+ EA96 C0          >                db      {b $} | END_BIT     // msb as name end
  19+ EA97             >
  19+ EA97 87 0A       >                dw      Prev_Ptr            // Link to previous definition Name
  19+ EA99             >Prev_Ptr        defl    Heap_Ptr
  19+ EA99             >
  19+ EA99             >mirror_Ptr      defl    $
  19+ EA99             >
  19+ EA99 71 AE       >                dw      Dict_Ptr + 2        // xt
  19+ EA9B             >Heap_Ptr        defl    $ - $E000           // save current HP
  19+ EA9B             >
  19+ EA9B             >Current_HP      defl  $ - $E000             // used to set HP once!
  19+ EA9B             >
  19+ EA9B             >//              ______________________________________________________________________
  19+ EA9B             >//              Dictionary part
  19+ EA9B             >
  19+ EA9B             >                org     Dict_Ptr
  19+ AE6F             >
  19+ AE6F 99 29       >                dw      mirror_Ptr - $E000 + $1F00
  19+ AE71             >
  19+ AE71             >REG_FETCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
  19+ AE71 ~           >                call    runcode ; ok        // for primitive definitions  actual code
  19+ AE71 ~           >
  19+ AE71 ~           >
  19+ AE71             >                endif           ; ok        // for other definitions it "points" the correct handler
  19+ AE71             >                // Use of "; ok" to suppress "warning[fwdref]"
  19+ AE71             >
  19+ AE71             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  20+ AE71 D9                           exx
  21+ AE72 01 3B 24                     ld      bc, $243B
  22+ AE75 E1                           pop     hl
  23+ AE76 ED 69                        out     (c), l
  24+ AE78 04                           inc     b
  25+ AE79 ED 68                        in      l, (c)
  26+ AE7B E5                           push    hl
  27+ AE7C D9                           exx
  28+ AE7D                              next
  28+ AE7D DD E9       >                jp      (ix)
  29+ AE7F
  30+ AE7F
  31+ AE7F              //  ______________________________________________________________________
  32+ AE7F              //
  33+ AE7F              // reg!         b n --
  34+ AE7F              // write value b to Next REGister n
  35+ AE7F              //
  36+ AE7F              //              Colon_Def REG_STORE, "REG!", is_normal
  37+ AE7F              //              dw      LIT, $243B
  38+ AE7F              //              dw      PSTORE
  39+ AE7F              //              dw      LIT, $253B
  40+ AE7F              //              dw      PSTORE
  41+ AE7F              //              dw      EXIT
  42+ AE7F                              New_Def REG_STORE, "REG!", is_code, is_normal
  42+ AE7F             >
  42+ AE7F             >Dict_Ptr        defl    $
  42+ AE7F             >
  42+ AE7F             >//              ______________________________________________________________________
  42+ AE7F             >//              Heap part
  42+ AE7F             >
  42+ AE7F             >
  42+ AE7F             >                org     (Heap_Ptr & $1FFF) + $E000
  42+ EA9B             >
  42+ EA9B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  42+ EA9B             >Latest_Definition defl  Heap_Ptr
  42+ EA9B             >
  42+ EA9B             >                // dummy db directives used to calculate length of namec
  42+ EA9B 52 45 47 21 >                db      "REG!"
  42+ EA9F             >len_NFA         defl    $ - temp_NFA
  42+ EA9F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  42+ EA9B             >
  42+ EA9B 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  42+ EA9C 52 45 47 21 >                db      "REG!"               // name string in 7-bit ascii, but
  42+ EAA0             >                org     $-1                 // alter last byte of Name just above to set
  42+ EA9F A1          >                db      {b $} | END_BIT     // msb as name end
  42+ EAA0             >
  42+ EAA0 92 0A       >                dw      Prev_Ptr            // Link to previous definition Name
  42+ EAA2             >Prev_Ptr        defl    Heap_Ptr
  42+ EAA2             >
  42+ EAA2             >mirror_Ptr      defl    $
  42+ EAA2             >
  42+ EAA2 81 AE       >                dw      Dict_Ptr + 2        // xt
  42+ EAA4             >Heap_Ptr        defl    $ - $E000           // save current HP
  42+ EAA4             >
  42+ EAA4             >Current_HP      defl  $ - $E000             // used to set HP once!
  42+ EAA4             >
  42+ EAA4             >//              ______________________________________________________________________
  42+ EAA4             >//              Dictionary part
  42+ EAA4             >
  42+ EAA4             >                org     Dict_Ptr
  42+ AE7F             >
  42+ AE7F A2 29       >                dw      mirror_Ptr - $E000 + $1F00
  42+ AE81             >
  42+ AE81             >REG_STORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
  42+ AE81 ~           >                call    runcode ; ok        // for primitive definitions  actual code
  42+ AE81 ~           >
  42+ AE81 ~           >
  42+ AE81             >                endif           ; ok        // for other definitions it "points" the correct handler
  42+ AE81             >                // Use of "; ok" to suppress "warning[fwdref]"
  42+ AE81             >
  42+ AE81             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  43+ AE81 D9                           exx
  44+ AE82 01 3B 24                     ld      bc, $243B
  45+ AE85 E1                           pop     hl
  46+ AE86 ED 69                        out     (c), l
  47+ AE88 04                           inc     b
  48+ AE89 E1                           pop     hl
  49+ AE8A ED 69                        out     (c), l
  50+ AE8C D9                           exx
  51+ AE8D                              next
  51+ AE8D DD E9       >                jp      (ix)
  52+ AE8F
  53+ AE8F
  54+ AE8F              //  ______________________________________________________________________
  55+ AE8F              //
  56+ AE8F              // m_p3dos      n1 n2 n3 n4 a -- n5 n6 n7 n8  f
  57+ AE8F              // NextZXOS call wrapper.
  58+ AE8F              //  n1 = hl register parameter value
  59+ AE8F              //  n2 = de register parameter value
  60+ AE8F              //  n3 = bc register parameter value
  61+ AE8F              //  n4 =  a register parameter value
  62+ AE8F              //   a = routine address in ROM 3
  63+ AE8F              // ----
  64+ AE8F              //  n5 = hl returned value
  65+ AE8F              //  n6 = de returned value
  66+ AE8F              //  n7 = bc returned value
  67+ AE8F              //  n8 =  a returned value
  68+ AE8F              //   f
  69+ AE8F                              New_Def M_P3DOS, "M_P3DOS", is_code, is_normal
  69+ AE8F             >
  69+ AE8F             >Dict_Ptr        defl    $
  69+ AE8F             >
  69+ AE8F             >//              ______________________________________________________________________
  69+ AE8F             >//              Heap part
  69+ AE8F             >
  69+ AE8F             >
  69+ AE8F             >                org     (Heap_Ptr & $1FFF) + $E000
  69+ EAA4             >
  69+ EAA4             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  69+ EAA4             >Latest_Definition defl  Heap_Ptr
  69+ EAA4             >
  69+ EAA4             >                // dummy db directives used to calculate length of namec
  69+ EAA4 4D 5F 50 33 >                db      "M_P3DOS"
  69+ EAA8 44 4F 53    >
  69+ EAAB             >len_NFA         defl    $ - temp_NFA
  69+ EAAB             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  69+ EAA4             >
  69+ EAA4 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  69+ EAA5 4D 5F 50 33 >                db      "M_P3DOS"               // name string in 7-bit ascii, but
  69+ EAA9 44 4F 53    >
  69+ EAAC             >                org     $-1                 // alter last byte of Name just above to set
  69+ EAAB D3          >                db      {b $} | END_BIT     // msb as name end
  69+ EAAC             >
  69+ EAAC 9B 0A       >                dw      Prev_Ptr            // Link to previous definition Name
  69+ EAAE             >Prev_Ptr        defl    Heap_Ptr
  69+ EAAE             >
  69+ EAAE             >mirror_Ptr      defl    $
  69+ EAAE             >
  69+ EAAE 91 AE       >                dw      Dict_Ptr + 2        // xt
  69+ EAB0             >Heap_Ptr        defl    $ - $E000           // save current HP
  69+ EAB0             >
  69+ EAB0             >Current_HP      defl  $ - $E000             // used to set HP once!
  69+ EAB0             >
  69+ EAB0             >//              ______________________________________________________________________
  69+ EAB0             >//              Dictionary part
  69+ EAB0             >
  69+ EAB0             >                org     Dict_Ptr
  69+ AE8F             >
  69+ AE8F AE 29       >                dw      mirror_Ptr - $E000 + $1F00
  69+ AE91             >
  69+ AE91             >M_P3DOS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
  69+ AE91 ~           >                call    runcode ; ok        // for primitive definitions  actual code
  69+ AE91 ~           >
  69+ AE91 ~           >
  69+ AE91             >                endif           ; ok        // for other definitions it "points" the correct handler
  69+ AE91             >                // Use of "; ok" to suppress "warning[fwdref]"
  69+ AE91             >
  69+ AE91             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  70+ AE91 D9                            exx
  71+ AE92 E1                            pop     hl                  // dos call entry address a  //  n1 n2 n3 n4
  72+ AE93 D1                            pop     de                  // a register argument       //  n1 n2 n3
  73+ AE94 7B                            ld      a, e
  74+ AE95 C1                            pop     bc                  // bc' argument              //  n1 n2
  75+ AE96 D1                            pop     de                  // de' argument              //  n1
  76+ AE97 E3                            ex      (sp), hl            // hl' argument and entry address in TOS
  77+ AE98 D9                           exx
  78+ AE99 E1                           pop     hl                  // entry address a
  79+ AE9A DD E5                        push    ix
  80+ AE9C D5                           push    de
  81+ AE9D C5                           push    bc
  82+ AE9E EB                           ex      de, hl              // de is entry address
  83+ AE9F              //              ld      (SP_Saved), sp
  84+ AE9F              //              ld      sp, Cold_origin - 5
  85+ AE9F 0E 07                        ld      c, 7                // use 7 RAM Bank
  86+ AEA1
  87+ AEA1 CF                           rst     08
  88+ AEA2 94                           db      $94
  89+ AEA3
  90+ AEA3              //              ld      sp, (SP_Saved)
  91+ AEA3              //              push    ix
  92+ AEA3              //              pop     hl
  93+ AEA3              //              ld      (IX_Echo), hl
  94+ AEA3 DD 22 E8 9A                  ld      (IX_Echo), ix
  95+ AEA7
  96+ AEA7 D9                           exx
  97+ AEA8 C1                           pop     bc
  98+ AEA9 D1                           pop     de
  99+ AEAA DD E1                        pop     ix
 100+ AEAC D9                            exx
 101+ AEAD E5                            push    hl
 102+ AEAE D5                            push    de
 103+ AEAF C5                            push    bc
 104+ AEB0 26 00                         ld      h, 0
 105+ AEB2 6F                            ld      l, a
 106+ AEB3 E5                            push    hl
 107+ AEB4 D9                           exx
 108+ AEB5 ED 62                        sbc     hl, hl              // -1 for OK ; 0 for KO but now...
 109+ AEB7 23                           inc     hl                  //  0 for OK ; 1 for ko
 110+ AEB8 E5                           push    hl
 111+ AEB9                              next
 111+ AEB9 DD E9       >                jp      (ix)
 112+ AEBB
 113+ AEBB              //  ______________________________________________________________________
 114+ AEBB              //
 115+ AEBB              // blk-fh
 116+ AEBB                              Variable_Def BLK_FH,   "BLK-FH",   1
 116+ AEBB             >                New_Def  BLK_FH, "BLK-FH", Variable_Ptr, is_normal
 116+ AEBB             >
 116+ AEBB             >Dict_Ptr        defl    $
 116+ AEBB             >
 116+ AEBB             >//              ______________________________________________________________________
 116+ AEBB             >//              Heap part
 116+ AEBB             >
 116+ AEBB             >
 116+ AEBB             >                org     (Heap_Ptr & $1FFF) + $E000
 116+ EAB0             >
 116+ EAB0             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 116+ EAB0             >Latest_Definition defl  Heap_Ptr
 116+ EAB0             >
 116+ EAB0             >                // dummy db directives used to calculate length of namec
 116+ EAB0 42 4C 4B 2D >                db      "BLK-FH"
 116+ EAB4 46 48       >
 116+ EAB6             >len_NFA         defl    $ - temp_NFA
 116+ EAB6             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 116+ EAB0             >
 116+ EAB0 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 116+ EAB1 42 4C 4B 2D >                db      "BLK-FH"               // name string in 7-bit ascii, but
 116+ EAB5 46 48       >
 116+ EAB7             >                org     $-1                 // alter last byte of Name just above to set
 116+ EAB6 C8          >                db      {b $} | END_BIT     // msb as name end
 116+ EAB7             >
 116+ EAB7 A4 0A       >                dw      Prev_Ptr            // Link to previous definition Name
 116+ EAB9             >Prev_Ptr        defl    Heap_Ptr
 116+ EAB9             >
 116+ EAB9             >mirror_Ptr      defl    $
 116+ EAB9             >
 116+ EAB9 BD AE       >                dw      Dict_Ptr + 2        // xt
 116+ EABB             >Heap_Ptr        defl    $ - $E000           // save current HP
 116+ EABB             >
 116+ EABB             >Current_HP      defl  $ - $E000             // used to set HP once!
 116+ EABB             >
 116+ EABB             >//              ______________________________________________________________________
 116+ EABB             >//              Dictionary part
 116+ EABB             >
 116+ EABB             >                org     Dict_Ptr
 116+ AEBB             >
 116+ AEBB B9 29       >                dw      mirror_Ptr - $E000 + $1F00
 116+ AEBD             >
 116+ AEBD             >BLK_FH:          if Variable_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 116+ AEBD CD B8 A1    >                call    Variable_Ptr ; ok        // for primitive definitions  actual code
 116+ AEC0             >
 116+ AEC0             >
 116+ AEC0             >                endif           ; ok        // for other definitions it "points" the correct handler
 116+ AEC0             >                // Use of "; ok" to suppress "warning[fwdref]"
 116+ AEC0             >
 116+ AEC0             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 116+ AEC0 01 00       >                dw      1
 117+ AEC2
 118+ AEC2                              New_Def BLK_FNAME,   "BLK-FNAME", Create_Ptr, is_normal
 118+ AEC2             >
 118+ AEC2             >Dict_Ptr        defl    $
 118+ AEC2             >
 118+ AEC2             >//              ______________________________________________________________________
 118+ AEC2             >//              Heap part
 118+ AEC2             >
 118+ AEC2             >
 118+ AEC2             >                org     (Heap_Ptr & $1FFF) + $E000
 118+ EABB             >
 118+ EABB             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 118+ EABB             >Latest_Definition defl  Heap_Ptr
 118+ EABB             >
 118+ EABB             >                // dummy db directives used to calculate length of namec
 118+ EABB 42 4C 4B 2D >                db      "BLK-FNAME"
 118+ EABF 46 4E 41 4D >
 118+ EAC3 45          >
 118+ EAC4             >len_NFA         defl    $ - temp_NFA
 118+ EAC4             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 118+ EABB             >
 118+ EABB 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 118+ EABC 42 4C 4B 2D >                db      "BLK-FNAME"               // name string in 7-bit ascii, but
 118+ EAC0 46 4E 41 4D >
 118+ EAC4 45          >
 118+ EAC5             >                org     $-1                 // alter last byte of Name just above to set
 118+ EAC4 C5          >                db      {b $} | END_BIT     // msb as name end
 118+ EAC5             >
 118+ EAC5 B0 0A       >                dw      Prev_Ptr            // Link to previous definition Name
 118+ EAC7             >Prev_Ptr        defl    Heap_Ptr
 118+ EAC7             >
 118+ EAC7             >mirror_Ptr      defl    $
 118+ EAC7             >
 118+ EAC7 C4 AE       >                dw      Dict_Ptr + 2        // xt
 118+ EAC9             >Heap_Ptr        defl    $ - $E000           // save current HP
 118+ EAC9             >
 118+ EAC9             >Current_HP      defl  $ - $E000             // used to set HP once!
 118+ EAC9             >
 118+ EAC9             >//              ______________________________________________________________________
 118+ EAC9             >//              Dictionary part
 118+ EAC9             >
 118+ EAC9             >                org     Dict_Ptr
 118+ AEC2             >
 118+ AEC2 C7 29       >                dw      mirror_Ptr - $E000 + $1F00
 118+ AEC4             >
 118+ AEC4             >BLK_FNAME:          if Create_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 118+ AEC4 CD CE AA    >                call    Create_Ptr ; ok        // for primitive definitions  actual code
 118+ AEC7             >
 118+ AEC7             >
 118+ AEC7             >                endif           ; ok        // for other definitions it "points" the correct handler
 118+ AEC7             >                // Use of "; ok" to suppress "warning[fwdref]"
 118+ AEC7             >
 118+ AEC7             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 119+ AEC7 0E 21 42 6C                  db      14, "!Blocks-64.bin", 0
 119+ AECB 6F 63 6B 73
 119+ AECF 2D 36 34 2E
 119+ AED3 62 69 6E 00
 120+ AED7 00 00 00...                  ds      24
 121+ AEEF
 122+ AEEF              //  ______________________________________________________________________
 123+ AEEF              //
 124+ AEEF              // blk-seek     n --
 125+ AEEF              // seek block n  within blocks!.bin  file
 126+ AEEF                              Colon_Def BLK_SEEK, "BLK-SEEK", is_normal
 126+ AEEF             >                New_Def  BLK_SEEK, "BLK-SEEK", Enter_Ptr, is_normal ; ok
 126+ AEEF             >
 126+ AEEF             >Dict_Ptr        defl    $
 126+ AEEF             >
 126+ AEEF             >//              ______________________________________________________________________
 126+ AEEF             >//              Heap part
 126+ AEEF             >
 126+ AEEF             >
 126+ AEEF             >                org     (Heap_Ptr & $1FFF) + $E000
 126+ EAC9             >
 126+ EAC9             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 126+ EAC9             >Latest_Definition defl  Heap_Ptr
 126+ EAC9             >
 126+ EAC9             >                // dummy db directives used to calculate length of namec
 126+ EAC9 42 4C 4B 2D >                db      "BLK-SEEK"
 126+ EACD 53 45 45 4B >
 126+ EAD1             >len_NFA         defl    $ - temp_NFA
 126+ EAD1             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 126+ EAC9             >
 126+ EAC9 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 126+ EACA 42 4C 4B 2D >                db      "BLK-SEEK"               // name string in 7-bit ascii, but
 126+ EACE 53 45 45 4B >
 126+ EAD2             >                org     $-1                 // alter last byte of Name just above to set
 126+ EAD1 CB          >                db      {b $} | END_BIT     // msb as name end
 126+ EAD2             >
 126+ EAD2 BB 0A       >                dw      Prev_Ptr            // Link to previous definition Name
 126+ EAD4             >Prev_Ptr        defl    Heap_Ptr
 126+ EAD4             >
 126+ EAD4             >mirror_Ptr      defl    $
 126+ EAD4             >
 126+ EAD4 F1 AE       >                dw      Dict_Ptr + 2        // xt
 126+ EAD6             >Heap_Ptr        defl    $ - $E000           // save current HP
 126+ EAD6             >
 126+ EAD6             >Current_HP      defl  $ - $E000             // used to set HP once!
 126+ EAD6             >
 126+ EAD6             >//              ______________________________________________________________________
 126+ EAD6             >//              Dictionary part
 126+ EAD6             >
 126+ EAD6             >                org     Dict_Ptr
 126+ AEEF             >
 126+ AEEF D4 29       >                dw      mirror_Ptr - $E000 + $1F00
 126+ AEF1             >
 126+ AEF1             >BLK_SEEK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 126+ AEF1 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 126+ AEF4             >
 126+ AEF4             >
 126+ AEF4             >                endif           ; ok        // for other definitions it "points" the correct handler
 126+ AEF4             >                // Use of "; ok" to suppress "warning[fwdref]"
 126+ AEF4             >
 126+ AEF4             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 127+ AEF4 02 A2 3F AD                  dw  BBUF, MMUL
 128+ AEF8 BD AE D9 A0                  dw  BLK_FH, FETCH
 129+ AEFC 33 9E                        dw  F_SEEK
 130+ AEFE F3 9A 2D 00                  dw  LIT, $2D, QERROR
 130+ AF02 32 A5
 131+ AF04 A2 9F                        dw  EXIT
 132+ AF06
 133+ AF06              //  ______________________________________________________________________
 134+ AF06              //
 135+ AF06              // blk-read     n --
 136+ AF06              // seek block n  within blocks!.bin  file
 137+ AF06                              Colon_Def BLK_READ, "BLK-READ", is_normal
 137+ AF06             >                New_Def  BLK_READ, "BLK-READ", Enter_Ptr, is_normal ; ok
 137+ AF06             >
 137+ AF06             >Dict_Ptr        defl    $
 137+ AF06             >
 137+ AF06             >//              ______________________________________________________________________
 137+ AF06             >//              Heap part
 137+ AF06             >
 137+ AF06             >
 137+ AF06             >                org     (Heap_Ptr & $1FFF) + $E000
 137+ EAD6             >
 137+ EAD6             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 137+ EAD6             >Latest_Definition defl  Heap_Ptr
 137+ EAD6             >
 137+ EAD6             >                // dummy db directives used to calculate length of namec
 137+ EAD6 42 4C 4B 2D >                db      "BLK-READ"
 137+ EADA 52 45 41 44 >
 137+ EADE             >len_NFA         defl    $ - temp_NFA
 137+ EADE             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 137+ EAD6             >
 137+ EAD6 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 137+ EAD7 42 4C 4B 2D >                db      "BLK-READ"               // name string in 7-bit ascii, but
 137+ EADB 52 45 41 44 >
 137+ EADF             >                org     $-1                 // alter last byte of Name just above to set
 137+ EADE C4          >                db      {b $} | END_BIT     // msb as name end
 137+ EADF             >
 137+ EADF C9 0A       >                dw      Prev_Ptr            // Link to previous definition Name
 137+ EAE1             >Prev_Ptr        defl    Heap_Ptr
 137+ EAE1             >
 137+ EAE1             >mirror_Ptr      defl    $
 137+ EAE1             >
 137+ EAE1 08 AF       >                dw      Dict_Ptr + 2        // xt
 137+ EAE3             >Heap_Ptr        defl    $ - $E000           // save current HP
 137+ EAE3             >
 137+ EAE3             >Current_HP      defl  $ - $E000             // used to set HP once!
 137+ EAE3             >
 137+ EAE3             >//              ______________________________________________________________________
 137+ EAE3             >//              Dictionary part
 137+ EAE3             >
 137+ EAE3             >                org     Dict_Ptr
 137+ AF06             >
 137+ AF06 E1 29       >                dw      mirror_Ptr - $E000 + $1F00
 137+ AF08             >
 137+ AF08             >BLK_READ:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 137+ AF08 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 137+ AF0B             >
 137+ AF0B             >
 137+ AF0B             >                endif           ; ok        // for other definitions it "points" the correct handler
 137+ AF0B             >                // Use of "; ok" to suppress "warning[fwdref]"
 137+ AF0B             >
 137+ AF0B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 138+ AF0B F1 AE                        dw  BLK_SEEK
 139+ AF0D 02 A2                        dw  BBUF
 140+ AF0F BD AE D9 A0                  dw  BLK_FH, FETCH
 141+ AF13 7F 9E                        dw  F_READ
 142+ AF15 F3 9A 2E 00                  dw  LIT, $2E, QERROR
 142+ AF19 32 A5
 143+ AF1B 60 A0                        dw  DROP
 144+ AF1D A2 9F                        dw  EXIT
 145+ AF1F
 146+ AF1F              //  ______________________________________________________________________
 147+ AF1F              //
 148+ AF1F              // blk-write     n --
 149+ AF1F              // seek block n  within blocks!.bin  file
 150+ AF1F                              Colon_Def BLK_WRITE, "BLK-WRITE", is_normal
 150+ AF1F             >                New_Def  BLK_WRITE, "BLK-WRITE", Enter_Ptr, is_normal ; ok
 150+ AF1F             >
 150+ AF1F             >Dict_Ptr        defl    $
 150+ AF1F             >
 150+ AF1F             >//              ______________________________________________________________________
 150+ AF1F             >//              Heap part
 150+ AF1F             >
 150+ AF1F             >
 150+ AF1F             >                org     (Heap_Ptr & $1FFF) + $E000
 150+ EAE3             >
 150+ EAE3             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 150+ EAE3             >Latest_Definition defl  Heap_Ptr
 150+ EAE3             >
 150+ EAE3             >                // dummy db directives used to calculate length of namec
 150+ EAE3 42 4C 4B 2D >                db      "BLK-WRITE"
 150+ EAE7 57 52 49 54 >
 150+ EAEB 45          >
 150+ EAEC             >len_NFA         defl    $ - temp_NFA
 150+ EAEC             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 150+ EAE3             >
 150+ EAE3 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 150+ EAE4 42 4C 4B 2D >                db      "BLK-WRITE"               // name string in 7-bit ascii, but
 150+ EAE8 57 52 49 54 >
 150+ EAEC 45          >
 150+ EAED             >                org     $-1                 // alter last byte of Name just above to set
 150+ EAEC C5          >                db      {b $} | END_BIT     // msb as name end
 150+ EAED             >
 150+ EAED D6 0A       >                dw      Prev_Ptr            // Link to previous definition Name
 150+ EAEF             >Prev_Ptr        defl    Heap_Ptr
 150+ EAEF             >
 150+ EAEF             >mirror_Ptr      defl    $
 150+ EAEF             >
 150+ EAEF 21 AF       >                dw      Dict_Ptr + 2        // xt
 150+ EAF1             >Heap_Ptr        defl    $ - $E000           // save current HP
 150+ EAF1             >
 150+ EAF1             >Current_HP      defl  $ - $E000             // used to set HP once!
 150+ EAF1             >
 150+ EAF1             >//              ______________________________________________________________________
 150+ EAF1             >//              Dictionary part
 150+ EAF1             >
 150+ EAF1             >                org     Dict_Ptr
 150+ AF1F             >
 150+ AF1F EF 29       >                dw      mirror_Ptr - $E000 + $1F00
 150+ AF21             >
 150+ AF21             >BLK_WRITE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 150+ AF21 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 150+ AF24             >
 150+ AF24             >
 150+ AF24             >                endif           ; ok        // for other definitions it "points" the correct handler
 150+ AF24             >                // Use of "; ok" to suppress "warning[fwdref]"
 150+ AF24             >
 150+ AF24             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 151+ AF24 F1 AE                        dw  BLK_SEEK
 152+ AF26 02 A2                        dw  BBUF
 153+ AF28 BD AE D9 A0                  dw  BLK_FH, FETCH
 154+ AF2C 9A 9E                        dw  F_WRITE
 155+ AF2E F3 9A 2F 00                  dw  LIT, $2F, QERROR
 155+ AF32 32 A5
 156+ AF34 60 A0                        dw  DROP
 157+ AF36 A2 9F                        dw  EXIT
 158+ AF38
 159+ AF38              //  ______________________________________________________________________
 160+ AF38              //
 161+ AF38              // blk-init     n --
 162+ AF38              // seek block n  within blocks!.bin  file
 163+ AF38                              Colon_Def BLK_INIT, "BLK-INIT", is_normal
 163+ AF38             >                New_Def  BLK_INIT, "BLK-INIT", Enter_Ptr, is_normal ; ok
 163+ AF38             >
 163+ AF38             >Dict_Ptr        defl    $
 163+ AF38             >
 163+ AF38             >//              ______________________________________________________________________
 163+ AF38             >//              Heap part
 163+ AF38             >
 163+ AF38             >
 163+ AF38             >                org     (Heap_Ptr & $1FFF) + $E000
 163+ EAF1             >
 163+ EAF1             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 163+ EAF1             >Latest_Definition defl  Heap_Ptr
 163+ EAF1             >
 163+ EAF1             >                // dummy db directives used to calculate length of namec
 163+ EAF1 42 4C 4B 2D >                db      "BLK-INIT"
 163+ EAF5 49 4E 49 54 >
 163+ EAF9             >len_NFA         defl    $ - temp_NFA
 163+ EAF9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 163+ EAF1             >
 163+ EAF1 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 163+ EAF2 42 4C 4B 2D >                db      "BLK-INIT"               // name string in 7-bit ascii, but
 163+ EAF6 49 4E 49 54 >
 163+ EAFA             >                org     $-1                 // alter last byte of Name just above to set
 163+ EAF9 D4          >                db      {b $} | END_BIT     // msb as name end
 163+ EAFA             >
 163+ EAFA E3 0A       >                dw      Prev_Ptr            // Link to previous definition Name
 163+ EAFC             >Prev_Ptr        defl    Heap_Ptr
 163+ EAFC             >
 163+ EAFC             >mirror_Ptr      defl    $
 163+ EAFC             >
 163+ EAFC 3A AF       >                dw      Dict_Ptr + 2        // xt
 163+ EAFE             >Heap_Ptr        defl    $ - $E000           // save current HP
 163+ EAFE             >
 163+ EAFE             >Current_HP      defl  $ - $E000             // used to set HP once!
 163+ EAFE             >
 163+ EAFE             >//              ______________________________________________________________________
 163+ EAFE             >//              Dictionary part
 163+ EAFE             >
 163+ EAFE             >                org     Dict_Ptr
 163+ AF38             >
 163+ AF38 FC 29       >                dw      mirror_Ptr - $E000 + $1F00
 163+ AF3A             >
 163+ AF3A             >BLK_INIT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 163+ AF3A CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 163+ AF3D             >
 163+ AF3D             >
 163+ AF3D             >                endif           ; ok        // for other definitions it "points" the correct handler
 163+ AF3D             >                // Use of "; ok" to suppress "warning[fwdref]"
 163+ AF3D             >
 163+ AF3D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 164+ AF3D BD AE D9 A0                  dw  BLK_FH, FETCH, F_CLOSE, DROP
 164+ AF41 4F 9E 60 A0
 165+ AF45 C4 AE 0E A0                  dw  BLK_FNAME, ONE_PLUS
 166+ AF49 F6 A2 E6 A1                  dw  HERE, THREE, F_OPEN         // open for update (read+write)
 166+ AF4D AA 9E
 167+ AF4F F3 9A 2C 00                  dw  LIT, $2C, QERROR
 167+ AF53 32 A5
 168+ AF55 BD AE E3 A0                  dw  BLK_FH, STORE
 169+ AF59 A2 9F                        dw  EXIT
 170+ AF5B
 171+ AF5B              //  ______________________________________________________________________
 172+ AF5B              //
 173+ AF5B              // #sec
 174+ AF5B              // number of 512-Byte "sectors" available on thie sysstem.
 175+ AF5B              // it adds up to 16 MByte of data that can be used as source or pool for almost anything.
 176+ AF5B
 177+ AF5B                              Constant_Def NSEC , "#SEC", 32767
 177+ AF5B             >                New_Def  NSEC, "#SEC", Constant_Ptr, is_normal
 177+ AF5B             >
 177+ AF5B             >Dict_Ptr        defl    $
 177+ AF5B             >
 177+ AF5B             >//              ______________________________________________________________________
 177+ AF5B             >//              Heap part
 177+ AF5B             >
 177+ AF5B             >
 177+ AF5B             >                org     (Heap_Ptr & $1FFF) + $E000
 177+ EAFE             >
 177+ EAFE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 177+ EAFE             >Latest_Definition defl  Heap_Ptr
 177+ EAFE             >
 177+ EAFE             >                // dummy db directives used to calculate length of namec
 177+ EAFE 23 53 45 43 >                db      "#SEC"
 177+ EB02             >len_NFA         defl    $ - temp_NFA
 177+ EB02             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 177+ EAFE             >
 177+ EAFE 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 177+ EAFF 23 53 45 43 >                db      "#SEC"               // name string in 7-bit ascii, but
 177+ EB03             >                org     $-1                 // alter last byte of Name just above to set
 177+ EB02 C3          >                db      {b $} | END_BIT     // msb as name end
 177+ EB03             >
 177+ EB03 F1 0A       >                dw      Prev_Ptr            // Link to previous definition Name
 177+ EB05             >Prev_Ptr        defl    Heap_Ptr
 177+ EB05             >
 177+ EB05             >mirror_Ptr      defl    $
 177+ EB05             >
 177+ EB05 5D AF       >                dw      Dict_Ptr + 2        // xt
 177+ EB07             >Heap_Ptr        defl    $ - $E000           // save current HP
 177+ EB07             >
 177+ EB07             >Current_HP      defl  $ - $E000             // used to set HP once!
 177+ EB07             >
 177+ EB07             >//              ______________________________________________________________________
 177+ EB07             >//              Dictionary part
 177+ EB07             >
 177+ EB07             >                org     Dict_Ptr
 177+ AF5B             >
 177+ AF5B 05 2A       >                dw      mirror_Ptr - $E000 + $1F00
 177+ AF5D             >
 177+ AF5D             >NSEC:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 177+ AF5D CD A5 A1    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 177+ AF60             >
 177+ AF60             >
 177+ AF60             >                endif           ; ok        // for other definitions it "points" the correct handler
 177+ AF60             >                // Use of "; ok" to suppress "warning[fwdref]"
 177+ AF60             >
 177+ AF60             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 177+ AF60 FF 7F       >                dw      32767
 178+ AF62
 179+ AF62              //  ______________________________________________________________________
 180+ AF62
 181+ AF62
 182+ AF62
# file closed: C:\Zx\CSpect\Projects\vForth17_MMU7/source/next-opt1.asm
 115  AF62                              include "L3.asm"
# file opened: C:\Zx\CSpect\Projects\vForth17_MMU7/source/L3.asm
   1+ AF62              //  ______________________________________________________________________
   2+ AF62              //
   3+ AF62              //  L3.asm
   4+ AF62              //
   5+ AF62              //  Continuation of L2.asm
   6+ AF62              //  I/O Block definitions
   7+ AF62              //  ______________________________________________________________________
   8+ AF62
   9+ AF62
  10+ AF62              //  ______________________________________________________________________
  11+ AF62              //
  12+ AF62              // r/w          a n f --
  13+ AF62              // read/write block n depending on flag f, true-flag means read, false-flag means write.
  14+ AF62                              Colon_Def READ_WRITE, "R/W", is_normal
  14+ AF62             >                New_Def  READ_WRITE, "R/W", Enter_Ptr, is_normal ; ok
  14+ AF62             >
  14+ AF62             >Dict_Ptr        defl    $
  14+ AF62             >
  14+ AF62             >//              ______________________________________________________________________
  14+ AF62             >//              Heap part
  14+ AF62             >
  14+ AF62             >
  14+ AF62             >                org     (Heap_Ptr & $1FFF) + $E000
  14+ EB07             >
  14+ EB07             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  14+ EB07             >Latest_Definition defl  Heap_Ptr
  14+ EB07             >
  14+ EB07             >                // dummy db directives used to calculate length of namec
  14+ EB07 52 2F 57    >                db      "R/W"
  14+ EB0A             >len_NFA         defl    $ - temp_NFA
  14+ EB0A             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  14+ EB07             >
  14+ EB07 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  14+ EB08 52 2F 57    >                db      "R/W"               // name string in 7-bit ascii, but
  14+ EB0B             >                org     $-1                 // alter last byte of Name just above to set
  14+ EB0A D7          >                db      {b $} | END_BIT     // msb as name end
  14+ EB0B             >
  14+ EB0B FE 0A       >                dw      Prev_Ptr            // Link to previous definition Name
  14+ EB0D             >Prev_Ptr        defl    Heap_Ptr
  14+ EB0D             >
  14+ EB0D             >mirror_Ptr      defl    $
  14+ EB0D             >
  14+ EB0D 64 AF       >                dw      Dict_Ptr + 2        // xt
  14+ EB0F             >Heap_Ptr        defl    $ - $E000           // save current HP
  14+ EB0F             >
  14+ EB0F             >Current_HP      defl  $ - $E000             // used to set HP once!
  14+ EB0F             >
  14+ EB0F             >//              ______________________________________________________________________
  14+ EB0F             >//              Dictionary part
  14+ EB0F             >
  14+ EB0F             >                org     Dict_Ptr
  14+ AF62             >
  14+ AF62 0D 2A       >                dw      mirror_Ptr - $E000 + $1F00
  14+ AF64             >
  14+ AF64             >READ_WRITE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
  14+ AF64 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
  14+ AF67             >
  14+ AF67             >
  14+ AF67             >                endif           ; ok        // for other definitions it "points" the correct handler
  14+ AF67             >                // Use of "; ok" to suppress "warning[fwdref]"
  14+ AF67             >
  14+ AF67             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  15+ AF67 AC 9F                        dw      TO_R                    // >r
  16+ AF69 15 A0                        dw      ONE_SUBTRACT            // 1-
  17+ AF6B 7B A0 DA 9F                  dw      DUP, ZLESS              // dup 0<
  18+ AF6F 57 A0 5D AF                  dw      OVER, NSEC              // over #sec
  19+ AF73 15 A0 6F A3                  dw      ONE_SUBTRACT, GREATER   // 1- >
  20+ AF77 6B 9F                        dw      OR_OP                   // or
  21+ AF79 F3 9A 06 00                  dw      LIT, 6, QERROR          // 6 ?error
  21+ AF7D 32 A5
  22+ AF7F B7 9F                        dw      R_TO                    // r>
  23+ AF81                                                              // if
  24+ AF81 45 9B                        dw      ZBRANCH
  25+ AF83 08 00                        dw      Read_Write_Else - $
  26+ AF85 08 AF                        dw          BLK_READ            //      blk-read
  27+ AF87 38 9B                        dw      BRANCH
  28+ AF89 04 00                        dw      Read_Write_Endif - $
  29+ AF8B              Read_Write_Else:                                // else
  30+ AF8B 21 AF                        dw          BLK_WRITE           //      blk-write
  31+ AF8D              Read_Write_Endif:                               // endif
  32+ AF8D A2 9F                        dw      EXIT                    // ;
  33+ AF8F
  34+ AF8F
  35+ AF8F              //  ______________________________________________________________________
  36+ AF8F              //
  37+ AF8F              // +buf        a1 -- a2 f
  38+ AF8F              // advences to next buffer, cyclically rotating along them
  39+ AF8F                              Colon_Def PBUF, "+BUF", is_normal
  39+ AF8F             >                New_Def  PBUF, "+BUF", Enter_Ptr, is_normal ; ok
  39+ AF8F             >
  39+ AF8F             >Dict_Ptr        defl    $
  39+ AF8F             >
  39+ AF8F             >//              ______________________________________________________________________
  39+ AF8F             >//              Heap part
  39+ AF8F             >
  39+ AF8F             >
  39+ AF8F             >                org     (Heap_Ptr & $1FFF) + $E000
  39+ EB0F             >
  39+ EB0F             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  39+ EB0F             >Latest_Definition defl  Heap_Ptr
  39+ EB0F             >
  39+ EB0F             >                // dummy db directives used to calculate length of namec
  39+ EB0F 2B 42 55 46 >                db      "+BUF"
  39+ EB13             >len_NFA         defl    $ - temp_NFA
  39+ EB13             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  39+ EB0F             >
  39+ EB0F 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  39+ EB10 2B 42 55 46 >                db      "+BUF"               // name string in 7-bit ascii, but
  39+ EB14             >                org     $-1                 // alter last byte of Name just above to set
  39+ EB13 C6          >                db      {b $} | END_BIT     // msb as name end
  39+ EB14             >
  39+ EB14 07 0B       >                dw      Prev_Ptr            // Link to previous definition Name
  39+ EB16             >Prev_Ptr        defl    Heap_Ptr
  39+ EB16             >
  39+ EB16             >mirror_Ptr      defl    $
  39+ EB16             >
  39+ EB16 91 AF       >                dw      Dict_Ptr + 2        // xt
  39+ EB18             >Heap_Ptr        defl    $ - $E000           // save current HP
  39+ EB18             >
  39+ EB18             >Current_HP      defl  $ - $E000             // used to set HP once!
  39+ EB18             >
  39+ EB18             >//              ______________________________________________________________________
  39+ EB18             >//              Dictionary part
  39+ EB18             >
  39+ EB18             >                org     Dict_Ptr
  39+ AF8F             >
  39+ AF8F 16 2A       >                dw      mirror_Ptr - $E000 + $1F00
  39+ AF91             >
  39+ AF91             >PBUF:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
  39+ AF91 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
  39+ AF94             >
  39+ AF94             >
  39+ AF94             >                endif           ; ok        // for other definitions it "points" the correct handler
  39+ AF94             >                // Use of "; ok" to suppress "warning[fwdref]"
  39+ AF94             >
  39+ AF94             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  40+ AF94 F3 9A 04 02                  dw      LIT, 516, PLUS          // 516 +
  40+ AF98 F5 9F
  41+ AF9A 7B A0 60 A2                  dw      DUP, LIMIT, FETCH       // dup limit @
  41+ AF9E D9 A0
  42+ AFA0 41 A3                        dw      EQUALS                  // =
  43+ AFA2                                                              // if
  44+ AFA2 45 9B                        dw      ZBRANCH
  45+ AFA4 08 00                        dw      PBuf_Endif - $
  46+ AFA6 60 A0                        dw          DROP                //      drop
  47+ AFA8 5A A2 D9 A0                  dw          FIRST, FETCH        //      first @
  48+ AFAC              PBuf_Endif:                                     // endif
  49+ AFAC 7B A0 CC A2                  dw      DUP, PREV, FETCH        // dup prev @
  49+ AFB0 D9 A0
  50+ AFB2 35 A3                        dw      SUBTRACT                // -
  51+ AFB4 A2 9F                        dw      EXIT                    // ;
  52+ AFB6
  53+ AFB6              //  ______________________________________________________________________
  54+ AFB6              //
  55+ AFB6              // update       --
  56+ AFB6              // mark the last used block to be written to disk
  57+ AFB6                              Colon_Def UPDATE, "UPDATE", is_normal
  57+ AFB6             >                New_Def  UPDATE, "UPDATE", Enter_Ptr, is_normal ; ok
  57+ AFB6             >
  57+ AFB6             >Dict_Ptr        defl    $
  57+ AFB6             >
  57+ AFB6             >//              ______________________________________________________________________
  57+ AFB6             >//              Heap part
  57+ AFB6             >
  57+ AFB6             >
  57+ AFB6             >                org     (Heap_Ptr & $1FFF) + $E000
  57+ EB18             >
  57+ EB18             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  57+ EB18             >Latest_Definition defl  Heap_Ptr
  57+ EB18             >
  57+ EB18             >                // dummy db directives used to calculate length of namec
  57+ EB18 55 50 44 41 >                db      "UPDATE"
  57+ EB1C 54 45       >
  57+ EB1E             >len_NFA         defl    $ - temp_NFA
  57+ EB1E             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  57+ EB18             >
  57+ EB18 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  57+ EB19 55 50 44 41 >                db      "UPDATE"               // name string in 7-bit ascii, but
  57+ EB1D 54 45       >
  57+ EB1F             >                org     $-1                 // alter last byte of Name just above to set
  57+ EB1E C5          >                db      {b $} | END_BIT     // msb as name end
  57+ EB1F             >
  57+ EB1F 0F 0B       >                dw      Prev_Ptr            // Link to previous definition Name
  57+ EB21             >Prev_Ptr        defl    Heap_Ptr
  57+ EB21             >
  57+ EB21             >mirror_Ptr      defl    $
  57+ EB21             >
  57+ EB21 B8 AF       >                dw      Dict_Ptr + 2        // xt
  57+ EB23             >Heap_Ptr        defl    $ - $E000           // save current HP
  57+ EB23             >
  57+ EB23             >Current_HP      defl  $ - $E000             // used to set HP once!
  57+ EB23             >
  57+ EB23             >//              ______________________________________________________________________
  57+ EB23             >//              Dictionary part
  57+ EB23             >
  57+ EB23             >                org     Dict_Ptr
  57+ AFB6             >
  57+ AFB6 21 2A       >                dw      mirror_Ptr - $E000 + $1F00
  57+ AFB8             >
  57+ AFB8             >UPDATE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
  57+ AFB8 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
  57+ AFBB             >
  57+ AFBB             >
  57+ AFBB             >                endif           ; ok        // for other definitions it "points" the correct handler
  57+ AFBB             >                // Use of "; ok" to suppress "warning[fwdref]"
  57+ AFBB             >
  57+ AFBB             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  58+ AFBB CC A2 D9 A0                  dw      PREV, FETCH, FETCH      // prev @ @
  58+ AFBF D9 A0
  59+ AFC1 F3 9A 00 80                  dw      LIT, $8000, OR_OP       // $8000, or
  59+ AFC5 6B 9F
  60+ AFC7 CC A2 D9 A0                  dw      PREV, FETCH, STORE      // prev @ !
  60+ AFCB E3 A0
  61+ AFCD A2 9F                        dw      EXIT                    // ;
  62+ AFCF
  63+ AFCF
  64+ AFCF              //  ______________________________________________________________________
  65+ AFCF              //
  66+ AFCF              // empty-buffers --
  67+ AFCF                              Colon_Def EMPTY_BUFFERS, "EMPTY-BUFFERS", is_normal
  67+ AFCF             >                New_Def  EMPTY_BUFFERS, "EMPTY-BUFFERS", Enter_Ptr, is_normal ; ok
  67+ AFCF             >
  67+ AFCF             >Dict_Ptr        defl    $
  67+ AFCF             >
  67+ AFCF             >//              ______________________________________________________________________
  67+ AFCF             >//              Heap part
  67+ AFCF             >
  67+ AFCF             >
  67+ AFCF             >                org     (Heap_Ptr & $1FFF) + $E000
  67+ EB23             >
  67+ EB23             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  67+ EB23             >Latest_Definition defl  Heap_Ptr
  67+ EB23             >
  67+ EB23             >                // dummy db directives used to calculate length of namec
  67+ EB23 45 4D 50 54 >                db      "EMPTY-BUFFERS"
  67+ EB27 59 2D 42 55 >
  67+ EB2B 46 46 45 52 >
  67+ EB2F 53          >
  67+ EB30             >len_NFA         defl    $ - temp_NFA
  67+ EB30             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  67+ EB23             >
  67+ EB23 8D          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  67+ EB24 45 4D 50 54 >                db      "EMPTY-BUFFERS"               // name string in 7-bit ascii, but
  67+ EB28 59 2D 42 55 >
  67+ EB2C 46 46 45 52 >
  67+ EB30 53          >
  67+ EB31             >                org     $-1                 // alter last byte of Name just above to set
  67+ EB30 D3          >                db      {b $} | END_BIT     // msb as name end
  67+ EB31             >
  67+ EB31 18 0B       >                dw      Prev_Ptr            // Link to previous definition Name
  67+ EB33             >Prev_Ptr        defl    Heap_Ptr
  67+ EB33             >
  67+ EB33             >mirror_Ptr      defl    $
  67+ EB33             >
  67+ EB33 D1 AF       >                dw      Dict_Ptr + 2        // xt
  67+ EB35             >Heap_Ptr        defl    $ - $E000           // save current HP
  67+ EB35             >
  67+ EB35             >Current_HP      defl  $ - $E000             // used to set HP once!
  67+ EB35             >
  67+ EB35             >//              ______________________________________________________________________
  67+ EB35             >//              Dictionary part
  67+ EB35             >
  67+ EB35             >                org     Dict_Ptr
  67+ AFCF             >
  67+ AFCF 33 2A       >                dw      mirror_Ptr - $E000 + $1F00
  67+ AFD1             >
  67+ AFD1             >EMPTY_BUFFERS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
  67+ AFD1 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
  67+ AFD4             >
  67+ AFD4             >
  67+ AFD4             >                endif           ; ok        // for other definitions it "points" the correct handler
  67+ AFD4             >                // Use of "; ok" to suppress "warning[fwdref]"
  67+ AFD4             >
  67+ AFD4             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  68+ AFD4 5A A2 D9 A0                  dw      FIRST, FETCH            // first @
  69+ AFD8 60 A2 D9 A0                  dw      LIMIT, FETCH            // limit @
  70+ AFDC 57 A0 35 A3                  dw      OVER, SUBTRACT, ERASE   // over - erase
  70+ AFE0 DC A7
  71+ AFE2 A2 9F                        dw      EXIT                    // ;
  72+ AFE4
  73+ AFE4              //  ______________________________________________________________________
  74+ AFE4              //
  75+ AFE4              // buffer       n -- a
  76+ AFE4              // read block n and gives the address to a buffer
  77+ AFE4              // any block previously inside the buffer, if modified, is rewritten to
  78+ AFE4              // disk before reading the block n.
  79+ AFE4
  80+ AFE4                              Colon_Def BUFFER, "BUFFER", is_normal
  80+ AFE4             >                New_Def  BUFFER, "BUFFER", Enter_Ptr, is_normal ; ok
  80+ AFE4             >
  80+ AFE4             >Dict_Ptr        defl    $
  80+ AFE4             >
  80+ AFE4             >//              ______________________________________________________________________
  80+ AFE4             >//              Heap part
  80+ AFE4             >
  80+ AFE4             >
  80+ AFE4             >                org     (Heap_Ptr & $1FFF) + $E000
  80+ EB35             >
  80+ EB35             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  80+ EB35             >Latest_Definition defl  Heap_Ptr
  80+ EB35             >
  80+ EB35             >                // dummy db directives used to calculate length of namec
  80+ EB35 42 55 46 46 >                db      "BUFFER"
  80+ EB39 45 52       >
  80+ EB3B             >len_NFA         defl    $ - temp_NFA
  80+ EB3B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  80+ EB35             >
  80+ EB35 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  80+ EB36 42 55 46 46 >                db      "BUFFER"               // name string in 7-bit ascii, but
  80+ EB3A 45 52       >
  80+ EB3C             >                org     $-1                 // alter last byte of Name just above to set
  80+ EB3B D2          >                db      {b $} | END_BIT     // msb as name end
  80+ EB3C             >
  80+ EB3C 23 0B       >                dw      Prev_Ptr            // Link to previous definition Name
  80+ EB3E             >Prev_Ptr        defl    Heap_Ptr
  80+ EB3E             >
  80+ EB3E             >mirror_Ptr      defl    $
  80+ EB3E             >
  80+ EB3E E6 AF       >                dw      Dict_Ptr + 2        // xt
  80+ EB40             >Heap_Ptr        defl    $ - $E000           // save current HP
  80+ EB40             >
  80+ EB40             >Current_HP      defl  $ - $E000             // used to set HP once!
  80+ EB40             >
  80+ EB40             >//              ______________________________________________________________________
  80+ EB40             >//              Dictionary part
  80+ EB40             >
  80+ EB40             >                org     Dict_Ptr
  80+ AFE4             >
  80+ AFE4 3E 2A       >                dw      mirror_Ptr - $E000 + $1F00
  80+ AFE6             >
  80+ AFE6             >BUFFER:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
  80+ AFE6 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
  80+ AFE9             >
  80+ AFE9             >
  80+ AFE9             >                endif           ; ok        // for other definitions it "points" the correct handler
  80+ AFE9             >                // Use of "; ok" to suppress "warning[fwdref]"
  80+ AFE9             >
  80+ AFE9             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  81+ AFE9 C6 A2 D9 A0                  dw      USE, FETCH              // use @
  82+ AFED 7B A0 AC 9F                  dw      DUP, TO_R               // dup >r
  83+ AFF1                                                              // begin
  84+ AFF1              Buffer_Begin:
  85+ AFF1 91 AF                        dw          PBUF                //      +buf
  86+ AFF3                                                              // until
  87+ AFF3 45 9B                        dw      ZBRANCH
  88+ AFF5 FC FF                        dw      Buffer_Begin - $
  89+ AFF7 C6 A2 E3 A0                  dw      USE, STORE              // use !
  90+ AFFB C2 9F D9 A0                  dw      R_OP, FETCH, ZLESS      // r @ 0<
  90+ AFFF DA 9F
  91+ B001                                                              // if
  92+ B001 45 9B                        dw      ZBRANCH
  93+ B003 14 00                        dw      Buffer_Endif - $
  94+ B005 C2 9F 24 A0                  dw          R_OP, CELL_PLUS     //      r cell+
  95+ B009 C2 9F D9 A0                  dw          R_OP, FETCH         //      r fetch
  96+ B00D F3 9A FF 7F                  dw          LIT, $7FFF          //      7FFF
  97+ B011 5C 9F                        dw          AND_OP              //      and
  98+ B013 D1 A1 64 AF                  dw          ZERO, READ_WRITE    //      0 r/w
  99+ B017              Buffer_Endif:                                   // endif
 100+ B017 C2 9F E3 A0                  dw      R_OP, STORE             // r !
 101+ B01B C2 9F CC A2                  dw      R_OP, PREV, STORE       // r prev !
 101+ B01F E3 A0
 102+ B021 B7 9F 24 A0                  dw      R_TO, CELL_PLUS         // r> cell+
 103+ B025 A2 9F                        dw      EXIT                    // ;
 104+ B027
 105+ B027              //  ______________________________________________________________________
 106+ B027              //
 107+ B027              // block        n -- a
 108+ B027              // Leaves the buffer address that contains the block n.
 109+ B027              // If the block is not already present, it will be loaded from disk
 110+ B027              // The block previously inside the buffer, if modified, is rewritten to
 111+ B027              // disk before reading the block n.
 112+ B027              // See also BUFFER, R/W, UPDATE, FLUSH.
 113+ B027
 114+ B027                              Colon_Def BLOCK, "BLOCK", is_normal
 114+ B027             >                New_Def  BLOCK, "BLOCK", Enter_Ptr, is_normal ; ok
 114+ B027             >
 114+ B027             >Dict_Ptr        defl    $
 114+ B027             >
 114+ B027             >//              ______________________________________________________________________
 114+ B027             >//              Heap part
 114+ B027             >
 114+ B027             >
 114+ B027             >                org     (Heap_Ptr & $1FFF) + $E000
 114+ EB40             >
 114+ EB40             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 114+ EB40             >Latest_Definition defl  Heap_Ptr
 114+ EB40             >
 114+ EB40             >                // dummy db directives used to calculate length of namec
 114+ EB40 42 4C 4F 43 >                db      "BLOCK"
 114+ EB44 4B          >
 114+ EB45             >len_NFA         defl    $ - temp_NFA
 114+ EB45             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 114+ EB40             >
 114+ EB40 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 114+ EB41 42 4C 4F 43 >                db      "BLOCK"               // name string in 7-bit ascii, but
 114+ EB45 4B          >
 114+ EB46             >                org     $-1                 // alter last byte of Name just above to set
 114+ EB45 CB          >                db      {b $} | END_BIT     // msb as name end
 114+ EB46             >
 114+ EB46 35 0B       >                dw      Prev_Ptr            // Link to previous definition Name
 114+ EB48             >Prev_Ptr        defl    Heap_Ptr
 114+ EB48             >
 114+ EB48             >mirror_Ptr      defl    $
 114+ EB48             >
 114+ EB48 29 B0       >                dw      Dict_Ptr + 2        // xt
 114+ EB4A             >Heap_Ptr        defl    $ - $E000           // save current HP
 114+ EB4A             >
 114+ EB4A             >Current_HP      defl  $ - $E000             // used to set HP once!
 114+ EB4A             >
 114+ EB4A             >//              ______________________________________________________________________
 114+ EB4A             >//              Dictionary part
 114+ EB4A             >
 114+ EB4A             >                org     Dict_Ptr
 114+ B027             >
 114+ B027 48 2A       >                dw      mirror_Ptr - $E000 + $1F00
 114+ B029             >
 114+ B029             >BLOCK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 114+ B029 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 114+ B02C             >
 114+ B02C             >
 114+ B02C             >                endif           ; ok        // for other definitions it "points" the correct handler
 114+ B02C             >                // Use of "; ok" to suppress "warning[fwdref]"
 114+ B02C             >
 114+ B02C             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 115+ B02C 8A A2 D9 A0                  dw      OFFSET, FETCH           // offset @
 116+ B030 F5 9F AC 9F                  dw      PLUS, TO_R              // + >r
 117+ B034 CC A2 D9 A0                  dw      PREV, FETCH             // prev @
 118+ B038 7B A0 D9 A0                  dw      DUP, FETCH              // dup @
 119+ B03C C2 9F 35 A3                  dw      R_OP, SUBTRACT          // r -
 120+ B040 7B A0 F5 9F                  dw      DUP, PLUS               // dup +  ( trick: check equality without most significant bit )
 121+ B044                                                              // if
 122+ B044 45 9B                        dw        ZBRANCH
 123+ B046 32 00                        dw        Block_Endif_1 - $
 124+ B048              Block_Begin:                                    //      begin
 125+ B048 91 AF C7 9F                  dw          PBUF, ZEQUAL        //          +buf 0
 126+ B04C                                                              //          if
 127+ B04C 45 9B                        dw          ZBRANCH
 128+ B04E 12 00                        dw          Block_Endif_2 - $
 129+ B050 60 A0                        dw              DROP            //              drop
 130+ B052 C2 9F E6 AF                  dw              R_OP, BUFFER    //              r buffer
 131+ B056 7B A0                        dw              DUP             //              dup
 132+ B058 C2 9F D8 A1                  dw              R_OP, ONE       //              r 1
 133+ B05C 64 AF                        dw              READ_WRITE      //              r/w
 134+ B05E 31 A0                        dw              TWO_MINUS       //              2-
 135+ B060              Block_Endif_2:                                  //          endif
 136+ B060 7B A0 D9 A0                  dw          DUP, FETCH, R_OP    //          dup @ r
 136+ B064 C2 9F
 137+ B066 35 A3 7B A0                  dw          SUBTRACT, DUP       //          - dup
 138+ B06A F5 9F C7 9F                  dw          PLUS, ZEQUAL        //          + 0=
 139+ B06E                                                              //      until
 140+ B06E 45 9B                        dw        ZBRANCH
 141+ B070 D8 FF                        dw        Block_Begin - $
 142+ B072 7B A0 CC A2                  dw        DUP, PREV, STORE      //      dup prev !
 142+ B076 E3 A0
 143+ B078              Block_Endif_1:                                  // endif
 144+ B078 B7 9F 60 A0                  dw      R_TO, DROP, CELL_PLUS   // r> drop cell+
 144+ B07C 24 A0
 145+ B07E A2 9F                        dw      EXIT                    // ;
 146+ B080
 147+ B080              //  ______________________________________________________________________
 148+ B080              //
 149+ B080              // #buff        -- n
 150+ B080              // number of buffers available. must be the difference between LIMIT and FIRST divided by 516
 151+ B080                              Constant_Def NBUFF,   "#BUFF", 7
 151+ B080             >                New_Def  NBUFF, "#BUFF", Constant_Ptr, is_normal
 151+ B080             >
 151+ B080             >Dict_Ptr        defl    $
 151+ B080             >
 151+ B080             >//              ______________________________________________________________________
 151+ B080             >//              Heap part
 151+ B080             >
 151+ B080             >
 151+ B080             >                org     (Heap_Ptr & $1FFF) + $E000
 151+ EB4A             >
 151+ EB4A             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 151+ EB4A             >Latest_Definition defl  Heap_Ptr
 151+ EB4A             >
 151+ EB4A             >                // dummy db directives used to calculate length of namec
 151+ EB4A 23 42 55 46 >                db      "#BUFF"
 151+ EB4E 46          >
 151+ EB4F             >len_NFA         defl    $ - temp_NFA
 151+ EB4F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 151+ EB4A             >
 151+ EB4A 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 151+ EB4B 23 42 55 46 >                db      "#BUFF"               // name string in 7-bit ascii, but
 151+ EB4F 46          >
 151+ EB50             >                org     $-1                 // alter last byte of Name just above to set
 151+ EB4F C6          >                db      {b $} | END_BIT     // msb as name end
 151+ EB50             >
 151+ EB50 40 0B       >                dw      Prev_Ptr            // Link to previous definition Name
 151+ EB52             >Prev_Ptr        defl    Heap_Ptr
 151+ EB52             >
 151+ EB52             >mirror_Ptr      defl    $
 151+ EB52             >
 151+ EB52 82 B0       >                dw      Dict_Ptr + 2        // xt
 151+ EB54             >Heap_Ptr        defl    $ - $E000           // save current HP
 151+ EB54             >
 151+ EB54             >Current_HP      defl  $ - $E000             // used to set HP once!
 151+ EB54             >
 151+ EB54             >//              ______________________________________________________________________
 151+ EB54             >//              Dictionary part
 151+ EB54             >
 151+ EB54             >                org     Dict_Ptr
 151+ B080             >
 151+ B080 52 2A       >                dw      mirror_Ptr - $E000 + $1F00
 151+ B082             >
 151+ B082             >NBUFF:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 151+ B082 CD A5 A1    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 151+ B085             >
 151+ B085             >
 151+ B085             >                endif           ; ok        // for other definitions it "points" the correct handler
 151+ B085             >                // Use of "; ok" to suppress "warning[fwdref]"
 151+ B085             >
 151+ B085             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 151+ B085 07 00       >                dw      7
 152+ B087
 153+ B087              //  ______________________________________________________________________
 154+ B087              //
 155+ B087              // flush        --
 156+ B087                              Colon_Def FLUSH, "FLUSH", is_normal
 156+ B087             >                New_Def  FLUSH, "FLUSH", Enter_Ptr, is_normal ; ok
 156+ B087             >
 156+ B087             >Dict_Ptr        defl    $
 156+ B087             >
 156+ B087             >//              ______________________________________________________________________
 156+ B087             >//              Heap part
 156+ B087             >
 156+ B087             >
 156+ B087             >                org     (Heap_Ptr & $1FFF) + $E000
 156+ EB54             >
 156+ EB54             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 156+ EB54             >Latest_Definition defl  Heap_Ptr
 156+ EB54             >
 156+ EB54             >                // dummy db directives used to calculate length of namec
 156+ EB54 46 4C 55 53 >                db      "FLUSH"
 156+ EB58 48          >
 156+ EB59             >len_NFA         defl    $ - temp_NFA
 156+ EB59             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 156+ EB54             >
 156+ EB54 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 156+ EB55 46 4C 55 53 >                db      "FLUSH"               // name string in 7-bit ascii, but
 156+ EB59 48          >
 156+ EB5A             >                org     $-1                 // alter last byte of Name just above to set
 156+ EB59 C8          >                db      {b $} | END_BIT     // msb as name end
 156+ EB5A             >
 156+ EB5A 4A 0B       >                dw      Prev_Ptr            // Link to previous definition Name
 156+ EB5C             >Prev_Ptr        defl    Heap_Ptr
 156+ EB5C             >
 156+ EB5C             >mirror_Ptr      defl    $
 156+ EB5C             >
 156+ EB5C 89 B0       >                dw      Dict_Ptr + 2        // xt
 156+ EB5E             >Heap_Ptr        defl    $ - $E000           // save current HP
 156+ EB5E             >
 156+ EB5E             >Current_HP      defl  $ - $E000             // used to set HP once!
 156+ EB5E             >
 156+ EB5E             >//              ______________________________________________________________________
 156+ EB5E             >//              Dictionary part
 156+ EB5E             >
 156+ EB5E             >                org     Dict_Ptr
 156+ B087             >
 156+ B087 5C 2A       >                dw      mirror_Ptr - $E000 + $1F00
 156+ B089             >
 156+ B089             >FLUSH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 156+ B089 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 156+ B08C             >
 156+ B08C             >
 156+ B08C             >                endif           ; ok        // for other definitions it "points" the correct handler
 156+ B08C             >                // Use of "; ok" to suppress "warning[fwdref]"
 156+ B08C             >
 156+ B08C             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 157+ B08C 82 B0 0E A0                  dw      NBUFF, ONE_PLUS, ZERO   // #buff 1+ 0
 157+ B090 D1 A1
 158+ B092              Flush_Do:                                       // do
 159+ B092 84 9B                        dw      C_DO
 160+ B094 D1 A1 E6 AF                  dw      ZERO, BUFFER, DROP      //      0 buffer drop
 160+ B098 60 A0
 161+ B09A                                                              // loop
 162+ B09A 30 9B F8 FF                  dw      C_LOOP, Flush_Do - $
 163+ B09E BD AE D9 A0                  dw      BLK_FH, FETCH           // blk-fh @     ( ZX-Next dependance )
 164+ B0A2 5B 9E 60 A0                  dw      F_SYNC, DROP            // f_sync drop
 165+ B0A6 A2 9F                        dw      EXIT                    // exit
 166+ B0A8
 167+ B0A8              //  ______________________________________________________________________
 168+ B0A8              //
 169+ B0A8              // f_getline    a m fh -- n
 170+ B0A8              // Given an open filehandle read next line (terminated with $0D or $0A)
 171+ B0A8              // Address a is left for subsequent processing
 172+ B0A8              // and n as the actual number of byte read, that is the length of line
 173+ B0A8                              Colon_Def F_GETLINE, "F_GETLINE", is_normal
 173+ B0A8             >                New_Def  F_GETLINE, "F_GETLINE", Enter_Ptr, is_normal ; ok
 173+ B0A8             >
 173+ B0A8             >Dict_Ptr        defl    $
 173+ B0A8             >
 173+ B0A8             >//              ______________________________________________________________________
 173+ B0A8             >//              Heap part
 173+ B0A8             >
 173+ B0A8             >
 173+ B0A8             >                org     (Heap_Ptr & $1FFF) + $E000
 173+ EB5E             >
 173+ EB5E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 173+ EB5E             >Latest_Definition defl  Heap_Ptr
 173+ EB5E             >
 173+ EB5E             >                // dummy db directives used to calculate length of namec
 173+ EB5E 46 5F 47 45 >                db      "F_GETLINE"
 173+ EB62 54 4C 49 4E >
 173+ EB66 45          >
 173+ EB67             >len_NFA         defl    $ - temp_NFA
 173+ EB67             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 173+ EB5E             >
 173+ EB5E 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 173+ EB5F 46 5F 47 45 >                db      "F_GETLINE"               // name string in 7-bit ascii, but
 173+ EB63 54 4C 49 4E >
 173+ EB67 45          >
 173+ EB68             >                org     $-1                 // alter last byte of Name just above to set
 173+ EB67 C5          >                db      {b $} | END_BIT     // msb as name end
 173+ EB68             >
 173+ EB68 54 0B       >                dw      Prev_Ptr            // Link to previous definition Name
 173+ EB6A             >Prev_Ptr        defl    Heap_Ptr
 173+ EB6A             >
 173+ EB6A             >mirror_Ptr      defl    $
 173+ EB6A             >
 173+ EB6A AA B0       >                dw      Dict_Ptr + 2        // xt
 173+ EB6C             >Heap_Ptr        defl    $ - $E000           // save current HP
 173+ EB6C             >
 173+ EB6C             >Current_HP      defl  $ - $E000             // used to set HP once!
 173+ EB6C             >
 173+ EB6C             >//              ______________________________________________________________________
 173+ EB6C             >//              Dictionary part
 173+ EB6C             >
 173+ EB6C             >                org     Dict_Ptr
 173+ B0A8             >
 173+ B0A8 6A 2A       >                dw      mirror_Ptr - $E000 + $1F00
 173+ B0AA             >
 173+ B0AA             >F_GETLINE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 173+ B0AA CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 173+ B0AD             >
 173+ B0AD             >
 173+ B0AD             >                endif           ; ok        // for other definitions it "points" the correct handler
 173+ B0AD             >                // Use of "; ok" to suppress "warning[fwdref]"
 173+ B0AD             >
 173+ B0AD             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 174+ B0AD AC 9F                        dw      TO_R                    // >r               ( a  m  )     \  fh
 175+ B0AF 6B A0                        dw      TUCK                    // tuck             ( m a m )
 176+ B0B1 C2 9F 67 9E                  dw      R_OP, F_FGETPOS         // r f_fgetpos      ( m a m d f )
 177+ B0B5 F3 9A 2C 00                  dw      LIT, 44, QERROR         // 44 ?error        ( m a m d )
 177+ B0B9 32 A5
 178+ B0BB
 179+ B0BB AA A0 57 A0                  dw      TWO_SWAP, OVER          // 2swap over       ( m d a m )
 180+ B0BF 0E A0 74 A0                  dw      ONE_PLUS, SWAP          // 1+ swap          ( m d a a+1 m )
 181+ B0C3
 182+ B0C3 C2 9F 7F 9E                  dw      R_OP, F_READ            // r f_read         ( m d a n f )
 183+ B0C7 F3 9A 2E 00                  dw      LIT, 46, QERROR         // 46 ?error        ( m d a n )
 183+ B0CB 32 A5
 184+ B0CD                                                              // if ( at least 1 chr was read )  \  fh
 185+ B0CD 45 9B                        dw      ZBRANCH
 186+ B0CF 3C 00                        dw      FGetline_Else - $
 187+ B0D1 F3 9A 0A 00                  dw          LIT, 10, ENCLOSE    //      10 enclose       ( m d a x b x )
 187+ B0D5 79 9C
 188+ B0D7 60 A0 65 A0                  dw          DROP, NIP           //      drop nip         ( m d a b )
 189+ B0DB 74 A0                        dw          SWAP                //      drop swap        ( m d b a )
 190+ B0DD F3 9A 0D 00                  dw          LIT, 13, ENCLOSE    //      13 enclose       ( m d b a x c x )
 190+ B0E1 79 9C
 191+ B0E3 60 A0 65 A0                  dw          DROP, NIP           //      drop nip         ( m d b a c )
 192+ B0E7 82 A0 7A A3                  dw          ROT, MIN            //      rot min          ( m d a n )
 193+ B0EB 7B A0 E4 A2                  dw          DUP, SPAN, STORE    //      dup span !       ( m d a n )
 193+ B0EF E3 A0
 194+ B0F1 7B A0 AC 9F                  dw          DUP, TO_R           //      dup >r           ( m d a n )      \ fh n
 195+ B0F5 AA A0 B7 9F                  dw          TWO_SWAP, R_TO      //      2swap r>         ( m a n d n )    \ fh
 196+ B0F9 D1 A1 FF 9F                  dw          ZERO, DPLUS         //      0 d+             ( m a n d+n )
 197+ B0FD B7 9F 33 9E                  dw          R_TO, F_SEEK        //      r> f_seek        ( m a n f )
 198+ B101 F3 9A 2D 00                  dw          LIT, 45, QERROR     //      45 ?error        ( m a n )
 198+ B105 32 A5
 199+ B107                                                              // else
 200+ B107 38 9B                        dw      BRANCH
 201+ B109 0C 00                        dw      FGetline_Endif - $
 202+ B10B              FGetline_Else:
 203+ B10B B7 9F                        dw          R_TO                //      r>              ( m d a fh )
 204+ B10D AA A0 A4 A0                  dw          TWO_SWAP, TWO_DROP  //      2swap 2drop     ( m a fh )
 205+ B111 60 A0 D1 A1                  dw          DROP, ZERO          //      drop, 0         ( m a 0 )
 206+ B115              FGetline_Endif:                                 // endif
 207+ B115 AC 9F 7B A0                  dw      TO_R, DUP, DUP          // >r dup dup           ( m a a a )
 207+ B119 7B A0
 208+ B11B 0E A0 74 A0                  dw      ONE_PLUS, SWAP          // 1+ swap              ( m a a+1 a )
 209+ B11F C2 9F DD 9E                  dw      R_OP, CMOVE             // r cmove              ( m a )
 210+ B123 B7 A0 F5 9F                  dw      TWO_DUP, PLUS           // 2dup +               ( m a m+a )
 211+ B127 D1 A1 74 A0                  dw      ZERO, SWAP              // 0 swap
 212+ B12B 29 A0 E3 A0                  dw      CELL_MINUS,  STORE      // cell-  !             ( m a )
 213+ B12F C2 9F F5 9F                  dw      R_OP, PLUS, ONE_SUBTRACT// r + 1-               ( m a+n1 )
 213+ B133 15 A0
 214+ B135 74 A0 C2 9F                  dw      SWAP, R_OP, SUBTRACT    // swap r -             ( a+n+1 m-n )
 214+ B139 35 A3
 215+ B13B E7 A7                        dw      BLANK                   // blank
 216+ B13D B7 9F                        dw      R_TO                    // r>                   ( n )
 217+ B13F A2 9F                        dw      EXIT                    // ;
 218+ B141
 219+ B141              //  ______________________________________________________________________
 220+ B141              //
 221+ B141              // f_include    fh --
 222+ B141              // Given a filehandle includes the source from file
 223+ B141                              Colon_Def F_INCLUDE, "F_INCLUDE", is_normal
 223+ B141             >                New_Def  F_INCLUDE, "F_INCLUDE", Enter_Ptr, is_normal ; ok
 223+ B141             >
 223+ B141             >Dict_Ptr        defl    $
 223+ B141             >
 223+ B141             >//              ______________________________________________________________________
 223+ B141             >//              Heap part
 223+ B141             >
 223+ B141             >
 223+ B141             >                org     (Heap_Ptr & $1FFF) + $E000
 223+ EB6C             >
 223+ EB6C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 223+ EB6C             >Latest_Definition defl  Heap_Ptr
 223+ EB6C             >
 223+ EB6C             >                // dummy db directives used to calculate length of namec
 223+ EB6C 46 5F 49 4E >                db      "F_INCLUDE"
 223+ EB70 43 4C 55 44 >
 223+ EB74 45          >
 223+ EB75             >len_NFA         defl    $ - temp_NFA
 223+ EB75             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 223+ EB6C             >
 223+ EB6C 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 223+ EB6D 46 5F 49 4E >                db      "F_INCLUDE"               // name string in 7-bit ascii, but
 223+ EB71 43 4C 55 44 >
 223+ EB75 45          >
 223+ EB76             >                org     $-1                 // alter last byte of Name just above to set
 223+ EB75 C5          >                db      {b $} | END_BIT     // msb as name end
 223+ EB76             >
 223+ EB76 5E 0B       >                dw      Prev_Ptr            // Link to previous definition Name
 223+ EB78             >Prev_Ptr        defl    Heap_Ptr
 223+ EB78             >
 223+ EB78             >mirror_Ptr      defl    $
 223+ EB78             >
 223+ EB78 43 B1       >                dw      Dict_Ptr + 2        // xt
 223+ EB7A             >Heap_Ptr        defl    $ - $E000           // save current HP
 223+ EB7A             >
 223+ EB7A             >Current_HP      defl  $ - $E000             // used to set HP once!
 223+ EB7A             >
 223+ EB7A             >//              ______________________________________________________________________
 223+ EB7A             >//              Dictionary part
 223+ EB7A             >
 223+ EB7A             >                org     Dict_Ptr
 223+ B141             >
 223+ B141 78 2A       >                dw      mirror_Ptr - $E000 + $1F00
 223+ B143             >
 223+ B143             >F_INCLUDE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 223+ B143 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 223+ B146             >
 223+ B146             >
 223+ B146             >                endif           ; ok        // for other definitions it "points" the correct handler
 223+ B146             >                // Use of "; ok" to suppress "warning[fwdref]"
 223+ B146             >
 223+ B146             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 224+ B146 72 A2 D9 A0                  dw      BLK, FETCH, TO_R        // blk @ >r
 224+ B14A AC 9F
 225+ B14C 78 A2 D9 A0                  dw      TO_IN, FETCH, TO_R      // >in @ >r
 225+ B150 AC 9F
 226+ B152 DE A2 D9 A0                  dw      SOURCE_ID, FETCH, TO_R  // source-id @ >r
 226+ B156 AC 9F
 227+ B158 C2 9F                        dw      R_OP                    // r
 228+ B15A                                                              // if
 229+ B15A 45 9B                        dw      ZBRANCH
 230+ B15C 20 00                        dw      FInclude_Else_1 - $
 231+ B15E C2 9F 67 9E                  dw          R_OP, F_FGETPOS     //      r f_getpos
 232+ B162 F3 9A 2C 00                  dw          LIT, 44, QERROR     //      44 ?error
 232+ B166 32 A5
 233+ B168 78 A2 D9 A0                  dw          TO_IN, FETCH        //      >in @ 2-
 234+ B16C 31 A0                        dw          TWO_MINUS
 235+ B16E E4 A2 D9 A0                  dw          SPAN, FETCH         //      span @ -
 236+ B172 35 A3                        dw          SUBTRACT
 237+ B174 2A A3 FF 9F                  dw          S_TO_D, DPLUS       //      s>d d+
 238+ B178                                                              // else
 239+ B178 38 9B                        dw      BRANCH
 240+ B17A 06 00                        dw      FInclude_Endif_1 - $
 241+ B17C              FInclude_Else_1:
 242+ B17C D1 A1 D1 A1                  dw          ZERO, ZERO          //      0 0
 243+ B180                                                              // endif
 244+ B180              FInclude_Endif_1:
 245+ B180 AC 9F AC 9F                  dw      TO_R, TO_R              // >r >r
 246+ B184 DE A2 E3 A0                  dw      SOURCE_ID, STORE        // source-id !
 247+ B188              FInclude_Begin:                                 // begin
 248+ B188 D8 A1 29 B0                  dw          ONE, BLOCK, BBUF    //      1 block b/buf
 248+ B18C 02 A2
 249+ B18E B7 A0 E7 A7                  dw          TWO_DUP, BLANK      //      2dup blank
 250+ B192 74 A0 0E A0                  dw          SWAP, ONE_PLUS      //      swap 1+
 251+ B196 74 A0 29 A0                  dw          SWAP, CELL_MINUS    //      swap cell-
 252+ B19A DE A2 D9 A0                  dw          SOURCE_ID, FETCH    //      source-id @
 253+ B19E AA B0                        dw          F_GETLINE           //      f_getline
 254+ B1A0                                                              // while
 255+ B1A0 45 9B                        dw      ZBRANCH
 256+ B1A2 14 00                        dw      FInclude_Repeat - $
 257+ B1A4 D8 A1 72 A2                  dw          ONE, BLK, STORE     //      1 blk !
 257+ B1A8 E3 A0
 258+ B1AA D1 A1 78 A2                  dw          ZERO, TO_IN, STORE  //      0 >in !
 258+ B1AE E3 A0
 259+ B1B0 8A AB                        dw          INTERPRET           //      interpret
 260+ B1B2 38 9B                        dw      BRANCH
 261+ B1B4 D4 FF                        dw      FInclude_Begin - $
 262+ B1B6              FInclude_Repeat:                                // repeat
 263+ B1B6 DE A2 D9 A0                  dw      SOURCE_ID, FETCH        // source-id @
 264+ B1BA D1 A1 DE A2                  dw      ZERO, SOURCE_ID, STORE  // 0 source-id !
 264+ B1BE E3 A0
 265+ B1C0 4F 9E                        dw      F_CLOSE                 // f_close
 266+ B1C2 F3 9A 2A 00                  dw      LIT, 42, QERROR         // 42 ?error
 266+ B1C6 32 A5
 267+ B1C8 B7 9F B7 9F                  dw      R_TO, R_TO, R_TO        // r> r> r>
 267+ B1CC B7 9F
 268+ B1CE 7B A0 DE A2                  dw      DUP, SOURCE_ID, STORE   // dup source-id !
 268+ B1D2 E3 A0
 269+ B1D4                                                              // if
 270+ B1D4 45 9B                        dw      ZBRANCH
 271+ B1D6 12 00                        dw      FInclude_Else_2 - $
 272+ B1D8 DE A2 D9 A0                  dw          SOURCE_ID, FETCH    //      source-id @
 273+ B1DC 33 9E                        dw          F_SEEK              //      f_seek
 274+ B1DE F3 9A 2B 00                  dw          LIT, 43, QERROR     //      43, ?error
 274+ B1E2 32 A5
 275+ B1E4                                                              // else
 276+ B1E4 38 9B                        dw      BRANCH
 277+ B1E6 04 00                        dw      FInclude_Endif_2 - $
 278+ B1E8              FInclude_Else_2:
 279+ B1E8 A4 A0                        dw          TWO_DROP            //      2drop
 280+ B1EA              FInclude_Endif_2:                               // endif
 281+ B1EA B7 9F 78 A2                  dw      R_TO, TO_IN, STORE      // r> >in !
 281+ B1EE E3 A0
 282+ B1F0 B7 9F 72 A2                  dw      R_TO, BLK, STORE        // r> blk !
 282+ B1F4 E3 A0
 283+ B1F6 A2 9F                        dw      EXIT                    // ;
 284+ B1F8
 285+ B1F8              //  ______________________________________________________________________
 286+ B1F8              //
 287+ B1F8              // open<         -- fh
 288+ B1F8              // Open the following filename and return it file-handle
 289+ B1F8              // Used in the form OPEN CCCC
 290+ B1F8                              Colon_Def OPEN_FH, "OPEN<", is_normal
 290+ B1F8             >                New_Def  OPEN_FH, "OPEN<", Enter_Ptr, is_normal ; ok
 290+ B1F8             >
 290+ B1F8             >Dict_Ptr        defl    $
 290+ B1F8             >
 290+ B1F8             >//              ______________________________________________________________________
 290+ B1F8             >//              Heap part
 290+ B1F8             >
 290+ B1F8             >
 290+ B1F8             >                org     (Heap_Ptr & $1FFF) + $E000
 290+ EB7A             >
 290+ EB7A             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 290+ EB7A             >Latest_Definition defl  Heap_Ptr
 290+ EB7A             >
 290+ EB7A             >                // dummy db directives used to calculate length of namec
 290+ EB7A 4F 50 45 4E >                db      "OPEN<"
 290+ EB7E 3C          >
 290+ EB7F             >len_NFA         defl    $ - temp_NFA
 290+ EB7F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 290+ EB7A             >
 290+ EB7A 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 290+ EB7B 4F 50 45 4E >                db      "OPEN<"               // name string in 7-bit ascii, but
 290+ EB7F 3C          >
 290+ EB80             >                org     $-1                 // alter last byte of Name just above to set
 290+ EB7F BC          >                db      {b $} | END_BIT     // msb as name end
 290+ EB80             >
 290+ EB80 6C 0B       >                dw      Prev_Ptr            // Link to previous definition Name
 290+ EB82             >Prev_Ptr        defl    Heap_Ptr
 290+ EB82             >
 290+ EB82             >mirror_Ptr      defl    $
 290+ EB82             >
 290+ EB82 FA B1       >                dw      Dict_Ptr + 2        // xt
 290+ EB84             >Heap_Ptr        defl    $ - $E000           // save current HP
 290+ EB84             >
 290+ EB84             >Current_HP      defl  $ - $E000             // used to set HP once!
 290+ EB84             >
 290+ EB84             >//              ______________________________________________________________________
 290+ EB84             >//              Dictionary part
 290+ EB84             >
 290+ EB84             >                org     Dict_Ptr
 290+ B1F8             >
 290+ B1F8 82 2A       >                dw      mirror_Ptr - $E000 + $1F00
 290+ B1FA             >
 290+ B1FA             >OPEN_FH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 290+ B1FA CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 290+ B1FD             >
 290+ B1FD             >
 290+ B1FD             >                endif           ; ok        // for other definitions it "points" the correct handler
 290+ B1FD             >                // Use of "; ok" to suppress "warning[fwdref]"
 290+ B1FD             >
 290+ B1FD             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 291+ B1FD F4 A1                        dw      BL
 292+ B1FF 14 A8 6E A6                  dw      WORD, COUNT, OVER       // bl word count over
 292+ B203 57 A0
 293+ B205 F5 9F D1 A1                  dw      PLUS, ZERO, SWAP, STORE // + 0 swap !
 293+ B209 74 A0 E3 A0
 294+ B20D 05 A8 D8 A1                  dw      PAD, ONE, F_OPEN        // pad 1 f_open
 294+ B211 AA 9E
 295+ B213 F3 9A 2B 00                  dw      LIT, 43                 // 43
 296+ B217 32 A5                        dw      QERROR                  // ?error
 297+ B219 A2 9F                        dw      EXIT                    // ;
 298+ B21B
 299+ B21B              //  ______________________________________________________________________
 300+ B21B              //
 301+ B21B              // include      -- cccc
 302+ B21B              // Include the following filename
 303+ B21B                              Colon_Def INCLUDE, "INCLUDE", is_normal
 303+ B21B             >                New_Def  INCLUDE, "INCLUDE", Enter_Ptr, is_normal ; ok
 303+ B21B             >
 303+ B21B             >Dict_Ptr        defl    $
 303+ B21B             >
 303+ B21B             >//              ______________________________________________________________________
 303+ B21B             >//              Heap part
 303+ B21B             >
 303+ B21B             >
 303+ B21B             >                org     (Heap_Ptr & $1FFF) + $E000
 303+ EB84             >
 303+ EB84             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 303+ EB84             >Latest_Definition defl  Heap_Ptr
 303+ EB84             >
 303+ EB84             >                // dummy db directives used to calculate length of namec
 303+ EB84 49 4E 43 4C >                db      "INCLUDE"
 303+ EB88 55 44 45    >
 303+ EB8B             >len_NFA         defl    $ - temp_NFA
 303+ EB8B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 303+ EB84             >
 303+ EB84 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 303+ EB85 49 4E 43 4C >                db      "INCLUDE"               // name string in 7-bit ascii, but
 303+ EB89 55 44 45    >
 303+ EB8C             >                org     $-1                 // alter last byte of Name just above to set
 303+ EB8B C5          >                db      {b $} | END_BIT     // msb as name end
 303+ EB8C             >
 303+ EB8C 7A 0B       >                dw      Prev_Ptr            // Link to previous definition Name
 303+ EB8E             >Prev_Ptr        defl    Heap_Ptr
 303+ EB8E             >
 303+ EB8E             >mirror_Ptr      defl    $
 303+ EB8E             >
 303+ EB8E 1D B2       >                dw      Dict_Ptr + 2        // xt
 303+ EB90             >Heap_Ptr        defl    $ - $E000           // save current HP
 303+ EB90             >
 303+ EB90             >Current_HP      defl  $ - $E000             // used to set HP once!
 303+ EB90             >
 303+ EB90             >//              ______________________________________________________________________
 303+ EB90             >//              Dictionary part
 303+ EB90             >
 303+ EB90             >                org     Dict_Ptr
 303+ B21B             >
 303+ B21B 8E 2A       >                dw      mirror_Ptr - $E000 + $1F00
 303+ B21D             >
 303+ B21D             >INCLUDE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 303+ B21D CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 303+ B220             >
 303+ B220             >
 303+ B220             >                endif           ; ok        // for other definitions it "points" the correct handler
 303+ B220             >                // Use of "; ok" to suppress "warning[fwdref]"
 303+ B220             >
 303+ B220             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 304+ B220 FA B1                        dw      OPEN_FH                 // open
 305+ B222 7B A0 43 B1                  dw      DUP, F_INCLUDE          // dup f_include
 306+ B226 4F 9E 60 A0                  dw      F_CLOSE, DROP           // f_close drop
 307+ B22A A2 9F                        dw      EXIT                    // ;
 308+ B22C
 309+ B22C              //  ______________________________________________________________________
 310+ B22C              //
 311+ B22C              // needs
 312+ B22C              // check for cccc exists in vocabulary
 313+ B22C              // if it doesn't then  INCLUDE  inc/cccc.F
 314+ B22C
 315+ B22C              // temp filename cccc.f as counted string zero-padded
 316+ B22C                              New_Def NEEDS_W,   "NEEDS-W", Create_Ptr, is_normal
 316+ B22C             >
 316+ B22C             >Dict_Ptr        defl    $
 316+ B22C             >
 316+ B22C             >//              ______________________________________________________________________
 316+ B22C             >//              Heap part
 316+ B22C             >
 316+ B22C             >
 316+ B22C             >                org     (Heap_Ptr & $1FFF) + $E000
 316+ EB90             >
 316+ EB90             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 316+ EB90             >Latest_Definition defl  Heap_Ptr
 316+ EB90             >
 316+ EB90             >                // dummy db directives used to calculate length of namec
 316+ EB90 4E 45 45 44 >                db      "NEEDS-W"
 316+ EB94 53 2D 57    >
 316+ EB97             >len_NFA         defl    $ - temp_NFA
 316+ EB97             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 316+ EB90             >
 316+ EB90 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 316+ EB91 4E 45 45 44 >                db      "NEEDS-W"               // name string in 7-bit ascii, but
 316+ EB95 53 2D 57    >
 316+ EB98             >                org     $-1                 // alter last byte of Name just above to set
 316+ EB97 D7          >                db      {b $} | END_BIT     // msb as name end
 316+ EB98             >
 316+ EB98 84 0B       >                dw      Prev_Ptr            // Link to previous definition Name
 316+ EB9A             >Prev_Ptr        defl    Heap_Ptr
 316+ EB9A             >
 316+ EB9A             >mirror_Ptr      defl    $
 316+ EB9A             >
 316+ EB9A 2E B2       >                dw      Dict_Ptr + 2        // xt
 316+ EB9C             >Heap_Ptr        defl    $ - $E000           // save current HP
 316+ EB9C             >
 316+ EB9C             >Current_HP      defl  $ - $E000             // used to set HP once!
 316+ EB9C             >
 316+ EB9C             >//              ______________________________________________________________________
 316+ EB9C             >//              Dictionary part
 316+ EB9C             >
 316+ EB9C             >                org     Dict_Ptr
 316+ B22C             >
 316+ B22C 9A 2A       >                dw      mirror_Ptr - $E000 + $1F00
 316+ B22E             >
 316+ B22E             >NEEDS_W:          if Create_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 316+ B22E CD CE AA    >                call    Create_Ptr ; ok        // for primitive definitions  actual code
 316+ B231             >
 316+ B231             >
 316+ B231             >                endif           ; ok        // for other definitions it "points" the correct handler
 316+ B231             >                // Use of "; ok" to suppress "warning[fwdref]"
 316+ B231             >
 316+ B231             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 317+ B231 00 00 00...                  ds      35                      // 32 + .f + 0x00 = len 35
 318+ B254              // temp complete path+filename
 319+ B254                              New_Def NEEDS_FN,  "NEEDS-FN", Create_Ptr, is_normal
 319+ B254             >
 319+ B254             >Dict_Ptr        defl    $
 319+ B254             >
 319+ B254             >//              ______________________________________________________________________
 319+ B254             >//              Heap part
 319+ B254             >
 319+ B254             >
 319+ B254             >                org     (Heap_Ptr & $1FFF) + $E000
 319+ EB9C             >
 319+ EB9C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 319+ EB9C             >Latest_Definition defl  Heap_Ptr
 319+ EB9C             >
 319+ EB9C             >                // dummy db directives used to calculate length of namec
 319+ EB9C 4E 45 45 44 >                db      "NEEDS-FN"
 319+ EBA0 53 2D 46 4E >
 319+ EBA4             >len_NFA         defl    $ - temp_NFA
 319+ EBA4             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 319+ EB9C             >
 319+ EB9C 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 319+ EB9D 4E 45 45 44 >                db      "NEEDS-FN"               // name string in 7-bit ascii, but
 319+ EBA1 53 2D 46 4E >
 319+ EBA5             >                org     $-1                 // alter last byte of Name just above to set
 319+ EBA4 CE          >                db      {b $} | END_BIT     // msb as name end
 319+ EBA5             >
 319+ EBA5 90 0B       >                dw      Prev_Ptr            // Link to previous definition Name
 319+ EBA7             >Prev_Ptr        defl    Heap_Ptr
 319+ EBA7             >
 319+ EBA7             >mirror_Ptr      defl    $
 319+ EBA7             >
 319+ EBA7 56 B2       >                dw      Dict_Ptr + 2        // xt
 319+ EBA9             >Heap_Ptr        defl    $ - $E000           // save current HP
 319+ EBA9             >
 319+ EBA9             >Current_HP      defl  $ - $E000             // used to set HP once!
 319+ EBA9             >
 319+ EBA9             >//              ______________________________________________________________________
 319+ EBA9             >//              Dictionary part
 319+ EBA9             >
 319+ EBA9             >                org     Dict_Ptr
 319+ B254             >
 319+ B254 A7 2A       >                dw      mirror_Ptr - $E000 + $1F00
 319+ B256             >
 319+ B256             >NEEDS_FN:          if Create_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 319+ B256 CD CE AA    >                call    Create_Ptr ; ok        // for primitive definitions  actual code
 319+ B259             >
 319+ B259             >
 319+ B259             >                endif           ; ok        // for other definitions it "points" the correct handler
 319+ B259             >                // Use of "; ok" to suppress "warning[fwdref]"
 319+ B259             >
 319+ B259             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 320+ B259 00 00 00...                  ds      40
 321+ B281              // constant path
 322+ B281                              New_Def NEEDS_INC,  "NEEDS-INC", Create_Ptr, is_normal
 322+ B281             >
 322+ B281             >Dict_Ptr        defl    $
 322+ B281             >
 322+ B281             >//              ______________________________________________________________________
 322+ B281             >//              Heap part
 322+ B281             >
 322+ B281             >
 322+ B281             >                org     (Heap_Ptr & $1FFF) + $E000
 322+ EBA9             >
 322+ EBA9             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 322+ EBA9             >Latest_Definition defl  Heap_Ptr
 322+ EBA9             >
 322+ EBA9             >                // dummy db directives used to calculate length of namec
 322+ EBA9 4E 45 45 44 >                db      "NEEDS-INC"
 322+ EBAD 53 2D 49 4E >
 322+ EBB1 43          >
 322+ EBB2             >len_NFA         defl    $ - temp_NFA
 322+ EBB2             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 322+ EBA9             >
 322+ EBA9 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 322+ EBAA 4E 45 45 44 >                db      "NEEDS-INC"               // name string in 7-bit ascii, but
 322+ EBAE 53 2D 49 4E >
 322+ EBB2 43          >
 322+ EBB3             >                org     $-1                 // alter last byte of Name just above to set
 322+ EBB2 C3          >                db      {b $} | END_BIT     // msb as name end
 322+ EBB3             >
 322+ EBB3 9C 0B       >                dw      Prev_Ptr            // Link to previous definition Name
 322+ EBB5             >Prev_Ptr        defl    Heap_Ptr
 322+ EBB5             >
 322+ EBB5             >mirror_Ptr      defl    $
 322+ EBB5             >
 322+ EBB5 83 B2       >                dw      Dict_Ptr + 2        // xt
 322+ EBB7             >Heap_Ptr        defl    $ - $E000           // save current HP
 322+ EBB7             >
 322+ EBB7             >Current_HP      defl  $ - $E000             // used to set HP once!
 322+ EBB7             >
 322+ EBB7             >//              ______________________________________________________________________
 322+ EBB7             >//              Dictionary part
 322+ EBB7             >
 322+ EBB7             >                org     Dict_Ptr
 322+ B281             >
 322+ B281 B5 2A       >                dw      mirror_Ptr - $E000 + $1F00
 322+ B283             >
 322+ B283             >NEEDS_INC:          if Create_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 322+ B283 CD CE AA    >                call    Create_Ptr ; ok        // for primitive definitions  actual code
 322+ B286             >
 322+ B286             >
 322+ B286             >                endif           ; ok        // for other definitions it "points" the correct handler
 322+ B286             >                // Use of "; ok" to suppress "warning[fwdref]"
 322+ B286             >
 322+ B286             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 323+ B286 04 69 6E 63                  db      4, "inc/", 0
 323+ B28A 2F 00
 324+ B28C                              New_Def NEEDS_LIB,  "NEEDS-LIB", Create_Ptr, is_normal
 324+ B28C             >
 324+ B28C             >Dict_Ptr        defl    $
 324+ B28C             >
 324+ B28C             >//              ______________________________________________________________________
 324+ B28C             >//              Heap part
 324+ B28C             >
 324+ B28C             >
 324+ B28C             >                org     (Heap_Ptr & $1FFF) + $E000
 324+ EBB7             >
 324+ EBB7             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 324+ EBB7             >Latest_Definition defl  Heap_Ptr
 324+ EBB7             >
 324+ EBB7             >                // dummy db directives used to calculate length of namec
 324+ EBB7 4E 45 45 44 >                db      "NEEDS-LIB"
 324+ EBBB 53 2D 4C 49 >
 324+ EBBF 42          >
 324+ EBC0             >len_NFA         defl    $ - temp_NFA
 324+ EBC0             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 324+ EBB7             >
 324+ EBB7 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 324+ EBB8 4E 45 45 44 >                db      "NEEDS-LIB"               // name string in 7-bit ascii, but
 324+ EBBC 53 2D 4C 49 >
 324+ EBC0 42          >
 324+ EBC1             >                org     $-1                 // alter last byte of Name just above to set
 324+ EBC0 C2          >                db      {b $} | END_BIT     // msb as name end
 324+ EBC1             >
 324+ EBC1 A9 0B       >                dw      Prev_Ptr            // Link to previous definition Name
 324+ EBC3             >Prev_Ptr        defl    Heap_Ptr
 324+ EBC3             >
 324+ EBC3             >mirror_Ptr      defl    $
 324+ EBC3             >
 324+ EBC3 8E B2       >                dw      Dict_Ptr + 2        // xt
 324+ EBC5             >Heap_Ptr        defl    $ - $E000           // save current HP
 324+ EBC5             >
 324+ EBC5             >Current_HP      defl  $ - $E000             // used to set HP once!
 324+ EBC5             >
 324+ EBC5             >//              ______________________________________________________________________
 324+ EBC5             >//              Dictionary part
 324+ EBC5             >
 324+ EBC5             >                org     Dict_Ptr
 324+ B28C             >
 324+ B28C C3 2A       >                dw      mirror_Ptr - $E000 + $1F00
 324+ B28E             >
 324+ B28E             >NEEDS_LIB:          if Create_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 324+ B28E CD CE AA    >                call    Create_Ptr ; ok        // for primitive definitions  actual code
 324+ B291             >
 324+ B291             >
 324+ B291             >                endif           ; ok        // for other definitions it "points" the correct handler
 324+ B291             >                // Use of "; ok" to suppress "warning[fwdref]"
 324+ B291             >
 324+ B291             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 325+ B291 04 6C 69 62                  db      4, "lib/", 0
 325+ B295 2F 00
 326+ B297
 327+ B297              // Concatenate path at a and filename and include it
 328+ B297              // No error is issued if filename doesn't exist.
 329+ B297                              Colon_Def NEEDS_SLASH, "NEEDS/", is_normal
 329+ B297             >                New_Def  NEEDS_SLASH, "NEEDS/", Enter_Ptr, is_normal ; ok
 329+ B297             >
 329+ B297             >Dict_Ptr        defl    $
 329+ B297             >
 329+ B297             >//              ______________________________________________________________________
 329+ B297             >//              Heap part
 329+ B297             >
 329+ B297             >
 329+ B297             >                org     (Heap_Ptr & $1FFF) + $E000
 329+ EBC5             >
 329+ EBC5             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 329+ EBC5             >Latest_Definition defl  Heap_Ptr
 329+ EBC5             >
 329+ EBC5             >                // dummy db directives used to calculate length of namec
 329+ EBC5 4E 45 45 44 >                db      "NEEDS/"
 329+ EBC9 53 2F       >
 329+ EBCB             >len_NFA         defl    $ - temp_NFA
 329+ EBCB             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 329+ EBC5             >
 329+ EBC5 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 329+ EBC6 4E 45 45 44 >                db      "NEEDS/"               // name string in 7-bit ascii, but
 329+ EBCA 53 2F       >
 329+ EBCC             >                org     $-1                 // alter last byte of Name just above to set
 329+ EBCB AF          >                db      {b $} | END_BIT     // msb as name end
 329+ EBCC             >
 329+ EBCC B7 0B       >                dw      Prev_Ptr            // Link to previous definition Name
 329+ EBCE             >Prev_Ptr        defl    Heap_Ptr
 329+ EBCE             >
 329+ EBCE             >mirror_Ptr      defl    $
 329+ EBCE             >
 329+ EBCE 99 B2       >                dw      Dict_Ptr + 2        // xt
 329+ EBD0             >Heap_Ptr        defl    $ - $E000           // save current HP
 329+ EBD0             >
 329+ EBD0             >Current_HP      defl  $ - $E000             // used to set HP once!
 329+ EBD0             >
 329+ EBD0             >//              ______________________________________________________________________
 329+ EBD0             >//              Dictionary part
 329+ EBD0             >
 329+ EBD0             >                org     Dict_Ptr
 329+ B297             >
 329+ B297 CE 2A       >                dw      mirror_Ptr - $E000 + $1F00
 329+ B299             >
 329+ B299             >NEEDS_SLASH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 329+ B299 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 329+ B29C             >
 329+ B29C             >
 329+ B29C             >                endif           ; ok        // for other definitions it "points" the correct handler
 329+ B29C             >                // Use of "; ok" to suppress "warning[fwdref]"
 329+ B29C             >
 329+ B29C             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 330+ B29C 6E A6 6B A0                  dw      COUNT, TUCK             // n a n
 331+ B2A0 56 B2 74 A0                  dw      NEEDS_FN, SWAP, CMOVE   // n        \ Path
 331+ B2A4 DD 9E
 332+ B2A6 56 B2 F5 9F                  dw      NEEDS_FN, PLUS          // a1+n     \ Concat
 333+ B2AA 2E B2 0E A0                  dw      NEEDS_W, ONE_PLUS, SWAP
 333+ B2AE 74 A0
 334+ B2B0 F3 9A 23 00                  dw      LIT, 35
 335+ B2B4 DD 9E                        dw      CMOVE
 336+ B2B6 56 B2                        dw      NEEDS_FN
 337+ B2B8 05 A8 D8 A1                  dw      PAD, ONE, F_OPEN
 337+ B2BC AA 9E
 338+ B2BE C7 9F                        dw      ZEQUAL
 339+ B2C0 45 9B                        dw      ZBRANCH
 340+ B2C2 08 00                        dw      Needs_1 - $
 341+ B2C4 43 B1                        dw          F_INCLUDE
 342+ B2C6 38 9B                        dw      BRANCH
 343+ B2C8 04 00                        dw      Needs_2 - $
 344+ B2CA              Needs_1:
 345+ B2CA              //              dw          NEEDS_W, COUNT, TYPE, SPACE
 346+ B2CA              //              dw          LIT, 43, MESSAGE
 347+ B2CA 60 A0                        dw          DROP
 348+ B2CC              Needs_2:
 349+ B2CC A2 9F                        dw      EXIT                    // ;
 350+ B2CE
 351+ B2CE
 352+ B2CE                              New_Def NDOM,   "NDOM", Create_Ptr, is_normal
 352+ B2CE             >
 352+ B2CE             >Dict_Ptr        defl    $
 352+ B2CE             >
 352+ B2CE             >//              ______________________________________________________________________
 352+ B2CE             >//              Heap part
 352+ B2CE             >
 352+ B2CE             >
 352+ B2CE             >                org     (Heap_Ptr & $1FFF) + $E000
 352+ EBD0             >
 352+ EBD0             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 352+ EBD0             >Latest_Definition defl  Heap_Ptr
 352+ EBD0             >
 352+ EBD0             >                // dummy db directives used to calculate length of namec
 352+ EBD0 4E 44 4F 4D >                db      "NDOM"
 352+ EBD4             >len_NFA         defl    $ - temp_NFA
 352+ EBD4             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 352+ EBD0             >
 352+ EBD0 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 352+ EBD1 4E 44 4F 4D >                db      "NDOM"               // name string in 7-bit ascii, but
 352+ EBD5             >                org     $-1                 // alter last byte of Name just above to set
 352+ EBD4 CD          >                db      {b $} | END_BIT     // msb as name end
 352+ EBD5             >
 352+ EBD5 C5 0B       >                dw      Prev_Ptr            // Link to previous definition Name
 352+ EBD7             >Prev_Ptr        defl    Heap_Ptr
 352+ EBD7             >
 352+ EBD7             >mirror_Ptr      defl    $
 352+ EBD7             >
 352+ EBD7 D0 B2       >                dw      Dict_Ptr + 2        // xt
 352+ EBD9             >Heap_Ptr        defl    $ - $E000           // save current HP
 352+ EBD9             >
 352+ EBD9             >Current_HP      defl  $ - $E000             // used to set HP once!
 352+ EBD9             >
 352+ EBD9             >//              ______________________________________________________________________
 352+ EBD9             >//              Dictionary part
 352+ EBD9             >
 352+ EBD9             >                org     Dict_Ptr
 352+ B2CE             >
 352+ B2CE D7 2A       >                dw      mirror_Ptr - $E000 + $1F00
 352+ B2D0             >
 352+ B2D0             >NDOM:          if Create_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 352+ B2D0 CD CE AA    >                call    Create_Ptr ; ok        // for primitive definitions  actual code
 352+ B2D3             >
 352+ B2D3             >
 352+ B2D3             >                endif           ; ok        // for other definitions it "points" the correct handler
 352+ B2D3             >                // Use of "; ok" to suppress "warning[fwdref]"
 352+ B2D3             >
 352+ B2D3             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 353+ B2D3              //              db $3A, $3F, $2F, $2A, $7C, $5C, $3C, $3E, $22
 354+ B2D3 3A 3F 2F 2A                  db ':?/*|\<>"'
 354+ B2D7 7C 5C 3C 3E
 354+ B2DB 22
 355+ B2DC 00                           db 0
 356+ B2DD
 357+ B2DD                              New_Def NCDM,   "NCDM", Create_Ptr, is_normal
 357+ B2DD             >
 357+ B2DD             >Dict_Ptr        defl    $
 357+ B2DD             >
 357+ B2DD             >//              ______________________________________________________________________
 357+ B2DD             >//              Heap part
 357+ B2DD             >
 357+ B2DD             >
 357+ B2DD             >                org     (Heap_Ptr & $1FFF) + $E000
 357+ EBD9             >
 357+ EBD9             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 357+ EBD9             >Latest_Definition defl  Heap_Ptr
 357+ EBD9             >
 357+ EBD9             >                // dummy db directives used to calculate length of namec
 357+ EBD9 4E 43 44 4D >                db      "NCDM"
 357+ EBDD             >len_NFA         defl    $ - temp_NFA
 357+ EBDD             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 357+ EBD9             >
 357+ EBD9 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 357+ EBDA 4E 43 44 4D >                db      "NCDM"               // name string in 7-bit ascii, but
 357+ EBDE             >                org     $-1                 // alter last byte of Name just above to set
 357+ EBDD CD          >                db      {b $} | END_BIT     // msb as name end
 357+ EBDE             >
 357+ EBDE D0 0B       >                dw      Prev_Ptr            // Link to previous definition Name
 357+ EBE0             >Prev_Ptr        defl    Heap_Ptr
 357+ EBE0             >
 357+ EBE0             >mirror_Ptr      defl    $
 357+ EBE0             >
 357+ EBE0 DF B2       >                dw      Dict_Ptr + 2        // xt
 357+ EBE2             >Heap_Ptr        defl    $ - $E000           // save current HP
 357+ EBE2             >
 357+ EBE2             >Current_HP      defl  $ - $E000             // used to set HP once!
 357+ EBE2             >
 357+ EBE2             >//              ______________________________________________________________________
 357+ EBE2             >//              Dictionary part
 357+ EBE2             >
 357+ EBE2             >                org     Dict_Ptr
 357+ B2DD             >
 357+ B2DD E0 2A       >                dw      mirror_Ptr - $E000 + $1F00
 357+ B2DF             >
 357+ B2DF             >NCDM:          if Create_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 357+ B2DF CD CE AA    >                call    Create_Ptr ; ok        // for primitive definitions  actual code
 357+ B2E2             >
 357+ B2E2             >
 357+ B2E2             >                endif           ; ok        // for other definitions it "points" the correct handler
 357+ B2E2             >                // Use of "; ok" to suppress "warning[fwdref]"
 357+ B2E2             >
 357+ B2E2             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 358+ B2E2              //              db $5F, $5E, $25, $26, $24, $5F, $7B, $7D, $7E
 359+ B2E2 5F 5E 25 26                  db '_^%&$_{}~'
 359+ B2E6 24 5F 7B 7D
 359+ B2EA 7E
 360+ B2EB 00                           db 0
 361+ B2EC
 362+ B2EC              // Replace illegal character in filename using the map here above
 363+ B2EC              // at the moment we need only  "
 364+ B2EC                              Colon_Def NEEDS_CHECK, "MAP-FN", is_normal
 364+ B2EC             >                New_Def  NEEDS_CHECK, "MAP-FN", Enter_Ptr, is_normal ; ok
 364+ B2EC             >
 364+ B2EC             >Dict_Ptr        defl    $
 364+ B2EC             >
 364+ B2EC             >//              ______________________________________________________________________
 364+ B2EC             >//              Heap part
 364+ B2EC             >
 364+ B2EC             >
 364+ B2EC             >                org     (Heap_Ptr & $1FFF) + $E000
 364+ EBE2             >
 364+ EBE2             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 364+ EBE2             >Latest_Definition defl  Heap_Ptr
 364+ EBE2             >
 364+ EBE2             >                // dummy db directives used to calculate length of namec
 364+ EBE2 4D 41 50 2D >                db      "MAP-FN"
 364+ EBE6 46 4E       >
 364+ EBE8             >len_NFA         defl    $ - temp_NFA
 364+ EBE8             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 364+ EBE2             >
 364+ EBE2 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 364+ EBE3 4D 41 50 2D >                db      "MAP-FN"               // name string in 7-bit ascii, but
 364+ EBE7 46 4E       >
 364+ EBE9             >                org     $-1                 // alter last byte of Name just above to set
 364+ EBE8 CE          >                db      {b $} | END_BIT     // msb as name end
 364+ EBE9             >
 364+ EBE9 D9 0B       >                dw      Prev_Ptr            // Link to previous definition Name
 364+ EBEB             >Prev_Ptr        defl    Heap_Ptr
 364+ EBEB             >
 364+ EBEB             >mirror_Ptr      defl    $
 364+ EBEB             >
 364+ EBEB EE B2       >                dw      Dict_Ptr + 2        // xt
 364+ EBED             >Heap_Ptr        defl    $ - $E000           // save current HP
 364+ EBED             >
 364+ EBED             >Current_HP      defl  $ - $E000             // used to set HP once!
 364+ EBED             >
 364+ EBED             >//              ______________________________________________________________________
 364+ EBED             >//              Dictionary part
 364+ EBED             >
 364+ EBED             >                org     Dict_Ptr
 364+ B2EC             >
 364+ B2EC EB 2A       >                dw      mirror_Ptr - $E000 + $1F00
 364+ B2EE             >
 364+ B2EE             >NEEDS_CHECK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 364+ B2EE CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 364+ B2F1             >
 364+ B2F1             >
 364+ B2F1             >                endif           ; ok        // for other definitions it "points" the correct handler
 364+ B2F1             >                // Use of "; ok" to suppress "warning[fwdref]"
 364+ B2F1             >
 364+ B2F1             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 365+ B2F1 6E A6 7B A6                  dw      COUNT, BOUNDS
 366+ B2F5 84 9B                        dw      C_DO
 367+ B2F7              Needs_3:
 368+ B2F7 DF B2 D0 B2                  dw          NCDM, NDOM, LIT, 10
 368+ B2FB F3 9A 0A 00
 369+ B2FF 8A 9B EE A0                  dw          I, CFETCH
 370+ B303 AB 9C                        dw          C_MAP
 371+ B305 8A 9B F7 A0                  dw          I, CSTORE
 372+ B309              Needs_4:
 373+ B309 30 9B                        dw      C_LOOP
 374+ B30B EC FF                        dw      Needs_3 - $
 375+ B30D A2 9F                        dw      EXIT
 376+ B30F
 377+ B30F
 378+ B30F              // include  "path/cccc.f" if cccc is not defined
 379+ B30F              // filename cccc.f is temporary stored at NEEDS-W
 380+ B30F                              Colon_Def NEEDS_PATH, "NEEDS-F", is_normal
 380+ B30F             >                New_Def  NEEDS_PATH, "NEEDS-F", Enter_Ptr, is_normal ; ok
 380+ B30F             >
 380+ B30F             >Dict_Ptr        defl    $
 380+ B30F             >
 380+ B30F             >//              ______________________________________________________________________
 380+ B30F             >//              Heap part
 380+ B30F             >
 380+ B30F             >
 380+ B30F             >                org     (Heap_Ptr & $1FFF) + $E000
 380+ EBED             >
 380+ EBED             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 380+ EBED             >Latest_Definition defl  Heap_Ptr
 380+ EBED             >
 380+ EBED             >                // dummy db directives used to calculate length of namec
 380+ EBED 4E 45 45 44 >                db      "NEEDS-F"
 380+ EBF1 53 2D 46    >
 380+ EBF4             >len_NFA         defl    $ - temp_NFA
 380+ EBF4             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 380+ EBED             >
 380+ EBED 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 380+ EBEE 4E 45 45 44 >                db      "NEEDS-F"               // name string in 7-bit ascii, but
 380+ EBF2 53 2D 46    >
 380+ EBF5             >                org     $-1                 // alter last byte of Name just above to set
 380+ EBF4 C6          >                db      {b $} | END_BIT     // msb as name end
 380+ EBF5             >
 380+ EBF5 E2 0B       >                dw      Prev_Ptr            // Link to previous definition Name
 380+ EBF7             >Prev_Ptr        defl    Heap_Ptr
 380+ EBF7             >
 380+ EBF7             >mirror_Ptr      defl    $
 380+ EBF7             >
 380+ EBF7 11 B3       >                dw      Dict_Ptr + 2        // xt
 380+ EBF9             >Heap_Ptr        defl    $ - $E000           // save current HP
 380+ EBF9             >
 380+ EBF9             >Current_HP      defl  $ - $E000             // used to set HP once!
 380+ EBF9             >
 380+ EBF9             >//              ______________________________________________________________________
 380+ EBF9             >//              Dictionary part
 380+ EBF9             >
 380+ EBF9             >                org     Dict_Ptr
 380+ B30F             >
 380+ B30F F7 2A       >                dw      mirror_Ptr - $E000 + $1F00
 380+ B311             >
 380+ B311             >NEEDS_PATH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 380+ B311 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 380+ B314             >
 380+ B314             >
 380+ B314             >                endif           ; ok        // for other definitions it "points" the correct handler
 380+ B314             >                // Use of "; ok" to suppress "warning[fwdref]"
 380+ B314             >
 380+ B314             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 381+ B314 C7 A9                        dw      LFIND
 382+ B316 45 9B                        dw      ZBRANCH
 383+ B318 0A 00                        dw      Needs_5 - $
 384+ B31A
 385+ B31A 60 A0 A4 A0                  dw          DROP, TWO_DROP
 386+ B31E 38 9B                        dw      BRANCH
 387+ B320 2C 00                        dw      Needs_6 - $
 388+ B322              Needs_5:
 389+ B322 2E B2                        dw          NEEDS_W
 390+ B324 F3 9A 23 00                  dw          LIT, 35
 391+ B328 DC A7                        dw          ERASE                   // a
 392+ B32A F6 A2 EE A0                  dw          HERE, CFETCH, ONE_PLUS  // a n
 392+ B32E 0E A0
 393+ B330 F6 A2 57 A0                  dw          HERE, OVER              // a n here n
 394+ B334 2E B2 74 A0                  dw          NEEDS_W, SWAP, CMOVE    // a n
 394+ B338 DD 9E
 395+ B33A 2E B2 EE B2                  dw          NEEDS_W, NEEDS_CHECK
 396+ B33E 2E B2 F5 9F                  dw          NEEDS_W, PLUS           // a a1+1
 397+ B342 F3 9A 2E 66                  dw          LIT, $662E              // a a1+1 ".F"
 398+ B346 74 A0 E3 A0                  dw          SWAP, STORE             // a
 399+ B34A 99 B2                        dw          NEEDS_SLASH
 400+ B34C              Needs_6:
 401+ B34C A2 9F                        dw      EXIT
 402+ B34E
 403+ B34E
 404+ B34E              // check for cccc exists in vocabulary
 405+ B34E              // if it doesn't then  INCLUDE  inc/cccc.F
 406+ B34E              // search in inc subdirectory
 407+ B34E                              Colon_Def NEEDS, "NEEDS", is_normal
 407+ B34E             >                New_Def  NEEDS, "NEEDS", Enter_Ptr, is_normal ; ok
 407+ B34E             >
 407+ B34E             >Dict_Ptr        defl    $
 407+ B34E             >
 407+ B34E             >//              ______________________________________________________________________
 407+ B34E             >//              Heap part
 407+ B34E             >
 407+ B34E             >
 407+ B34E             >                org     (Heap_Ptr & $1FFF) + $E000
 407+ EBF9             >
 407+ EBF9             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 407+ EBF9             >Latest_Definition defl  Heap_Ptr
 407+ EBF9             >
 407+ EBF9             >                // dummy db directives used to calculate length of namec
 407+ EBF9 4E 45 45 44 >                db      "NEEDS"
 407+ EBFD 53          >
 407+ EBFE             >len_NFA         defl    $ - temp_NFA
 407+ EBFE             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 407+ EBF9             >
 407+ EBF9 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 407+ EBFA 4E 45 45 44 >                db      "NEEDS"               // name string in 7-bit ascii, but
 407+ EBFE 53          >
 407+ EBFF             >                org     $-1                 // alter last byte of Name just above to set
 407+ EBFE D3          >                db      {b $} | END_BIT     // msb as name end
 407+ EBFF             >
 407+ EBFF ED 0B       >                dw      Prev_Ptr            // Link to previous definition Name
 407+ EC01             >Prev_Ptr        defl    Heap_Ptr
 407+ EC01             >
 407+ EC01             >mirror_Ptr      defl    $
 407+ EC01             >
 407+ EC01 50 B3       >                dw      Dict_Ptr + 2        // xt
 407+ EC03             >Heap_Ptr        defl    $ - $E000           // save current HP
 407+ EC03             >
 407+ EC03             >Current_HP      defl  $ - $E000             // used to set HP once!
 407+ EC03             >
 407+ EC03             >//              ______________________________________________________________________
 407+ EC03             >//              Dictionary part
 407+ EC03             >
 407+ EC03             >                org     Dict_Ptr
 407+ B34E             >
 407+ B34E 01 2B       >                dw      mirror_Ptr - $E000 + $1F00
 407+ B350             >
 407+ B350             >NEEDS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 407+ B350 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 407+ B353             >
 407+ B353             >
 407+ B353             >                endif           ; ok        // for other definitions it "points" the correct handler
 407+ B353             >                // Use of "; ok" to suppress "warning[fwdref]"
 407+ B353             >
 407+ B353             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 408+ B353 78 A2 D9 A0                  dw      TO_IN, FETCH
 409+ B357 7B A0                        dw      DUP
 410+ B359 83 B2 11 B3                  dw      NEEDS_INC, NEEDS_PATH
 411+ B35D 78 A2 E3 A0                  dw      TO_IN, STORE
 412+ B361 8E B2 11 B3                  dw      NEEDS_LIB, NEEDS_PATH
 413+ B365 78 A2 E3 A0                  dw      TO_IN, STORE
 414+ B369 C7 A9                        dw      LFIND
 415+ B36B 45 9B                        dw      ZBRANCH
 416+ B36D 08 00                        dw      Needs_10 - $
 417+ B36F A4 A0                        dw          TWO_DROP
 418+ B371 38 9B                        dw      BRANCH
 419+ B373 10 00                        dw      Needs_11 - $
 420+ B375              Needs_10:
 421+ B375 2E B2 6E A6                  dw      NEEDS_W, COUNT, TYPE, SPACE
 421+ B379 C2 A6 C7 A3
 422+ B37D F3 9A 2B 00                  dw      LIT, 43, MESSAGE
 422+ B381 3C AE
 423+ B383              Needs_11:
 424+ B383 A2 9F                        dw      EXIT
 425+ B385
 426+ B385
 427+ B385              //  ______________________________________________________________________
 428+ B385              //
 429+ B385              // load         n --
 430+ B385                              Colon_Def LOAD, "LOAD", is_normal
 430+ B385             >                New_Def  LOAD, "LOAD", Enter_Ptr, is_normal ; ok
 430+ B385             >
 430+ B385             >Dict_Ptr        defl    $
 430+ B385             >
 430+ B385             >//              ______________________________________________________________________
 430+ B385             >//              Heap part
 430+ B385             >
 430+ B385             >
 430+ B385             >                org     (Heap_Ptr & $1FFF) + $E000
 430+ EC03             >
 430+ EC03             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 430+ EC03             >Latest_Definition defl  Heap_Ptr
 430+ EC03             >
 430+ EC03             >                // dummy db directives used to calculate length of namec
 430+ EC03 4C 4F 41 44 >                db      "LOAD"
 430+ EC07             >len_NFA         defl    $ - temp_NFA
 430+ EC07             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 430+ EC03             >
 430+ EC03 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 430+ EC04 4C 4F 41 44 >                db      "LOAD"               // name string in 7-bit ascii, but
 430+ EC08             >                org     $-1                 // alter last byte of Name just above to set
 430+ EC07 C4          >                db      {b $} | END_BIT     // msb as name end
 430+ EC08             >
 430+ EC08 F9 0B       >                dw      Prev_Ptr            // Link to previous definition Name
 430+ EC0A             >Prev_Ptr        defl    Heap_Ptr
 430+ EC0A             >
 430+ EC0A             >mirror_Ptr      defl    $
 430+ EC0A             >
 430+ EC0A 87 B3       >                dw      Dict_Ptr + 2        // xt
 430+ EC0C             >Heap_Ptr        defl    $ - $E000           // save current HP
 430+ EC0C             >
 430+ EC0C             >Current_HP      defl  $ - $E000             // used to set HP once!
 430+ EC0C             >
 430+ EC0C             >//              ______________________________________________________________________
 430+ EC0C             >//              Dictionary part
 430+ EC0C             >
 430+ EC0C             >                org     Dict_Ptr
 430+ B385             >
 430+ B385 0A 2B       >                dw      mirror_Ptr - $E000 + $1F00
 430+ B387             >
 430+ B387             >LOAD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 430+ B387 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 430+ B38A             >
 430+ B38A             >
 430+ B38A             >                endif           ; ok        // for other definitions it "points" the correct handler
 430+ B38A             >                // Use of "; ok" to suppress "warning[fwdref]"
 430+ B38A             >
 430+ B38A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 431+ B38A 72 A2 D9 A0                  dw      BLK, FETCH, TO_R        // blk @ >r
 431+ B38E AC 9F
 432+ B390 78 A2 D9 A0                  dw      TO_IN, FETCH, TO_R      // >in @ >r
 432+ B394 AC 9F
 433+ B396
 434+ B396 D1 A1 78 A2                  dw      ZERO, TO_IN, STORE      // 0 >in !
 434+ B39A E3 A0
 435+ B39C 09 A2 C8 AD                  dw      BSCR, MUL, BLK, STORE   // b/scr * blk !
 435+ B3A0 72 A2 E3 A0
 436+ B3A4 8A AB                        dw      INTERPRET               // interpret
 437+ B3A6
 438+ B3A6 B7 9F 78 A2                  dw      R_TO, TO_IN, STORE      // r> >in !
 438+ B3AA E3 A0
 439+ B3AC B7 9F 72 A2                  dw      R_TO, BLK, STORE        // r> blk !
 439+ B3B0 E3 A0
 440+ B3B2 A2 9F                        dw      EXIT                    // ;
 441+ B3B4
 442+ B3B4              //  ______________________________________________________________________
 443+ B3B4              //
 444+ B3B4              // -->          --
 445+ B3B4                              Colon_Def LOAD_NEXT, "-->", is_immediate
 445+ B3B4             >                New_Def  LOAD_NEXT, "-->", Enter_Ptr, is_immediate ; ok
 445+ B3B4             >
 445+ B3B4             >Dict_Ptr        defl    $
 445+ B3B4             >
 445+ B3B4             >//              ______________________________________________________________________
 445+ B3B4             >//              Heap part
 445+ B3B4             >
 445+ B3B4             >
 445+ B3B4             >                org     (Heap_Ptr & $1FFF) + $E000
 445+ EC0C             >
 445+ EC0C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 445+ EC0C             >Latest_Definition defl  Heap_Ptr
 445+ EC0C             >
 445+ EC0C             >                // dummy db directives used to calculate length of namec
 445+ EC0C 2D 2D 3E    >                db      "-->"
 445+ EC0F             >len_NFA         defl    $ - temp_NFA
 445+ EC0F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 445+ EC0C             >
 445+ EC0C C3          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 445+ EC0D 2D 2D 3E    >                db      "-->"               // name string in 7-bit ascii, but
 445+ EC10             >                org     $-1                 // alter last byte of Name just above to set
 445+ EC0F BE          >                db      {b $} | END_BIT     // msb as name end
 445+ EC10             >
 445+ EC10 03 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 445+ EC12             >Prev_Ptr        defl    Heap_Ptr
 445+ EC12             >
 445+ EC12             >mirror_Ptr      defl    $
 445+ EC12             >
 445+ EC12 B6 B3       >                dw      Dict_Ptr + 2        // xt
 445+ EC14             >Heap_Ptr        defl    $ - $E000           // save current HP
 445+ EC14             >
 445+ EC14             >Current_HP      defl  $ - $E000             // used to set HP once!
 445+ EC14             >
 445+ EC14             >//              ______________________________________________________________________
 445+ EC14             >//              Dictionary part
 445+ EC14             >
 445+ EC14             >                org     Dict_Ptr
 445+ B3B4             >
 445+ B3B4 12 2B       >                dw      mirror_Ptr - $E000 + $1F00
 445+ B3B6             >
 445+ B3B6             >LOAD_NEXT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 445+ B3B6 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 445+ B3B9             >
 445+ B3B9             >
 445+ B3B9             >                endif           ; ok        // for other definitions it "points" the correct handler
 445+ B3B9             >                // Use of "; ok" to suppress "warning[fwdref]"
 445+ B3B9             >
 445+ B3B9             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 446+ B3B9 8F A5                        dw      QLOADING                // ?loading
 447+ B3BB D1 A1 78 A2                  dw      ZERO, TO_IN, STORE      // 0 >in !
 447+ B3BF E3 A0
 448+ B3C1 09 A2                        dw      BSCR                    // b/scr
 449+ B3C3 72 A2 D9 A0                  dw      BLK, FETCH              // blk @
 450+ B3C7 57 A0                        dw      OVER                    // over
 451+ B3C9 ED AD                        dw      MOD                     // mod
 452+ B3CB 35 A3                        dw      SUBTRACT                // -
 453+ B3CD 72 A2 C1 A0                  dw      BLK, PLUSSTORE          // +!
 454+ B3D1 A2 9F                        dw      EXIT                    // ;
 455+ B3D3
 456+ B3D3              //  ______________________________________________________________________
 457+ B3D3              //
 458+ B3D3              // '            -- xt
 459+ B3D3                              Colon_Def TICK, "'", is_normal
 459+ B3D3             >                New_Def  TICK, "'", Enter_Ptr, is_normal ; ok
 459+ B3D3             >
 459+ B3D3             >Dict_Ptr        defl    $
 459+ B3D3             >
 459+ B3D3             >//              ______________________________________________________________________
 459+ B3D3             >//              Heap part
 459+ B3D3             >
 459+ B3D3             >
 459+ B3D3             >                org     (Heap_Ptr & $1FFF) + $E000
 459+ EC14             >
 459+ EC14             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 459+ EC14             >Latest_Definition defl  Heap_Ptr
 459+ EC14             >
 459+ EC14             >                // dummy db directives used to calculate length of namec
 459+ EC14 27          >                db      "'"
 459+ EC15             >len_NFA         defl    $ - temp_NFA
 459+ EC15             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 459+ EC14             >
 459+ EC14 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 459+ EC15 27          >                db      "'"               // name string in 7-bit ascii, but
 459+ EC16             >                org     $-1                 // alter last byte of Name just above to set
 459+ EC15 A7          >                db      {b $} | END_BIT     // msb as name end
 459+ EC16             >
 459+ EC16 0C 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 459+ EC18             >Prev_Ptr        defl    Heap_Ptr
 459+ EC18             >
 459+ EC18             >mirror_Ptr      defl    $
 459+ EC18             >
 459+ EC18 D5 B3       >                dw      Dict_Ptr + 2        // xt
 459+ EC1A             >Heap_Ptr        defl    $ - $E000           // save current HP
 459+ EC1A             >
 459+ EC1A             >Current_HP      defl  $ - $E000             // used to set HP once!
 459+ EC1A             >
 459+ EC1A             >//              ______________________________________________________________________
 459+ EC1A             >//              Dictionary part
 459+ EC1A             >
 459+ EC1A             >                org     Dict_Ptr
 459+ B3D3             >
 459+ B3D3 18 2B       >                dw      mirror_Ptr - $E000 + $1F00
 459+ B3D5             >
 459+ B3D5             >TICK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 459+ B3D5 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 459+ B3D8             >
 459+ B3D8             >
 459+ B3D8             >                endif           ; ok        // for other definitions it "points" the correct handler
 459+ B3D8             >                // Use of "; ok" to suppress "warning[fwdref]"
 459+ B3D8             >
 459+ B3D8             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 460+ B3D8 C7 A9                        dw      LFIND                   // -find
 461+ B3DA C7 9F                        dw      ZEQUAL                  // 0=
 462+ B3DC D1 A1 32 A5                  dw      ZERO, QERROR            // 0 ?error
 463+ B3E0 60 A0                        dw      DROP                    // drop
 464+ B3E2 A2 9F                        dw      EXIT                    // ;
 465+ B3E4
 466+ B3E4              //  ______________________________________________________________________
 467+ B3E4              //
 468+ B3E4              // forget       -- cccc
 469+ B3E4                              Colon_Def FORGET, "FORGET", is_normal
 469+ B3E4             >                New_Def  FORGET, "FORGET", Enter_Ptr, is_normal ; ok
 469+ B3E4             >
 469+ B3E4             >Dict_Ptr        defl    $
 469+ B3E4             >
 469+ B3E4             >//              ______________________________________________________________________
 469+ B3E4             >//              Heap part
 469+ B3E4             >
 469+ B3E4             >
 469+ B3E4             >                org     (Heap_Ptr & $1FFF) + $E000
 469+ EC1A             >
 469+ EC1A             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 469+ EC1A             >Latest_Definition defl  Heap_Ptr
 469+ EC1A             >
 469+ EC1A             >                // dummy db directives used to calculate length of namec
 469+ EC1A 46 4F 52 47 >                db      "FORGET"
 469+ EC1E 45 54       >
 469+ EC20             >len_NFA         defl    $ - temp_NFA
 469+ EC20             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 469+ EC1A             >
 469+ EC1A 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 469+ EC1B 46 4F 52 47 >                db      "FORGET"               // name string in 7-bit ascii, but
 469+ EC1F 45 54       >
 469+ EC21             >                org     $-1                 // alter last byte of Name just above to set
 469+ EC20 D4          >                db      {b $} | END_BIT     // msb as name end
 469+ EC21             >
 469+ EC21 14 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 469+ EC23             >Prev_Ptr        defl    Heap_Ptr
 469+ EC23             >
 469+ EC23             >mirror_Ptr      defl    $
 469+ EC23             >
 469+ EC23 E6 B3       >                dw      Dict_Ptr + 2        // xt
 469+ EC25             >Heap_Ptr        defl    $ - $E000           // save current HP
 469+ EC25             >
 469+ EC25             >Current_HP      defl  $ - $E000             // used to set HP once!
 469+ EC25             >
 469+ EC25             >//              ______________________________________________________________________
 469+ EC25             >//              Dictionary part
 469+ EC25             >
 469+ EC25             >                org     Dict_Ptr
 469+ B3E4             >
 469+ B3E4 23 2B       >                dw      mirror_Ptr - $E000 + $1F00
 469+ B3E6             >
 469+ B3E6             >FORGET:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 469+ B3E6 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 469+ B3E9             >
 469+ B3E9             >
 469+ B3E9             >                endif           ; ok        // for other definitions it "points" the correct handler
 469+ B3E9             >                // Use of "; ok" to suppress "warning[fwdref]"
 469+ B3E9             >
 469+ B3E9             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 470+ B3E9 96 A2 D9 A0                  dw      CURRENT, FETCH          // current @
 471+ B3ED 90 A2 D9 A0                  dw      CONTEXT, FETCH          // context @
 472+ B3F1 35 A3 F3 9A                  dw      SUBTRACT, LIT, 23, QERROR // - 23 ?error
 472+ B3F5 17 00 32 A5
 473+ B3F9 D5 B3 B1 A4                  dw      TICK, TO_BODY           // ' >body
 474+ B3FD 7B A0 48 A2                  dw      DUP, FENCE, FETCH       // dup fence @
 474+ B401 D9 A0
 475+ B403 4C A3 F3 9A                  dw      ULESS, LIT, 21, QERROR  // u< 21 ?error
 475+ B407 15 00 32 A5
 476+ B40B 7B A0 E6 A4                  dw      DUP, NFA                // dup nfa
 477+ B40F
 478+ B40F                          //  dw      DUP
 479+ B40F                          //  dw      LIT, $E000, LESS
 480+ B40F                          //  dw      MMU7_FETCH, ONE, EQUALS
 481+ B40F                          //  dw      OR_OP, NOT_OP
 482+ B40F                          //  dw      ZBRANCH
 483+ B40F                          //  dw      Forget_then - $
 484+ B40F
 485+ B40F EF A3 12 A4                  dw      MMU7_FETCH, FROM_FAR
 486+ B413 66 A2 E3 A0                  dw      HP, STORE
 487+ B417 7B A0 DB A4                  dw      DUP, CFA, CELL_MINUS
 487+ B41B 29 A0
 488+ B41D              // Forget_then:
 489+ B41D 4E A2 E3 A0                  dw      DP, STORE               // dp !
 490+ B421 F1 A4 D9 A0                  dw      LFA, FETCH              // lfa @
 491+ B425 90 A2 D9 A0                  dw      CONTEXT, FETCH, STORE   // context @ !
 491+ B429 E3 A0
 492+ B42B A2 9F                        dw      EXIT                    // ;
 493+ B42D
 494+ B42D              //  ______________________________________________________________________
 495+ B42D              //
 496+ B42D              // marker       -- cccc
 497+ B42D                              Colon_Def MARKER, "MARKER", is_immediate
 497+ B42D             >                New_Def  MARKER, "MARKER", Enter_Ptr, is_immediate ; ok
 497+ B42D             >
 497+ B42D             >Dict_Ptr        defl    $
 497+ B42D             >
 497+ B42D             >//              ______________________________________________________________________
 497+ B42D             >//              Heap part
 497+ B42D             >
 497+ B42D             >
 497+ B42D             >                org     (Heap_Ptr & $1FFF) + $E000
 497+ EC25             >
 497+ EC25             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 497+ EC25             >Latest_Definition defl  Heap_Ptr
 497+ EC25             >
 497+ EC25             >                // dummy db directives used to calculate length of namec
 497+ EC25 4D 41 52 4B >                db      "MARKER"
 497+ EC29 45 52       >
 497+ EC2B             >len_NFA         defl    $ - temp_NFA
 497+ EC2B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 497+ EC25             >
 497+ EC25 C6          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 497+ EC26 4D 41 52 4B >                db      "MARKER"               // name string in 7-bit ascii, but
 497+ EC2A 45 52       >
 497+ EC2C             >                org     $-1                 // alter last byte of Name just above to set
 497+ EC2B D2          >                db      {b $} | END_BIT     // msb as name end
 497+ EC2C             >
 497+ EC2C 1A 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 497+ EC2E             >Prev_Ptr        defl    Heap_Ptr
 497+ EC2E             >
 497+ EC2E             >mirror_Ptr      defl    $
 497+ EC2E             >
 497+ EC2E 2F B4       >                dw      Dict_Ptr + 2        // xt
 497+ EC30             >Heap_Ptr        defl    $ - $E000           // save current HP
 497+ EC30             >
 497+ EC30             >Current_HP      defl  $ - $E000             // used to set HP once!
 497+ EC30             >
 497+ EC30             >//              ______________________________________________________________________
 497+ EC30             >//              Dictionary part
 497+ EC30             >
 497+ EC30             >                org     Dict_Ptr
 497+ B42D             >
 497+ B42D 2E 2B       >                dw      mirror_Ptr - $E000 + $1F00
 497+ B42F             >
 497+ B42F             >MARKER:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 497+ B42F CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 497+ B432             >
 497+ B432             >
 497+ B432             >                endif           ; ok        // for other definitions it "points" the correct handler
 497+ B432             >                // Use of "; ok" to suppress "warning[fwdref]"
 497+ B432             >
 497+ B432             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 498+ B432 46 A6                        dw      CBUILDS
 499+ B434 54 A2 D9 A0                  dw      VOC_LINK, FETCH, COMMA
 499+ B438 0C A3
 500+ B43A 96 A2 D9 A0                  dw      CURRENT, FETCH, COMMA
 500+ B43E 0C A3
 501+ B440 90 A2 D9 A0                  dw      CONTEXT, FETCH, COMMA
 501+ B444 0C A3
 502+ B446 96 A2 D9 A0                  dw      CURRENT, FETCH, FETCH,  COMMA
 502+ B44A D9 A0 0C A3
 503+ B44E A2 A4 00 A5                  dw      LATEST, PFA, LFA, FETCH, COMMA
 503+ B452 F1 A4 D9 A0
 503+ B456 0C A3
 504+ B458 51 A6                        dw      DOES_TO
 505+ B45A 7B A0 D9 A0                  dw      DUP, FETCH, VOC_LINK, STORE, CELL_PLUS
 505+ B45E 54 A2 E3 A0
 505+ B462 24 A0
 506+ B464 7B A0 D9 A0                  dw      DUP, FETCH, CURRENT, STORE, CELL_PLUS
 506+ B468 96 A2 E3 A0
 506+ B46C 24 A0
 507+ B46E 7B A0 D9 A0                  dw      DUP, FETCH, CONTEXT, STORE, CELL_PLUS
 507+ B472 90 A2 E3 A0
 507+ B476 24 A0
 508+ B478 7B A0 D9 A0                  dw      DUP, FETCH
 509+ B47C                          //  dw      DUP, QHEAPP
 510+ B47C                          //  dw      ZBRANCH
 511+ B47C                          //  dw      Marker_then - $
 512+ B47C 7B A0 66 A2                  dw          DUP, HP, STORE
 512+ B480 E3 A0
 513+ B482 00 A5 DB A4                  dw          PFA, CFA, CELL_MINUS
 513+ B486 29 A0
 514+ B488              // Marker_then:
 515+ B488 4E A2 E3 A0                  dw      DP, STORE, CELL_PLUS
 515+ B48C 24 A0
 516+ B48E D9 A0 96 A2                  dw      FETCH, CURRENT, FETCH, STORE
 516+ B492 D9 A0 E3 A0
 517+ B496 A2 9F                        dw      EXIT
 518+ B498
 519+ B498              //  ______________________________________________________________________
 520+ B498              //
 521+ B498              // spaces       n --
 522+ B498                              Colon_Def SPACES, "SPACES", is_normal
 522+ B498             >                New_Def  SPACES, "SPACES", Enter_Ptr, is_normal ; ok
 522+ B498             >
 522+ B498             >Dict_Ptr        defl    $
 522+ B498             >
 522+ B498             >//              ______________________________________________________________________
 522+ B498             >//              Heap part
 522+ B498             >
 522+ B498             >
 522+ B498             >                org     (Heap_Ptr & $1FFF) + $E000
 522+ EC30             >
 522+ EC30             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 522+ EC30             >Latest_Definition defl  Heap_Ptr
 522+ EC30             >
 522+ EC30             >                // dummy db directives used to calculate length of namec
 522+ EC30 53 50 41 43 >                db      "SPACES"
 522+ EC34 45 53       >
 522+ EC36             >len_NFA         defl    $ - temp_NFA
 522+ EC36             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 522+ EC30             >
 522+ EC30 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 522+ EC31 53 50 41 43 >                db      "SPACES"               // name string in 7-bit ascii, but
 522+ EC35 45 53       >
 522+ EC37             >                org     $-1                 // alter last byte of Name just above to set
 522+ EC36 D3          >                db      {b $} | END_BIT     // msb as name end
 522+ EC37             >
 522+ EC37 25 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 522+ EC39             >Prev_Ptr        defl    Heap_Ptr
 522+ EC39             >
 522+ EC39             >mirror_Ptr      defl    $
 522+ EC39             >
 522+ EC39 9A B4       >                dw      Dict_Ptr + 2        // xt
 522+ EC3B             >Heap_Ptr        defl    $ - $E000           // save current HP
 522+ EC3B             >
 522+ EC3B             >Current_HP      defl  $ - $E000             // used to set HP once!
 522+ EC3B             >
 522+ EC3B             >//              ______________________________________________________________________
 522+ EC3B             >//              Dictionary part
 522+ EC3B             >
 522+ EC3B             >                org     Dict_Ptr
 522+ B498             >
 522+ B498 39 2B       >                dw      mirror_Ptr - $E000 + $1F00
 522+ B49A             >
 522+ B49A             >SPACES:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 522+ B49A CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 522+ B49D             >
 522+ B49D             >
 522+ B49D             >                endif           ; ok        // for other definitions it "points" the correct handler
 522+ B49D             >                // Use of "; ok" to suppress "warning[fwdref]"
 522+ B49D             >
 522+ B49D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 523+ B49D D1 A1 8D A3                  dw      ZERO, MAX
 524+ B4A1 D1 A1 5C 9B                  dw      ZERO, C_Q_DO
 525+ B4A5 08 00                        dw      Spaces_Leave - $
 526+ B4A7              Spaces_Loop:
 527+ B4A7 C7 A3                        dw          SPACE
 528+ B4A9 30 9B                        dw      C_LOOP
 529+ B4AB FC FF                        dw      Spaces_Loop - $
 530+ B4AD              Spaces_Leave:
 531+ B4AD A2 9F                        dw      EXIT                    // ;
 532+ B4AF
 533+ B4AF              //  ______________________________________________________________________
 534+ B4AF              //
 535+ B4AF              // <#           --
 536+ B4AF                              Colon_Def BEGIN_DASH, "<#", is_normal
 536+ B4AF             >                New_Def  BEGIN_DASH, "<#", Enter_Ptr, is_normal ; ok
 536+ B4AF             >
 536+ B4AF             >Dict_Ptr        defl    $
 536+ B4AF             >
 536+ B4AF             >//              ______________________________________________________________________
 536+ B4AF             >//              Heap part
 536+ B4AF             >
 536+ B4AF             >
 536+ B4AF             >                org     (Heap_Ptr & $1FFF) + $E000
 536+ EC3B             >
 536+ EC3B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 536+ EC3B             >Latest_Definition defl  Heap_Ptr
 536+ EC3B             >
 536+ EC3B             >                // dummy db directives used to calculate length of namec
 536+ EC3B 3C 23       >                db      "<#"
 536+ EC3D             >len_NFA         defl    $ - temp_NFA
 536+ EC3D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 536+ EC3B             >
 536+ EC3B 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 536+ EC3C 3C 23       >                db      "<#"               // name string in 7-bit ascii, but
 536+ EC3E             >                org     $-1                 // alter last byte of Name just above to set
 536+ EC3D A3          >                db      {b $} | END_BIT     // msb as name end
 536+ EC3E             >
 536+ EC3E 30 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 536+ EC40             >Prev_Ptr        defl    Heap_Ptr
 536+ EC40             >
 536+ EC40             >mirror_Ptr      defl    $
 536+ EC40             >
 536+ EC40 B1 B4       >                dw      Dict_Ptr + 2        // xt
 536+ EC42             >Heap_Ptr        defl    $ - $E000           // save current HP
 536+ EC42             >
 536+ EC42             >Current_HP      defl  $ - $E000             // used to set HP once!
 536+ EC42             >
 536+ EC42             >//              ______________________________________________________________________
 536+ EC42             >//              Dictionary part
 536+ EC42             >
 536+ EC42             >                org     Dict_Ptr
 536+ B4AF             >
 536+ B4AF 40 2B       >                dw      mirror_Ptr - $E000 + $1F00
 536+ B4B1             >
 536+ B4B1             >BEGIN_DASH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 536+ B4B1 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 536+ B4B4             >
 536+ B4B4             >
 536+ B4B4             >                endif           ; ok        // for other definitions it "points" the correct handler
 536+ B4B4             >                // Use of "; ok" to suppress "warning[fwdref]"
 536+ B4B4             >
 536+ B4B4             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 537+ B4B4 05 A8 C0 A2                  dw      PAD, HLD, STORE
 537+ B4B8 E3 A0
 538+ B4BA A2 9F                        dw      EXIT
 539+ B4BC
 540+ B4BC              //  ______________________________________________________________________
 541+ B4BC              //
 542+ B4BC              // #>           --
 543+ B4BC                              Colon_Def DASH_END, "#>", is_normal
 543+ B4BC             >                New_Def  DASH_END, "#>", Enter_Ptr, is_normal ; ok
 543+ B4BC             >
 543+ B4BC             >Dict_Ptr        defl    $
 543+ B4BC             >
 543+ B4BC             >//              ______________________________________________________________________
 543+ B4BC             >//              Heap part
 543+ B4BC             >
 543+ B4BC             >
 543+ B4BC             >                org     (Heap_Ptr & $1FFF) + $E000
 543+ EC42             >
 543+ EC42             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 543+ EC42             >Latest_Definition defl  Heap_Ptr
 543+ EC42             >
 543+ EC42             >                // dummy db directives used to calculate length of namec
 543+ EC42 23 3E       >                db      "#>"
 543+ EC44             >len_NFA         defl    $ - temp_NFA
 543+ EC44             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 543+ EC42             >
 543+ EC42 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 543+ EC43 23 3E       >                db      "#>"               // name string in 7-bit ascii, but
 543+ EC45             >                org     $-1                 // alter last byte of Name just above to set
 543+ EC44 BE          >                db      {b $} | END_BIT     // msb as name end
 543+ EC45             >
 543+ EC45 3B 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 543+ EC47             >Prev_Ptr        defl    Heap_Ptr
 543+ EC47             >
 543+ EC47             >mirror_Ptr      defl    $
 543+ EC47             >
 543+ EC47 BE B4       >                dw      Dict_Ptr + 2        // xt
 543+ EC49             >Heap_Ptr        defl    $ - $E000           // save current HP
 543+ EC49             >
 543+ EC49             >Current_HP      defl  $ - $E000             // used to set HP once!
 543+ EC49             >
 543+ EC49             >//              ______________________________________________________________________
 543+ EC49             >//              Dictionary part
 543+ EC49             >
 543+ EC49             >                org     Dict_Ptr
 543+ B4BC             >
 543+ B4BC 47 2B       >                dw      mirror_Ptr - $E000 + $1F00
 543+ B4BE             >
 543+ B4BE             >DASH_END:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 543+ B4BE CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 543+ B4C1             >
 543+ B4C1             >
 543+ B4C1             >                endif           ; ok        // for other definitions it "points" the correct handler
 543+ B4C1             >                // Use of "; ok" to suppress "warning[fwdref]"
 543+ B4C1             >
 543+ B4C1             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 544+ B4C1 A4 A0                        dw      TWO_DROP
 545+ B4C3 C0 A2 D9 A0                  dw      HLD, FETCH, PAD, OVER, SUBTRACT
 545+ B4C7 05 A8 57 A0
 545+ B4CB 35 A3
 546+ B4CD A2 9F                        dw      EXIT
 547+ B4CF
 548+ B4CF              //  ______________________________________________________________________
 549+ B4CF              //
 550+ B4CF              // sign         n d -- d
 551+ B4CF                              Colon_Def SIGN, "SIGN", is_normal
 551+ B4CF             >                New_Def  SIGN, "SIGN", Enter_Ptr, is_normal ; ok
 551+ B4CF             >
 551+ B4CF             >Dict_Ptr        defl    $
 551+ B4CF             >
 551+ B4CF             >//              ______________________________________________________________________
 551+ B4CF             >//              Heap part
 551+ B4CF             >
 551+ B4CF             >
 551+ B4CF             >                org     (Heap_Ptr & $1FFF) + $E000
 551+ EC49             >
 551+ EC49             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 551+ EC49             >Latest_Definition defl  Heap_Ptr
 551+ EC49             >
 551+ EC49             >                // dummy db directives used to calculate length of namec
 551+ EC49 53 49 47 4E >                db      "SIGN"
 551+ EC4D             >len_NFA         defl    $ - temp_NFA
 551+ EC4D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 551+ EC49             >
 551+ EC49 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 551+ EC4A 53 49 47 4E >                db      "SIGN"               // name string in 7-bit ascii, but
 551+ EC4E             >                org     $-1                 // alter last byte of Name just above to set
 551+ EC4D CE          >                db      {b $} | END_BIT     // msb as name end
 551+ EC4E             >
 551+ EC4E 42 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 551+ EC50             >Prev_Ptr        defl    Heap_Ptr
 551+ EC50             >
 551+ EC50             >mirror_Ptr      defl    $
 551+ EC50             >
 551+ EC50 D1 B4       >                dw      Dict_Ptr + 2        // xt
 551+ EC52             >Heap_Ptr        defl    $ - $E000           // save current HP
 551+ EC52             >
 551+ EC52             >Current_HP      defl  $ - $E000             // used to set HP once!
 551+ EC52             >
 551+ EC52             >//              ______________________________________________________________________
 551+ EC52             >//              Dictionary part
 551+ EC52             >
 551+ EC52             >                org     Dict_Ptr
 551+ B4CF             >
 551+ B4CF 50 2B       >                dw      mirror_Ptr - $E000 + $1F00
 551+ B4D1             >
 551+ B4D1             >SIGN:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 551+ B4D1 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 551+ B4D4             >
 551+ B4D4             >
 551+ B4D4             >                endif           ; ok        // for other definitions it "points" the correct handler
 551+ B4D4             >                // Use of "; ok" to suppress "warning[fwdref]"
 551+ B4D4             >
 551+ B4D4             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 552+ B4D4 DA 9F                        dw      ZLESS
 553+ B4D6 45 9B                        dw      ZBRANCH
 554+ B4D8 08 00                        dw      Sign_Endif - $
 555+ B4DA F3 9A 2D 00                  dw          LIT, 45, HOLD
 555+ B4DE F2 A7
 556+ B4E0              Sign_Endif:
 557+ B4E0 A2 9F                        dw      EXIT
 558+ B4E2
 559+ B4E2              //  ______________________________________________________________________
 560+ B4E2              //
 561+ B4E2              // #           d1 -- d2
 562+ B4E2                              Colon_Def DASH, "#", is_normal
 562+ B4E2             >                New_Def  DASH, "#", Enter_Ptr, is_normal ; ok
 562+ B4E2             >
 562+ B4E2             >Dict_Ptr        defl    $
 562+ B4E2             >
 562+ B4E2             >//              ______________________________________________________________________
 562+ B4E2             >//              Heap part
 562+ B4E2             >
 562+ B4E2             >
 562+ B4E2             >                org     (Heap_Ptr & $1FFF) + $E000
 562+ EC52             >
 562+ EC52             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 562+ EC52             >Latest_Definition defl  Heap_Ptr
 562+ EC52             >
 562+ EC52             >                // dummy db directives used to calculate length of namec
 562+ EC52 23          >                db      "#"
 562+ EC53             >len_NFA         defl    $ - temp_NFA
 562+ EC53             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 562+ EC52             >
 562+ EC52 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 562+ EC53 23          >                db      "#"               // name string in 7-bit ascii, but
 562+ EC54             >                org     $-1                 // alter last byte of Name just above to set
 562+ EC53 A3          >                db      {b $} | END_BIT     // msb as name end
 562+ EC54             >
 562+ EC54 49 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 562+ EC56             >Prev_Ptr        defl    Heap_Ptr
 562+ EC56             >
 562+ EC56             >mirror_Ptr      defl    $
 562+ EC56             >
 562+ EC56 E4 B4       >                dw      Dict_Ptr + 2        // xt
 562+ EC58             >Heap_Ptr        defl    $ - $E000           // save current HP
 562+ EC58             >
 562+ EC58             >Current_HP      defl  $ - $E000             // used to set HP once!
 562+ EC58             >
 562+ EC58             >//              ______________________________________________________________________
 562+ EC58             >//              Dictionary part
 562+ EC58             >
 562+ EC58             >                org     Dict_Ptr
 562+ B4E2             >
 562+ B4E2 56 2B       >                dw      mirror_Ptr - $E000 + $1F00
 562+ B4E4             >
 562+ B4E4             >DASH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 562+ B4E4 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 562+ B4E7             >
 562+ B4E7             >
 562+ B4E7             >                endif           ; ok        // for other definitions it "points" the correct handler
 562+ B4E7             >                // Use of "; ok" to suppress "warning[fwdref]"
 562+ B4E7             >
 562+ B4E7             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 563+ B4E7 A2 A2 D9 A0                  dw      BASE, FETCH
 564+ B4EB
 565+ B4EB AC 9F                        dw      TO_R                    // >r           ( ud1 )
 566+ B4ED D1 A1 C2 9F                  dw      ZERO, R_OP, UMDIVMOD    // 0 r um/mod   ( l rem1 h/r )
 566+ B4F1 29 9F
 567+ B4F3 B7 9F 74 A0                  dw      R_TO, SWAP, TO_R        // r> swap >r   ( l rem )
 567+ B4F7 AC 9F
 568+ B4F9 29 9F                        dw      UMDIVMOD                // um/mod       ( rem2 l/r )
 569+ B4FB B7 9F                        dw      R_TO                    // r>           ( rem2 l/r h/r )
 570+ B4FD
 571+ B4FD 82 A0                        dw      ROT
 572+ B4FF F3 9A 09 00                  dw      LIT, 9, OVER, LESS
 572+ B503 57 A0 5A A3
 573+ B507 45 9B                        dw      ZBRANCH
 574+ B509 08 00                        dw      Dash_Endif - $
 575+ B50B F3 9A 07 00                  dw          LIT, 7, PLUS
 575+ B50F F5 9F
 576+ B511              Dash_Endif:
 577+ B511
 578+ B511 F3 9A 30 00                  dw      LIT, 48, PLUS, HOLD
 578+ B515 F5 9F F2 A7
 579+ B519 A2 9F                        dw      EXIT
 580+ B51B
 581+ B51B              //  ______________________________________________________________________
 582+ B51B              //
 583+ B51B              // #s           d1 -- d2
 584+ B51B                              Colon_Def DASHES, "#S", is_normal
 584+ B51B             >                New_Def  DASHES, "#S", Enter_Ptr, is_normal ; ok
 584+ B51B             >
 584+ B51B             >Dict_Ptr        defl    $
 584+ B51B             >
 584+ B51B             >//              ______________________________________________________________________
 584+ B51B             >//              Heap part
 584+ B51B             >
 584+ B51B             >
 584+ B51B             >                org     (Heap_Ptr & $1FFF) + $E000
 584+ EC58             >
 584+ EC58             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 584+ EC58             >Latest_Definition defl  Heap_Ptr
 584+ EC58             >
 584+ EC58             >                // dummy db directives used to calculate length of namec
 584+ EC58 23 53       >                db      "#S"
 584+ EC5A             >len_NFA         defl    $ - temp_NFA
 584+ EC5A             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 584+ EC58             >
 584+ EC58 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 584+ EC59 23 53       >                db      "#S"               // name string in 7-bit ascii, but
 584+ EC5B             >                org     $-1                 // alter last byte of Name just above to set
 584+ EC5A D3          >                db      {b $} | END_BIT     // msb as name end
 584+ EC5B             >
 584+ EC5B 52 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 584+ EC5D             >Prev_Ptr        defl    Heap_Ptr
 584+ EC5D             >
 584+ EC5D             >mirror_Ptr      defl    $
 584+ EC5D             >
 584+ EC5D 1D B5       >                dw      Dict_Ptr + 2        // xt
 584+ EC5F             >Heap_Ptr        defl    $ - $E000           // save current HP
 584+ EC5F             >
 584+ EC5F             >Current_HP      defl  $ - $E000             // used to set HP once!
 584+ EC5F             >
 584+ EC5F             >//              ______________________________________________________________________
 584+ EC5F             >//              Dictionary part
 584+ EC5F             >
 584+ EC5F             >                org     Dict_Ptr
 584+ B51B             >
 584+ B51B 5D 2B       >                dw      mirror_Ptr - $E000 + $1F00
 584+ B51D             >
 584+ B51D             >DASHES:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 584+ B51D CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 584+ B520             >
 584+ B520             >
 584+ B520             >                endif           ; ok        // for other definitions it "points" the correct handler
 584+ B520             >                // Use of "; ok" to suppress "warning[fwdref]"
 584+ B520             >
 584+ B520             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 585+ B520              Dashes_Begin:
 586+ B520 E4 B4 B7 A0                  dw      DASH, TWO_DUP
 587+ B524 6B 9F C7 9F                  dw          OR_OP, ZEQUAL
 588+ B528 45 9B                        dw      ZBRANCH
 589+ B52A F6 FF                        dw      Dashes_Begin - $
 590+ B52C A2 9F                        dw      EXIT
 591+ B52E
 592+ B52E              //  ______________________________________________________________________
 593+ B52E              //
 594+ B52E              // d.r          d n --
 595+ B52E                              Colon_Def D_DOT_R, "D.R", is_normal
 595+ B52E             >                New_Def  D_DOT_R, "D.R", Enter_Ptr, is_normal ; ok
 595+ B52E             >
 595+ B52E             >Dict_Ptr        defl    $
 595+ B52E             >
 595+ B52E             >//              ______________________________________________________________________
 595+ B52E             >//              Heap part
 595+ B52E             >
 595+ B52E             >
 595+ B52E             >                org     (Heap_Ptr & $1FFF) + $E000
 595+ EC5F             >
 595+ EC5F             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 595+ EC5F             >Latest_Definition defl  Heap_Ptr
 595+ EC5F             >
 595+ EC5F             >                // dummy db directives used to calculate length of namec
 595+ EC5F 44 2E 52    >                db      "D.R"
 595+ EC62             >len_NFA         defl    $ - temp_NFA
 595+ EC62             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 595+ EC5F             >
 595+ EC5F 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 595+ EC60 44 2E 52    >                db      "D.R"               // name string in 7-bit ascii, but
 595+ EC63             >                org     $-1                 // alter last byte of Name just above to set
 595+ EC62 D2          >                db      {b $} | END_BIT     // msb as name end
 595+ EC63             >
 595+ EC63 58 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 595+ EC65             >Prev_Ptr        defl    Heap_Ptr
 595+ EC65             >
 595+ EC65             >mirror_Ptr      defl    $
 595+ EC65             >
 595+ EC65 30 B5       >                dw      Dict_Ptr + 2        // xt
 595+ EC67             >Heap_Ptr        defl    $ - $E000           // save current HP
 595+ EC67             >
 595+ EC67             >Current_HP      defl  $ - $E000             // used to set HP once!
 595+ EC67             >
 595+ EC67             >//              ______________________________________________________________________
 595+ EC67             >//              Dictionary part
 595+ EC67             >
 595+ EC67             >                org     Dict_Ptr
 595+ B52E             >
 595+ B52E 65 2B       >                dw      mirror_Ptr - $E000 + $1F00
 595+ B530             >
 595+ B530             >D_DOT_R:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 595+ B530 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 595+ B533             >
 595+ B533             >
 595+ B533             >                endif           ; ok        // for other definitions it "points" the correct handler
 595+ B533             >                // Use of "; ok" to suppress "warning[fwdref]"
 595+ B533             >
 595+ B533             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 596+ B533 AC 9F                        dw      TO_R
 597+ B535 6B A0 34 AD                  dw      TUCK, DABS
 598+ B539 B1 B4 1D B5                  dw      BEGIN_DASH, DASHES, ROT, SIGN, DASH_END
 598+ B53D 82 A0 D1 B4
 598+ B541 BE B4
 599+ B543 B7 9F                        dw      R_TO
 600+ B545 57 A0 35 A3                  dw      OVER, SUBTRACT, SPACES, TYPE
 600+ B549 9A B4 C2 A6
 601+ B54D A2 9F                        dw      EXIT
 602+ B54F
 603+ B54F              //  ______________________________________________________________________
 604+ B54F              //
 605+ B54F              // .r           n1 n2 --
 606+ B54F                              Colon_Def DOT_R, ".R", is_normal
 606+ B54F             >                New_Def  DOT_R, ".R", Enter_Ptr, is_normal ; ok
 606+ B54F             >
 606+ B54F             >Dict_Ptr        defl    $
 606+ B54F             >
 606+ B54F             >//              ______________________________________________________________________
 606+ B54F             >//              Heap part
 606+ B54F             >
 606+ B54F             >
 606+ B54F             >                org     (Heap_Ptr & $1FFF) + $E000
 606+ EC67             >
 606+ EC67             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 606+ EC67             >Latest_Definition defl  Heap_Ptr
 606+ EC67             >
 606+ EC67             >                // dummy db directives used to calculate length of namec
 606+ EC67 2E 52       >                db      ".R"
 606+ EC69             >len_NFA         defl    $ - temp_NFA
 606+ EC69             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 606+ EC67             >
 606+ EC67 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 606+ EC68 2E 52       >                db      ".R"               // name string in 7-bit ascii, but
 606+ EC6A             >                org     $-1                 // alter last byte of Name just above to set
 606+ EC69 D2          >                db      {b $} | END_BIT     // msb as name end
 606+ EC6A             >
 606+ EC6A 5F 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 606+ EC6C             >Prev_Ptr        defl    Heap_Ptr
 606+ EC6C             >
 606+ EC6C             >mirror_Ptr      defl    $
 606+ EC6C             >
 606+ EC6C 51 B5       >                dw      Dict_Ptr + 2        // xt
 606+ EC6E             >Heap_Ptr        defl    $ - $E000           // save current HP
 606+ EC6E             >
 606+ EC6E             >Current_HP      defl  $ - $E000             // used to set HP once!
 606+ EC6E             >
 606+ EC6E             >//              ______________________________________________________________________
 606+ EC6E             >//              Dictionary part
 606+ EC6E             >
 606+ EC6E             >                org     Dict_Ptr
 606+ B54F             >
 606+ B54F 6C 2B       >                dw      mirror_Ptr - $E000 + $1F00
 606+ B551             >
 606+ B551             >DOT_R:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 606+ B551 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 606+ B554             >
 606+ B554             >
 606+ B554             >                endif           ; ok        // for other definitions it "points" the correct handler
 606+ B554             >                // Use of "; ok" to suppress "warning[fwdref]"
 606+ B554             >
 606+ B554             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 607+ B554 AC 9F                        dw      TO_R
 608+ B556 2A A3 B7 9F                  dw      S_TO_D, R_TO
 609+ B55A 30 B5                        dw      D_DOT_R
 610+ B55C A2 9F                        dw      EXIT
 611+ B55E
 612+ B55E              //  ______________________________________________________________________
 613+ B55E              //
 614+ B55E              // d.           d --
 615+ B55E                              Colon_Def D_DOT, "D.", is_normal
 615+ B55E             >                New_Def  D_DOT, "D.", Enter_Ptr, is_normal ; ok
 615+ B55E             >
 615+ B55E             >Dict_Ptr        defl    $
 615+ B55E             >
 615+ B55E             >//              ______________________________________________________________________
 615+ B55E             >//              Heap part
 615+ B55E             >
 615+ B55E             >
 615+ B55E             >                org     (Heap_Ptr & $1FFF) + $E000
 615+ EC6E             >
 615+ EC6E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 615+ EC6E             >Latest_Definition defl  Heap_Ptr
 615+ EC6E             >
 615+ EC6E             >                // dummy db directives used to calculate length of namec
 615+ EC6E 44 2E       >                db      "D."
 615+ EC70             >len_NFA         defl    $ - temp_NFA
 615+ EC70             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 615+ EC6E             >
 615+ EC6E 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 615+ EC6F 44 2E       >                db      "D."               // name string in 7-bit ascii, but
 615+ EC71             >                org     $-1                 // alter last byte of Name just above to set
 615+ EC70 AE          >                db      {b $} | END_BIT     // msb as name end
 615+ EC71             >
 615+ EC71 67 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 615+ EC73             >Prev_Ptr        defl    Heap_Ptr
 615+ EC73             >
 615+ EC73             >mirror_Ptr      defl    $
 615+ EC73             >
 615+ EC73 60 B5       >                dw      Dict_Ptr + 2        // xt
 615+ EC75             >Heap_Ptr        defl    $ - $E000           // save current HP
 615+ EC75             >
 615+ EC75             >Current_HP      defl  $ - $E000             // used to set HP once!
 615+ EC75             >
 615+ EC75             >//              ______________________________________________________________________
 615+ EC75             >//              Dictionary part
 615+ EC75             >
 615+ EC75             >                org     Dict_Ptr
 615+ B55E             >
 615+ B55E 73 2B       >                dw      mirror_Ptr - $E000 + $1F00
 615+ B560             >
 615+ B560             >D_DOT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 615+ B560 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 615+ B563             >
 615+ B563             >
 615+ B563             >                endif           ; ok        // for other definitions it "points" the correct handler
 615+ B563             >                // Use of "; ok" to suppress "warning[fwdref]"
 615+ B563             >
 615+ B563             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 616+ B563 D1 A1 30 B5                  dw      ZERO, D_DOT_R, SPACE
 616+ B567 C7 A3
 617+ B569 A2 9F                        dw      EXIT
 618+ B56B
 619+ B56B              //  ______________________________________________________________________
 620+ B56B              //
 621+ B56B              // .            n --
 622+ B56B                              Colon_Def DOT, ".", is_normal
 622+ B56B             >                New_Def  DOT, ".", Enter_Ptr, is_normal ; ok
 622+ B56B             >
 622+ B56B             >Dict_Ptr        defl    $
 622+ B56B             >
 622+ B56B             >//              ______________________________________________________________________
 622+ B56B             >//              Heap part
 622+ B56B             >
 622+ B56B             >
 622+ B56B             >                org     (Heap_Ptr & $1FFF) + $E000
 622+ EC75             >
 622+ EC75             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 622+ EC75             >Latest_Definition defl  Heap_Ptr
 622+ EC75             >
 622+ EC75             >                // dummy db directives used to calculate length of namec
 622+ EC75 2E          >                db      "."
 622+ EC76             >len_NFA         defl    $ - temp_NFA
 622+ EC76             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 622+ EC75             >
 622+ EC75 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 622+ EC76 2E          >                db      "."               // name string in 7-bit ascii, but
 622+ EC77             >                org     $-1                 // alter last byte of Name just above to set
 622+ EC76 AE          >                db      {b $} | END_BIT     // msb as name end
 622+ EC77             >
 622+ EC77 6E 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 622+ EC79             >Prev_Ptr        defl    Heap_Ptr
 622+ EC79             >
 622+ EC79             >mirror_Ptr      defl    $
 622+ EC79             >
 622+ EC79 6D B5       >                dw      Dict_Ptr + 2        // xt
 622+ EC7B             >Heap_Ptr        defl    $ - $E000           // save current HP
 622+ EC7B             >
 622+ EC7B             >Current_HP      defl  $ - $E000             // used to set HP once!
 622+ EC7B             >
 622+ EC7B             >//              ______________________________________________________________________
 622+ EC7B             >//              Dictionary part
 622+ EC7B             >
 622+ EC7B             >                org     Dict_Ptr
 622+ B56B             >
 622+ B56B 79 2B       >                dw      mirror_Ptr - $E000 + $1F00
 622+ B56D             >
 622+ B56D             >DOT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 622+ B56D CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 622+ B570             >
 622+ B570             >
 622+ B570             >                endif           ; ok        // for other definitions it "points" the correct handler
 622+ B570             >                // Use of "; ok" to suppress "warning[fwdref]"
 622+ B570             >
 622+ B570             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 623+ B570 2A A3 60 B5                  dw      S_TO_D, D_DOT
 624+ B574 A2 9F                        dw      EXIT
 625+ B576
 626+ B576              //  ______________________________________________________________________
 627+ B576              //
 628+ B576              // ?            n --
 629+ B576                              Colon_Def QUESTION, "?", is_normal
 629+ B576             >                New_Def  QUESTION, "?", Enter_Ptr, is_normal ; ok
 629+ B576             >
 629+ B576             >Dict_Ptr        defl    $
 629+ B576             >
 629+ B576             >//              ______________________________________________________________________
 629+ B576             >//              Heap part
 629+ B576             >
 629+ B576             >
 629+ B576             >                org     (Heap_Ptr & $1FFF) + $E000
 629+ EC7B             >
 629+ EC7B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 629+ EC7B             >Latest_Definition defl  Heap_Ptr
 629+ EC7B             >
 629+ EC7B             >                // dummy db directives used to calculate length of namec
 629+ EC7B 3F          >                db      "?"
 629+ EC7C             >len_NFA         defl    $ - temp_NFA
 629+ EC7C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 629+ EC7B             >
 629+ EC7B 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 629+ EC7C 3F          >                db      "?"               // name string in 7-bit ascii, but
 629+ EC7D             >                org     $-1                 // alter last byte of Name just above to set
 629+ EC7C BF          >                db      {b $} | END_BIT     // msb as name end
 629+ EC7D             >
 629+ EC7D 75 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 629+ EC7F             >Prev_Ptr        defl    Heap_Ptr
 629+ EC7F             >
 629+ EC7F             >mirror_Ptr      defl    $
 629+ EC7F             >
 629+ EC7F 78 B5       >                dw      Dict_Ptr + 2        // xt
 629+ EC81             >Heap_Ptr        defl    $ - $E000           // save current HP
 629+ EC81             >
 629+ EC81             >Current_HP      defl  $ - $E000             // used to set HP once!
 629+ EC81             >
 629+ EC81             >//              ______________________________________________________________________
 629+ EC81             >//              Dictionary part
 629+ EC81             >
 629+ EC81             >                org     Dict_Ptr
 629+ B576             >
 629+ B576 7F 2B       >                dw      mirror_Ptr - $E000 + $1F00
 629+ B578             >
 629+ B578             >QUESTION:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 629+ B578 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 629+ B57B             >
 629+ B57B             >
 629+ B57B             >                endif           ; ok        // for other definitions it "points" the correct handler
 629+ B57B             >                // Use of "; ok" to suppress "warning[fwdref]"
 629+ B57B             >
 629+ B57B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 630+ B57B D9 A0 6D B5                  dw      FETCH, DOT
 631+ B57F A2 9F                        dw      EXIT
 632+ B581
 633+ B581              //  ______________________________________________________________________
 634+ B581              //
 635+ B581              // u.           u --
 636+ B581                              Colon_Def U_DOT, "U.", is_normal
 636+ B581             >                New_Def  U_DOT, "U.", Enter_Ptr, is_normal ; ok
 636+ B581             >
 636+ B581             >Dict_Ptr        defl    $
 636+ B581             >
 636+ B581             >//              ______________________________________________________________________
 636+ B581             >//              Heap part
 636+ B581             >
 636+ B581             >
 636+ B581             >                org     (Heap_Ptr & $1FFF) + $E000
 636+ EC81             >
 636+ EC81             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 636+ EC81             >Latest_Definition defl  Heap_Ptr
 636+ EC81             >
 636+ EC81             >                // dummy db directives used to calculate length of namec
 636+ EC81 55 2E       >                db      "U."
 636+ EC83             >len_NFA         defl    $ - temp_NFA
 636+ EC83             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 636+ EC81             >
 636+ EC81 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 636+ EC82 55 2E       >                db      "U."               // name string in 7-bit ascii, but
 636+ EC84             >                org     $-1                 // alter last byte of Name just above to set
 636+ EC83 AE          >                db      {b $} | END_BIT     // msb as name end
 636+ EC84             >
 636+ EC84 7B 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 636+ EC86             >Prev_Ptr        defl    Heap_Ptr
 636+ EC86             >
 636+ EC86             >mirror_Ptr      defl    $
 636+ EC86             >
 636+ EC86 83 B5       >                dw      Dict_Ptr + 2        // xt
 636+ EC88             >Heap_Ptr        defl    $ - $E000           // save current HP
 636+ EC88             >
 636+ EC88             >Current_HP      defl  $ - $E000             // used to set HP once!
 636+ EC88             >
 636+ EC88             >//              ______________________________________________________________________
 636+ EC88             >//              Dictionary part
 636+ EC88             >
 636+ EC88             >                org     Dict_Ptr
 636+ B581             >
 636+ B581 86 2B       >                dw      mirror_Ptr - $E000 + $1F00
 636+ B583             >
 636+ B583             >U_DOT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 636+ B583 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 636+ B586             >
 636+ B586             >
 636+ B586             >                endif           ; ok        // for other definitions it "points" the correct handler
 636+ B586             >                // Use of "; ok" to suppress "warning[fwdref]"
 636+ B586             >
 636+ B586             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 637+ B586 D1 A1 60 B5                  dw      ZERO, D_DOT
 638+ B58A A2 9F                        dw      EXIT
 639+ B58C
 640+ B58C              //  ______________________________________________________________________
 641+ B58C              //
 642+ B58C              // words        --
 643+ B58C                              Colon_Def WORDS, "WORDS", is_normal
 643+ B58C             >                New_Def  WORDS, "WORDS", Enter_Ptr, is_normal ; ok
 643+ B58C             >
 643+ B58C             >Dict_Ptr        defl    $
 643+ B58C             >
 643+ B58C             >//              ______________________________________________________________________
 643+ B58C             >//              Heap part
 643+ B58C             >
 643+ B58C             >
 643+ B58C             >                org     (Heap_Ptr & $1FFF) + $E000
 643+ EC88             >
 643+ EC88             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 643+ EC88             >Latest_Definition defl  Heap_Ptr
 643+ EC88             >
 643+ EC88             >                // dummy db directives used to calculate length of namec
 643+ EC88 57 4F 52 44 >                db      "WORDS"
 643+ EC8C 53          >
 643+ EC8D             >len_NFA         defl    $ - temp_NFA
 643+ EC8D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 643+ EC88             >
 643+ EC88 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 643+ EC89 57 4F 52 44 >                db      "WORDS"               // name string in 7-bit ascii, but
 643+ EC8D 53          >
 643+ EC8E             >                org     $-1                 // alter last byte of Name just above to set
 643+ EC8D D3          >                db      {b $} | END_BIT     // msb as name end
 643+ EC8E             >
 643+ EC8E 81 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 643+ EC90             >Prev_Ptr        defl    Heap_Ptr
 643+ EC90             >
 643+ EC90             >mirror_Ptr      defl    $
 643+ EC90             >
 643+ EC90 8E B5       >                dw      Dict_Ptr + 2        // xt
 643+ EC92             >Heap_Ptr        defl    $ - $E000           // save current HP
 643+ EC92             >
 643+ EC92             >Current_HP      defl  $ - $E000             // used to set HP once!
 643+ EC92             >
 643+ EC92             >//              ______________________________________________________________________
 643+ EC92             >//              Dictionary part
 643+ EC92             >
 643+ EC92             >                org     Dict_Ptr
 643+ B58C             >
 643+ B58C 90 2B       >                dw      mirror_Ptr - $E000 + $1F00
 643+ B58E             >
 643+ B58E             >WORDS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 643+ B58E CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 643+ B591             >
 643+ B591             >
 643+ B591             >                endif           ; ok        // for other definitions it "points" the correct handler
 643+ B591             >                // Use of "; ok" to suppress "warning[fwdref]"
 643+ B591             >
 643+ B591             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 644+ B591 F3 9A 80 00                  dw      LIT, 128, OUT, STORE
 644+ B595 7E A2 E3 A0
 645+ B599 90 A2 D9 A0                  dw      CONTEXT, FETCH, FETCH
 645+ B59D D9 A0
 646+ B59F              Words_Begin:
 647+ B59F 38 A4                        dw          FAR // Q TO HEAP
 648+ B5A1 7B A0 EE A0                  dw          DUP, CFETCH, LIT, $1F, AND_OP
 648+ B5A5 F3 9A 1F 00
 648+ B5A9 5C 9F
 649+ B5AB 7E A2 D9 A0                  dw          OUT, FETCH, PLUS
 649+ B5AF F5 9F
 650+ B5B1 FB A1 5A A3                  dw          CL, LESS, ZEQUAL
 650+ B5B5 C7 9F
 651+ B5B7 45 9B                        dw          ZBRANCH
 652+ B5B9 0A 00                        dw          Words_Endif - $
 653+ B5BB 06 9D D1 A1                  dw              CR, ZERO, OUT, STORE
 653+ B5BF 7E A2 E3 A0
 654+ B5C3              Words_Endif:
 655+ B5C3 7B A0 15 AA                  dw          DUP, ID_DOT
 656+ B5C7 D8 A1 D2 A3                  dw          ONE, TRAVERSE, ONE_PLUS, FETCH
 656+ B5CB 0E A0 D9 A0
 657+ B5CF 7B A0 C7 9F                  dw          DUP, ZEQUAL
 658+ B5D3 03 9E 6B 9F                  dw          QTERMINAL, OR_OP
 659+ B5D7 45 9B                        dw      ZBRANCH
 660+ B5D9 C6 FF                        dw      Words_Begin - $
 661+ B5DB 60 A0                        dw      DROP
 662+ B5DD A2 9F                        dw      EXIT
 663+ B5DF
 664+ B5DF              //  ______________________________________________________________________
 665+ B5DF              //
 666+ B5DF              // list         n --
 667+ B5DF                              Colon_Def LIST, "LIST", is_normal
 667+ B5DF             >                New_Def  LIST, "LIST", Enter_Ptr, is_normal ; ok
 667+ B5DF             >
 667+ B5DF             >Dict_Ptr        defl    $
 667+ B5DF             >
 667+ B5DF             >//              ______________________________________________________________________
 667+ B5DF             >//              Heap part
 667+ B5DF             >
 667+ B5DF             >
 667+ B5DF             >                org     (Heap_Ptr & $1FFF) + $E000
 667+ EC92             >
 667+ EC92             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 667+ EC92             >Latest_Definition defl  Heap_Ptr
 667+ EC92             >
 667+ EC92             >                // dummy db directives used to calculate length of namec
 667+ EC92 4C 49 53 54 >                db      "LIST"
 667+ EC96             >len_NFA         defl    $ - temp_NFA
 667+ EC96             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 667+ EC92             >
 667+ EC92 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 667+ EC93 4C 49 53 54 >                db      "LIST"               // name string in 7-bit ascii, but
 667+ EC97             >                org     $-1                 // alter last byte of Name just above to set
 667+ EC96 D4          >                db      {b $} | END_BIT     // msb as name end
 667+ EC97             >
 667+ EC97 88 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 667+ EC99             >Prev_Ptr        defl    Heap_Ptr
 667+ EC99             >
 667+ EC99             >mirror_Ptr      defl    $
 667+ EC99             >
 667+ EC99 E1 B5       >                dw      Dict_Ptr + 2        // xt
 667+ EC9B             >Heap_Ptr        defl    $ - $E000           // save current HP
 667+ EC9B             >
 667+ EC9B             >Current_HP      defl  $ - $E000             // used to set HP once!
 667+ EC9B             >
 667+ EC9B             >//              ______________________________________________________________________
 667+ EC9B             >//              Dictionary part
 667+ EC9B             >
 667+ EC9B             >                org     Dict_Ptr
 667+ B5DF             >
 667+ B5DF 99 2B       >                dw      mirror_Ptr - $E000 + $1F00
 667+ B5E1             >
 667+ B5E1             >LIST:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 667+ B5E1 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 667+ B5E4             >
 667+ B5E4             >
 667+ B5E4             >                endif           ; ok        // for other definitions it "points" the correct handler
 667+ B5E4             >                // Use of "; ok" to suppress "warning[fwdref]"
 667+ B5E4             >
 667+ B5E4             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 668+ B5E4 0B A6 06 9D                  dw      DECIMAL, CR
 669+ B5E8 7B A0 84 A2                  dw      DUP, SCR, STORE
 669+ B5EC E3 A0
 670+ B5EE 5F A8                        dw      C_DOT_QUOTE
 671+ B5F0 05 53 63 72                  db      5, "Scr# "
 671+ B5F4 23 20
 672+ B5F6 6D B5                        dw      DOT
 673+ B5F8 10 A2 D1 A1                  dw      LSCR, ZERO, C_DO
 673+ B5FC 84 9B
 674+ B5FE              List_Loop:
 675+ B5FE 06 9D                        dw          CR
 676+ B600 8A 9B E6 A1                  dw          I, THREE
 677+ B604 51 B5 C7 A3                  dw          DOT_R, SPACE
 678+ B608 8A 9B 84 A2                  dw          I, SCR, FETCH, DOT_LINE
 678+ B60C D9 A0 2F AE
 679+ B610 03 9E                        dw          QTERMINAL
 680+ B612 45 9B                        dw          ZBRANCH
 681+ B614 06 00                        dw          List_Endif - $
 682+ B616 50 9B                        dw              C_LEAVE
 683+ B618 06 00                        dw              List_Leave - $
 684+ B61A              List_Endif:
 685+ B61A 30 9B                        dw      C_LOOP
 686+ B61C E2 FF                        dw      List_Loop - $
 687+ B61E              List_Leave:
 688+ B61E 06 9D                        dw      CR
 689+ B620 A2 9F                        dw      EXIT
 690+ B622
 691+ B622              //  ______________________________________________________________________
 692+ B622              //
 693+ B622              // index        n1 n2 --
 694+ B622                              Colon_Def INDEX, "INDEX", is_normal
 694+ B622             >                New_Def  INDEX, "INDEX", Enter_Ptr, is_normal ; ok
 694+ B622             >
 694+ B622             >Dict_Ptr        defl    $
 694+ B622             >
 694+ B622             >//              ______________________________________________________________________
 694+ B622             >//              Heap part
 694+ B622             >
 694+ B622             >
 694+ B622             >                org     (Heap_Ptr & $1FFF) + $E000
 694+ EC9B             >
 694+ EC9B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 694+ EC9B             >Latest_Definition defl  Heap_Ptr
 694+ EC9B             >
 694+ EC9B             >                // dummy db directives used to calculate length of namec
 694+ EC9B 49 4E 44 45 >                db      "INDEX"
 694+ EC9F 58          >
 694+ ECA0             >len_NFA         defl    $ - temp_NFA
 694+ ECA0             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 694+ EC9B             >
 694+ EC9B 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 694+ EC9C 49 4E 44 45 >                db      "INDEX"               // name string in 7-bit ascii, but
 694+ ECA0 58          >
 694+ ECA1             >                org     $-1                 // alter last byte of Name just above to set
 694+ ECA0 D8          >                db      {b $} | END_BIT     // msb as name end
 694+ ECA1             >
 694+ ECA1 92 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 694+ ECA3             >Prev_Ptr        defl    Heap_Ptr
 694+ ECA3             >
 694+ ECA3             >mirror_Ptr      defl    $
 694+ ECA3             >
 694+ ECA3 24 B6       >                dw      Dict_Ptr + 2        // xt
 694+ ECA5             >Heap_Ptr        defl    $ - $E000           // save current HP
 694+ ECA5             >
 694+ ECA5             >Current_HP      defl  $ - $E000             // used to set HP once!
 694+ ECA5             >
 694+ ECA5             >//              ______________________________________________________________________
 694+ ECA5             >//              Dictionary part
 694+ ECA5             >
 694+ ECA5             >                org     Dict_Ptr
 694+ B622             >
 694+ B622 A3 2B       >                dw      mirror_Ptr - $E000 + $1F00
 694+ B624             >
 694+ B624             >INDEX:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 694+ B624 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 694+ B627             >
 694+ B627             >
 694+ B627             >                endif           ; ok        // for other definitions it "points" the correct handler
 694+ B627             >                // Use of "; ok" to suppress "warning[fwdref]"
 694+ B627             >
 694+ B627             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 695+ B627 0E A0 74 A0                  dw      ONE_PLUS, SWAP, C_DO
 695+ B62B 84 9B
 696+ B62D              Index_Loop:
 697+ B62D 06 9D 8A 9B                  dw          CR, I, THREE
 697+ B631 E6 A1
 698+ B633 51 B5 C7 A3                  dw          DOT_R, SPACE
 699+ B637 D1 A1 8A 9B                  dw          ZERO, I, DOT_LINE
 699+ B63B 2F AE
 700+ B63D 03 9E                        dw          QTERMINAL
 701+ B63F 45 9B                        dw          ZBRANCH
 702+ B641 06 00                        dw          Index_Endif - $
 703+ B643 50 9B                        dw              C_LEAVE
 704+ B645 06 00                        dw              Index_Leave - $
 705+ B647              Index_Endif:
 706+ B647 30 9B                        dw      C_LOOP
 707+ B649 E4 FF                        dw      Index_Loop - $
 708+ B64B              Index_Leave:
 709+ B64B 06 9D                        dw      CR
 710+ B64D A2 9F                        dw      EXIT
 711+ B64F
 712+ B64F              //  ______________________________________________________________________
 713+ B64F              //
 714+ B64F              // cls          --
 715+ B64F                              Colon_Def CLS, "CLS", is_normal
 715+ B64F             >                New_Def  CLS, "CLS", Enter_Ptr, is_normal ; ok
 715+ B64F             >
 715+ B64F             >Dict_Ptr        defl    $
 715+ B64F             >
 715+ B64F             >//              ______________________________________________________________________
 715+ B64F             >//              Heap part
 715+ B64F             >
 715+ B64F             >
 715+ B64F             >                org     (Heap_Ptr & $1FFF) + $E000
 715+ ECA5             >
 715+ ECA5             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 715+ ECA5             >Latest_Definition defl  Heap_Ptr
 715+ ECA5             >
 715+ ECA5             >                // dummy db directives used to calculate length of namec
 715+ ECA5 43 4C 53    >                db      "CLS"
 715+ ECA8             >len_NFA         defl    $ - temp_NFA
 715+ ECA8             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 715+ ECA5             >
 715+ ECA5 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 715+ ECA6 43 4C 53    >                db      "CLS"               // name string in 7-bit ascii, but
 715+ ECA9             >                org     $-1                 // alter last byte of Name just above to set
 715+ ECA8 D3          >                db      {b $} | END_BIT     // msb as name end
 715+ ECA9             >
 715+ ECA9 9B 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 715+ ECAB             >Prev_Ptr        defl    Heap_Ptr
 715+ ECAB             >
 715+ ECAB             >mirror_Ptr      defl    $
 715+ ECAB             >
 715+ ECAB 51 B6       >                dw      Dict_Ptr + 2        // xt
 715+ ECAD             >Heap_Ptr        defl    $ - $E000           // save current HP
 715+ ECAD             >
 715+ ECAD             >Current_HP      defl  $ - $E000             // used to set HP once!
 715+ ECAD             >
 715+ ECAD             >//              ______________________________________________________________________
 715+ ECAD             >//              Dictionary part
 715+ ECAD             >
 715+ ECAD             >                org     Dict_Ptr
 715+ B64F             >
 715+ B64F AB 2B       >                dw      mirror_Ptr - $E000 + $1F00
 715+ B651             >
 715+ B651             >CLS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 715+ B651 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 715+ B654             >
 715+ B654             >
 715+ B654             >                endif           ; ok        // for other definitions it "points" the correct handler
 715+ B654             >                // Use of "; ok" to suppress "warning[fwdref]"
 715+ B654             >
 715+ B654             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 716+ B654 F3 9A 0E 00                  dw      LIT, $0E, EMITC
 716+ B658 F2 9C
 717+ B65A A2 9F                        dw      EXIT
 718+ B65C
 719+ B65C              //  ______________________________________________________________________
 720+ B65C              //
 721+ B65C              // splash       --
 722+ B65C                              Colon_Def SPLASH, "SPLASH", is_normal
 722+ B65C             >                New_Def  SPLASH, "SPLASH", Enter_Ptr, is_normal ; ok
 722+ B65C             >
 722+ B65C             >Dict_Ptr        defl    $
 722+ B65C             >
 722+ B65C             >//              ______________________________________________________________________
 722+ B65C             >//              Heap part
 722+ B65C             >
 722+ B65C             >
 722+ B65C             >                org     (Heap_Ptr & $1FFF) + $E000
 722+ ECAD             >
 722+ ECAD             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 722+ ECAD             >Latest_Definition defl  Heap_Ptr
 722+ ECAD             >
 722+ ECAD             >                // dummy db directives used to calculate length of namec
 722+ ECAD 53 50 4C 41 >                db      "SPLASH"
 722+ ECB1 53 48       >
 722+ ECB3             >len_NFA         defl    $ - temp_NFA
 722+ ECB3             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 722+ ECAD             >
 722+ ECAD 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 722+ ECAE 53 50 4C 41 >                db      "SPLASH"               // name string in 7-bit ascii, but
 722+ ECB2 53 48       >
 722+ ECB4             >                org     $-1                 // alter last byte of Name just above to set
 722+ ECB3 C8          >                db      {b $} | END_BIT     // msb as name end
 722+ ECB4             >
 722+ ECB4 A5 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 722+ ECB6             >Prev_Ptr        defl    Heap_Ptr
 722+ ECB6             >
 722+ ECB6             >mirror_Ptr      defl    $
 722+ ECB6             >
 722+ ECB6 5E B6       >                dw      Dict_Ptr + 2        // xt
 722+ ECB8             >Heap_Ptr        defl    $ - $E000           // save current HP
 722+ ECB8             >
 722+ ECB8             >Current_HP      defl  $ - $E000             // used to set HP once!
 722+ ECB8             >
 722+ ECB8             >//              ______________________________________________________________________
 722+ ECB8             >//              Dictionary part
 722+ ECB8             >
 722+ ECB8             >                org     Dict_Ptr
 722+ B65C             >
 722+ B65C B6 2B       >                dw      mirror_Ptr - $E000 + $1F00
 722+ B65E             >
 722+ B65E             >SPLASH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 722+ B65E CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 722+ B661             >
 722+ B661             >
 722+ B661             >                endif           ; ok        // for other definitions it "points" the correct handler
 722+ B661             >                // Use of "; ok" to suppress "warning[fwdref]"
 722+ B661             >
 722+ B661             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 723+ B661 51 B6                        dw      CLS
 724+ B663 5F A8                        dw      C_DOT_QUOTE
 725+ B665 57                           db      87
 726+ B666 76 2D 46 6F                  db      "v-Forth 1.7 NextZXOS version", 13    // 29
 726+ B66A 72 74 68 20
 726+ B66E 31 2E 37 20
 726+ B672 4E 65 78 74
 726+ B676 5A 58 4F 53
 726+ B67A 20 76 65 72
 726+ B67E 73 69 6F 6E
 726+ B682 0D
 727+ B683 48 65 61 70                  db      "Heap Vocabulary - build 20230321", 13  // 33
 727+ B687 20 56 6F 63
 727+ B68B 61 62 75 6C
 727+ B68F 61 72 79 20
 727+ B693 2D 20 62 75
 727+ B697 69 6C 64 20
 727+ B69B 32 30 32 33
 727+ B69F 30 33 32 31
 727+ B6A3 0D
 728+ B6A4 31 39 39 30                  db      "1990-2023 Matteo Vitturi", 13        // 25
 728+ B6A8 2D 32 30 32
 728+ B6AC 33 20 4D 61
 728+ B6B0 74 74 65 6F
 728+ B6B4 20 56 69 74
 728+ B6B8 74 75 72 69
 728+ B6BC 0D
 729+ B6BD A2 9F                        dw      EXIT
 730+ B6BF
 731+ B6BF              //  ______________________________________________________________________
 732+ B6BF              //
 733+ B6BF              // video        --
 734+ B6BF                              Colon_Def VIDEO, "VIDEO", is_normal
 734+ B6BF             >                New_Def  VIDEO, "VIDEO", Enter_Ptr, is_normal ; ok
 734+ B6BF             >
 734+ B6BF             >Dict_Ptr        defl    $
 734+ B6BF             >
 734+ B6BF             >//              ______________________________________________________________________
 734+ B6BF             >//              Heap part
 734+ B6BF             >
 734+ B6BF             >
 734+ B6BF             >                org     (Heap_Ptr & $1FFF) + $E000
 734+ ECB8             >
 734+ ECB8             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 734+ ECB8             >Latest_Definition defl  Heap_Ptr
 734+ ECB8             >
 734+ ECB8             >                // dummy db directives used to calculate length of namec
 734+ ECB8 56 49 44 45 >                db      "VIDEO"
 734+ ECBC 4F          >
 734+ ECBD             >len_NFA         defl    $ - temp_NFA
 734+ ECBD             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 734+ ECB8             >
 734+ ECB8 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 734+ ECB9 56 49 44 45 >                db      "VIDEO"               // name string in 7-bit ascii, but
 734+ ECBD 4F          >
 734+ ECBE             >                org     $-1                 // alter last byte of Name just above to set
 734+ ECBD CF          >                db      {b $} | END_BIT     // msb as name end
 734+ ECBE             >
 734+ ECBE AD 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 734+ ECC0             >Prev_Ptr        defl    Heap_Ptr
 734+ ECC0             >
 734+ ECC0             >mirror_Ptr      defl    $
 734+ ECC0             >
 734+ ECC0 C1 B6       >                dw      Dict_Ptr + 2        // xt
 734+ ECC2             >Heap_Ptr        defl    $ - $E000           // save current HP
 734+ ECC2             >
 734+ ECC2             >Current_HP      defl  $ - $E000             // used to set HP once!
 734+ ECC2             >
 734+ ECC2             >//              ______________________________________________________________________
 734+ ECC2             >//              Dictionary part
 734+ ECC2             >
 734+ ECC2             >                org     Dict_Ptr
 734+ B6BF             >
 734+ B6BF C0 2B       >                dw      mirror_Ptr - $E000 + $1F00
 734+ B6C1             >
 734+ B6C1             >VIDEO:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 734+ B6C1 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 734+ B6C4             >
 734+ B6C4             >
 734+ B6C4             >                endif           ; ok        // for other definitions it "points" the correct handler
 734+ B6C4             >                // Use of "; ok" to suppress "warning[fwdref]"
 734+ B6C4             >
 734+ B6C4             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 735+ B6C4 DF A1 7B A0                  dw      TWO, DUP, DEVICE, STORE
 735+ B6C8 6A AE E3 A0
 736+ B6CC 17 9E                        dw      SELECT
 737+ B6CE A2 9F                        dw      EXIT
 738+ B6D0
 739+ B6D0              //  ______________________________________________________________________
 740+ B6D0              //
 741+ B6D0              // autoexec     --
 742+ B6D0              // this word is called the first time the Forth system boot to
 743+ B6D0              // load Screen# 1. Once called it patches itself to prevent furhter runs.
 744+ B6D0                              Colon_Def AUTOEXEC, "AUTOEXEC", is_normal
 744+ B6D0             >                New_Def  AUTOEXEC, "AUTOEXEC", Enter_Ptr, is_normal ; ok
 744+ B6D0             >
 744+ B6D0             >Dict_Ptr        defl    $
 744+ B6D0             >
 744+ B6D0             >//              ______________________________________________________________________
 744+ B6D0             >//              Heap part
 744+ B6D0             >
 744+ B6D0             >
 744+ B6D0             >                org     (Heap_Ptr & $1FFF) + $E000
 744+ ECC2             >
 744+ ECC2             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 744+ ECC2             >Latest_Definition defl  Heap_Ptr
 744+ ECC2             >
 744+ ECC2             >                // dummy db directives used to calculate length of namec
 744+ ECC2 41 55 54 4F >                db      "AUTOEXEC"
 744+ ECC6 45 58 45 43 >
 744+ ECCA             >len_NFA         defl    $ - temp_NFA
 744+ ECCA             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 744+ ECC2             >
 744+ ECC2 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 744+ ECC3 41 55 54 4F >                db      "AUTOEXEC"               // name string in 7-bit ascii, but
 744+ ECC7 45 58 45 43 >
 744+ ECCB             >                org     $-1                 // alter last byte of Name just above to set
 744+ ECCA C3          >                db      {b $} | END_BIT     // msb as name end
 744+ ECCB             >
 744+ ECCB B8 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 744+ ECCD             >Prev_Ptr        defl    Heap_Ptr
 744+ ECCD             >
 744+ ECCD             >mirror_Ptr      defl    $
 744+ ECCD             >
 744+ ECCD D2 B6       >                dw      Dict_Ptr + 2        // xt
 744+ ECCF             >Heap_Ptr        defl    $ - $E000           // save current HP
 744+ ECCF             >
 744+ ECCF             >Current_HP      defl  $ - $E000             // used to set HP once!
 744+ ECCF             >
 744+ ECCF             >//              ______________________________________________________________________
 744+ ECCF             >//              Dictionary part
 744+ ECCF             >
 744+ ECCF             >                org     Dict_Ptr
 744+ B6D0             >
 744+ B6D0 CD 2B       >                dw      mirror_Ptr - $E000 + $1F00
 744+ B6D2             >
 744+ B6D2             >AUTOEXEC:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 744+ B6D2 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 744+ B6D5             >
 744+ B6D5             >
 744+ B6D5             >                endif           ; ok        // for other definitions it "points" the correct handler
 744+ B6D5             >                // Use of "; ok" to suppress "warning[fwdref]"
 744+ B6D5             >
 744+ B6D5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 745+ B6D5 F3 9A 0B 00                  dw      LIT, 11
 746+ B6D9 F3 9A 98 A1                  dw      LIT, NOOP
 747+ B6DD F3 9A 76 AC                  dw      LIT, Autoexec_Ptr
 748+ B6E1 E3 A0                        dw      STORE
 749+ B6E3 87 B3                        dw      LOAD
 750+ B6E5 2B AC                        dw      QUIT
 751+ B6E7 A2 9F                        dw      EXIT
 752+ B6E9
 753+ B6E9
 754+ B6E9              //  ______________________________________________________________________
 755+ B6E9              //
 756+ B6E9              // bye     --
 757+ B6E9              //
 758+ B6E9                              Colon_Def BYE, "BYE", is_normal
 758+ B6E9             >                New_Def  BYE, "BYE", Enter_Ptr, is_normal ; ok
 758+ B6E9             >
 758+ B6E9             >Dict_Ptr        defl    $
 758+ B6E9             >
 758+ B6E9             >//              ______________________________________________________________________
 758+ B6E9             >//              Heap part
 758+ B6E9             >
 758+ B6E9             >
 758+ B6E9             >                org     (Heap_Ptr & $1FFF) + $E000
 758+ ECCF             >
 758+ ECCF             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 758+ ECCF             >Latest_Definition defl  Heap_Ptr
 758+ ECCF             >
 758+ ECCF             >                // dummy db directives used to calculate length of namec
 758+ ECCF 42 59 45    >                db      "BYE"
 758+ ECD2             >len_NFA         defl    $ - temp_NFA
 758+ ECD2             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 758+ ECCF             >
 758+ ECCF 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 758+ ECD0 42 59 45    >                db      "BYE"               // name string in 7-bit ascii, but
 758+ ECD3             >                org     $-1                 // alter last byte of Name just above to set
 758+ ECD2 C5          >                db      {b $} | END_BIT     // msb as name end
 758+ ECD3             >
 758+ ECD3 C2 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 758+ ECD5             >Prev_Ptr        defl    Heap_Ptr
 758+ ECD5             >
 758+ ECD5             >mirror_Ptr      defl    $
 758+ ECD5             >
 758+ ECD5 EB B6       >                dw      Dict_Ptr + 2        // xt
 758+ ECD7             >Heap_Ptr        defl    $ - $E000           // save current HP
 758+ ECD7             >
 758+ ECD7             >Current_HP      defl  $ - $E000             // used to set HP once!
 758+ ECD7             >
 758+ ECD7             >//              ______________________________________________________________________
 758+ ECD7             >//              Dictionary part
 758+ ECD7             >
 758+ ECD7             >                org     Dict_Ptr
 758+ B6E9             >
 758+ B6E9 D5 2B       >                dw      mirror_Ptr - $E000 + $1F00
 758+ B6EB             >
 758+ B6EB             >BYE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 758+ B6EB CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 758+ B6EE             >
 758+ B6EE             >
 758+ B6EE             >                endif           ; ok        // for other definitions it "points" the correct handler
 758+ B6EE             >                // Use of "; ok" to suppress "warning[fwdref]"
 758+ B6EE             >
 758+ B6EE             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 759+ B6EE 89 B0                        dw      FLUSH
 760+ B6F0 D1 AF                        dw      EMPTY_BUFFERS
 761+ B6F2 BD AE D9 A0                  dw      BLK_FH, FETCH, F_CLOSE, DROP
 761+ B6F6 4F 9E 60 A0
 762+ B6FA D1 A1 17 A2                  dw      ZERO, PLUS_ORIGIN
 763+ B6FE F9 AC                        dw      BASIC
 764+ B700
 765+ B700              //  ______________________________________________________________________
 766+ B700              //
 767+ B700              // invv     --
 768+ B700              //
 769+ B700              //              Colon_Def INVV, "INVV", is_normal
 770+ B700              //              dw      LIT, 20, EMITC, ONE, EMITC
 771+ B700              //              dw      EXIT
 772+ B700
 773+ B700              //  ______________________________________________________________________
 774+ B700              //
 775+ B700              // truv     --
 776+ B700              //
 777+ B700              //              Colon_Def TRUV, "TRUV", is_normal
 778+ B700              //              dw      LIT, 20, EMITC, ZERO, EMITC
 779+ B700              //              dw      EXIT
 780+ B700
 781+ B700              //  ______________________________________________________________________
 782+ B700              //
 783+ B700              // mark     --
 784+ B700              //
 785+ B700              //              Colon_Def MARK, "MARK", is_normal
 786+ B700              //              dw      INVV, TYPE, TRUV
 787+ B700              //              dw      EXIT
 788+ B700
 789+ B700              //  ______________________________________________________________________
 790+ B700              //
 791+ B700              // back     --
 792+ B700              //
 793+ B700                              Colon_Def BACK, "BACK", is_normal
 793+ B700             >                New_Def  BACK, "BACK", Enter_Ptr, is_normal ; ok
 793+ B700             >
 793+ B700             >Dict_Ptr        defl    $
 793+ B700             >
 793+ B700             >//              ______________________________________________________________________
 793+ B700             >//              Heap part
 793+ B700             >
 793+ B700             >
 793+ B700             >                org     (Heap_Ptr & $1FFF) + $E000
 793+ ECD7             >
 793+ ECD7             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 793+ ECD7             >Latest_Definition defl  Heap_Ptr
 793+ ECD7             >
 793+ ECD7             >                // dummy db directives used to calculate length of namec
 793+ ECD7 42 41 43 4B >                db      "BACK"
 793+ ECDB             >len_NFA         defl    $ - temp_NFA
 793+ ECDB             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 793+ ECD7             >
 793+ ECD7 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 793+ ECD8 42 41 43 4B >                db      "BACK"               // name string in 7-bit ascii, but
 793+ ECDC             >                org     $-1                 // alter last byte of Name just above to set
 793+ ECDB CB          >                db      {b $} | END_BIT     // msb as name end
 793+ ECDC             >
 793+ ECDC CF 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 793+ ECDE             >Prev_Ptr        defl    Heap_Ptr
 793+ ECDE             >
 793+ ECDE             >mirror_Ptr      defl    $
 793+ ECDE             >
 793+ ECDE 02 B7       >                dw      Dict_Ptr + 2        // xt
 793+ ECE0             >Heap_Ptr        defl    $ - $E000           // save current HP
 793+ ECE0             >
 793+ ECE0             >Current_HP      defl  $ - $E000             // used to set HP once!
 793+ ECE0             >
 793+ ECE0             >//              ______________________________________________________________________
 793+ ECE0             >//              Dictionary part
 793+ ECE0             >
 793+ ECE0             >                org     Dict_Ptr
 793+ B700             >
 793+ B700 DE 2B       >                dw      mirror_Ptr - $E000 + $1F00
 793+ B702             >
 793+ B702             >BACK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 793+ B702 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 793+ B705             >
 793+ B705             >
 793+ B705             >                endif           ; ok        // for other definitions it "points" the correct handler
 793+ B705             >                // Use of "; ok" to suppress "warning[fwdref]"
 793+ B705             >
 793+ B705             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 794+ B705 F6 A2 35 A3                  dw      HERE, SUBTRACT, COMMA
 794+ B709 0C A3
 795+ B70B A2 9F                        dw      EXIT
 796+ B70D
 797+ B70D              //  ______________________________________________________________________
 798+ B70D              //
 799+ B70D              // if          ( -- a 2 ) \ compile-time
 800+ B70D              // IF ... THEN
 801+ B70D              // IF ... ELSE ... ENDIF
 802+ B70D                              Colon_Def IF, "IF", is_immediate
 802+ B70D             >                New_Def  IF, "IF", Enter_Ptr, is_immediate ; ok
 802+ B70D             >
 802+ B70D             >Dict_Ptr        defl    $
 802+ B70D             >
 802+ B70D             >//              ______________________________________________________________________
 802+ B70D             >//              Heap part
 802+ B70D             >
 802+ B70D             >
 802+ B70D             >                org     (Heap_Ptr & $1FFF) + $E000
 802+ ECE0             >
 802+ ECE0             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 802+ ECE0             >Latest_Definition defl  Heap_Ptr
 802+ ECE0             >
 802+ ECE0             >                // dummy db directives used to calculate length of namec
 802+ ECE0 49 46       >                db      "IF"
 802+ ECE2             >len_NFA         defl    $ - temp_NFA
 802+ ECE2             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 802+ ECE0             >
 802+ ECE0 C2          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 802+ ECE1 49 46       >                db      "IF"               // name string in 7-bit ascii, but
 802+ ECE3             >                org     $-1                 // alter last byte of Name just above to set
 802+ ECE2 C6          >                db      {b $} | END_BIT     // msb as name end
 802+ ECE3             >
 802+ ECE3 D7 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 802+ ECE5             >Prev_Ptr        defl    Heap_Ptr
 802+ ECE5             >
 802+ ECE5             >mirror_Ptr      defl    $
 802+ ECE5             >
 802+ ECE5 0F B7       >                dw      Dict_Ptr + 2        // xt
 802+ ECE7             >Heap_Ptr        defl    $ - $E000           // save current HP
 802+ ECE7             >
 802+ ECE7             >Current_HP      defl  $ - $E000             // used to set HP once!
 802+ ECE7             >
 802+ ECE7             >//              ______________________________________________________________________
 802+ ECE7             >//              Dictionary part
 802+ ECE7             >
 802+ ECE7             >                org     Dict_Ptr
 802+ B70D             >
 802+ B70D E5 2B       >                dw      mirror_Ptr - $E000 + $1F00
 802+ B70F             >
 802+ B70F             >IF:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 802+ B70F CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 802+ B712             >
 802+ B712             >
 802+ B712             >                endif           ; ok        // for other definitions it "points" the correct handler
 802+ B712             >                // Use of "; ok" to suppress "warning[fwdref]"
 802+ B712             >
 802+ B712             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 803+ B712 A2 A5 45 9B                  dw      COMPILE, ZBRANCH
 804+ B716 F6 A2 D1 A1                  dw      HERE, ZERO, COMMA
 804+ B71A 0C A3
 805+ B71C DF A1                        dw      TWO
 806+ B71E A2 9F                        dw      EXIT
 807+ B720
 808+ B720              //  ______________________________________________________________________
 809+ B720              //
 810+ B720              // then        ( a 2 -- ) \ compile-time
 811+ B720              //
 812+ B720                              Colon_Def THEN, "THEN", is_immediate
 812+ B720             >                New_Def  THEN, "THEN", Enter_Ptr, is_immediate ; ok
 812+ B720             >
 812+ B720             >Dict_Ptr        defl    $
 812+ B720             >
 812+ B720             >//              ______________________________________________________________________
 812+ B720             >//              Heap part
 812+ B720             >
 812+ B720             >
 812+ B720             >                org     (Heap_Ptr & $1FFF) + $E000
 812+ ECE7             >
 812+ ECE7             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 812+ ECE7             >Latest_Definition defl  Heap_Ptr
 812+ ECE7             >
 812+ ECE7             >                // dummy db directives used to calculate length of namec
 812+ ECE7 54 48 45 4E >                db      "THEN"
 812+ ECEB             >len_NFA         defl    $ - temp_NFA
 812+ ECEB             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 812+ ECE7             >
 812+ ECE7 C4          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 812+ ECE8 54 48 45 4E >                db      "THEN"               // name string in 7-bit ascii, but
 812+ ECEC             >                org     $-1                 // alter last byte of Name just above to set
 812+ ECEB CE          >                db      {b $} | END_BIT     // msb as name end
 812+ ECEC             >
 812+ ECEC E0 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 812+ ECEE             >Prev_Ptr        defl    Heap_Ptr
 812+ ECEE             >
 812+ ECEE             >mirror_Ptr      defl    $
 812+ ECEE             >
 812+ ECEE 22 B7       >                dw      Dict_Ptr + 2        // xt
 812+ ECF0             >Heap_Ptr        defl    $ - $E000           // save current HP
 812+ ECF0             >
 812+ ECF0             >Current_HP      defl  $ - $E000             // used to set HP once!
 812+ ECF0             >
 812+ ECF0             >//              ______________________________________________________________________
 812+ ECF0             >//              Dictionary part
 812+ ECF0             >
 812+ ECF0             >                org     Dict_Ptr
 812+ B720             >
 812+ B720 EE 2B       >                dw      mirror_Ptr - $E000 + $1F00
 812+ B722             >
 812+ B722             >THEN:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 812+ B722 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 812+ B725             >
 812+ B725             >
 812+ B725             >                endif           ; ok        // for other definitions it "points" the correct handler
 812+ B725             >                // Use of "; ok" to suppress "warning[fwdref]"
 812+ B725             >
 812+ B725             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 813+ B725 47 A5                        dw      QCOMP
 814+ B727 DF A1 6B A5                  dw      TWO, QPAIRS
 815+ B72B F6 A2 57 A0                  dw      HERE, OVER, SUBTRACT, SWAP, STORE
 815+ B72F 35 A3 74 A0
 815+ B733 E3 A0
 816+ B735 A2 9F                        dw      EXIT
 817+ B737
 818+ B737              //  ______________________________________________________________________
 819+ B737              //
 820+ B737              // endif       ( a 2 -- ) \ compile-time
 821+ B737              //
 822+ B737                              Colon_Def ENDIF, "ENDIF", is_immediate
 822+ B737             >                New_Def  ENDIF, "ENDIF", Enter_Ptr, is_immediate ; ok
 822+ B737             >
 822+ B737             >Dict_Ptr        defl    $
 822+ B737             >
 822+ B737             >//              ______________________________________________________________________
 822+ B737             >//              Heap part
 822+ B737             >
 822+ B737             >
 822+ B737             >                org     (Heap_Ptr & $1FFF) + $E000
 822+ ECF0             >
 822+ ECF0             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 822+ ECF0             >Latest_Definition defl  Heap_Ptr
 822+ ECF0             >
 822+ ECF0             >                // dummy db directives used to calculate length of namec
 822+ ECF0 45 4E 44 49 >                db      "ENDIF"
 822+ ECF4 46          >
 822+ ECF5             >len_NFA         defl    $ - temp_NFA
 822+ ECF5             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 822+ ECF0             >
 822+ ECF0 C5          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 822+ ECF1 45 4E 44 49 >                db      "ENDIF"               // name string in 7-bit ascii, but
 822+ ECF5 46          >
 822+ ECF6             >                org     $-1                 // alter last byte of Name just above to set
 822+ ECF5 C6          >                db      {b $} | END_BIT     // msb as name end
 822+ ECF6             >
 822+ ECF6 E7 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 822+ ECF8             >Prev_Ptr        defl    Heap_Ptr
 822+ ECF8             >
 822+ ECF8             >mirror_Ptr      defl    $
 822+ ECF8             >
 822+ ECF8 39 B7       >                dw      Dict_Ptr + 2        // xt
 822+ ECFA             >Heap_Ptr        defl    $ - $E000           // save current HP
 822+ ECFA             >
 822+ ECFA             >Current_HP      defl  $ - $E000             // used to set HP once!
 822+ ECFA             >
 822+ ECFA             >//              ______________________________________________________________________
 822+ ECFA             >//              Dictionary part
 822+ ECFA             >
 822+ ECFA             >                org     Dict_Ptr
 822+ B737             >
 822+ B737 F8 2B       >                dw      mirror_Ptr - $E000 + $1F00
 822+ B739             >
 822+ B739             >ENDIF:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 822+ B739 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 822+ B73C             >
 822+ B73C             >
 822+ B73C             >                endif           ; ok        // for other definitions it "points" the correct handler
 822+ B73C             >                // Use of "; ok" to suppress "warning[fwdref]"
 822+ B73C             >
 822+ B73C             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 823+ B73C 22 B7                        dw      THEN
 824+ B73E A2 9F                        dw      EXIT
 825+ B740
 826+ B740              //  ______________________________________________________________________
 827+ B740              //
 828+ B740              // else        ( a1 2 -- a2 2 ) \ compile-time
 829+ B740              //
 830+ B740                              Colon_Def ELSE, "ELSE", is_immediate
 830+ B740             >                New_Def  ELSE, "ELSE", Enter_Ptr, is_immediate ; ok
 830+ B740             >
 830+ B740             >Dict_Ptr        defl    $
 830+ B740             >
 830+ B740             >//              ______________________________________________________________________
 830+ B740             >//              Heap part
 830+ B740             >
 830+ B740             >
 830+ B740             >                org     (Heap_Ptr & $1FFF) + $E000
 830+ ECFA             >
 830+ ECFA             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 830+ ECFA             >Latest_Definition defl  Heap_Ptr
 830+ ECFA             >
 830+ ECFA             >                // dummy db directives used to calculate length of namec
 830+ ECFA 45 4C 53 45 >                db      "ELSE"
 830+ ECFE             >len_NFA         defl    $ - temp_NFA
 830+ ECFE             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 830+ ECFA             >
 830+ ECFA C4          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 830+ ECFB 45 4C 53 45 >                db      "ELSE"               // name string in 7-bit ascii, but
 830+ ECFF             >                org     $-1                 // alter last byte of Name just above to set
 830+ ECFE C5          >                db      {b $} | END_BIT     // msb as name end
 830+ ECFF             >
 830+ ECFF F0 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 830+ ED01             >Prev_Ptr        defl    Heap_Ptr
 830+ ED01             >
 830+ ED01             >mirror_Ptr      defl    $
 830+ ED01             >
 830+ ED01 42 B7       >                dw      Dict_Ptr + 2        // xt
 830+ ED03             >Heap_Ptr        defl    $ - $E000           // save current HP
 830+ ED03             >
 830+ ED03             >Current_HP      defl  $ - $E000             // used to set HP once!
 830+ ED03             >
 830+ ED03             >//              ______________________________________________________________________
 830+ ED03             >//              Dictionary part
 830+ ED03             >
 830+ ED03             >                org     Dict_Ptr
 830+ B740             >
 830+ B740 01 2C       >                dw      mirror_Ptr - $E000 + $1F00
 830+ B742             >
 830+ B742             >ELSE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 830+ B742 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 830+ B745             >
 830+ B745             >
 830+ B745             >                endif           ; ok        // for other definitions it "points" the correct handler
 830+ B745             >                // Use of "; ok" to suppress "warning[fwdref]"
 830+ B745             >
 830+ B745             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 831+ B745 47 A5                        dw      QCOMP
 832+ B747 DF A1 6B A5                  dw      TWO, QPAIRS
 833+ B74B A2 A5 38 9B                  dw      COMPILE, BRANCH
 834+ B74F F6 A2 D1 A1                  dw      HERE, ZERO, COMMA
 834+ B753 0C A3
 835+ B755 74 A0 DF A1                  dw      SWAP, TWO, THEN
 835+ B759 22 B7
 836+ B75B DF A1                        dw      TWO
 837+ B75D A2 9F                        dw      EXIT
 838+ B75F
 839+ B75F              //  ______________________________________________________________________
 840+ B75F              //
 841+ B75F              // begin        ( -- a 1 ) \ compile-time
 842+ B75F              // BEGIN ... AGAIN
 843+ B75F              // BEGIN ... f UNTIL
 844+ B75F              // BEGIN ... f WHILE ... REPEAT
 845+ B75F                              Colon_Def BEGIN, "BEGIN", is_immediate
 845+ B75F             >                New_Def  BEGIN, "BEGIN", Enter_Ptr, is_immediate ; ok
 845+ B75F             >
 845+ B75F             >Dict_Ptr        defl    $
 845+ B75F             >
 845+ B75F             >//              ______________________________________________________________________
 845+ B75F             >//              Heap part
 845+ B75F             >
 845+ B75F             >
 845+ B75F             >                org     (Heap_Ptr & $1FFF) + $E000
 845+ ED03             >
 845+ ED03             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 845+ ED03             >Latest_Definition defl  Heap_Ptr
 845+ ED03             >
 845+ ED03             >                // dummy db directives used to calculate length of namec
 845+ ED03 42 45 47 49 >                db      "BEGIN"
 845+ ED07 4E          >
 845+ ED08             >len_NFA         defl    $ - temp_NFA
 845+ ED08             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 845+ ED03             >
 845+ ED03 C5          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 845+ ED04 42 45 47 49 >                db      "BEGIN"               // name string in 7-bit ascii, but
 845+ ED08 4E          >
 845+ ED09             >                org     $-1                 // alter last byte of Name just above to set
 845+ ED08 CE          >                db      {b $} | END_BIT     // msb as name end
 845+ ED09             >
 845+ ED09 FA 0C       >                dw      Prev_Ptr            // Link to previous definition Name
 845+ ED0B             >Prev_Ptr        defl    Heap_Ptr
 845+ ED0B             >
 845+ ED0B             >mirror_Ptr      defl    $
 845+ ED0B             >
 845+ ED0B 61 B7       >                dw      Dict_Ptr + 2        // xt
 845+ ED0D             >Heap_Ptr        defl    $ - $E000           // save current HP
 845+ ED0D             >
 845+ ED0D             >Current_HP      defl  $ - $E000             // used to set HP once!
 845+ ED0D             >
 845+ ED0D             >//              ______________________________________________________________________
 845+ ED0D             >//              Dictionary part
 845+ ED0D             >
 845+ ED0D             >                org     Dict_Ptr
 845+ B75F             >
 845+ B75F 0B 2C       >                dw      mirror_Ptr - $E000 + $1F00
 845+ B761             >
 845+ B761             >BEGIN:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 845+ B761 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 845+ B764             >
 845+ B764             >
 845+ B764             >                endif           ; ok        // for other definitions it "points" the correct handler
 845+ B764             >                // Use of "; ok" to suppress "warning[fwdref]"
 845+ B764             >
 845+ B764             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 846+ B764 47 A5                        dw      QCOMP
 847+ B766 F6 A2                        dw      HERE
 848+ B768 DF A1                        dw      TWO
 849+ B76A A2 9F                        dw      EXIT
 850+ B76C
 851+ B76C              //  ______________________________________________________________________
 852+ B76C              //
 853+ B76C              // again        ( a 1 -- ) \ compile-time
 854+ B76C                              Colon_Def AGAIN, "AGAIN", is_immediate
 854+ B76C             >                New_Def  AGAIN, "AGAIN", Enter_Ptr, is_immediate ; ok
 854+ B76C             >
 854+ B76C             >Dict_Ptr        defl    $
 854+ B76C             >
 854+ B76C             >//              ______________________________________________________________________
 854+ B76C             >//              Heap part
 854+ B76C             >
 854+ B76C             >
 854+ B76C             >                org     (Heap_Ptr & $1FFF) + $E000
 854+ ED0D             >
 854+ ED0D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 854+ ED0D             >Latest_Definition defl  Heap_Ptr
 854+ ED0D             >
 854+ ED0D             >                // dummy db directives used to calculate length of namec
 854+ ED0D 41 47 41 49 >                db      "AGAIN"
 854+ ED11 4E          >
 854+ ED12             >len_NFA         defl    $ - temp_NFA
 854+ ED12             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 854+ ED0D             >
 854+ ED0D C5          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 854+ ED0E 41 47 41 49 >                db      "AGAIN"               // name string in 7-bit ascii, but
 854+ ED12 4E          >
 854+ ED13             >                org     $-1                 // alter last byte of Name just above to set
 854+ ED12 CE          >                db      {b $} | END_BIT     // msb as name end
 854+ ED13             >
 854+ ED13 03 0D       >                dw      Prev_Ptr            // Link to previous definition Name
 854+ ED15             >Prev_Ptr        defl    Heap_Ptr
 854+ ED15             >
 854+ ED15             >mirror_Ptr      defl    $
 854+ ED15             >
 854+ ED15 6E B7       >                dw      Dict_Ptr + 2        // xt
 854+ ED17             >Heap_Ptr        defl    $ - $E000           // save current HP
 854+ ED17             >
 854+ ED17             >Current_HP      defl  $ - $E000             // used to set HP once!
 854+ ED17             >
 854+ ED17             >//              ______________________________________________________________________
 854+ ED17             >//              Dictionary part
 854+ ED17             >
 854+ ED17             >                org     Dict_Ptr
 854+ B76C             >
 854+ B76C 15 2C       >                dw      mirror_Ptr - $E000 + $1F00
 854+ B76E             >
 854+ B76E             >AGAIN:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 854+ B76E CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 854+ B771             >
 854+ B771             >
 854+ B771             >                endif           ; ok        // for other definitions it "points" the correct handler
 854+ B771             >                // Use of "; ok" to suppress "warning[fwdref]"
 854+ B771             >
 854+ B771             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 855+ B771 47 A5                        dw      QCOMP
 856+ B773 DF A1 6B A5                  dw      TWO, QPAIRS
 857+ B777 A2 A5 38 9B                  dw      COMPILE, BRANCH
 858+ B77B 02 B7                        dw      BACK
 859+ B77D A2 9F                        dw      EXIT
 860+ B77F
 861+ B77F              //  ______________________________________________________________________
 862+ B77F              //
 863+ B77F              // until        ( a 1 -- ) \ compile-time
 864+ B77F                              Colon_Def UNTIL, "UNTIL", is_immediate
 864+ B77F             >                New_Def  UNTIL, "UNTIL", Enter_Ptr, is_immediate ; ok
 864+ B77F             >
 864+ B77F             >Dict_Ptr        defl    $
 864+ B77F             >
 864+ B77F             >//              ______________________________________________________________________
 864+ B77F             >//              Heap part
 864+ B77F             >
 864+ B77F             >
 864+ B77F             >                org     (Heap_Ptr & $1FFF) + $E000
 864+ ED17             >
 864+ ED17             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 864+ ED17             >Latest_Definition defl  Heap_Ptr
 864+ ED17             >
 864+ ED17             >                // dummy db directives used to calculate length of namec
 864+ ED17 55 4E 54 49 >                db      "UNTIL"
 864+ ED1B 4C          >
 864+ ED1C             >len_NFA         defl    $ - temp_NFA
 864+ ED1C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 864+ ED17             >
 864+ ED17 C5          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 864+ ED18 55 4E 54 49 >                db      "UNTIL"               // name string in 7-bit ascii, but
 864+ ED1C 4C          >
 864+ ED1D             >                org     $-1                 // alter last byte of Name just above to set
 864+ ED1C CC          >                db      {b $} | END_BIT     // msb as name end
 864+ ED1D             >
 864+ ED1D 0D 0D       >                dw      Prev_Ptr            // Link to previous definition Name
 864+ ED1F             >Prev_Ptr        defl    Heap_Ptr
 864+ ED1F             >
 864+ ED1F             >mirror_Ptr      defl    $
 864+ ED1F             >
 864+ ED1F 81 B7       >                dw      Dict_Ptr + 2        // xt
 864+ ED21             >Heap_Ptr        defl    $ - $E000           // save current HP
 864+ ED21             >
 864+ ED21             >Current_HP      defl  $ - $E000             // used to set HP once!
 864+ ED21             >
 864+ ED21             >//              ______________________________________________________________________
 864+ ED21             >//              Dictionary part
 864+ ED21             >
 864+ ED21             >                org     Dict_Ptr
 864+ B77F             >
 864+ B77F 1F 2C       >                dw      mirror_Ptr - $E000 + $1F00
 864+ B781             >
 864+ B781             >UNTIL:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 864+ B781 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 864+ B784             >
 864+ B784             >
 864+ B784             >                endif           ; ok        // for other definitions it "points" the correct handler
 864+ B784             >                // Use of "; ok" to suppress "warning[fwdref]"
 864+ B784             >
 864+ B784             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 865+ B784 47 A5                        dw      QCOMP
 866+ B786 DF A1 6B A5                  dw      TWO, QPAIRS
 867+ B78A A2 A5 45 9B                  dw      COMPILE, ZBRANCH
 868+ B78E 02 B7                        dw      BACK
 869+ B790 A2 9F                        dw      EXIT
 870+ B792
 871+ B792              //  ______________________________________________________________________
 872+ B792              //
 873+ B792              // end          ( a 1 -- ) \ compile-time
 874+ B792                              Colon_Def END, "END", is_immediate
 874+ B792             >                New_Def  END, "END", Enter_Ptr, is_immediate ; ok
 874+ B792             >
 874+ B792             >Dict_Ptr        defl    $
 874+ B792             >
 874+ B792             >//              ______________________________________________________________________
 874+ B792             >//              Heap part
 874+ B792             >
 874+ B792             >
 874+ B792             >                org     (Heap_Ptr & $1FFF) + $E000
 874+ ED21             >
 874+ ED21             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 874+ ED21             >Latest_Definition defl  Heap_Ptr
 874+ ED21             >
 874+ ED21             >                // dummy db directives used to calculate length of namec
 874+ ED21 45 4E 44    >                db      "END"
 874+ ED24             >len_NFA         defl    $ - temp_NFA
 874+ ED24             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 874+ ED21             >
 874+ ED21 C3          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 874+ ED22 45 4E 44    >                db      "END"               // name string in 7-bit ascii, but
 874+ ED25             >                org     $-1                 // alter last byte of Name just above to set
 874+ ED24 C4          >                db      {b $} | END_BIT     // msb as name end
 874+ ED25             >
 874+ ED25 17 0D       >                dw      Prev_Ptr            // Link to previous definition Name
 874+ ED27             >Prev_Ptr        defl    Heap_Ptr
 874+ ED27             >
 874+ ED27             >mirror_Ptr      defl    $
 874+ ED27             >
 874+ ED27 94 B7       >                dw      Dict_Ptr + 2        // xt
 874+ ED29             >Heap_Ptr        defl    $ - $E000           // save current HP
 874+ ED29             >
 874+ ED29             >Current_HP      defl  $ - $E000             // used to set HP once!
 874+ ED29             >
 874+ ED29             >//              ______________________________________________________________________
 874+ ED29             >//              Dictionary part
 874+ ED29             >
 874+ ED29             >                org     Dict_Ptr
 874+ B792             >
 874+ B792 27 2C       >                dw      mirror_Ptr - $E000 + $1F00
 874+ B794             >
 874+ B794             >END:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 874+ B794 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 874+ B797             >
 874+ B797             >
 874+ B797             >                endif           ; ok        // for other definitions it "points" the correct handler
 874+ B797             >                // Use of "; ok" to suppress "warning[fwdref]"
 874+ B797             >
 874+ B797             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 875+ B797 81 B7                        dw      UNTIL
 876+ B799 A2 9F                        dw      EXIT
 877+ B79B
 878+ B79B              //  ______________________________________________________________________
 879+ B79B              //
 880+ B79B              // while        ( a1 1 -- a1 1 a2 4 ) \ compile-time
 881+ B79B                              Colon_Def WHILE, "WHILE", is_immediate
 881+ B79B             >                New_Def  WHILE, "WHILE", Enter_Ptr, is_immediate ; ok
 881+ B79B             >
 881+ B79B             >Dict_Ptr        defl    $
 881+ B79B             >
 881+ B79B             >//              ______________________________________________________________________
 881+ B79B             >//              Heap part
 881+ B79B             >
 881+ B79B             >
 881+ B79B             >                org     (Heap_Ptr & $1FFF) + $E000
 881+ ED29             >
 881+ ED29             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 881+ ED29             >Latest_Definition defl  Heap_Ptr
 881+ ED29             >
 881+ ED29             >                // dummy db directives used to calculate length of namec
 881+ ED29 57 48 49 4C >                db      "WHILE"
 881+ ED2D 45          >
 881+ ED2E             >len_NFA         defl    $ - temp_NFA
 881+ ED2E             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 881+ ED29             >
 881+ ED29 C5          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 881+ ED2A 57 48 49 4C >                db      "WHILE"               // name string in 7-bit ascii, but
 881+ ED2E 45          >
 881+ ED2F             >                org     $-1                 // alter last byte of Name just above to set
 881+ ED2E C5          >                db      {b $} | END_BIT     // msb as name end
 881+ ED2F             >
 881+ ED2F 21 0D       >                dw      Prev_Ptr            // Link to previous definition Name
 881+ ED31             >Prev_Ptr        defl    Heap_Ptr
 881+ ED31             >
 881+ ED31             >mirror_Ptr      defl    $
 881+ ED31             >
 881+ ED31 9D B7       >                dw      Dict_Ptr + 2        // xt
 881+ ED33             >Heap_Ptr        defl    $ - $E000           // save current HP
 881+ ED33             >
 881+ ED33             >Current_HP      defl  $ - $E000             // used to set HP once!
 881+ ED33             >
 881+ ED33             >//              ______________________________________________________________________
 881+ ED33             >//              Dictionary part
 881+ ED33             >
 881+ ED33             >                org     Dict_Ptr
 881+ B79B             >
 881+ B79B 31 2C       >                dw      mirror_Ptr - $E000 + $1F00
 881+ B79D             >
 881+ B79D             >WHILE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 881+ B79D CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 881+ B7A0             >
 881+ B7A0             >
 881+ B7A0             >                endif           ; ok        // for other definitions it "points" the correct handler
 881+ B7A0             >                // Use of "; ok" to suppress "warning[fwdref]"
 881+ B7A0             >
 881+ B7A0             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 882+ B7A0 0F B7                        dw      IF
 883+ B7A2              //              dw      TWO_PLUS // ( that is 4 )
 884+ B7A2 AA A0                        dw      TWO_SWAP
 885+ B7A4 A2 9F                        dw      EXIT
 886+ B7A6
 887+ B7A6              //  ______________________________________________________________________
 888+ B7A6              //
 889+ B7A6              // repeat       ( a1 1 a2 4 -- ) \ compile-time
 890+ B7A6                              Colon_Def REPEAT, "REPEAT", is_immediate
 890+ B7A6             >                New_Def  REPEAT, "REPEAT", Enter_Ptr, is_immediate ; ok
 890+ B7A6             >
 890+ B7A6             >Dict_Ptr        defl    $
 890+ B7A6             >
 890+ B7A6             >//              ______________________________________________________________________
 890+ B7A6             >//              Heap part
 890+ B7A6             >
 890+ B7A6             >
 890+ B7A6             >                org     (Heap_Ptr & $1FFF) + $E000
 890+ ED33             >
 890+ ED33             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 890+ ED33             >Latest_Definition defl  Heap_Ptr
 890+ ED33             >
 890+ ED33             >                // dummy db directives used to calculate length of namec
 890+ ED33 52 45 50 45 >                db      "REPEAT"
 890+ ED37 41 54       >
 890+ ED39             >len_NFA         defl    $ - temp_NFA
 890+ ED39             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 890+ ED33             >
 890+ ED33 C6          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 890+ ED34 52 45 50 45 >                db      "REPEAT"               // name string in 7-bit ascii, but
 890+ ED38 41 54       >
 890+ ED3A             >                org     $-1                 // alter last byte of Name just above to set
 890+ ED39 D4          >                db      {b $} | END_BIT     // msb as name end
 890+ ED3A             >
 890+ ED3A 29 0D       >                dw      Prev_Ptr            // Link to previous definition Name
 890+ ED3C             >Prev_Ptr        defl    Heap_Ptr
 890+ ED3C             >
 890+ ED3C             >mirror_Ptr      defl    $
 890+ ED3C             >
 890+ ED3C A8 B7       >                dw      Dict_Ptr + 2        // xt
 890+ ED3E             >Heap_Ptr        defl    $ - $E000           // save current HP
 890+ ED3E             >
 890+ ED3E             >Current_HP      defl  $ - $E000             // used to set HP once!
 890+ ED3E             >
 890+ ED3E             >//              ______________________________________________________________________
 890+ ED3E             >//              Dictionary part
 890+ ED3E             >
 890+ ED3E             >                org     Dict_Ptr
 890+ B7A6             >
 890+ B7A6 3C 2C       >                dw      mirror_Ptr - $E000 + $1F00
 890+ B7A8             >
 890+ B7A8             >REPEAT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 890+ B7A8 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 890+ B7AB             >
 890+ B7AB             >
 890+ B7AB             >                endif           ; ok        // for other definitions it "points" the correct handler
 890+ B7AB             >                // Use of "; ok" to suppress "warning[fwdref]"
 890+ B7AB             >
 890+ B7AB             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 891+ B7AB 6E B7                        dw      AGAIN
 892+ B7AD              //              dw      TWO_MINUS
 893+ B7AD 22 B7                        dw      THEN
 894+ B7AF A2 9F                        dw      EXIT
 895+ B7B1
 896+ B7B1              //  ______________________________________________________________________
 897+ B7B1              //
 898+ B7B1              // ?do-
 899+ B7B1              // special version of "BACK" used by ?DO and LOOP
 900+ B7B1                              Colon_Def C_DO_BACK, "?DO-", is_normal
 900+ B7B1             >                New_Def  C_DO_BACK, "?DO-", Enter_Ptr, is_normal ; ok
 900+ B7B1             >
 900+ B7B1             >Dict_Ptr        defl    $
 900+ B7B1             >
 900+ B7B1             >//              ______________________________________________________________________
 900+ B7B1             >//              Heap part
 900+ B7B1             >
 900+ B7B1             >
 900+ B7B1             >                org     (Heap_Ptr & $1FFF) + $E000
 900+ ED3E             >
 900+ ED3E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 900+ ED3E             >Latest_Definition defl  Heap_Ptr
 900+ ED3E             >
 900+ ED3E             >                // dummy db directives used to calculate length of namec
 900+ ED3E 3F 44 4F 2D >                db      "?DO-"
 900+ ED42             >len_NFA         defl    $ - temp_NFA
 900+ ED42             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 900+ ED3E             >
 900+ ED3E 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 900+ ED3F 3F 44 4F 2D >                db      "?DO-"               // name string in 7-bit ascii, but
 900+ ED43             >                org     $-1                 // alter last byte of Name just above to set
 900+ ED42 AD          >                db      {b $} | END_BIT     // msb as name end
 900+ ED43             >
 900+ ED43 33 0D       >                dw      Prev_Ptr            // Link to previous definition Name
 900+ ED45             >Prev_Ptr        defl    Heap_Ptr
 900+ ED45             >
 900+ ED45             >mirror_Ptr      defl    $
 900+ ED45             >
 900+ ED45 B3 B7       >                dw      Dict_Ptr + 2        // xt
 900+ ED47             >Heap_Ptr        defl    $ - $E000           // save current HP
 900+ ED47             >
 900+ ED47             >Current_HP      defl  $ - $E000             // used to set HP once!
 900+ ED47             >
 900+ ED47             >//              ______________________________________________________________________
 900+ ED47             >//              Dictionary part
 900+ ED47             >
 900+ ED47             >                org     Dict_Ptr
 900+ B7B1             >
 900+ B7B1 45 2C       >                dw      mirror_Ptr - $E000 + $1F00
 900+ B7B3             >
 900+ B7B3             >C_DO_BACK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 900+ B7B3 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 900+ B7B6             >
 900+ B7B6             >
 900+ B7B6             >                endif           ; ok        // for other definitions it "points" the correct handler
 900+ B7B6             >                // Use of "; ok" to suppress "warning[fwdref]"
 900+ B7B6             >
 900+ B7B6             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 901+ B7B6 02 B7                        dw      BACK
 902+ B7B8              CDoBack_Begin:
 903+ B7B8 89 9F B4 A2                  dw      SPFETCH, CSP, FETCH, SUBTRACT
 903+ B7BC D9 A0 35 A3
 904+ B7C0 45 9B                        dw      ZBRANCH
 905+ B7C2 0A 00                        dw      CDoBack_While - $
 906+ B7C4 1C A0 22 B7                  dw          TWO_PLUS, THEN
 907+ B7C8 38 9B                        dw      BRANCH
 908+ B7CA EE FF                        dw      CDoBack_Begin - $
 909+ B7CC              CDoBack_While:
 910+ B7CC 7A A5 B4 A2                  dw      QCSP, CSP, STORE
 910+ B7D0 E3 A0
 911+ B7D2 A2 9F                        dw      EXIT
 912+ B7D4
 913+ B7D4              //  ______________________________________________________________________
 914+ B7D4              //
 915+ B7D4              // do
 916+ B7D4              // DO  ... LOOP
 917+ B7D4              // DO  ... n +LOOP
 918+ B7D4              // ?DO ... LOOP
 919+ B7D4              // ?DO ... n +LOOP
 920+ B7D4                              Colon_Def DO, "DO", is_immediate
 920+ B7D4             >                New_Def  DO, "DO", Enter_Ptr, is_immediate ; ok
 920+ B7D4             >
 920+ B7D4             >Dict_Ptr        defl    $
 920+ B7D4             >
 920+ B7D4             >//              ______________________________________________________________________
 920+ B7D4             >//              Heap part
 920+ B7D4             >
 920+ B7D4             >
 920+ B7D4             >                org     (Heap_Ptr & $1FFF) + $E000
 920+ ED47             >
 920+ ED47             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 920+ ED47             >Latest_Definition defl  Heap_Ptr
 920+ ED47             >
 920+ ED47             >                // dummy db directives used to calculate length of namec
 920+ ED47 44 4F       >                db      "DO"
 920+ ED49             >len_NFA         defl    $ - temp_NFA
 920+ ED49             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 920+ ED47             >
 920+ ED47 C2          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 920+ ED48 44 4F       >                db      "DO"               // name string in 7-bit ascii, but
 920+ ED4A             >                org     $-1                 // alter last byte of Name just above to set
 920+ ED49 CF          >                db      {b $} | END_BIT     // msb as name end
 920+ ED4A             >
 920+ ED4A 3E 0D       >                dw      Prev_Ptr            // Link to previous definition Name
 920+ ED4C             >Prev_Ptr        defl    Heap_Ptr
 920+ ED4C             >
 920+ ED4C             >mirror_Ptr      defl    $
 920+ ED4C             >
 920+ ED4C D6 B7       >                dw      Dict_Ptr + 2        // xt
 920+ ED4E             >Heap_Ptr        defl    $ - $E000           // save current HP
 920+ ED4E             >
 920+ ED4E             >Current_HP      defl  $ - $E000             // used to set HP once!
 920+ ED4E             >
 920+ ED4E             >//              ______________________________________________________________________
 920+ ED4E             >//              Dictionary part
 920+ ED4E             >
 920+ ED4E             >                org     Dict_Ptr
 920+ B7D4             >
 920+ B7D4 4C 2C       >                dw      mirror_Ptr - $E000 + $1F00
 920+ B7D6             >
 920+ B7D6             >DO:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 920+ B7D6 CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 920+ B7D9             >
 920+ B7D9             >
 920+ B7D9             >                endif           ; ok        // for other definitions it "points" the correct handler
 920+ B7D9             >                // Use of "; ok" to suppress "warning[fwdref]"
 920+ B7D9             >
 920+ B7D9             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 921+ B7D9 A2 A5 84 9B                  dw      COMPILE, C_DO
 922+ B7DD B4 A2 D9 A0                  dw      CSP, FETCH, STORE_CSP
 922+ B7E1 25 A5
 923+ B7E3 F6 A2 E6 A1                  dw      HERE, THREE
 924+ B7E7 A2 9F                        dw      EXIT
 925+ B7E9
 926+ B7E9              //  ______________________________________________________________________
 927+ B7E9              //
 928+ B7E9              // loop
 929+ B7E9                              Colon_Def LOOP, "LOOP", is_immediate
 929+ B7E9             >                New_Def  LOOP, "LOOP", Enter_Ptr, is_immediate ; ok
 929+ B7E9             >
 929+ B7E9             >Dict_Ptr        defl    $
 929+ B7E9             >
 929+ B7E9             >//              ______________________________________________________________________
 929+ B7E9             >//              Heap part
 929+ B7E9             >
 929+ B7E9             >
 929+ B7E9             >                org     (Heap_Ptr & $1FFF) + $E000
 929+ ED4E             >
 929+ ED4E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 929+ ED4E             >Latest_Definition defl  Heap_Ptr
 929+ ED4E             >
 929+ ED4E             >                // dummy db directives used to calculate length of namec
 929+ ED4E 4C 4F 4F 50 >                db      "LOOP"
 929+ ED52             >len_NFA         defl    $ - temp_NFA
 929+ ED52             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 929+ ED4E             >
 929+ ED4E C4          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 929+ ED4F 4C 4F 4F 50 >                db      "LOOP"               // name string in 7-bit ascii, but
 929+ ED53             >                org     $-1                 // alter last byte of Name just above to set
 929+ ED52 D0          >                db      {b $} | END_BIT     // msb as name end
 929+ ED53             >
 929+ ED53 47 0D       >                dw      Prev_Ptr            // Link to previous definition Name
 929+ ED55             >Prev_Ptr        defl    Heap_Ptr
 929+ ED55             >
 929+ ED55             >mirror_Ptr      defl    $
 929+ ED55             >
 929+ ED55 EB B7       >                dw      Dict_Ptr + 2        // xt
 929+ ED57             >Heap_Ptr        defl    $ - $E000           // save current HP
 929+ ED57             >
 929+ ED57             >Current_HP      defl  $ - $E000             // used to set HP once!
 929+ ED57             >
 929+ ED57             >//              ______________________________________________________________________
 929+ ED57             >//              Dictionary part
 929+ ED57             >
 929+ ED57             >                org     Dict_Ptr
 929+ B7E9             >
 929+ B7E9 55 2C       >                dw      mirror_Ptr - $E000 + $1F00
 929+ B7EB             >
 929+ B7EB             >LOOP:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 929+ B7EB CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 929+ B7EE             >
 929+ B7EE             >
 929+ B7EE             >                endif           ; ok        // for other definitions it "points" the correct handler
 929+ B7EE             >                // Use of "; ok" to suppress "warning[fwdref]"
 929+ B7EE             >
 929+ B7EE             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 930+ B7EE E6 A1 6B A5                  dw      THREE, QPAIRS
 931+ B7F2 A2 A5 30 9B                  dw      COMPILE, C_LOOP
 932+ B7F6 B3 B7                        dw      C_DO_BACK
 933+ B7F8 A2 9F                        dw      EXIT
 934+ B7FA
 935+ B7FA              //  ______________________________________________________________________
 936+ B7FA              //
 937+ B7FA              // +loop
 938+ B7FA                              Colon_Def PLOOP, "+LOOP", is_immediate
 938+ B7FA             >                New_Def  PLOOP, "+LOOP", Enter_Ptr, is_immediate ; ok
 938+ B7FA             >
 938+ B7FA             >Dict_Ptr        defl    $
 938+ B7FA             >
 938+ B7FA             >//              ______________________________________________________________________
 938+ B7FA             >//              Heap part
 938+ B7FA             >
 938+ B7FA             >
 938+ B7FA             >                org     (Heap_Ptr & $1FFF) + $E000
 938+ ED57             >
 938+ ED57             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 938+ ED57             >Latest_Definition defl  Heap_Ptr
 938+ ED57             >
 938+ ED57             >                // dummy db directives used to calculate length of namec
 938+ ED57 2B 4C 4F 4F >                db      "+LOOP"
 938+ ED5B 50          >
 938+ ED5C             >len_NFA         defl    $ - temp_NFA
 938+ ED5C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 938+ ED57             >
 938+ ED57 C5          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 938+ ED58 2B 4C 4F 4F >                db      "+LOOP"               // name string in 7-bit ascii, but
 938+ ED5C 50          >
 938+ ED5D             >                org     $-1                 // alter last byte of Name just above to set
 938+ ED5C D0          >                db      {b $} | END_BIT     // msb as name end
 938+ ED5D             >
 938+ ED5D 4E 0D       >                dw      Prev_Ptr            // Link to previous definition Name
 938+ ED5F             >Prev_Ptr        defl    Heap_Ptr
 938+ ED5F             >
 938+ ED5F             >mirror_Ptr      defl    $
 938+ ED5F             >
 938+ ED5F FC B7       >                dw      Dict_Ptr + 2        // xt
 938+ ED61             >Heap_Ptr        defl    $ - $E000           // save current HP
 938+ ED61             >
 938+ ED61             >Current_HP      defl  $ - $E000             // used to set HP once!
 938+ ED61             >
 938+ ED61             >//              ______________________________________________________________________
 938+ ED61             >//              Dictionary part
 938+ ED61             >
 938+ ED61             >                org     Dict_Ptr
 938+ B7FA             >
 938+ B7FA 5F 2C       >                dw      mirror_Ptr - $E000 + $1F00
 938+ B7FC             >
 938+ B7FC             >PLOOP:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 938+ B7FC CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 938+ B7FF             >
 938+ B7FF             >
 938+ B7FF             >                endif           ; ok        // for other definitions it "points" the correct handler
 938+ B7FF             >                // Use of "; ok" to suppress "warning[fwdref]"
 938+ B7FF             >
 938+ B7FF             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 939+ B7FF E6 A1 6B A5                  dw      THREE, QPAIRS
 940+ B803 A2 A5 01 9B                  dw      COMPILE, C_PLOOP
 941+ B807 B3 B7                        dw      C_DO_BACK
 942+ B809 A2 9F                        dw      EXIT
 943+ B80B
 944+ B80B              //  ______________________________________________________________________
 945+ B80B              //
 946+ B80B              // ?do
 947+ B80B                              Colon_Def QDO, "?DO", is_immediate
 947+ B80B             >                New_Def  QDO, "?DO", Enter_Ptr, is_immediate ; ok
 947+ B80B             >
 947+ B80B             >Dict_Ptr        defl    $
 947+ B80B             >
 947+ B80B             >//              ______________________________________________________________________
 947+ B80B             >//              Heap part
 947+ B80B             >
 947+ B80B             >
 947+ B80B             >                org     (Heap_Ptr & $1FFF) + $E000
 947+ ED61             >
 947+ ED61             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 947+ ED61             >Latest_Definition defl  Heap_Ptr
 947+ ED61             >
 947+ ED61             >                // dummy db directives used to calculate length of namec
 947+ ED61 3F 44 4F    >                db      "?DO"
 947+ ED64             >len_NFA         defl    $ - temp_NFA
 947+ ED64             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 947+ ED61             >
 947+ ED61 C3          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 947+ ED62 3F 44 4F    >                db      "?DO"               // name string in 7-bit ascii, but
 947+ ED65             >                org     $-1                 // alter last byte of Name just above to set
 947+ ED64 CF          >                db      {b $} | END_BIT     // msb as name end
 947+ ED65             >
 947+ ED65 57 0D       >                dw      Prev_Ptr            // Link to previous definition Name
 947+ ED67             >Prev_Ptr        defl    Heap_Ptr
 947+ ED67             >
 947+ ED67             >mirror_Ptr      defl    $
 947+ ED67             >
 947+ ED67 0D B8       >                dw      Dict_Ptr + 2        // xt
 947+ ED69             >Heap_Ptr        defl    $ - $E000           // save current HP
 947+ ED69             >
 947+ ED69             >Current_HP      defl  $ - $E000             // used to set HP once!
 947+ ED69             >
 947+ ED69             >//              ______________________________________________________________________
 947+ ED69             >//              Dictionary part
 947+ ED69             >
 947+ ED69             >                org     Dict_Ptr
 947+ B80B             >
 947+ B80B 67 2C       >                dw      mirror_Ptr - $E000 + $1F00
 947+ B80D             >
 947+ B80D             >QDO:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 947+ B80D CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 947+ B810             >
 947+ B810             >
 947+ B810             >                endif           ; ok        // for other definitions it "points" the correct handler
 947+ B810             >                // Use of "; ok" to suppress "warning[fwdref]"
 947+ B810             >
 947+ B810             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 948+ B810 A2 A5 5C 9B                  dw      COMPILE, C_Q_DO
 949+ B814 B4 A2 D9 A0                  dw      CSP, FETCH, STORE_CSP
 949+ B818 25 A5
 950+ B81A F6 A2 D1 A1                  dw      HERE, ZERO, COMMA, ZERO
 950+ B81E 0C A3 D1 A1
 951+ B822 F6 A2 E6 A1                  dw      HERE, THREE
 952+ B826 A2 9F                        dw      EXIT
 953+ B828
 954+ B828              //  ______________________________________________________________________
 955+ B828              //
 956+ B828              // \
 957+ B828                              Colon_Def BACKSLASH, "\\", is_immediate  // this is a single back-slash
 957+ B828             >                New_Def  BACKSLASH, "\\", Enter_Ptr, is_immediate ; ok
 957+ B828             >
 957+ B828             >Dict_Ptr        defl    $
 957+ B828             >
 957+ B828             >//              ______________________________________________________________________
 957+ B828             >//              Heap part
 957+ B828             >
 957+ B828             >
 957+ B828             >                org     (Heap_Ptr & $1FFF) + $E000
 957+ ED69             >
 957+ ED69             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 957+ ED69             >Latest_Definition defl  Heap_Ptr
 957+ ED69             >
 957+ ED69             >                // dummy db directives used to calculate length of namec
 957+ ED69 5C          >                db      "\\"
 957+ ED6A             >len_NFA         defl    $ - temp_NFA
 957+ ED6A             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 957+ ED69             >
 957+ ED69 C1          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 957+ ED6A 5C          >                db      "\\"               // name string in 7-bit ascii, but
 957+ ED6B             >                org     $-1                 // alter last byte of Name just above to set
 957+ ED6A DC          >                db      {b $} | END_BIT     // msb as name end
 957+ ED6B             >
 957+ ED6B 61 0D       >                dw      Prev_Ptr            // Link to previous definition Name
 957+ ED6D             >Prev_Ptr        defl    Heap_Ptr
 957+ ED6D             >
 957+ ED6D             >mirror_Ptr      defl    $
 957+ ED6D             >
 957+ ED6D 2A B8       >                dw      Dict_Ptr + 2        // xt
 957+ ED6F             >Heap_Ptr        defl    $ - $E000           // save current HP
 957+ ED6F             >
 957+ ED6F             >Current_HP      defl  $ - $E000             // used to set HP once!
 957+ ED6F             >
 957+ ED6F             >//              ______________________________________________________________________
 957+ ED6F             >//              Dictionary part
 957+ ED6F             >
 957+ ED6F             >                org     Dict_Ptr
 957+ B828             >
 957+ B828 6D 2C       >                dw      mirror_Ptr - $E000 + $1F00
 957+ B82A             >
 957+ B82A             >BACKSLASH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 957+ B82A CD 7C A1    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 957+ B82D             >
 957+ B82D             >
 957+ B82D             >                endif           ; ok        // for other definitions it "points" the correct handler
 957+ B82D             >                // Use of "; ok" to suppress "warning[fwdref]"
 957+ B82D             >
 957+ B82D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 958+ B82D 72 A2 D9 A0                  dw      BLK, FETCH
 959+ B831 45 9B                        dw      ZBRANCH
 960+ B833 30 00                        dw      Backslash_Else_1 - $
 961+ B835 72 A2 D9 A0                  dw          BLK, FETCH, ONE, GREATER  // BLOCK 1 is used as temp-line in INCLUDE file
 961+ B839 D8 A1 6F A3
 962+ B83D 45 9B                        dw          ZBRANCH
 963+ B83F 18 00                        dw          Backslash_Else_2 - $
 964+ B841 78 A2 D9 A0                  dw              TO_IN, FETCH, CL, MOD, CL
 964+ B845 FB A1 ED AD
 964+ B849 FB A1
 965+ B84B 74 A0 35 A3                  dw              SWAP, SUBTRACT, TO_IN, PLUSSTORE
 965+ B84F 78 A2 C1 A0
 966+ B853 38 9B                        dw          BRANCH
 967+ B855 0A 00                        dw          Backslash_Endif_2 - $
 968+ B857              Backslash_Else_2:
 969+ B857 02 A2 29 A0                  dw              BBUF, CELL_MINUS, TO_IN, STORE
 969+ B85B 78 A2 E3 A0
 970+ B85F              Backslash_Endif_2:
 971+ B85F 38 9B                        dw      BRANCH
 972+ B861 10 00                        dw      Backslash_Endif_1 - $
 973+ B863              Backslash_Else_1:
 974+ B863 D1 A1 36 A2                  dw          ZERO, TIB, FETCH, TO_IN, FETCH, PLUS, STORE
 974+ B867 D9 A0 78 A2
 974+ B86B D9 A0 F5 9F
 974+ B86F E3 A0
 975+ B871              Backslash_Endif_1:
 976+ B871 A2 9F                        dw      EXIT
 977+ B873
 978+ B873              Fence_Word:
 979+ B873              //  ______________________________________________________________________
 980+ B873              //
 981+ B873
 982+ B873 00           Here_Dictionary db      0
 983+ B874
# file closed: C:\Zx\CSpect\Projects\vForth17_MMU7/source/L3.asm
 116  B874
 117  B874              // now we save the compiled file so we can either run it or debug it
 118  B874                              SAVENEX OPEN "output/main.nex", ORIGIN
 119  B874                              SAVENEX CORE 3, 0, 0                                // Next core 3.0.0 required as minimum
 120  B874                              SAVENEX CFG  0
 121  B874                              SAVENEX BANK 2, 0
 122  B874                              SAVENEX AUTO
 123  B874                              SAVENEX CLOSE
 124  B874
 125  B874              //              PAGE 7 ;set 7 page to current slot
 126  B874              //              SAVEBIN "ram7.bin",$C000,$4000 ;- save 4000h begin from C000h of RAM to file
 127  B874              //              SAVEBIN "output/ram2.bin", $8000, 9800 ;- save 3000h begin from 8000h of RAM to file
 128  B874
 129  B874                              SAVETAP "output/F16d.tap", CODE, "forth17d", ORIGIN, 9999
 130  B874                              SAVETAP "output/F16e.tap", CODE, "forth17e", $E000, $2000
 131  B874
 132  B874                              SAVEBIN "output/forth17d.bin", ORIGIN, 9999
 133  B874                              SAVEBIN "output/ram7.bin", $E000, $2000 ;- save 2000h begin from E000h of RAM to file
 134  B874
 135  B874                              // To load on ZX Spectrum Next you have to type
 136  B874                              //      LOAD "ram7.bin" BANK 16
 137  B874                              //      LOAD "forth17d.bin" CODE
 138  B874
 139  B874                              END
# file closed: C:\Zx\CSpect\Projects\vForth17_MMU7/source/main.asm
