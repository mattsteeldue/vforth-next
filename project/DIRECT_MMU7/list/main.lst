# file opened: C:\Zx\CSpect\Projects\vForth17_MMU7/source/main.asm
   1  0000              //  ______________________________________________________________________
   2  0000              //
   3  0000              //  main.asm
   4  0000              //  ______________________________________________________________________
   5  0000              //
   6  0000              //  v-Forth 1.62 NextZXOS version
   7  0000              //  build 20230626
   8  0000              //
   9  0000              //  Direct-Threaded version.
  10  0000              //
  11  0000              //  NextZXOS version
  12  0000              //  ______________________________________________________________________
  13  0000              //
  14  0000              //  This work is available as-is with no whatsoever warranty.
  15  0000              //  Copying, modifying and distributing this software is allowed
  16  0000              //  provided that the copyright notice is kept.
  17  0000              //  ______________________________________________________________________
  18  0000              //
  19  0000              //  by Matteo Vitturi, 1990-2023
  20  0000              //
  21  0000              //  https://sites.google.com/view/vforth/vforth15-next
  22  0000              //  https://www.oocities.org/matteo_vitturi/english/index.htm
  23  0000              //
  24  0000              //  This is the complete compiler for v.Forth for SINCLAIR ZX Spectrum Next.
  25  0000              //  Each line of this source list mustn't exceed 80 bytes.
  26  0000              //  Z80N (ZX Spectrum Next) extension is available.
  27  0000              //
  28  0000              //  This list has been tested using the following configuration:
  29  0000              //      - CSpect emulator V.2.12.30
  30  0000              //  ______________________________________________________________________
  31  0000              //
  32  0000              //  Z80 Registers usage map
  33  0000              //
  34  0000              //  AF
  35  0000              //  BC - Instruction Pointer: should be preserved during ROM/OS calls
  36  0000              //  DE - Return Stack Pointer: should be preserved during ROM/OS calls
  37  0000              //  HL - Working
  38  0000              //
  39  0000              //  AF'- Sometime used for backup purpose
  40  0000              //  BC'- Not used
  41  0000              //  DE'- Not used
  42  0000              //  HL'- Not used
  43  0000              //
  44  0000              //  SP - Calculator Stack Pointer
  45  0000              //  IX - Inner interpreter "next" address pointer. This way jp (ix) is 2T-state faster than JP next
  46  0000              //  IY - (ZX System: must be preserved to interact with standard ROM)
  47  0000              //
  48  0000              //  ______________________________________________________________________
  49  0000              //
  50  0000              //  _________________
  51  0000              //
  52  0000              //  FORTH DEFINITIONS
  53  0000              //  _________________
  54  0000
  55  0000                              OPT     --zxnext
  56  0000              //  ______________________________________________________________________
  57  0000              //
  58  0000              // this controls some debugging code in L0.asm
  59  0000              //  0 for final binary release.
  60  0000              //  1 for debugging with Visual Studio Code and DeZog
  61  0000              // -1 for for binary comparison with Forth generated code.
  62  0000              DEBUGGING       equ     -1
  63  0000              //
  64  0000              //  ______________________________________________________________________
  65  0000
  66  0000                              if ( -1 == DEBUGGING )
  67  0000              // ORIGIN          equ     $6366 - $80                 // for binary comparison with double compilation
  68  0000              ORIGIN          equ     39844 - $80               // for binary comparison with single compilation
  69  0000              Heap_Ptr        defl    -6                      // HP before compilation
  70  0000              Heap_offset     defl     $2000
  71  0000
  72  0000                              endif
  73  0000              //  ______________________________________________________________________
  74  0000
  75  0000                              if (  0 == DEBUGGING )
  76  0000 ~            ORIGIN          equ     $6366                   // binary and Tape
  77  0000 ~            // ORIGIN          equ     $9A93                // binary and Tape
  78  0000 ~            Heap_Ptr        defl    $0002
  79  0000 ~            Heap_offset     defl     0
  80  0000 ~
  81  0000                              endif
  82  0000              //  ______________________________________________________________________
  83  0000
  84  0000                              if (  1 == DEBUGGING )
  85  0000 ~            ORIGIN          equ     $8080                   // for DeZog
  86  0000 ~            Heap_Ptr        defl    $0002
  87  0000 ~            Heap_offset     defl     0
  88  0000 ~
  89  0000                              endif
  90  0000              //  ______________________________________________________________________
  91  0000
  92  0000                              DEVICE  ZXSPECTRUMNEXT
  93  0000
  94  0000                              ORG     ORIGIN
  95  9B24
  96  9B24                              if ( -1 == DEBUGGING )
  97  9B24 00 00 00...                  ds 128                            // for binary comparison
  98  9B28                              endif
  99  9BA4
 100  9BA4              //  ______________________________________________________________________
 101  9BA4              //
 102  9BA4              //  Naming convention for Label vs Forth correspondance
 103  9BA4              //  Forth words are named as they are named for real with some exception to avoid assembler syntax errors.
 104  9BA4              //    - Leading "0" is converted into "Z_"
 105  9BA4              //    - Leading "(" is converted into "C_", closing bracket is omitted
 106  9BA4              //    - Leading numbers are converted in letters: ONE_  TWO_ etc.
 107  9BA4              //    - Question mark "?" is converted into "Q" or omitted if needed / useful.
 108  9BA4              //    - Plus sign "+" is converted in _PLUS or ADD_ depending.
 109  9BA4              //    - Minus sign "-" in L (for Line), MINUS or SUBTRACT depending
 110  9BA4              //    - Greater-Than sign ">" in _GREATER or TO_ depending
 111  9BA4              //    - Equal sign "=" is converted in EQUAL
 112  9BA4              //    - Less-Than sign "<" in _LESS or FROM_ (or TO_ again) depending
 113  9BA4              //    - Asterisk sign "*" is converted in _MUL or STAR
 114  9BA4              //    - Slash "/" is converted in _DIV or omitted if it is clear what it means
 115  9BA4              //    - Exclamation mark "!" is converted in STORE
 116  9BA4              //    - At-Sign "@" is converted in FETCH
 117  9BA4              //    - Words that collide with Assembler are normally suffixed with "_OP"
 118  9BA4
 119  9BA4                              include "system.asm"
# file opened: C:\Zx\CSpect\Projects\vForth17_MMU7/source/system.asm
   1+ 9BA4              //  ______________________________________________________________________
   2+ 9BA4              //
   3+ 9BA4              //  system.asm
   4+ 9BA4              //  ______________________________________________________________________
   5+ 9BA4
   6+ 9BA4              // Registers:
   7+ 9BA4              //
   8+ 9BA4              //      BC: Instruction Pointer
   9+ 9BA4              //      DE:
  10+ 9BA4              //      HL: W register
  11+ 9BA4              //      SP: Calc stack Pointer
  12+ 9BA4              //      IX: Inner-Interpreter Address
  13+ 9BA4
  14+ 9BA4              //  ______________________________________________________________________
  15+ 9BA4              //
  16+ 9BA4              // ZX-Spectrum standard system variables
  17+ 9BA4              SCR_CT          equ     $5C8C                   // SCR-CT system variable
  18+ 9BA4              LASTK           equ     $5C08                   // LASTK system variable
  19+ 9BA4              BORDCR          equ     $5C48                   // BORDCR system variable
  20+ 9BA4              FLAGS2          equ     $5C6A                   // for caps-lock
  21+ 9BA4
  22+ 9BA4              //  ______________________________________________________________________
  23+ 9BA4              //
  24+ 9BA4              // Flag constants
  25+ 9BA4              TRUE_FLAG       equ     $FFFF
  26+ 9BA4              FALSE_FLAG      equ     $0000
  27+ 9BA4
  28+ 9BA4              //  ______________________________________________________________________
  29+ 9BA4              //
  30+ 9BA4              // Ascii char constants
  31+ 9BA4              NUL_CHAR        equ     $00
  32+ 9BA4              COMMA_CHAR      equ     $06
  33+ 9BA4              BACKSPACE_CHAR  equ     $08
  34+ 9BA4              CR_CHAR         equ     $0D
  35+ 9BA4              BLANK_CHAR      equ     $20
  36+ 9BA4              QUOTE_CHAR      equ     "'"
  37+ 9BA4              DQUOTE_CHAR     equ     '"'
  38+ 9BA4              UNDERSCORE_CHAR equ     $5F
  39+ 9BA4              SOLIDBLOCK_CHAR equ     $8F
  40+ 9BA4              HALFBLOCK_CHAR  equ     $8C
  41+ 9BA4              LC_A_CHAR       equ     $61                 // lower-case "a"
  42+ 9BA4              LC_Z_CHAR       equ     $7A                 // lower-case "z"
  43+ 9BA4
  44+ 9BA4
  45+ 9BA4              //  ______________________________________________________________________
  46+ 9BA4              //
  47+ 9BA4
  48+ 9BA4                              // emulate something like:  ld hl,rp
  49+ 9BA4              ldhlrp          macro
  50+ 9BA4 ~                            ld      hl,(RP_Pointer)
  51+ 9BA4                              endm
  52+ 9BA4
  53+ 9BA4                              // emulate something like:  ld rp,hl
  54+ 9BA4              ldrphl          macro
  55+ 9BA4 ~                            ld      (RP_Pointer),hl
  56+ 9BA4                              endm
  57+ 9BA4
  58+ 9BA4              //  ______________________________________________________________________
  59+ 9BA4              //
  60+ 9BA4              //  Inner interpreter next-address pointer. This is 2T-state faster than "jp address"
  61+ 9BA4              next            macro
  62+ 9BA4 ~                            jp      (ix)
  63+ 9BA4                              endm
  64+ 9BA4
  65+ 9BA4              psh1            macro
  66+ 9BA4 ~                            push    hl
  67+ 9BA4 ~                            jp      (ix)
  68+ 9BA4                              endm
  69+ 9BA4
  70+ 9BA4              psh2            macro
  71+ 9BA4 ~                            push    de
  72+ 9BA4 ~                            push    hl
  73+ 9BA4 ~                            jp      (ix)
  74+ 9BA4                              endm
  75+ 9BA4
  76+ 9BA4              //  ______________________________________________________________________
  77+ 9BA4              //
  78+ 9BA4              // Bit constants in length-byte
  79+ 9BA4
  80+ 9BA4              SMUDGE_BIT      equ     %00100000               // $20
  81+ 9BA4              IMMEDIATE_BIT   equ     %01000000               // $40
  82+ 9BA4              END_BIT         equ     %10000000               // $80
  83+ 9BA4
  84+ 9BA4
  85+ 9BA4              //  ______________________________________________________________________
  86+ 9BA4              //
  87+ 9BA4              //  To create Forth words using this (nice) Assembler, we have to use the two following
  88+ 9BA4              //  pointers
  89+ 9BA4              temp_NFA        defl    0
  90+ 9BA4              last_NFA        defl    0
  91+ 9BA4              len_NFA         defl    0
  92+ 9BA4
  93+ 9BA4              Dict_Ptr        defl    0
  94+ 9BA4              // Heap_Ptr        defl    $0002
  95+ 9BA4              Prev_Ptr        defl    0
  96+ 9BA4              mirror_Ptr      defl    0
  97+ 9BA4
  98+ 9BA4              is_code         equ     0                   // so the direct machine-code starts at CFA
  99+ 9BA4              is_normal       equ     0                   // so the direct machine-code starts at CFA
 100+ 9BA4              is_immediate    equ     IMMEDIATE_BIT       // $40 - the definition is IMMEDIATE.
 101+ 9BA4
 102+ 9BA4              //  ______________________________________________________________________
 103+ 9BA4              //
 104+ 9BA4              //  Create a new "low-level" definition
 105+ 9BA4              //  This macro is used in the form  Create FORTH_NAME,n,"forth_name"
 106+ 9BA4              //  to create a new Forth Dictionary entry the same way Forth itself would do.
 107+ 9BA4              //  A word begins with a Length-Byte in range 1-31. Top 3 msb are used as flags
 108+ 9BA4              //  see SMUDGE_BIT and IMMEDIATE_BIT constant above.
 109+ 9BA4              //  It is followed by the Name of the word, i.e. a string expressed in 7-bit Ascii.
 110+ 9BA4              //  The last character of the Name must have the msb set to signal the end of it (END_BIT)
 111+ 9BA4              //  This macro acts much like the standard Forth definition CREATE
 112+ 9BA4
 113+ 9BA4              New_Def         macro   label, namec, runcode, bits
 114+ 9BA4 ~
 115+ 9BA4 ~            Dict_Ptr        defl    $
 116+ 9BA4 ~
 117+ 9BA4 ~            //              ______________________________________________________________________
 118+ 9BA4 ~            //              Heap part
 119+ 9BA4 ~
 120+ 9BA4 ~
 121+ 9BA4 ~                            org     (Heap_Ptr & $1FFF) + $E000
 122+ 9BA4 ~
 123+ 9BA4 ~            temp_NFA        defl    $                   // save this NFA address to temp_NFA
 124+ 9BA4 ~            Latest_Definition defl  Heap_Ptr
 125+ 9BA4 ~
 126+ 9BA4 ~                            // dummy db directives used to calculate length of namec
 127+ 9BA4 ~                            db      namec
 128+ 9BA4 ~            len_NFA         defl    $ - temp_NFA
 129+ 9BA4 ~                            org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 130+ 9BA4 ~
 131+ 9BA4 ~                            db      len_NFA | END_BIT | bits  // The start of NFA must have msb set to signal the beginning of the sounted string
 132+ 9BA4 ~                            db      namec               // name string in 7-bit ascii, but
 133+ 9BA4 ~                            org     $-1                 // alter last byte of Name just above to set
 134+ 9BA4 ~                            db      {b $} | END_BIT     // msb as name end
 135+ 9BA4 ~
 136+ 9BA4 ~                            dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 137+ 9BA4 ~            Prev_Ptr        defl    Heap_Ptr
 138+ 9BA4 ~
 139+ 9BA4 ~            mirror_Ptr      defl    $
 140+ 9BA4 ~
 141+ 9BA4 ~                            dw      Dict_Ptr + 2        // xt
 142+ 9BA4 ~            Heap_Ptr        defl    $ - $E000           // save current HP
 143+ 9BA4 ~
 144+ 9BA4 ~            Current_HP      defl  $ - $E000             // used to set HP once!
 145+ 9BA4 ~
 146+ 9BA4 ~            //              ______________________________________________________________________
 147+ 9BA4 ~            //              Dictionary part
 148+ 9BA4 ~
 149+ 9BA4 ~                            org     Dict_Ptr
 150+ 9BA4 ~
 151+ 9BA4 ~                            dw      mirror_Ptr - $E000 + Heap_offset
 152+ 9BA4 ~
 153+ 9BA4 ~            label:          if runcode != 0 ; ok        // This is the start address of the direct jp(hl)
 154+ 9BA4 ~                            call    runcode ; ok        // for primitive definitions  actual code
 155+ 9BA4 ~
 156+ 9BA4 ~
 157+ 9BA4 ~                            endif           ; ok        // for other definitions it "points" the correct handler
 158+ 9BA4 ~                            // Use of "; ok" to suppress "warning[fwdref]"
 159+ 9BA4 ~
 160+ 9BA4 ~            last_NFA        defl    temp_NFA            // keep track of NFA saved above
 161+ 9BA4                              endm
 162+ 9BA4
 163+ 9BA4              //  ______________________________________________________________________
 164+ 9BA4              //
 165+ 9BA4              // Create a "constant"
 166+ 9BA4              // The constant value is compiled in first PFA cell
 167+ 9BA4              Constant_Def    macro   label, namec, constant_value
 168+ 9BA4 ~                            New_Def  label, namec, Constant_Ptr, is_normal
 169+ 9BA4 ~                            dw      constant_value
 170+ 9BA4                              endm
 171+ 9BA4
 172+ 9BA4              //  ______________________________________________________________________
 173+ 9BA4              //
 174+ 9BA4              // Create a "variable"
 175+ 9BA4              // The when invoked, a variable returns a pointer, the address of first PFA cell
 176+ 9BA4              // this allow creation of "variables" which content is  of any length
 177+ 9BA4              Variable_Def    macro   label, namec, initial_value
 178+ 9BA4 ~                            New_Def  label, namec, Variable_Ptr, is_normal
 179+ 9BA4 ~                            dw      initial_value
 180+ 9BA4                              endm
 181+ 9BA4
 182+ 9BA4              //  ______________________________________________________________________
 183+ 9BA4              //
 184+ 9BA4              // Create a "user"
 185+ 9BA4              // It uses a single byte as offset to calculate the address of the variable
 186+ 9BA4              User_Def        macro   label, namec, offset_value
 187+ 9BA4 ~                            New_Def  label, namec, User_Ptr, is_normal
 188+ 9BA4 ~                            db      offset_value
 189+ 9BA4                              endm
 190+ 9BA4
 191+ 9BA4              //  ______________________________________________________________________
 192+ 9BA4              //
 193+ 9BA4              // Create a "colon-definition"
 194+ 9BA4              // The CFA contains a small routine i.e. "call Enter_Ptr".
 195+ 9BA4              // The PFA, three bytes later, contains the actual Forth definition
 196+ 9BA4              Colon_Def       macro   label, namec, bits
 197+ 9BA4 ~                            New_Def  label, namec, Enter_Ptr, bits ; ok
 198+ 9BA4                              endm
 199+ 9BA4
 200+ 9BA4              //  ______________________________________________________________________
 201+ 9BA4              //
 202+ 9BA4
 203+ 9BA4              S0_system:      equ     $D0E8               // Address of top of Calc Stack
 204+ 9BA4              TIB_system      equ     $D0E8               // TIB grows upwards, Return-Stack downward.
 205+ 9BA4              R0_system:      equ     $D188               // Address of top of Return Stack. This is S0 + $00A0
 206+ 9BA4              USER_system:    equ     $D188               // User variables zone.
 207+ 9BA4              FIRST_system:   equ     $D1E4               // Address of first BUFFER
 208+ 9BA4              LIMIT_system:   equ     $E000               // Address of first byte beyond last BUFFER
 209+ 9BA4
# file closed: C:\Zx\CSpect\Projects\vForth17_MMU7/source/system.asm
 120  9BA4                              include "L0.asm"
# file opened: C:\Zx\CSpect\Projects\vForth17_MMU7/source/L0.asm
   1+ 9BA4              //  ______________________________________________________________________
   2+ 9BA4              //
   3+ 9BA4              //  L0.asm
   4+ 9BA4              //
   5+ 9BA4              //  Origin-Area and Level-0 definitions
   6+ 9BA4              //  ______________________________________________________________________
   7+ 9BA4
   8+ 9BA4              Cold_origin:
   9+ 9BA4 A7                           and     a
  10+ 9BA5 C3 0D AE                     jp      ColdRoutine
  11+ 9BA8              Warm_origin:
  12+ 9BA8 37                           scf
  13+ 9BA9 C3 0D AE                     jp      WarmRoutine
  14+ 9BAC
  15+ 9BAC              // +008
  16+ 9BAC E6 D0        SP_Basic:       dw      $D0E6               // These are bits with some "standard" meaning... 0101
  17+ 9BAE
  18+ 9BAE              // +00A
  19+ 9BAE 00 0E                        dw      $0E00
  20+ 9BB0
  21+ 9BB0              // +00C
  22+ 9BB0 76 0C        Latest_origin:  dw      Latest_Definition   // Latest word (used in Cold_Start)
  23+ 9BB2
  24+ 9BB2              // +00E
  25+ 9BB2 0C 00        DEL_Char_Ptr:   dw      $000C               // This is the characther used as "Back-Space"
  26+ 9BB4
  27+ 9BB4              // +010
  28+ 9BB4 50 B2        CPU_Id          dw      $B250               // Z80 expressed in base 36
  29+ 9BB6
  30+ 9BB6              // +012
  31+ 9BB6 E8 D0        S0_origin:      dw      S0_system
  32+ 9BB8 88 D1        R0_origin:      dw      R0_system
  33+ 9BBA E8 D0        TIB_origin:     dw      TIB_system
  34+ 9BBC 1F 00        WIDTH_origin:   dw      31
  35+ 9BBE 01 00        WARNING_origin: dw      1
  36+ 9BC0 A8 B9        FENCE_origin:   dw      Fence_Word
  37+ 9BC2 A8 B9        DP_origin       dw      Fence_Word
  38+ 9BC4 3E AD        VOCLINK_origin: dw      Voclink_Ptr
  39+ 9BC6 E4 D1                        dw      FIRST_system
  40+ 9BC8 00 E0                        dw      LIMIT_system
  41+ 9BCA 7C 0C        HP_origin:      dw      Current_HP
  42+ 9BCC
  43+ 9BCC              // +028
  44+ 9BCC 8F           Block_Face:     db      SOLIDBLOCK_CHAR     // Caps-Lock   Cursor face
  45+ 9BCD 8C           Half_Face:      db      HALFBLOCK_CHAR      // Caps-unlock Cursor face
  46+ 9BCE 5F           Underscore_Face:db      UNDERSCORE_CHAR     // Underscore  Cursor face
  47+ 9BCF 00                           db      0
  48+ 9BD0
  49+ 9BD0              // +02C
  50+ 9BD0 00 00        SP_Saved:       dw      $0000               // Saved SP dufing NextOS call
  51+ 9BD2
  52+ 9BD2              // +02E
  53+ 9BD2 88 D1        USER_Pointer:   dw      USER_system
  54+ 9BD4
  55+ 9BD4              // +030
  56+ 9BD4 88 D1        RP_Pointer:     dw      $d188 // R0_system
  57+ 9BD6
  58+ 9BD6              // +32
  59+ 9BD6 00 00        IX_Echo:        dw      $0000               // Echo IX after NextOS call
  60+ 9BD8
  61+ 9BD8
  62+ 9BD8
  63+ 9BD8              //  ______________________________________________________________________
  64+ 9BD8
  65+ 9BD8              // from this point we can use LDHLRP and LDRPHL Assembler macros
  66+ 9BD8              // instead of their equivalent long sequences.
  67+ 9BD8
  68+ 9BD8              //  ______________________________________________________________________
  69+ 9BD8
  70+ 9BD8              // address for "next" - inner interpreter
  71+ 9BD8              // This address must always be pointed by IX
  72+ 9BD8              // "next" macro simply does a  jp(ix)  instruction
  73+ 9BD8
  74+ 9BD8              // Psh2_Ptr:       push    de
  75+ 9BD8              // Psh1_Ptr:       push    hl
  76+ 9BD8
  77+ 9BD8              Next_Ptr:       // This address must always be kept in IX: "next" relies on that
  78+ 9BD8
  79+ 9BD8                              if ( 1 == DEBUGGING )
  80+ 9BD8 ~                            ld      hl, Next_Breakpoint_1
  81+ 9BD8 ~                            and     a
  82+ 9BD8 ~                            sbc     hl, bc
  83+ 9BD8 ~                            jr      nz, Next_Continue
  84+ 9BD8 ~                            nop // This is where you have to put a real breakpoint to intercept BC values...
  85+ 9BD8                              endif
  86+ 9BD8
  87+ 9BD8              Next_Continue:
  88+ 9BD8 0A                           ld      a, (bc)
  89+ 9BD9 03                           inc     bc
  90+ 9BDA 6F                           ld      l, a
  91+ 9BDB 0A                           ld      a, (bc)
  92+ 9BDC 03                           inc     bc
  93+ 9BDD 67                           ld      h, a                // hl contains a CFA (xt) of word being executed
  94+ 9BDE
  95+ 9BDE              // Execute xt i.e. CFA held in HL
  96+ 9BDE              Exec_Ptr:
  97+ 9BDE
  98+ 9BDE
  99+ 9BDE
 100+ 9BDE
 101+ 9BDE E9                           jp      (hl)                // and jump to it
 102+ 9BDF                                                          // there you'll find the real code or a CALL to a ;code part
 103+ 9BDF
 104+ 9BDF              //  ______________________________________________________________________
 105+ 9BDF              //
 106+ 9BDF              // lit          -- x
 107+ 9BDF              // puts on top of stack the value of the following word.
 108+ 9BDF              // it is compiled in colon definition before a literal number
 109+ 9BDF
 110+ 9BDF                              New_Def  LIT, "LIT", is_code, is_normal
 110+ 9BDF             >
 110+ 9BDF             >Dict_Ptr        defl    $
 110+ 9BDF             >
 110+ 9BDF             >//              ______________________________________________________________________
 110+ 9BDF             >//              Heap part
 110+ 9BDF             >
 110+ 9BDF             >
 110+ 9BDF             >                org     (Heap_Ptr & $1FFF) + $E000
 110+ FFFA             >
 110+ FFFA             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 110+ FFFA             >Latest_Definition defl  Heap_Ptr
 110+ FFFA             >
 110+ FFFA             >                // dummy db directives used to calculate length of namec
 110+ FFFA 4C 49 54    >                db      "LIT"
 110+ FFFD             >len_NFA         defl    $ - temp_NFA
 110+ FFFD             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 110+ FFFA             >
 110+ FFFA 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 110+ FFFB 4C 49 54    >                db      "LIT"               // name string in 7-bit ascii, but
 110+ FFFE             >                org     $-1                 // alter last byte of Name just above to set
 110+ FFFD D4          >                db      {b $} | END_BIT     // msb as name end
 110+ FFFE             >
 110+ FFFE 00 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 110+ 0000             >Prev_Ptr        defl    Heap_Ptr
 110+ 0000             >
 110+ 0000             >mirror_Ptr      defl    $
 110+ 0000             >
C:\Zx\CSpect\Projects\vForth17_MMU7/source/system.asm(141): error: Write outside of device memory at: 65536
C:\Zx\CSpect\Projects\vForth17_MMU7/source/L0.asm(110): ^ emitted from here
 110+ 0000 E1 9B       >                dw      Dict_Ptr + 2        // xt
 110+ 0002             >Heap_Ptr        defl    $ - $E000           // save current HP
 110+ 0002             >
 110+ 0002             >Current_HP      defl  $ - $E000             // used to set HP once!
 110+ 0002             >
 110+ 0002             >//              ______________________________________________________________________
 110+ 0002             >//              Dictionary part
 110+ 0002             >
 110+ 0002             >                org     Dict_Ptr
 110+ 9BDF             >
 110+ 9BDF 00 40       >                dw      mirror_Ptr - $E000 + Heap_offset
 110+ 9BE1             >
 110+ 9BE1             >LIT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 110+ 9BE1 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 110+ 9BE1 ~           >
 110+ 9BE1 ~           >
 110+ 9BE1             >                endif           ; ok        // for other definitions it "points" the correct handler
 110+ 9BE1             >                // Use of "; ok" to suppress "warning[fwdref]"
 110+ 9BE1             >
 110+ 9BE1             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 111+ 9BE1
 112+ 9BE1 0A                           ld      a, (bc)
 113+ 9BE2 03                           inc     bc
 114+ 9BE3 6F                           ld      l, a
 115+ 9BE4 0A                           ld      a, (bc)
 116+ 9BE5 03                           inc     bc
 117+ 9BE6 67                           ld      h, a
 118+ 9BE7 E5                           push    hl
 119+ 9BE8                              next
 119+ 9BE8 DD E9       >                jp      (ix)
 120+ 9BEA
 121+ 9BEA              //  ______________________________________________________________________
 122+ 9BEA              //
 123+ 9BEA              // execute      i*x xt -- j*x
 124+ 9BEA              // execution token. usually xt is given by CFA
 125+ 9BEA
 126+ 9BEA                              New_Def  EXECUTE, "EXECUTE", is_code, is_normal
 126+ 9BEA             >
 126+ 9BEA             >Dict_Ptr        defl    $
 126+ 9BEA             >
 126+ 9BEA             >//              ______________________________________________________________________
 126+ 9BEA             >//              Heap part
 126+ 9BEA             >
 126+ 9BEA             >
 126+ 9BEA             >                org     (Heap_Ptr & $1FFF) + $E000
 126+ E002             >
 126+ E002             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 126+ E002             >Latest_Definition defl  Heap_Ptr
 126+ E002             >
 126+ E002             >                // dummy db directives used to calculate length of namec
 126+ E002 45 58 45 43 >                db      "EXECUTE"
 126+ E006 55 54 45    >
 126+ E009             >len_NFA         defl    $ - temp_NFA
 126+ E009             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 126+ E002             >
 126+ E002 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 126+ E003 45 58 45 43 >                db      "EXECUTE"               // name string in 7-bit ascii, but
 126+ E007 55 54 45    >
 126+ E00A             >                org     $-1                 // alter last byte of Name just above to set
 126+ E009 C5          >                db      {b $} | END_BIT     // msb as name end
 126+ E00A             >
 126+ E00A FA 1F       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 126+ E00C             >Prev_Ptr        defl    Heap_Ptr
 126+ E00C             >
 126+ E00C             >mirror_Ptr      defl    $
 126+ E00C             >
 126+ E00C EC 9B       >                dw      Dict_Ptr + 2        // xt
 126+ E00E             >Heap_Ptr        defl    $ - $E000           // save current HP
 126+ E00E             >
 126+ E00E             >Current_HP      defl  $ - $E000             // used to set HP once!
 126+ E00E             >
 126+ E00E             >//              ______________________________________________________________________
 126+ E00E             >//              Dictionary part
 126+ E00E             >
 126+ E00E             >                org     Dict_Ptr
 126+ 9BEA             >
 126+ 9BEA 0C 20       >                dw      mirror_Ptr - $E000 + Heap_offset
 126+ 9BEC             >
 126+ 9BEC             >EXECUTE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 126+ 9BEC ~           >                call    runcode ; ok        // for primitive definitions  actual code
 126+ 9BEC ~           >
 126+ 9BEC ~           >
 126+ 9BEC             >                endif           ; ok        // for other definitions it "points" the correct handler
 126+ 9BEC             >                // Use of "; ok" to suppress "warning[fwdref]"
 126+ 9BEC             >
 126+ 9BEC             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 127+ 9BEC C9                           ret
 128+ 9BED
 129+ 9BED              //  ______________________________________________________________________
 130+ 9BED              //
 131+ 9BED              // brk
 132+ 9BED              //              New_Def  BRK, "BRK", is_code, is_normal
 133+ 9BED              //              next
 134+ 9BED
 135+ 9BED
 136+ 9BED
 137+ 9BED              //  ______________________________________________________________________
 138+ 9BED              //
 139+ 9BED              // (+loop)      n --
 140+ 9BED              // compiled by +LOOP. it uses the top two values of return-stack to
 141+ 9BED              // keep track of index and limit, they are accessed via I and I'
 142+ 9BED              // Add n to the loop index. If the loop index did not cross the boundary
 143+ 9BED              // between the loop limit minus one and the loop limit, continue execution
 144+ 9BED              // at the beginning of the loop. Otherwise, discard the current loop control
 145+ 9BED              // parameters and continue execution immediately following the loop.
 146+ 9BED                              New_Def C_PLOOP, "(+LOOP)", is_code, is_normal
 146+ 9BED             >
 146+ 9BED             >Dict_Ptr        defl    $
 146+ 9BED             >
 146+ 9BED             >//              ______________________________________________________________________
 146+ 9BED             >//              Heap part
 146+ 9BED             >
 146+ 9BED             >
 146+ 9BED             >                org     (Heap_Ptr & $1FFF) + $E000
 146+ E00E             >
 146+ E00E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 146+ E00E             >Latest_Definition defl  Heap_Ptr
 146+ E00E             >
 146+ E00E             >                // dummy db directives used to calculate length of namec
 146+ E00E 28 2B 4C 4F >                db      "(+LOOP)"
 146+ E012 4F 50 29    >
 146+ E015             >len_NFA         defl    $ - temp_NFA
 146+ E015             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 146+ E00E             >
 146+ E00E 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 146+ E00F 28 2B 4C 4F >                db      "(+LOOP)"               // name string in 7-bit ascii, but
 146+ E013 4F 50 29    >
 146+ E016             >                org     $-1                 // alter last byte of Name just above to set
 146+ E015 A9          >                db      {b $} | END_BIT     // msb as name end
 146+ E016             >
 146+ E016 02 40       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 146+ E018             >Prev_Ptr        defl    Heap_Ptr
 146+ E018             >
 146+ E018             >mirror_Ptr      defl    $
 146+ E018             >
 146+ E018 EF 9B       >                dw      Dict_Ptr + 2        // xt
 146+ E01A             >Heap_Ptr        defl    $ - $E000           // save current HP
 146+ E01A             >
 146+ E01A             >Current_HP      defl  $ - $E000             // used to set HP once!
 146+ E01A             >
 146+ E01A             >//              ______________________________________________________________________
 146+ E01A             >//              Dictionary part
 146+ E01A             >
 146+ E01A             >                org     Dict_Ptr
 146+ 9BED             >
 146+ 9BED 18 20       >                dw      mirror_Ptr - $E000 + Heap_offset
 146+ 9BEF             >
 146+ 9BEF             >C_PLOOP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 146+ 9BEF ~           >                call    runcode ; ok        // for primitive definitions  actual code
 146+ 9BEF ~           >
 146+ 9BEF ~           >
 146+ 9BEF             >                endif           ; ok        // for other definitions it "points" the correct handler
 146+ 9BEF             >                // Use of "; ok" to suppress "warning[fwdref]"
 146+ 9BEF             >
 146+ 9BEF             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 147+ 9BEF
 148+ 9BEF              Loop_Ptr:
 149+ 9BEF E1                           pop     hl                  // get increment
 150+ 9BF0 EB                           ex      de, hl
 151+ 9BF1                              // *** ldhlrp
 152+ 9BF1 C5                           push    bc                  // Save IP
 153+ 9BF2 42                           ld      b, d                // bc is increment
 154+ 9BF3 4B                           ld      c, e
 155+ 9BF4 E5                           push    hl
 156+ 9BF5 5E                           ld      e, (hl)             // hl points to loop-index, add increment to it.
 157+ 9BF6 7B                           ld      a, e                // de keeps index before increment.
 158+ 9BF7 81                           add     c
 159+ 9BF8 77                           ld      (hl), a
 160+ 9BF9 23                           inc     hl
 161+ 9BFA 56                           ld      d, (hl)
 162+ 9BFB 7A                           ld      a, d
 163+ 9BFC 88                           adc     b
 164+ 9BFD 77                           ld      (hl),a
 165+ 9BFE 23                           inc     hl
 166+ 9BFF
 167+ 9BFF 7B                           ld      a, e
 168+ 9C00 96                           sub     (hl)
 169+ 9C01 5F                           ld      e, a
 170+ 9C02 23                           inc     hl
 171+ 9C03 7A                           ld      a, d
 172+ 9C04 9E                           sbc     (hl)
 173+ 9C05 57                           ld      d, a                // DE is index - limit : limit is the "new zero"
 174+ 9C06
 175+ 9C06 EB                           ex      de, hl              // swap HL and DE, so restore DE:=RP+3
 176+ 9C07 09                           add     hl, bc
 177+ 9C08 CB 78                        bit     7, b                // keep increment-sign just before overwriting d
 178+ 9C0A 28 01                        jr      z, Loop_NegativeIncrement
 179+ 9C0C 3F                               ccf                     // carry-flag tracks bonudary limit crossing.
 180+ 9C0D              Loop_NegativeIncrement:
 181+ 9C0D 38 04                        jr      c, Loop_Endif
 182+ 9C0F D1                               pop     de              // Discard RP+3, retrieve original RP
 183+ 9C10 C1                               pop     bc                  // Retrieve IP
 184+ 9C11 18 13                            jr      Branch_Ptr      // perform branch consuming following cell
 185+ 9C13              Loop_Endif:
 186+ 9C13 C1                           pop     bc                  // discard original RP
 187+ 9C14 EB                           ex      de, hl
 188+ 9C15 23                           inc     hl                  // keep    RP+4 (exit from loop)
 189+ 9C16                              // *** ldrphl                      // ld rp,hl macro 30h +Origin
 190+ 9C16 EB                           ex      de, hl
 191+ 9C17 C1                           pop     bc                  // Retrieve IP
 192+ 9C18 03                           inc     bc                  // skip branch-style offset
 193+ 9C19 03                           inc     bc
 194+ 9C1A                              next
 194+ 9C1A DD E9       >                jp      (ix)
 195+ 9C1C
 196+ 9C1C              //  ______________________________________________________________________
 197+ 9C1C              //
 198+ 9C1C              // (loop)       n --
 199+ 9C1C              // same as (LOOP) but index is incremented by 1
 200+ 9C1C              // compiled by LOOP.
 201+ 9C1C                              New_Def C_LOOP, "(LOOP)", is_code, is_normal
 201+ 9C1C             >
 201+ 9C1C             >Dict_Ptr        defl    $
 201+ 9C1C             >
 201+ 9C1C             >//              ______________________________________________________________________
 201+ 9C1C             >//              Heap part
 201+ 9C1C             >
 201+ 9C1C             >
 201+ 9C1C             >                org     (Heap_Ptr & $1FFF) + $E000
 201+ E01A             >
 201+ E01A             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 201+ E01A             >Latest_Definition defl  Heap_Ptr
 201+ E01A             >
 201+ E01A             >                // dummy db directives used to calculate length of namec
 201+ E01A 28 4C 4F 4F >                db      "(LOOP)"
 201+ E01E 50 29       >
 201+ E020             >len_NFA         defl    $ - temp_NFA
 201+ E020             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 201+ E01A             >
 201+ E01A 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 201+ E01B 28 4C 4F 4F >                db      "(LOOP)"               // name string in 7-bit ascii, but
 201+ E01F 50 29       >
 201+ E021             >                org     $-1                 // alter last byte of Name just above to set
 201+ E020 A9          >                db      {b $} | END_BIT     // msb as name end
 201+ E021             >
 201+ E021 0E 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 201+ E023             >Prev_Ptr        defl    Heap_Ptr
 201+ E023             >
 201+ E023             >mirror_Ptr      defl    $
 201+ E023             >
 201+ E023 1E 9C       >                dw      Dict_Ptr + 2        // xt
 201+ E025             >Heap_Ptr        defl    $ - $E000           // save current HP
 201+ E025             >
 201+ E025             >Current_HP      defl  $ - $E000             // used to set HP once!
 201+ E025             >
 201+ E025             >//              ______________________________________________________________________
 201+ E025             >//              Dictionary part
 201+ E025             >
 201+ E025             >                org     Dict_Ptr
 201+ 9C1C             >
 201+ 9C1C 23 20       >                dw      mirror_Ptr - $E000 + Heap_offset
 201+ 9C1E             >
 201+ 9C1E             >C_LOOP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 201+ 9C1E ~           >                call    runcode ; ok        // for primitive definitions  actual code
 201+ 9C1E ~           >
 201+ 9C1E ~           >
 201+ 9C1E             >                endif           ; ok        // for other definitions it "points" the correct handler
 201+ 9C1E             >                // Use of "; ok" to suppress "warning[fwdref]"
 201+ 9C1E             >
 201+ 9C1E             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 202+ 9C1E ED 8A 00 01                  push    1
 203+ 9C22 18 CB                        jr      Loop_Ptr
 204+ 9C24
 205+ 9C24              //  ______________________________________________________________________
 206+ 9C24              //
 207+ 9C24              // branch       --
 208+ 9C24              // unconditional branch in colon definition using the following cell as an offset from current IP value
 209+ 9C24              // compiled by ELSE, AGAIN and some other immediate words
 210+ 9C24
 211+ 9C24                              New_Def BRANCH, "BRANCH", is_code, is_normal
 211+ 9C24             >
 211+ 9C24             >Dict_Ptr        defl    $
 211+ 9C24             >
 211+ 9C24             >//              ______________________________________________________________________
 211+ 9C24             >//              Heap part
 211+ 9C24             >
 211+ 9C24             >
 211+ 9C24             >                org     (Heap_Ptr & $1FFF) + $E000
 211+ E025             >
 211+ E025             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 211+ E025             >Latest_Definition defl  Heap_Ptr
 211+ E025             >
 211+ E025             >                // dummy db directives used to calculate length of namec
 211+ E025 42 52 41 4E >                db      "BRANCH"
 211+ E029 43 48       >
 211+ E02B             >len_NFA         defl    $ - temp_NFA
 211+ E02B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 211+ E025             >
 211+ E025 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 211+ E026 42 52 41 4E >                db      "BRANCH"               // name string in 7-bit ascii, but
 211+ E02A 43 48       >
 211+ E02C             >                org     $-1                 // alter last byte of Name just above to set
 211+ E02B C8          >                db      {b $} | END_BIT     // msb as name end
 211+ E02C             >
 211+ E02C 1A 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 211+ E02E             >Prev_Ptr        defl    Heap_Ptr
 211+ E02E             >
 211+ E02E             >mirror_Ptr      defl    $
 211+ E02E             >
 211+ E02E 26 9C       >                dw      Dict_Ptr + 2        // xt
 211+ E030             >Heap_Ptr        defl    $ - $E000           // save current HP
 211+ E030             >
 211+ E030             >Current_HP      defl  $ - $E000             // used to set HP once!
 211+ E030             >
 211+ E030             >//              ______________________________________________________________________
 211+ E030             >//              Dictionary part
 211+ E030             >
 211+ E030             >                org     Dict_Ptr
 211+ 9C24             >
 211+ 9C24 2E 20       >                dw      mirror_Ptr - $E000 + Heap_offset
 211+ 9C26             >
 211+ 9C26             >BRANCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 211+ 9C26 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 211+ 9C26 ~           >
 211+ 9C26 ~           >
 211+ 9C26             >                endif           ; ok        // for other definitions it "points" the correct handler
 211+ 9C26             >                // Use of "; ok" to suppress "warning[fwdref]"
 211+ 9C26             >
 211+ 9C26             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 212+ 9C26              Branch_Ptr:
 213+ 9C26 0A                           ld      a, (bc)
 214+ 9C27 6F                           ld      l, a
 215+ 9C28 03                           inc     bc
 216+ 9C29 0A                           ld      a, (bc)
 217+ 9C2A 67                           ld      h, a
 218+ 9C2B 0B                           dec     bc
 219+ 9C2C 09                           add     hl, bc
 220+ 9C2D 4D                           ld      c, l
 221+ 9C2E 44                           ld      b, h
 222+ 9C2F                              next
 222+ 9C2F DD E9       >                jp      (ix)
 223+ 9C31
 224+ 9C31
 225+ 9C31              //  ______________________________________________________________________
 226+ 9C31              //
 227+ 9C31              // 0branch      f --
 228+ 9C31              // conditional branch if the top-of-stack is ZERO or FALSE.
 229+ 9C31              // compiled by IF, UNTIL and some other immediate words
 230+ 9C31
 231+ 9C31                              New_Def ZBRANCH, "0BRANCH", is_code, is_normal
 231+ 9C31             >
 231+ 9C31             >Dict_Ptr        defl    $
 231+ 9C31             >
 231+ 9C31             >//              ______________________________________________________________________
 231+ 9C31             >//              Heap part
 231+ 9C31             >
 231+ 9C31             >
 231+ 9C31             >                org     (Heap_Ptr & $1FFF) + $E000
 231+ E030             >
 231+ E030             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 231+ E030             >Latest_Definition defl  Heap_Ptr
 231+ E030             >
 231+ E030             >                // dummy db directives used to calculate length of namec
 231+ E030 30 42 52 41 >                db      "0BRANCH"
 231+ E034 4E 43 48    >
 231+ E037             >len_NFA         defl    $ - temp_NFA
 231+ E037             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 231+ E030             >
 231+ E030 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 231+ E031 30 42 52 41 >                db      "0BRANCH"               // name string in 7-bit ascii, but
 231+ E035 4E 43 48    >
 231+ E038             >                org     $-1                 // alter last byte of Name just above to set
 231+ E037 C8          >                db      {b $} | END_BIT     // msb as name end
 231+ E038             >
 231+ E038 25 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 231+ E03A             >Prev_Ptr        defl    Heap_Ptr
 231+ E03A             >
 231+ E03A             >mirror_Ptr      defl    $
 231+ E03A             >
 231+ E03A 33 9C       >                dw      Dict_Ptr + 2        // xt
 231+ E03C             >Heap_Ptr        defl    $ - $E000           // save current HP
 231+ E03C             >
 231+ E03C             >Current_HP      defl  $ - $E000             // used to set HP once!
 231+ E03C             >
 231+ E03C             >//              ______________________________________________________________________
 231+ E03C             >//              Dictionary part
 231+ E03C             >
 231+ E03C             >                org     Dict_Ptr
 231+ 9C31             >
 231+ 9C31 3A 20       >                dw      mirror_Ptr - $E000 + Heap_offset
 231+ 9C33             >
 231+ 9C33             >ZBRANCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 231+ 9C33 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 231+ 9C33 ~           >
 231+ 9C33 ~           >
 231+ 9C33             >                endif           ; ok        // for other definitions it "points" the correct handler
 231+ 9C33             >                // Use of "; ok" to suppress "warning[fwdref]"
 231+ 9C33             >
 231+ 9C33             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 232+ 9C33              ZBranch_Ptr:
 233+ 9C33 E1                           pop     hl
 234+ 9C34 7D                           ld      a, l
 235+ 9C35 B4                           or      h
 236+ 9C36 28 EE                        jr      z, Branch_Ptr
 237+ 9C38 03                           inc     bc                  // if not branch, skip offset cell.
 238+ 9C39 03                           inc     bc
 239+ 9C3A                              next
 239+ 9C3A DD E9       >                jp      (ix)
 240+ 9C3C
 241+ 9C3C              //  ______________________________________________________________________
 242+ 9C3C              //
 243+ 9C3C              // (leave)        --
 244+ 9C3C              // compiled by LEAVE
 245+ 9C3C              // this forces to exit from loop and jump past
 246+ 9C3C                              New_Def C_LEAVE, "(LEAVE)", is_code, is_normal
 246+ 9C3C             >
 246+ 9C3C             >Dict_Ptr        defl    $
 246+ 9C3C             >
 246+ 9C3C             >//              ______________________________________________________________________
 246+ 9C3C             >//              Heap part
 246+ 9C3C             >
 246+ 9C3C             >
 246+ 9C3C             >                org     (Heap_Ptr & $1FFF) + $E000
 246+ E03C             >
 246+ E03C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 246+ E03C             >Latest_Definition defl  Heap_Ptr
 246+ E03C             >
 246+ E03C             >                // dummy db directives used to calculate length of namec
 246+ E03C 28 4C 45 41 >                db      "(LEAVE)"
 246+ E040 56 45 29    >
 246+ E043             >len_NFA         defl    $ - temp_NFA
 246+ E043             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 246+ E03C             >
 246+ E03C 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 246+ E03D 28 4C 45 41 >                db      "(LEAVE)"               // name string in 7-bit ascii, but
 246+ E041 56 45 29    >
 246+ E044             >                org     $-1                 // alter last byte of Name just above to set
 246+ E043 A9          >                db      {b $} | END_BIT     // msb as name end
 246+ E044             >
 246+ E044 30 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 246+ E046             >Prev_Ptr        defl    Heap_Ptr
 246+ E046             >
 246+ E046             >mirror_Ptr      defl    $
 246+ E046             >
 246+ E046 3E 9C       >                dw      Dict_Ptr + 2        // xt
 246+ E048             >Heap_Ptr        defl    $ - $E000           // save current HP
 246+ E048             >
 246+ E048             >Current_HP      defl  $ - $E000             // used to set HP once!
 246+ E048             >
 246+ E048             >//              ______________________________________________________________________
 246+ E048             >//              Dictionary part
 246+ E048             >
 246+ E048             >                org     Dict_Ptr
 246+ 9C3C             >
 246+ 9C3C 46 20       >                dw      mirror_Ptr - $E000 + Heap_offset
 246+ 9C3E             >
 246+ 9C3E             >C_LEAVE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 246+ 9C3E ~           >                call    runcode ; ok        // for primitive definitions  actual code
 246+ 9C3E ~           >
 246+ 9C3E ~           >
 246+ 9C3E             >                endif           ; ok        // for other definitions it "points" the correct handler
 246+ 9C3E             >                // Use of "; ok" to suppress "warning[fwdref]"
 246+ 9C3E             >
 246+ 9C3E             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 247+ 9C3E EB                           ex      de, hl
 248+ 9C3F                              // *** ldhlrp
 249+ 9C3F 3E 04                        ld      a, 4
 250+ 9C41 ED 31                        add     hl, a
 251+ 9C43                              // *** ldrphl
 252+ 9C43 EB                           ex      de, hl
 253+ 9C44 18 E0                        jr      Branch_Ptr       // perform branch consuming following cell
 254+ 9C46                              next
 254+ 9C46 DD E9       >                jp      (ix)
 255+ 9C48
 256+ 9C48              //  ______________________________________________________________________
 257+ 9C48              //
 258+ 9C48              // (?do)        lim ind --
 259+ 9C48              // compiled by ?DO to make a loop checking for lim == ind first
 260+ 9C48              // at run-time (?DO) must be followed by a BRANCH offset
 261+ 9C48              // used to skip the loop if lim == ind
 262+ 9C48                              New_Def C_Q_DO, "(?DO)", is_code, is_normal
 262+ 9C48             >
 262+ 9C48             >Dict_Ptr        defl    $
 262+ 9C48             >
 262+ 9C48             >//              ______________________________________________________________________
 262+ 9C48             >//              Heap part
 262+ 9C48             >
 262+ 9C48             >
 262+ 9C48             >                org     (Heap_Ptr & $1FFF) + $E000
 262+ E048             >
 262+ E048             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 262+ E048             >Latest_Definition defl  Heap_Ptr
 262+ E048             >
 262+ E048             >                // dummy db directives used to calculate length of namec
 262+ E048 28 3F 44 4F >                db      "(?DO)"
 262+ E04C 29          >
 262+ E04D             >len_NFA         defl    $ - temp_NFA
 262+ E04D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 262+ E048             >
 262+ E048 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 262+ E049 28 3F 44 4F >                db      "(?DO)"               // name string in 7-bit ascii, but
 262+ E04D 29          >
 262+ E04E             >                org     $-1                 // alter last byte of Name just above to set
 262+ E04D A9          >                db      {b $} | END_BIT     // msb as name end
 262+ E04E             >
 262+ E04E 3C 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 262+ E050             >Prev_Ptr        defl    Heap_Ptr
 262+ E050             >
 262+ E050             >mirror_Ptr      defl    $
 262+ E050             >
 262+ E050 4A 9C       >                dw      Dict_Ptr + 2        // xt
 262+ E052             >Heap_Ptr        defl    $ - $E000           // save current HP
 262+ E052             >
 262+ E052             >Current_HP      defl  $ - $E000             // used to set HP once!
 262+ E052             >
 262+ E052             >//              ______________________________________________________________________
 262+ E052             >//              Dictionary part
 262+ E052             >
 262+ E052             >                org     Dict_Ptr
 262+ 9C48             >
 262+ 9C48 50 20       >                dw      mirror_Ptr - $E000 + Heap_offset
 262+ 9C4A             >
 262+ 9C4A             >C_Q_DO:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 262+ 9C4A ~           >                call    runcode ; ok        // for primitive definitions  actual code
 262+ 9C4A ~           >
 262+ 9C4A ~           >
 262+ 9C4A             >                endif           ; ok        // for other definitions it "points" the correct handler
 262+ 9C4A             >                // Use of "; ok" to suppress "warning[fwdref]"
 262+ 9C4A             >
 262+ 9C4A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 263+ 9C4A D9                           exx
 264+ 9C4B D1                            pop     de                  // de has the index
 265+ 9C4C E1                            pop     hl                  // hl has the limit
 266+ 9C4D 44                            ld      b, h
 267+ 9C4E 4D                            ld      c, l
 268+ 9C4F E5                            push    hl                  // put them back to stack for later
 269+ 9C50 D5                            push    de
 270+ 9C51 A7                            and     a                   // reset carry flag
 271+ 9C52 ED 52                         sbc     hl, de              // compute limit - index
 272+ 9C54 D9                           exx
 273+ 9C55 20 04                        jr      nz, Do_Ptr          // if zero then don't even begin loop
 274+ 9C57 E1                               pop     hl
 275+ 9C58 E1                               pop     hl
 276+ 9C59 18 CB                            jr      Branch_Ptr          // perform branch consuming following cell
 277+ 9C5B              Do_Ptr:
 278+ 9C5B                              // *** ldhlrp                 // prepare RP
 279+ 9C5B                              // *** ex      de, hl
 280+ 9C5B 1B                           dec     de
 281+ 9C5C 1B                           dec     de
 282+ 9C5D 1B                           dec     de
 283+ 9C5E 1B                           dec     de
 284+ 9C5F D5                           push    de                  // pass it to h'l'
 285+ 9C60                              // *** ex      de, hl
 286+ 9C60                              // *** ldrphl
 287+ 9C60 D9                           exx
 288+ 9C61 E1                            pop     hl
 289+ 9C62
 290+ 9C62                               // store index as top RP
 291+ 9C62 D1                            pop     de
 292+ 9C63 73                            ld      (hl), e
 293+ 9C64 23                            inc     hl
 294+ 9C65 72                            ld      (hl), d
 295+ 9C66 23                            inc     hl
 296+ 9C67                               // stores lim as second from top RP
 297+ 9C67 D1                            pop     de
 298+ 9C68 73                            ld      (hl), e
 299+ 9C69 23                            inc     hl
 300+ 9C6A 72                            ld      (hl), d
 301+ 9C6B D9                           exx
 302+ 9C6C                              // skip branch-style offseet
 303+ 9C6C 03                           inc     bc
 304+ 9C6D 03                           inc     bc
 305+ 9C6E                              next
 305+ 9C6E DD E9       >                jp      (ix)
 306+ 9C70
 307+ 9C70              //  ______________________________________________________________________
 308+ 9C70              //
 309+ 9C70              // (do)        lim ind --
 310+ 9C70              // compiled by DO to make a loop checking for lim == ind first
 311+ 9C70              // this is a simpler version of (?DO)
 312+ 9C70                              New_Def C_DO, "(DO)", is_code, is_normal
 312+ 9C70             >
 312+ 9C70             >Dict_Ptr        defl    $
 312+ 9C70             >
 312+ 9C70             >//              ______________________________________________________________________
 312+ 9C70             >//              Heap part
 312+ 9C70             >
 312+ 9C70             >
 312+ 9C70             >                org     (Heap_Ptr & $1FFF) + $E000
 312+ E052             >
 312+ E052             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 312+ E052             >Latest_Definition defl  Heap_Ptr
 312+ E052             >
 312+ E052             >                // dummy db directives used to calculate length of namec
 312+ E052 28 44 4F 29 >                db      "(DO)"
 312+ E056             >len_NFA         defl    $ - temp_NFA
 312+ E056             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 312+ E052             >
 312+ E052 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 312+ E053 28 44 4F 29 >                db      "(DO)"               // name string in 7-bit ascii, but
 312+ E057             >                org     $-1                 // alter last byte of Name just above to set
 312+ E056 A9          >                db      {b $} | END_BIT     // msb as name end
 312+ E057             >
 312+ E057 48 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 312+ E059             >Prev_Ptr        defl    Heap_Ptr
 312+ E059             >
 312+ E059             >mirror_Ptr      defl    $
 312+ E059             >
 312+ E059 72 9C       >                dw      Dict_Ptr + 2        // xt
 312+ E05B             >Heap_Ptr        defl    $ - $E000           // save current HP
 312+ E05B             >
 312+ E05B             >Current_HP      defl  $ - $E000             // used to set HP once!
 312+ E05B             >
 312+ E05B             >//              ______________________________________________________________________
 312+ E05B             >//              Dictionary part
 312+ E05B             >
 312+ E05B             >                org     Dict_Ptr
 312+ 9C70             >
 312+ 9C70 59 20       >                dw      mirror_Ptr - $E000 + Heap_offset
 312+ 9C72             >
 312+ 9C72             >C_DO:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 312+ 9C72 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 312+ 9C72 ~           >
 312+ 9C72 ~           >
 312+ 9C72             >                endif           ; ok        // for other definitions it "points" the correct handler
 312+ 9C72             >                // Use of "; ok" to suppress "warning[fwdref]"
 312+ 9C72             >
 312+ 9C72             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 313+ 9C72 0B                           dec     bc                  // prepare IP beforehand
 314+ 9C73 0B                           dec     bc                  // to balance the two final inc bc in (?do)
 315+ 9C74 18 E5                        jr      Do_Ptr
 316+ 9C76
 317+ 9C76              //  ______________________________________________________________________
 318+ 9C76              //
 319+ 9C76              // i            -- n
 320+ 9C76              // used between DO and LOOP or between DO e +LOOP to copy on top of stack
 321+ 9C76              // the current value of the index-loop
 322+ 9C76                              New_Def I, "I", is_code, is_normal
 322+ 9C76             >
 322+ 9C76             >Dict_Ptr        defl    $
 322+ 9C76             >
 322+ 9C76             >//              ______________________________________________________________________
 322+ 9C76             >//              Heap part
 322+ 9C76             >
 322+ 9C76             >
 322+ 9C76             >                org     (Heap_Ptr & $1FFF) + $E000
 322+ E05B             >
 322+ E05B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 322+ E05B             >Latest_Definition defl  Heap_Ptr
 322+ E05B             >
 322+ E05B             >                // dummy db directives used to calculate length of namec
 322+ E05B 49          >                db      "I"
 322+ E05C             >len_NFA         defl    $ - temp_NFA
 322+ E05C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 322+ E05B             >
 322+ E05B 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 322+ E05C 49          >                db      "I"               // name string in 7-bit ascii, but
 322+ E05D             >                org     $-1                 // alter last byte of Name just above to set
 322+ E05C C9          >                db      {b $} | END_BIT     // msb as name end
 322+ E05D             >
 322+ E05D 52 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 322+ E05F             >Prev_Ptr        defl    Heap_Ptr
 322+ E05F             >
 322+ E05F             >mirror_Ptr      defl    $
 322+ E05F             >
 322+ E05F 78 9C       >                dw      Dict_Ptr + 2        // xt
 322+ E061             >Heap_Ptr        defl    $ - $E000           // save current HP
 322+ E061             >
 322+ E061             >Current_HP      defl  $ - $E000             // used to set HP once!
 322+ E061             >
 322+ E061             >//              ______________________________________________________________________
 322+ E061             >//              Dictionary part
 322+ E061             >
 322+ E061             >                org     Dict_Ptr
 322+ 9C76             >
 322+ 9C76 5F 20       >                dw      mirror_Ptr - $E000 + Heap_offset
 322+ 9C78             >
 322+ 9C78             >I:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 322+ 9C78 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 322+ 9C78 ~           >
 322+ 9C78 ~           >
 322+ 9C78             >                endif           ; ok        // for other definitions it "points" the correct handler
 322+ 9C78             >                // Use of "; ok" to suppress "warning[fwdref]"
 322+ 9C78             >
 322+ 9C78             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 323+ 9C78              I_Ptr:
 324+ 9C78 62                           ld      h, d
 325+ 9C79 6B                           ld      l, e
 326+ 9C7A                              // *** ldhlrp
 327+ 9C7A              I_Ptr_prime:
 328+ 9C7A 7E                           ld      a, (hl)
 329+ 9C7B 23                           inc     hl
 330+ 9C7C 66                           ld      h, (hl)
 331+ 9C7D 6F                           ld      l, a
 332+ 9C7E E5                           push    hl
 333+ 9C7F                              next
 333+ 9C7F DD E9       >                jp      (ix)
 334+ 9C81
 335+ 9C81
 336+ 9C81              //  ______________________________________________________________________
 337+ 9C81              //
 338+ 9C81              // i'            -- n
 339+ 9C81              // used between DO and LOOP or between DO e +LOOP to copy on top of stack
 340+ 9C81              // the limit of the index-loop
 341+ 9C81
 342+ 9C81                              New_Def II, "I'", is_code, is_normal
 342+ 9C81             >
 342+ 9C81             >Dict_Ptr        defl    $
 342+ 9C81             >
 342+ 9C81             >//              ______________________________________________________________________
 342+ 9C81             >//              Heap part
 342+ 9C81             >
 342+ 9C81             >
 342+ 9C81             >                org     (Heap_Ptr & $1FFF) + $E000
 342+ E061             >
 342+ E061             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 342+ E061             >Latest_Definition defl  Heap_Ptr
 342+ E061             >
 342+ E061             >                // dummy db directives used to calculate length of namec
 342+ E061 49 27       >                db      "I'"
 342+ E063             >len_NFA         defl    $ - temp_NFA
 342+ E063             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 342+ E061             >
 342+ E061 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 342+ E062 49 27       >                db      "I'"               // name string in 7-bit ascii, but
 342+ E064             >                org     $-1                 // alter last byte of Name just above to set
 342+ E063 A7          >                db      {b $} | END_BIT     // msb as name end
 342+ E064             >
 342+ E064 5B 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 342+ E066             >Prev_Ptr        defl    Heap_Ptr
 342+ E066             >
 342+ E066             >mirror_Ptr      defl    $
 342+ E066             >
 342+ E066 83 9C       >                dw      Dict_Ptr + 2        // xt
 342+ E068             >Heap_Ptr        defl    $ - $E000           // save current HP
 342+ E068             >
 342+ E068             >Current_HP      defl  $ - $E000             // used to set HP once!
 342+ E068             >
 342+ E068             >//              ______________________________________________________________________
 342+ E068             >//              Dictionary part
 342+ E068             >
 342+ E068             >                org     Dict_Ptr
 342+ 9C81             >
 342+ 9C81 66 20       >                dw      mirror_Ptr - $E000 + Heap_offset
 342+ 9C83             >
 342+ 9C83             >II:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 342+ 9C83 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 342+ 9C83 ~           >
 342+ 9C83 ~           >
 342+ 9C83             >                endif           ; ok        // for other definitions it "points" the correct handler
 342+ 9C83             >                // Use of "; ok" to suppress "warning[fwdref]"
 342+ 9C83             >
 342+ 9C83             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 343+ 9C83 62                           ld      h, d
 344+ 9C84 6B                           ld      l, e
 345+ 9C85                              // *** ldhlrp
 346+ 9C85 23                           inc     hl
 347+ 9C86 23                           inc     hl
 348+ 9C87 18 F1                        jr      I_Ptr_prime
 349+ 9C89
 350+ 9C89
 351+ 9C89              //  ______________________________________________________________________
 352+ 9C89              //
 353+ 9C89              // digit        c n -- u tf  |  ff
 354+ 9C89              // convert a character c using base n
 355+ 9C89              // returns a unsigned number and a true flag
 356+ 9C89              // or just a false flag if the conversion fails
 357+ 9C89                              New_Def DIGIT, "DIGIT", is_code, is_normal
 357+ 9C89             >
 357+ 9C89             >Dict_Ptr        defl    $
 357+ 9C89             >
 357+ 9C89             >//              ______________________________________________________________________
 357+ 9C89             >//              Heap part
 357+ 9C89             >
 357+ 9C89             >
 357+ 9C89             >                org     (Heap_Ptr & $1FFF) + $E000
 357+ E068             >
 357+ E068             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 357+ E068             >Latest_Definition defl  Heap_Ptr
 357+ E068             >
 357+ E068             >                // dummy db directives used to calculate length of namec
 357+ E068 44 49 47 49 >                db      "DIGIT"
 357+ E06C 54          >
 357+ E06D             >len_NFA         defl    $ - temp_NFA
 357+ E06D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 357+ E068             >
 357+ E068 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 357+ E069 44 49 47 49 >                db      "DIGIT"               // name string in 7-bit ascii, but
 357+ E06D 54          >
 357+ E06E             >                org     $-1                 // alter last byte of Name just above to set
 357+ E06D D4          >                db      {b $} | END_BIT     // msb as name end
 357+ E06E             >
 357+ E06E 61 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 357+ E070             >Prev_Ptr        defl    Heap_Ptr
 357+ E070             >
 357+ E070             >mirror_Ptr      defl    $
 357+ E070             >
 357+ E070 8B 9C       >                dw      Dict_Ptr + 2        // xt
 357+ E072             >Heap_Ptr        defl    $ - $E000           // save current HP
 357+ E072             >
 357+ E072             >Current_HP      defl  $ - $E000             // used to set HP once!
 357+ E072             >
 357+ E072             >//              ______________________________________________________________________
 357+ E072             >//              Dictionary part
 357+ E072             >
 357+ E072             >                org     Dict_Ptr
 357+ 9C89             >
 357+ 9C89 70 20       >                dw      mirror_Ptr - $E000 + Heap_offset
 357+ 9C8B             >
 357+ 9C8B             >DIGIT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 357+ 9C8B ~           >                call    runcode ; ok        // for primitive definitions  actual code
 357+ 9C8B ~           >
 357+ 9C8B ~           >
 357+ 9C8B             >                endif           ; ok        // for other definitions it "points" the correct handler
 357+ 9C8B             >                // Use of "; ok" to suppress "warning[fwdref]"
 357+ 9C8B             >
 357+ 9C8B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 358+ 9C8B D9                           exx
 359+ 9C8C E1                           pop     hl                  // l has the base
 360+ 9C8D D1                           pop     de                  // e has the digit
 361+ 9C8E 7B                           ld      a, e
 362+ 9C8F FE 60                        cp      $60                 // check if lowercase
 363+ 9C91 38 02                        jr      c, Digit_Uppercase
 364+ 9C93 D6 20                            sub     $20                 // quick'n'dirty uppercase
 365+ 9C95              Digit_Uppercase:
 366+ 9C95 D6 30                        sub     $30
 367+ 9C97 38 16                        jr      c, Digit_Fail       // fail when character < "0"
 368+ 9C99 FE 0A                            cp      $0A
 369+ 9C9B 38 06                            jr      c, Digit_Decimal    // perhaps is not decimal
 370+ 9C9D D6 07                                sub     7                   // try hex and subtract 7
 371+ 9C9F FE 0A                                cp      $0A
 372+ 9CA1 38 0C                                jr      c,  Digit_Fail      // it is not hex !
 373+ 9CA3
 374+ 9CA3              Digit_Decimal:
 375+ 9CA3                              // compare digit
 376+ 9CA3 BD                           cp      l                   // compare with base
 377+ 9CA4 30 09                        jr      nc, Digit_Fail      // fail when greater than base
 378+ 9CA6 5F                               ld      e, a                // digit is returned as second from TOS
 379+ 9CA7 21 01 00                         ld      hl, 1
 380+ 9CAA D5                               push    de
 381+ 9CAB E5                               push    hl
 382+ 9CAC D9                               exx
 383+ 9CAD                                  next
 383+ 9CAD DD E9       >                jp      (ix)
 384+ 9CAF              Digit_Fail:
 385+ 9CAF 21 00 00                     ld      hl, 0
 386+ 9CB2 E5                           push    hl
 387+ 9CB3 D9                           exx
 388+ 9CB4                              next
 388+ 9CB4 DD E9       >                jp      (ix)
 389+ 9CB6
 390+ 9CB6              //  ______________________________________________________________________
 391+ 9CB6              //
 392+ 9CB6              //  parametric uppercase routine
 393+ 9CB6              //  depending on the following op-code the routine can be by-passed
 394+ 9CB6              //  changing the behaviour of some callers.
 395+ 9CB6              //  If it is "ret" then the system is Case-Sensitive
 396+ 9CB6              //  If it is "Nop" then the system is Case-Insensitive
 397+ 9CB6              //  Only A register is touched.
 398+ 9CB6 00           Case_Sensitive: nop                         // Default is case-insensitive.
 399+ 9CB7              Case_Upper:
 400+ 9CB7 FE 61                        cp      LC_A_CHAR           // lower-case "a"
 401+ 9CB9 D8                           ret     c                   // no change if A < "a"
 402+ 9CBA FE 7B                        cp      LC_Z_CHAR + 1       // lower-case "z" + 1
 403+ 9CBC D0                           ret     nc                  // no change if A > "z"
 404+ 9CBD D6 20                        sub     $20                 // Make uppercase if A in ["a".."z"]
 405+ 9CBF C9                           ret
 406+ 9CC0
 407+ 9CC0              //  ______________________________________________________________________
 408+ 9CC0              //
 409+ 9CC0              //  caseon      --
 410+ 9CC0              // set system case-sensitivity on
 411+ 9CC0              // it patches a RET/NOP at the beginning of the uppercase-routine
 412+ 9CC0                              New_Def CASEON, "CASEON", is_code, is_normal
 412+ 9CC0             >
 412+ 9CC0             >Dict_Ptr        defl    $
 412+ 9CC0             >
 412+ 9CC0             >//              ______________________________________________________________________
 412+ 9CC0             >//              Heap part
 412+ 9CC0             >
 412+ 9CC0             >
 412+ 9CC0             >                org     (Heap_Ptr & $1FFF) + $E000
 412+ E072             >
 412+ E072             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 412+ E072             >Latest_Definition defl  Heap_Ptr
 412+ E072             >
 412+ E072             >                // dummy db directives used to calculate length of namec
 412+ E072 43 41 53 45 >                db      "CASEON"
 412+ E076 4F 4E       >
 412+ E078             >len_NFA         defl    $ - temp_NFA
 412+ E078             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 412+ E072             >
 412+ E072 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 412+ E073 43 41 53 45 >                db      "CASEON"               // name string in 7-bit ascii, but
 412+ E077 4F 4E       >
 412+ E079             >                org     $-1                 // alter last byte of Name just above to set
 412+ E078 CE          >                db      {b $} | END_BIT     // msb as name end
 412+ E079             >
 412+ E079 68 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 412+ E07B             >Prev_Ptr        defl    Heap_Ptr
 412+ E07B             >
 412+ E07B             >mirror_Ptr      defl    $
 412+ E07B             >
 412+ E07B C2 9C       >                dw      Dict_Ptr + 2        // xt
 412+ E07D             >Heap_Ptr        defl    $ - $E000           // save current HP
 412+ E07D             >
 412+ E07D             >Current_HP      defl  $ - $E000             // used to set HP once!
 412+ E07D             >
 412+ E07D             >//              ______________________________________________________________________
 412+ E07D             >//              Dictionary part
 412+ E07D             >
 412+ E07D             >                org     Dict_Ptr
 412+ 9CC0             >
 412+ 9CC0 7B 20       >                dw      mirror_Ptr - $E000 + Heap_offset
 412+ 9CC2             >
 412+ 9CC2             >CASEON:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 412+ 9CC2 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 412+ 9CC2 ~           >
 412+ 9CC2 ~           >
 412+ 9CC2             >                endif           ; ok        // for other definitions it "points" the correct handler
 412+ 9CC2             >                // Use of "; ok" to suppress "warning[fwdref]"
 412+ 9CC2             >
 412+ 9CC2             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 413+ 9CC2 3E C9                        ld      a, $C9              // "ret"
 414+ 9CC4 32 B6 9C                     ld      (Case_Sensitive), a
 415+ 9CC7                              next
 415+ 9CC7 DD E9       >                jp      (ix)
 416+ 9CC9
 417+ 9CC9              //  ______________________________________________________________________
 418+ 9CC9              //
 419+ 9CC9              //  caseoff     --
 420+ 9CC9              // set system case-sensitivity on
 421+ 9CC9              // it patches a RET/NOP at the beginning of the uppercase-routine
 422+ 9CC9                              New_Def CASEOFF, "CASEOFF", is_code, is_normal
 422+ 9CC9             >
 422+ 9CC9             >Dict_Ptr        defl    $
 422+ 9CC9             >
 422+ 9CC9             >//              ______________________________________________________________________
 422+ 9CC9             >//              Heap part
 422+ 9CC9             >
 422+ 9CC9             >
 422+ 9CC9             >                org     (Heap_Ptr & $1FFF) + $E000
 422+ E07D             >
 422+ E07D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 422+ E07D             >Latest_Definition defl  Heap_Ptr
 422+ E07D             >
 422+ E07D             >                // dummy db directives used to calculate length of namec
 422+ E07D 43 41 53 45 >                db      "CASEOFF"
 422+ E081 4F 46 46    >
 422+ E084             >len_NFA         defl    $ - temp_NFA
 422+ E084             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 422+ E07D             >
 422+ E07D 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 422+ E07E 43 41 53 45 >                db      "CASEOFF"               // name string in 7-bit ascii, but
 422+ E082 4F 46 46    >
 422+ E085             >                org     $-1                 // alter last byte of Name just above to set
 422+ E084 C6          >                db      {b $} | END_BIT     // msb as name end
 422+ E085             >
 422+ E085 72 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 422+ E087             >Prev_Ptr        defl    Heap_Ptr
 422+ E087             >
 422+ E087             >mirror_Ptr      defl    $
 422+ E087             >
 422+ E087 CB 9C       >                dw      Dict_Ptr + 2        // xt
 422+ E089             >Heap_Ptr        defl    $ - $E000           // save current HP
 422+ E089             >
 422+ E089             >Current_HP      defl  $ - $E000             // used to set HP once!
 422+ E089             >
 422+ E089             >//              ______________________________________________________________________
 422+ E089             >//              Dictionary part
 422+ E089             >
 422+ E089             >                org     Dict_Ptr
 422+ 9CC9             >
 422+ 9CC9 87 20       >                dw      mirror_Ptr - $E000 + Heap_offset
 422+ 9CCB             >
 422+ 9CCB             >CASEOFF:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 422+ 9CCB ~           >                call    runcode ; ok        // for primitive definitions  actual code
 422+ 9CCB ~           >
 422+ 9CCB ~           >
 422+ 9CCB             >                endif           ; ok        // for other definitions it "points" the correct handler
 422+ 9CCB             >                // Use of "; ok" to suppress "warning[fwdref]"
 422+ 9CCB             >
 422+ 9CCB             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 423+ 9CCB 3E 00                        ld      a, $00              // "nop"
 424+ 9CCD 32 B6 9C                     ld      (Case_Sensitive), a
 425+ 9CD0                              next
 425+ 9CD0 DD E9       >                jp      (ix)
 426+ 9CD2
 427+ 9CD2              //  ______________________________________________________________________
 428+ 9CD2              //
 429+ 9CD2              //  upper       c1 -- c1 | c2
 430+ 9CD2              // character on top of stack is forced to Uppercase.
 431+ 9CD2                              New_Def UPPER, "UPPER", is_code, is_normal
 431+ 9CD2             >
 431+ 9CD2             >Dict_Ptr        defl    $
 431+ 9CD2             >
 431+ 9CD2             >//              ______________________________________________________________________
 431+ 9CD2             >//              Heap part
 431+ 9CD2             >
 431+ 9CD2             >
 431+ 9CD2             >                org     (Heap_Ptr & $1FFF) + $E000
 431+ E089             >
 431+ E089             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 431+ E089             >Latest_Definition defl  Heap_Ptr
 431+ E089             >
 431+ E089             >                // dummy db directives used to calculate length of namec
 431+ E089 55 50 50 45 >                db      "UPPER"
 431+ E08D 52          >
 431+ E08E             >len_NFA         defl    $ - temp_NFA
 431+ E08E             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 431+ E089             >
 431+ E089 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 431+ E08A 55 50 50 45 >                db      "UPPER"               // name string in 7-bit ascii, but
 431+ E08E 52          >
 431+ E08F             >                org     $-1                 // alter last byte of Name just above to set
 431+ E08E D2          >                db      {b $} | END_BIT     // msb as name end
 431+ E08F             >
 431+ E08F 7D 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 431+ E091             >Prev_Ptr        defl    Heap_Ptr
 431+ E091             >
 431+ E091             >mirror_Ptr      defl    $
 431+ E091             >
 431+ E091 D4 9C       >                dw      Dict_Ptr + 2        // xt
 431+ E093             >Heap_Ptr        defl    $ - $E000           // save current HP
 431+ E093             >
 431+ E093             >Current_HP      defl  $ - $E000             // used to set HP once!
 431+ E093             >
 431+ E093             >//              ______________________________________________________________________
 431+ E093             >//              Dictionary part
 431+ E093             >
 431+ E093             >                org     Dict_Ptr
 431+ 9CD2             >
 431+ 9CD2 91 20       >                dw      mirror_Ptr - $E000 + Heap_offset
 431+ 9CD4             >
 431+ 9CD4             >UPPER:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 431+ 9CD4 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 431+ 9CD4 ~           >
 431+ 9CD4 ~           >
 431+ 9CD4             >                endif           ; ok        // for other definitions it "points" the correct handler
 431+ 9CD4             >                // Use of "; ok" to suppress "warning[fwdref]"
 431+ 9CD4             >
 431+ 9CD4             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 432+ 9CD4 E1                           pop     hl
 433+ 9CD5 7D                           ld      a, l
 434+ 9CD6 CD B7 9C                     call    Case_Upper
 435+ 9CD9 6F                           ld      l, a
 436+ 9CDA
 437+ 9CDA                              psh1
 437+ 9CDA E5          >                push    hl
 437+ 9CDB DD E9       >                jp      (ix)
 438+ 9CDD
 439+ 9CDD              //  ______________________________________________________________________
 440+ 9CDD
 441+ 9CDD              MMU7_read:
 442+ 9CDD 01 3B 24                     ld      bc, $243B
 443+ 9CE0 3E 57                        ld      a, 87
 444+ 9CE2 ED 79                        out     (c), a
 445+ 9CE4 04                           inc     b
 446+ 9CE5 ED 78                        in      a, (c)
 447+ 9CE7 C9                           ret
 448+ 9CE8
 449+ 9CE8              //  ______________________________________________________________________
 450+ 9CE8
 451+ 9CE8              TO_FAR_rout:
 452+ 9CE8 7C                           ld      a, h
 453+ 9CE9 08                           ex      af, af
 454+ 9CEA 7C                           ld      a, h
 455+ 9CEB F6 E0                        or      $E0
 456+ 9CED 67                           ld      h, a
 457+ 9CEE 08                           ex      af, af
 458+ 9CEF 07                           rlca
 459+ 9CF0 07                           rlca
 460+ 9CF1 07                           rlca
 461+ 9CF2 E6 07                        and     $07
 462+ 9CF4 C6 20                        add     $20
 463+ 9CF6 C9                           ret
 464+ 9CF7
 465+ 9CF7
 466+ 9CF7              //  ______________________________________________________________________
 467+ 9CF7              //
 468+ 9CF7              // (find)       addr voc -- 0 | cfa b 1
 469+ 9CF7              // vocabulary search,
 470+ 9CF7              // - voc is starting word's NFA
 471+ 9CF7              // - addr is the string to be searched for
 472+ 9CF7              // On success, it returns the CFA of found word, the first NFA byte
 473+ 9CF7              // (which contains length and some flags) and a true flag.
 474+ 9CF7              // On fail, a false flag  (no more: leaves addr unchanged)
 475+ 9CF7                              New_Def C_FIND, "(FIND)", is_code, is_normal
 475+ 9CF7             >
 475+ 9CF7             >Dict_Ptr        defl    $
 475+ 9CF7             >
 475+ 9CF7             >//              ______________________________________________________________________
 475+ 9CF7             >//              Heap part
 475+ 9CF7             >
 475+ 9CF7             >
 475+ 9CF7             >                org     (Heap_Ptr & $1FFF) + $E000
 475+ E093             >
 475+ E093             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 475+ E093             >Latest_Definition defl  Heap_Ptr
 475+ E093             >
 475+ E093             >                // dummy db directives used to calculate length of namec
 475+ E093 28 46 49 4E >                db      "(FIND)"
 475+ E097 44 29       >
 475+ E099             >len_NFA         defl    $ - temp_NFA
 475+ E099             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 475+ E093             >
 475+ E093 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 475+ E094 28 46 49 4E >                db      "(FIND)"               // name string in 7-bit ascii, but
 475+ E098 44 29       >
 475+ E09A             >                org     $-1                 // alter last byte of Name just above to set
 475+ E099 A9          >                db      {b $} | END_BIT     // msb as name end
 475+ E09A             >
 475+ E09A 89 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 475+ E09C             >Prev_Ptr        defl    Heap_Ptr
 475+ E09C             >
 475+ E09C             >mirror_Ptr      defl    $
 475+ E09C             >
 475+ E09C F9 9C       >                dw      Dict_Ptr + 2        // xt
 475+ E09E             >Heap_Ptr        defl    $ - $E000           // save current HP
 475+ E09E             >
 475+ E09E             >Current_HP      defl  $ - $E000             // used to set HP once!
 475+ E09E             >
 475+ E09E             >//              ______________________________________________________________________
 475+ E09E             >//              Dictionary part
 475+ E09E             >
 475+ E09E             >                org     Dict_Ptr
 475+ 9CF7             >
 475+ 9CF7 9C 20       >                dw      mirror_Ptr - $E000 + Heap_offset
 475+ 9CF9             >
 475+ 9CF9             >C_FIND:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 475+ 9CF9 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 475+ 9CF9 ~           >
 475+ 9CF9 ~           >
 475+ 9CF9             >                endif           ; ok        // for other definitions it "points" the correct handler
 475+ 9CF9             >                // Use of "; ok" to suppress "warning[fwdref]"
 475+ 9CF9             >
 475+ 9CF9             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 476+ 9CF9 D9                           exx
 477+ 9CFA CD DD 9C                     call    MMU7_read
 478+ 9CFD D9                           exx
 479+ 9CFE 6F                           ld      l, a
 480+ 9CFF D9                           exx
 481+ 9D00
 482+ 9D00 D1                           pop     de                      // de has dictionary pointer
 483+ 9D01              Find_VocabularyLoop:
 484+ 9D01 7A                               ld      a, d
 485+ 9D02 D6 60                            sub     $60
 486+ 9D04 30 08                            jr      nc, Find_far_endif
 487+ 9D06 EB                                   ex      de, hl
 488+ 9D07 CD E8 9C                             call    TO_FAR_rout
 489+ 9D0A EB                                   ex      de, hl
 490+ 9D0B ED 92 57                             nextreg 87, a
 491+ 9D0E              Find_far_endif:
 492+ 9D0E E1                               pop     hl                  // string pointer to search for
 493+ 9D0F E5                               push    hl                  // keep it on stack too for the end.
 494+ 9D10 1A                               ld      a, (de)             // save NFA length byte
 495+ 9D11 08                               ex      af,af'              // for later use (!)
 496+ 9D12 1A                               ld      a, (de)             // reload NFA length byte
 497+ 9D13 AE                               xor     (hl)                // check if same length
 498+ 9D14 E6 3F                            and     $3F                 // by resetting 3 high bits (flags)
 499+ 9D16                                  // word and text haven't the same length, skip to next vocabulary entry
 500+ 9D16 20 33                            jr      nz, Find_DifferentLenght
 501+ 9D18
 502+ 9D18              Find_ThisWord:      // begin loop
 503+ 9D18 23                                   inc     hl
 504+ 9D19 13                                   inc     de
 505+ 9D1A 1A                                   ld      a, (de)
 506+ 9D1B                                      // case insensitive option - begin
 507+ 9D1B                                      // push    bc
 508+ 9D1B E6 80                                and     $80                 // split A in msb and the rest
 509+ 9D1D 47                                   ld      b, a
 510+ 9D1E 1A                                   ld      a, (de)
 511+ 9D1F E6 7F                                and     $7F                 // ... the rest (lower 7 bits)
 512+ 9D21 CD B6 9C                             call    Case_Sensitive      // uppercase routine
 513+ 9D24 4F                                   ld      c, a
 514+ 9D25 7E                                   ld      a, (hl)
 515+ 9D26 CD B6 9C                             call    Case_Sensitive      // uppercase routine
 516+ 9D29 A9                                   xor     c
 517+ 9D2A A8                                   xor     b
 518+ 9D2B                                      // pop     bc
 519+ 9D2B                                      // case insensitive option - end
 520+ 9D2B 87                                   add     a                   // ignore msb during compare
 521+ 9D2C 20 1B                                jr      nz, Find_DidntMatch  // jump if doesn't match (*)
 522+ 9D2E
 523+ 9D2E                                  // loop back until last byte msb is found set
 524+ 9D2E                                  // that bit marks the ending char of this word
 525+ 9D2E 30 E8                            jr      nc, Find_ThisWord
 526+ 9D30
 527+ 9D30                                  // match found !
 528+ 9D30 21 03 00                         ld      hl, 3               // 3 bytes for CFA offset to skip LFA
 529+ 9D33 19                               add     hl, de
 530+ 9D34
 531+ 9D34                              //  ld      a, h
 532+ 9D34                              //  and     $E0
 533+ 9D34                              //  xor     h
 534+ 9D34                              //  jr      nz, Non_MMU7
 535+ 9D34                                  //  call    MMU7_read
 536+ 9D34                                  //  dec     a
 537+ 9D34                                  //  jr      z, Non_MMU7
 538+ 9D34 5E                                       ld      e, (hl)
 539+ 9D35 23                                       inc     hl
 540+ 9D36 56                                       ld      d, (hl)
 541+ 9D37 EB                                       ex      de, hl
 542+ 9D38              //Non_MMU7:
 543+ 9D38 E3                               ex      (sp), hl            // CFA on stack and drop addr
 544+ 9D39 08                               ex      af, af'             // retrieve NFA byte (!)
 545+ 9D3A 5F                               ld      e, a
 546+ 9D3B 16 00                            ld      d, 0
 547+ 9D3D 21 FF FF                         ld      hl, -1
 548+ 9D40 D5                               push    de
 549+ 9D41 E5                               push    hl
 550+ 9D42 D9                               exx
 551+ 9D43 7D                               ld      a, l
 552+ 9D44 ED 92 57                         nextreg 87, a
 553+ 9D47                                  next
 553+ 9D47 DD E9       >                jp      (ix)
 554+ 9D49
 555+ 9D49              Find_DidntMatch: // didn't match (*)
 556+ 9D49 38 05                            jr      c,  Find_WordEnd   // jump if not end of word (**)
 557+ 9D4B
 558+ 9D4B              Find_DifferentLenght:
 559+ 9D4B                                  // consume chars until the end of the word
 560+ 9D4B                                  // that is last byte msb is found set
 561+ 9D4B 13                                   inc     de
 562+ 9D4C 1A                                   ld      a, (de)
 563+ 9D4D 87                                   add     a, a
 564+ 9D4E 30 FB                            jr      nc, Find_DifferentLenght
 565+ 9D50
 566+ 9D50              Find_WordEnd:   // word-end  found (**)
 567+ 9D50                                  // take LFA and use it
 568+ 9D50 13                               inc     de
 569+ 9D51 EB                               ex      de, hl
 570+ 9D52 5E                               ld      e, (hl)
 571+ 9D53 23                               inc     hl
 572+ 9D54 56                               ld      d, (hl)
 573+ 9D55 7A                               ld      a, d
 574+ 9D56 B3                               or      e
 575+ 9D57
 576+ 9D57                              // loop until end of vocabulary
 577+ 9D57 20 A8                        jr      nz, Find_VocabularyLoop
 578+ 9D59
 579+ 9D59 E1                           pop     hl              // without this, leaves addr unchanged
 580+ 9D5A 21 00 00                     ld      hl, 0
 581+ 9D5D E5                           push    hl
 582+ 9D5E D9                           exx
 583+ 9D5F 7D                           ld      a, l
 584+ 9D60 ED 92 57                     nextreg 87, a
 585+ 9D63                              next
 585+ 9D63 DD E9       >                jp      (ix)
 586+ 9D65
 587+ 9D65              //  ______________________________________________________________________
 588+ 9D65              //
 589+ 9D65              // enclose      a c -- a  n1 n2 n3
 590+ 9D65              // starting from a, using delimiter c, determines the offsets:
 591+ 9D65              //   n1   the first character non-delimiter
 592+ 9D65              //   n2   the first delimiter after the text
 593+ 9D65              //   n3   the first character non enclosed.
 594+ 9D65              // This procedure does not go beyond a 'nul' ASCII (0x00) that represents
 595+ 9D65              // an uncoditional delimiter.
 596+ 9D65              // Examples:
 597+ 9D65              //   i:	c  c  x  x  x  c  x	 -- 2  5  6
 598+ 9D65              //  ii:	c  c  x  x  x  'nul' -- 2  5  5
 599+ 9D65              // iii:	c  c  'nul'          -- 2  3  2
 600+ 9D65                              New_Def ENCLOSE, "ENCLOSE", is_code, is_normal
 600+ 9D65             >
 600+ 9D65             >Dict_Ptr        defl    $
 600+ 9D65             >
 600+ 9D65             >//              ______________________________________________________________________
 600+ 9D65             >//              Heap part
 600+ 9D65             >
 600+ 9D65             >
 600+ 9D65             >                org     (Heap_Ptr & $1FFF) + $E000
 600+ E09E             >
 600+ E09E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 600+ E09E             >Latest_Definition defl  Heap_Ptr
 600+ E09E             >
 600+ E09E             >                // dummy db directives used to calculate length of namec
 600+ E09E 45 4E 43 4C >                db      "ENCLOSE"
 600+ E0A2 4F 53 45    >
 600+ E0A5             >len_NFA         defl    $ - temp_NFA
 600+ E0A5             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 600+ E09E             >
 600+ E09E 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 600+ E09F 45 4E 43 4C >                db      "ENCLOSE"               // name string in 7-bit ascii, but
 600+ E0A3 4F 53 45    >
 600+ E0A6             >                org     $-1                 // alter last byte of Name just above to set
 600+ E0A5 C5          >                db      {b $} | END_BIT     // msb as name end
 600+ E0A6             >
 600+ E0A6 93 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 600+ E0A8             >Prev_Ptr        defl    Heap_Ptr
 600+ E0A8             >
 600+ E0A8             >mirror_Ptr      defl    $
 600+ E0A8             >
 600+ E0A8 67 9D       >                dw      Dict_Ptr + 2        // xt
 600+ E0AA             >Heap_Ptr        defl    $ - $E000           // save current HP
 600+ E0AA             >
 600+ E0AA             >Current_HP      defl  $ - $E000             // used to set HP once!
 600+ E0AA             >
 600+ E0AA             >//              ______________________________________________________________________
 600+ E0AA             >//              Dictionary part
 600+ E0AA             >
 600+ E0AA             >                org     Dict_Ptr
 600+ 9D65             >
 600+ 9D65 A8 20       >                dw      mirror_Ptr - $E000 + Heap_offset
 600+ 9D67             >
 600+ 9D67             >ENCLOSE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 600+ 9D67 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 600+ 9D67 ~           >
 600+ 9D67 ~           >
 600+ 9D67             >                endif           ; ok        // for other definitions it "points" the correct handler
 600+ 9D67             >                // Use of "; ok" to suppress "warning[fwdref]"
 600+ 9D67             >
 600+ 9D67             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 601+ 9D67 D9                           exx
 602+ 9D68 D1                           pop     de                  //  e has the character
 603+ 9D69 E1                           pop     hl                  // hl has the string address
 604+ 9D6A E5                           push    hl
 605+ 9D6B 7B                           ld      a, e
 606+ 9D6C 11 FF FF                     ld      de, -1              // let's start from -1
 607+ 9D6F 2B                           dec     hl
 608+ 9D70              Enclose_NonDelimiter:
 609+ 9D70                              // find first non delimiter
 610+ 9D70 23                               inc     hl
 611+ 9D71 13                               inc     de
 612+ 9D72 BE                               cp      (hl)
 613+ 9D73 28 FB                        jr      z, Enclose_NonDelimiter
 614+ 9D75 D5                           push    de
 615+ 9D76
 616+ 9D76                              // push    bc                  // save Instruction Pointer
 617+ 9D76
 618+ 9D76 4F                           ld      c, a                // save char
 619+ 9D77 7E                           ld      a, (hl)
 620+ 9D78 A7                           and     a                   // stop if 0x00
 621+ 9D79 20 07                        jr      nz, Enclose_NextChar
 622+ 9D7B                              /// case iii. no more character in string
 623+ 9D7B                                  // pop     bc                  // restore Instruction Pointer
 624+ 9D7B 13                               inc     de
 625+ 9D7C D5                               push    de
 626+ 9D7D 1B                               dec     de
 627+ 9D7E D5                               push    de
 628+ 9D7F D9                               exx
 629+ 9D80                                  next
 629+ 9D80 DD E9       >                jp      (ix)
 630+ 9D82              Enclose_NextChar:
 631+ 9D82 79                               ld      a, c
 632+ 9D83 23                               inc     hl
 633+ 9D84 13                               inc     de
 634+ 9D85 BE                               cp      (hl)
 635+ 9D86 20 06                            jr      nz, Enclose_NonSeparator
 636+ 9D88                                      // case i. first non enclosed
 637+ 9D88                                      // pop     bc                  // restore Instruction Pointer
 638+ 9D88 D5                                   push    de
 639+ 9D89 13                                   inc     de
 640+ 9D8A D5                                   push    de
 641+ 9D8B D9                                   exx
 642+ 9D8C                                      next
 642+ 9D8C DD E9       >                jp      (ix)
 643+ 9D8E              Enclose_NonSeparator:
 644+ 9D8E 7E                               ld      a, (hl)
 645+ 9D8F A7                               and     a
 646+ 9D90 20 F0                        jr      nz, Enclose_NextChar
 647+ 9D92
 648+ 9D92                              // case ii. separator & terminator
 649+ 9D92                              // pop     bc                  // restore Instruction Pointer
 650+ 9D92 D5                           push    de
 651+ 9D93 D5                           push    de
 652+ 9D94 D9                           exx
 653+ 9D95                              next
 653+ 9D95 DD E9       >                jp      (ix)
 654+ 9D97
 655+ 9D97              //  ______________________________________________________________________
 656+ 9D97              //
 657+ 9D97              // (map)        a2 a1 n c1 -- c2
 658+ 9D97              // translate character c1 using mapping string a2 and a2
 659+ 9D97              // if c1 is not present within string a1 then
 660+ 9D97              // c2 = c2 if it is not translated. n is the length of both a1 and a2.
 661+ 9D97                              New_Def C_MAP, "(MAP)", is_code, is_normal
 661+ 9D97             >
 661+ 9D97             >Dict_Ptr        defl    $
 661+ 9D97             >
 661+ 9D97             >//              ______________________________________________________________________
 661+ 9D97             >//              Heap part
 661+ 9D97             >
 661+ 9D97             >
 661+ 9D97             >                org     (Heap_Ptr & $1FFF) + $E000
 661+ E0AA             >
 661+ E0AA             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 661+ E0AA             >Latest_Definition defl  Heap_Ptr
 661+ E0AA             >
 661+ E0AA             >                // dummy db directives used to calculate length of namec
 661+ E0AA 28 4D 41 50 >                db      "(MAP)"
 661+ E0AE 29          >
 661+ E0AF             >len_NFA         defl    $ - temp_NFA
 661+ E0AF             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 661+ E0AA             >
 661+ E0AA 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 661+ E0AB 28 4D 41 50 >                db      "(MAP)"               // name string in 7-bit ascii, but
 661+ E0AF 29          >
 661+ E0B0             >                org     $-1                 // alter last byte of Name just above to set
 661+ E0AF A9          >                db      {b $} | END_BIT     // msb as name end
 661+ E0B0             >
 661+ E0B0 9E 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 661+ E0B2             >Prev_Ptr        defl    Heap_Ptr
 661+ E0B2             >
 661+ E0B2             >mirror_Ptr      defl    $
 661+ E0B2             >
 661+ E0B2 99 9D       >                dw      Dict_Ptr + 2        // xt
 661+ E0B4             >Heap_Ptr        defl    $ - $E000           // save current HP
 661+ E0B4             >
 661+ E0B4             >Current_HP      defl  $ - $E000             // used to set HP once!
 661+ E0B4             >
 661+ E0B4             >//              ______________________________________________________________________
 661+ E0B4             >//              Dictionary part
 661+ E0B4             >
 661+ E0B4             >                org     Dict_Ptr
 661+ 9D97             >
 661+ 9D97 B2 20       >                dw      mirror_Ptr - $E000 + Heap_offset
 661+ 9D99             >
 661+ 9D99             >C_MAP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 661+ 9D99 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 661+ 9D99 ~           >
 661+ 9D99 ~           >
 661+ 9D99             >                endif           ; ok        // for other definitions it "points" the correct handler
 661+ 9D99             >                // Use of "; ok" to suppress "warning[fwdref]"
 661+ 9D99             >
 661+ 9D99             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 662+ 9D99 D9                           exx
 663+ 9D9A E1                           pop     hl
 664+ 9D9B 7D                           ld      a, l
 665+ 9D9C C1                           pop     bc
 666+ 9D9D E1                           pop     hl
 667+ 9D9E 50                           ld      d, b
 668+ 9D9F 59                           ld      e, c
 669+ 9DA0 ED B1                        cpir
 670+ 9DA2 E1                           pop     hl
 671+ 9DA3 20 05                        jr      nz, C_Map_Then
 671+ 9DA5
 672+ 9DA5 19                               add     hl, de
 673+ 9DA6 2B                               dec     hl
 674+ 9DA7 ED 42                            sbc     hl, bc
 675+ 9DA9 7E                               ld      a, (hl)
 676+ 9DAA              C_Map_Then:
 677+ 9DAA 6F                           ld      l, a
 678+ 9DAB 26 00                        ld      h, 0
 679+ 9DAD E5                           push    hl
 680+ 9DAE D9                           exx
 681+ 9DAF                              next
 681+ 9DAF DD E9       >                jp      (ix)
 682+ 9DB1
 683+ 9DB1              //  ______________________________________________________________________
 684+ 9DB1              //
 685+ 9DB1              // (compare)    a1 a2 n -- b
 686+ 9DB1              // this word performs a lexicographic compare of n bytes of text at address a1
 687+ 9DB1              // with n bytes of text at address a2. It returns numeric a value:
 688+ 9DB1              //  0 : if strings are equal
 689+ 9DB1              // +1 : if string at a1 greater than string at a2
 690+ 9DB1              // -1 : if string at a1 less than string at a2
 691+ 9DB1              // strings can be 256 bytes in length at most.
 692+ 9DB1                              New_Def C_COMPARE, "(COMPARE)", is_code, is_normal
 692+ 9DB1             >
 692+ 9DB1             >Dict_Ptr        defl    $
 692+ 9DB1             >
 692+ 9DB1             >//              ______________________________________________________________________
 692+ 9DB1             >//              Heap part
 692+ 9DB1             >
 692+ 9DB1             >
 692+ 9DB1             >                org     (Heap_Ptr & $1FFF) + $E000
 692+ E0B4             >
 692+ E0B4             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 692+ E0B4             >Latest_Definition defl  Heap_Ptr
 692+ E0B4             >
 692+ E0B4             >                // dummy db directives used to calculate length of namec
 692+ E0B4 28 43 4F 4D >                db      "(COMPARE)"
 692+ E0B8 50 41 52 45 >
 692+ E0BC 29          >
 692+ E0BD             >len_NFA         defl    $ - temp_NFA
 692+ E0BD             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 692+ E0B4             >
 692+ E0B4 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 692+ E0B5 28 43 4F 4D >                db      "(COMPARE)"               // name string in 7-bit ascii, but
 692+ E0B9 50 41 52 45 >
 692+ E0BD 29          >
 692+ E0BE             >                org     $-1                 // alter last byte of Name just above to set
 692+ E0BD A9          >                db      {b $} | END_BIT     // msb as name end
 692+ E0BE             >
 692+ E0BE AA 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 692+ E0C0             >Prev_Ptr        defl    Heap_Ptr
 692+ E0C0             >
 692+ E0C0             >mirror_Ptr      defl    $
 692+ E0C0             >
 692+ E0C0 B3 9D       >                dw      Dict_Ptr + 2        // xt
 692+ E0C2             >Heap_Ptr        defl    $ - $E000           // save current HP
 692+ E0C2             >
 692+ E0C2             >Current_HP      defl  $ - $E000             // used to set HP once!
 692+ E0C2             >
 692+ E0C2             >//              ______________________________________________________________________
 692+ E0C2             >//              Dictionary part
 692+ E0C2             >
 692+ E0C2             >                org     Dict_Ptr
 692+ 9DB1             >
 692+ 9DB1 C0 20       >                dw      mirror_Ptr - $E000 + Heap_offset
 692+ 9DB3             >
 692+ 9DB3             >C_COMPARE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 692+ 9DB3 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 692+ 9DB3 ~           >
 692+ 9DB3 ~           >
 692+ 9DB3             >                endif           ; ok        // for other definitions it "points" the correct handler
 692+ 9DB3             >                // Use of "; ok" to suppress "warning[fwdref]"
 692+ 9DB3             >
 692+ 9DB3             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 693+ 9DB3 D9                           exx
 694+ 9DB4 E1                           pop     hl                  // Number of bytes
 695+ 9DB5 7D                           ld      a, l
 696+ 9DB6 E1                           pop     hl                  // hl points string a2
 697+ 9DB7 D1                           pop     de                  // hl points string a1
 698+ 9DB8              //              push    bc                  // Instruction pointer on stack
 699+ 9DB8 47                           ld      b, a
 700+ 9DB9              C_Compare_Loop:
 701+ 9DB9 7E                               ld      a, (hl)
 702+ 9DBA CD B6 9C                         call    Case_Sensitive
 703+ 9DBD 4F                               ld      c, a
 704+ 9DBE 1A                               ld      a, (de)
 705+ 9DBF CD B6 9C                         call    Case_Sensitive
 706+ 9DC2 B9                               cp      c
 707+ 9DC3 13                               inc     de
 708+ 9DC4 23                               inc     hl
 709+ 9DC5 28 0E                            jr      z, C_Compare_Equal
 710+ 9DC7 38 05                                jr      c, C_Compare_NotLessThan  // If LessThan
 711+ 9DC9 21 01 00                                 ld      hl, 1               // a1 gt a2
 712+ 9DCC 18 03                                jr      C_Compare_Then      // Else
 713+ 9DCE              C_Compare_NotLessThan:
 714+ 9DCE 21 FF FF                                 ld      hl, -1              // a1 lt a2
 715+ 9DD1              C_Compare_Then:                                 // Endif
 716+ 9DD1              //                      pop     bc              // restore Instruction Pointer
 717+ 9DD1 E5                                   push    hl
 718+ 9DD2 D9                                   exx
 719+ 9DD3
 720+ 9DD3                                      next
 720+ 9DD3 DD E9       >                jp      (ix)
 721+ 9DD5
 722+ 9DD5              C_Compare_Equal:
 723+ 9DD5 10 E2                        djnz    C_Compare_Loop
 724+ 9DD7 21 00 00                     ld      hl, 0               // a1 eq a2
 725+ 9DDA              //              pop     bc                  // restore Instruction Pointer
 726+ 9DDA E5                           push    hl
 727+ 9DDB D9                           exx
 728+ 9DDC
 729+ 9DDC                              next
 729+ 9DDC DD E9       >                jp      (ix)
 730+ 9DDE
 731+ 9DDE              //  ______________________________________________________________________
 732+ 9DDE              //
 733+ 9DDE              // emitc        c --
 734+ 9DDE              // low level emit, calls ROM routine at #10 to send a character to
 735+ 9DDE              // the the current channel (see SELECT to change stream-channel)
 736+ 9DDE                              New_Def EMITC, "EMITC", is_code, is_normal
 736+ 9DDE             >
 736+ 9DDE             >Dict_Ptr        defl    $
 736+ 9DDE             >
 736+ 9DDE             >//              ______________________________________________________________________
 736+ 9DDE             >//              Heap part
 736+ 9DDE             >
 736+ 9DDE             >
 736+ 9DDE             >                org     (Heap_Ptr & $1FFF) + $E000
 736+ E0C2             >
 736+ E0C2             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 736+ E0C2             >Latest_Definition defl  Heap_Ptr
 736+ E0C2             >
 736+ E0C2             >                // dummy db directives used to calculate length of namec
 736+ E0C2 45 4D 49 54 >                db      "EMITC"
 736+ E0C6 43          >
 736+ E0C7             >len_NFA         defl    $ - temp_NFA
 736+ E0C7             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 736+ E0C2             >
 736+ E0C2 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 736+ E0C3 45 4D 49 54 >                db      "EMITC"               // name string in 7-bit ascii, but
 736+ E0C7 43          >
 736+ E0C8             >                org     $-1                 // alter last byte of Name just above to set
 736+ E0C7 C3          >                db      {b $} | END_BIT     // msb as name end
 736+ E0C8             >
 736+ E0C8 B4 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 736+ E0CA             >Prev_Ptr        defl    Heap_Ptr
 736+ E0CA             >
 736+ E0CA             >mirror_Ptr      defl    $
 736+ E0CA             >
 736+ E0CA E0 9D       >                dw      Dict_Ptr + 2        // xt
 736+ E0CC             >Heap_Ptr        defl    $ - $E000           // save current HP
 736+ E0CC             >
 736+ E0CC             >Current_HP      defl  $ - $E000             // used to set HP once!
 736+ E0CC             >
 736+ E0CC             >//              ______________________________________________________________________
 736+ E0CC             >//              Dictionary part
 736+ E0CC             >
 736+ E0CC             >                org     Dict_Ptr
 736+ 9DDE             >
 736+ 9DDE CA 20       >                dw      mirror_Ptr - $E000 + Heap_offset
 736+ 9DE0             >
 736+ 9DE0             >EMITC:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 736+ 9DE0 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 736+ 9DE0 ~           >
 736+ 9DE0 ~           >
 736+ 9DE0             >                endif           ; ok        // for other definitions it "points" the correct handler
 736+ 9DE0             >                // Use of "; ok" to suppress "warning[fwdref]"
 736+ 9DE0             >
 736+ 9DE0             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 737+ 9DE0 E1                           pop     hl
 738+ 9DE1 7D                           ld      a, l
 739+ 9DE2              Emitc_Ptr:
 740+ 9DE2 C5                           push    bc
 741+ 9DE3 D5                           push    de
 742+ 9DE4 DD E5                        push    ix
 743+ 9DE6 D7                           rst     $10
 744+ 9DE7 DD E1                        pop     ix
 745+ 9DE9 D1                           pop     de
 746+ 9DEA C1                           pop     bc
 747+ 9DEB 3E FF                        ld      a, 255            // max possible
 748+ 9DED 32 8C 5C                     ld      (SCR_CT), a
 749+ 9DF0                              next
 749+ 9DF0 DD E9       >                jp      (ix)
 750+ 9DF2
 751+ 9DF2              //  ______________________________________________________________________
 752+ 9DF2              //
 753+ 9DF2              // cr           --
 754+ 9DF2              // send a CR via EMITC
 755+ 9DF2                              New_Def CR, "CR", is_code, is_normal
 755+ 9DF2             >
 755+ 9DF2             >Dict_Ptr        defl    $
 755+ 9DF2             >
 755+ 9DF2             >//              ______________________________________________________________________
 755+ 9DF2             >//              Heap part
 755+ 9DF2             >
 755+ 9DF2             >
 755+ 9DF2             >                org     (Heap_Ptr & $1FFF) + $E000
 755+ E0CC             >
 755+ E0CC             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 755+ E0CC             >Latest_Definition defl  Heap_Ptr
 755+ E0CC             >
 755+ E0CC             >                // dummy db directives used to calculate length of namec
 755+ E0CC 43 52       >                db      "CR"
 755+ E0CE             >len_NFA         defl    $ - temp_NFA
 755+ E0CE             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 755+ E0CC             >
 755+ E0CC 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 755+ E0CD 43 52       >                db      "CR"               // name string in 7-bit ascii, but
 755+ E0CF             >                org     $-1                 // alter last byte of Name just above to set
 755+ E0CE D2          >                db      {b $} | END_BIT     // msb as name end
 755+ E0CF             >
 755+ E0CF C2 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 755+ E0D1             >Prev_Ptr        defl    Heap_Ptr
 755+ E0D1             >
 755+ E0D1             >mirror_Ptr      defl    $
 755+ E0D1             >
 755+ E0D1 F4 9D       >                dw      Dict_Ptr + 2        // xt
 755+ E0D3             >Heap_Ptr        defl    $ - $E000           // save current HP
 755+ E0D3             >
 755+ E0D3             >Current_HP      defl  $ - $E000             // used to set HP once!
 755+ E0D3             >
 755+ E0D3             >//              ______________________________________________________________________
 755+ E0D3             >//              Dictionary part
 755+ E0D3             >
 755+ E0D3             >                org     Dict_Ptr
 755+ 9DF2             >
 755+ 9DF2 D1 20       >                dw      mirror_Ptr - $E000 + Heap_offset
 755+ 9DF4             >
 755+ 9DF4             >CR:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 755+ 9DF4 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 755+ 9DF4 ~           >
 755+ 9DF4 ~           >
 755+ 9DF4             >                endif           ; ok        // for other definitions it "points" the correct handler
 755+ 9DF4             >                // Use of "; ok" to suppress "warning[fwdref]"
 755+ 9DF4             >
 755+ 9DF4             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 756+ 9DF4
 757+ 9DF4 3E 0D                        ld      a, CR_CHAR
 758+ 9DF6 18 EA                        jr      Emitc_Ptr
 759+ 9DF8
 760+ 9DF8              Emitc_Vec:
 761+ 9DF8 31 9E                        dw      C_Emit_Printable  // comma
 762+ 9DFA 38 9E                        dw      C_Emit_Bel        // bel
 763+ 9DFC 31 9E                        dw      C_Emit_Printable  // bs
 764+ 9DFE 50 9E                        dw      C_Emit_Tab        // tab
 765+ 9E00 31 9E                        dw      C_Emit_Printable  // cr
 766+ 9E02 57 9E                        dw      C_Emit_NL         // lf (unix newline)
 767+ 9E04 31 9E                        dw      C_Emit_Printable  // blank
 768+ 9E06 31 9E                        dw      C_Emit_Printable  // blank
 769+ 9E08
 770+ 9E08              Emit_Selector_Start:
 771+ 9E08 06                           db      $06                 // comma
 772+ 9E09 07                           db      $07                 // bel
 773+ 9E0A 08                           db      $08                 // bs
 774+ 9E0B 09                           db      $09                 // tab
 775+ 9E0C 0D                           db      $0D                 // cr
 776+ 9E0D 0A                           db      $0A                 // lf (unix newline)
 777+ 9E0E 20                           db      $20
 778+ 9E0F              Emit_Selector_End:
 779+ 9E0F 20                           db      $20
 780+ 9E10
 781+ 9E10              //  ______________________________________________________________________
 782+ 9E10              //
 783+ 9E10              // (?emit)      c1 -- c2 | c1
 784+ 9E10              // decode a character to be sent via EMIT
 785+ 9E10              // search first the Emit_Selector table, if found jump to the corresponding routine in Emit_Vector
 786+ 9E10              // the routine should resolve anything and convert the character anyway.
 787+ 9E10                              New_Def C_EMIT, "(?EMIT)", is_code, is_normal
 787+ 9E10             >
 787+ 9E10             >Dict_Ptr        defl    $
 787+ 9E10             >
 787+ 9E10             >//              ______________________________________________________________________
 787+ 9E10             >//              Heap part
 787+ 9E10             >
 787+ 9E10             >
 787+ 9E10             >                org     (Heap_Ptr & $1FFF) + $E000
 787+ E0D3             >
 787+ E0D3             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 787+ E0D3             >Latest_Definition defl  Heap_Ptr
 787+ E0D3             >
 787+ E0D3             >                // dummy db directives used to calculate length of namec
 787+ E0D3 28 3F 45 4D >                db      "(?EMIT)"
 787+ E0D7 49 54 29    >
 787+ E0DA             >len_NFA         defl    $ - temp_NFA
 787+ E0DA             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 787+ E0D3             >
 787+ E0D3 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 787+ E0D4 28 3F 45 4D >                db      "(?EMIT)"               // name string in 7-bit ascii, but
 787+ E0D8 49 54 29    >
 787+ E0DB             >                org     $-1                 // alter last byte of Name just above to set
 787+ E0DA A9          >                db      {b $} | END_BIT     // msb as name end
 787+ E0DB             >
 787+ E0DB CC 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 787+ E0DD             >Prev_Ptr        defl    Heap_Ptr
 787+ E0DD             >
 787+ E0DD             >mirror_Ptr      defl    $
 787+ E0DD             >
 787+ E0DD 12 9E       >                dw      Dict_Ptr + 2        // xt
 787+ E0DF             >Heap_Ptr        defl    $ - $E000           // save current HP
 787+ E0DF             >
 787+ E0DF             >Current_HP      defl  $ - $E000             // used to set HP once!
 787+ E0DF             >
 787+ E0DF             >//              ______________________________________________________________________
 787+ E0DF             >//              Dictionary part
 787+ E0DF             >
 787+ E0DF             >                org     Dict_Ptr
 787+ 9E10             >
 787+ 9E10 DD 20       >                dw      mirror_Ptr - $E000 + Heap_offset
 787+ 9E12             >
 787+ 9E12             >C_EMIT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 787+ 9E12 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 787+ 9E12 ~           >
 787+ 9E12 ~           >
 787+ 9E12             >                endif           ; ok        // for other definitions it "points" the correct handler
 787+ 9E12             >                // Use of "; ok" to suppress "warning[fwdref]"
 787+ 9E12             >
 787+ 9E12             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 788+ 9E12 D9                           exx
 789+ 9E13 D1                           pop     de
 790+ 9E14 7B                           ld      a, e                //  de has c1
 791+ 9E15 E6 7F                        and     $7F                 // 7-bit ascii only
 792+ 9E17                              // push    bc                  // save Instruction Pointer
 793+ 9E17 01 08 00                     ld      bc, Emit_Selector_End - Emit_Selector_Start + 1
 794+ 9E1A 21 0F 9E                     ld      hl, Emit_Selector_End
 795+ 9E1D ED B9                        cpdr                        // search for c1 in Emit_Selector table, backward
 796+ 9E1F 20 0A                        jr      nz, C_Emit_Not_Found
 797+ 9E21                                  // Found then decode it
 798+ 9E21 21 F8 9D                         ld      hl, Emitc_Vec
 799+ 9E24 09                               add     hl, bc
 800+ 9E25 09                               add     hl, bc
 801+ 9E26 5E                               ld      e, (hl)
 802+ 9E27 23                               inc     hl
 803+ 9E28 56                               ld      d, (hl)
 804+ 9E29 EB                               ex      de, hl
 805+ 9E2A                                  // pop     bc                  // restore Instruction Pointer
 806+ 9E2A E9                               jp      (hl)                // one of the following labels
 807+ 9E2B              C_Emit_Not_Found:
 808+ 9E2B                              // pop     bc                  // restore Instruction Pointer
 809+ 9E2B FE 20                        cp      BLANK_CHAR          // cp $20 non-printable check
 810+ 9E2D 30 02                        jr      nc, C_Emit_Printable
 811+ 9E2F 3E 00                            ld      a, NUL_CHAR         // NUL is never "printed"
 812+ 9E31              C_Emit_Printable:
 813+ 9E31 6F                           ld      l, a
 814+ 9E32 26 00                        ld      h, 0
 815+ 9E34 E5                           push    hl
 816+ 9E35 D9                           exx
 817+ 9E36                              next
 817+ 9E36 DD E9       >                jp      (ix)
 818+ 9E38
 819+ 9E38              C_Emit_Bel:
 820+ 9E38 D9                            exx
 821+ 9E39 C5                           push    bc                  // save Instruction Pointer
 822+ 9E3A D5                           push    de
 823+ 9E3B 11 00 01                     ld      de, $0100
 824+ 9E3E 21 00 02                     ld      hl, $0200
 825+ 9E41 DD E5                        push    ix                  // save Next Pointer
 826+ 9E43 CD B6 03                     call    $03B6               // bleep Standard-ROM routine
 827+ 9E46 DD E1                        pop     ix                  // restore Next Pointer
 828+ 9E48 D1                           pop     de
 829+ 9E49 C1                           pop     bc                  // restore Instruction Pointer
 830+ 9E4A 21 00 00                     ld      hl, NUL_CHAR
 831+ 9E4D E5                           push    hl
 832+ 9E4E                              next
 832+ 9E4E DD E9       >                jp      (ix)
 833+ 9E50
 834+ 9E50 21 06 00     C_Emit_Tab:     ld      hl, COMMA_CHAR
 835+ 9E53 E5                           push    hl
 836+ 9E54 D9                           exx
 837+ 9E55                              next
 837+ 9E55 DD E9       >                jp      (ix)
 838+ 9E57
 839+ 9E57 21 0D 00     C_Emit_NL       ld      hl, CR_CHAR           // 0x0A --> 0x0D  à la Spectrum
 840+ 9E5A E5                           push    hl
 841+ 9E5B D9                           exx
 842+ 9E5C                              next
 842+ 9E5C DD E9       >                jp      (ix)
 843+ 9E5E
 844+ 9E5E              //  ______________________________________________________________________
 845+ 9E5E
 846+ 9E5E              Key_Table:
 847+ 9E5E E2                           db      $E2                 //  0: STOP  --> SYMBOL+A : ~
 848+ 9E5F C3                           db      $C3                 //  1: NOT   --> SYMBOL+S : |
 849+ 9E60 CD                           db      $CD                 //  2: STEP  --> SYMBOl+D : //
 850+ 9E61 CC                           db      $CC                 //  3: TO    --> SYMBOL+F : {
 851+ 9E62 CB                           db      $CB                 //  4: THEN  --> SYMBOL+G : }
 852+ 9E63 C6                           db      $C6                 //  5: AND   --> SYMBOL+Y : [
 853+ 9E64 C5                           db      $C5                 //  6: OR    --> SYMBOL+U : ]
 854+ 9E65 AC                           db      $AC                 //  7: AT    --> SYMBOL+I : (C) copyright symbol
 855+ 9E66 C7                           db      $C7                 //  8: <=    --> same as SHIFT-1 [EDIT]
 856+ 9E67 C8                           db      $C8                 //  9: >=    --> same as SHIFT-0 [BACKSPACE]
 857+ 9E68 C9                           db      $C9                 // 10: <>    --> SYMBOL+W is the same as CAPS (toggle) SHIFT+2
 858+ 9E69              Key_MapTo:
 859+ 9E69 06                           db      $06                 // 10: SYMBOL+W is the same as CAPS (toggle) SHIFT+2
 860+ 9E6A 0C                           db      $0C                 //  9: same as SHIFT-0 [BACKSPACE]
 861+ 9E6B 07                           db      $07                 //  8: same as SHIFT-1 [EDIT]
 862+ 9E6C 7F                           db      $7F                 //  7: SYMBOL+I : (C) copyright symbol
 863+ 9E6D 5D                           db      $5D                 //  6: SYMBOL+U : ]
 864+ 9E6E 5B                           db      $5B                 //  5: SYMBOL+Y : [
 865+ 9E6F 7D                           db      $7D                 //  4: SYMBOL+G : }
 866+ 9E70 7B                           db      $7B                 //  3: SYMBOL+F : {
 867+ 9E71 5C                           db      $5C                 //  2: SYMBOl+D : //
 868+ 9E72 7C                           db      $7C                 //  1: SYMBOL+S : |
 869+ 9E73 7E                           db      $7E                 //  0: SYMBOL+A : ~
 870+ 9E74
 871+ 9E74              //  ______________________________________________________________________
 872+ 9E74              //
 873+ 9E74              // curs         -- c
 874+ 9E74              // wait for a keypress
 875+ 9E74              // This definition need Standard ROM Interrupt to be served
 876+ 9E74
 877+ 9E74                              New_Def CUR, "CURS", is_code, is_normal
 877+ 9E74             >
 877+ 9E74             >Dict_Ptr        defl    $
 877+ 9E74             >
 877+ 9E74             >//              ______________________________________________________________________
 877+ 9E74             >//              Heap part
 877+ 9E74             >
 877+ 9E74             >
 877+ 9E74             >                org     (Heap_Ptr & $1FFF) + $E000
 877+ E0DF             >
 877+ E0DF             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 877+ E0DF             >Latest_Definition defl  Heap_Ptr
 877+ E0DF             >
 877+ E0DF             >                // dummy db directives used to calculate length of namec
 877+ E0DF 43 55 52 53 >                db      "CURS"
 877+ E0E3             >len_NFA         defl    $ - temp_NFA
 877+ E0E3             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 877+ E0DF             >
 877+ E0DF 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 877+ E0E0 43 55 52 53 >                db      "CURS"               // name string in 7-bit ascii, but
 877+ E0E4             >                org     $-1                 // alter last byte of Name just above to set
 877+ E0E3 D3          >                db      {b $} | END_BIT     // msb as name end
 877+ E0E4             >
 877+ E0E4 D3 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 877+ E0E6             >Prev_Ptr        defl    Heap_Ptr
 877+ E0E6             >
 877+ E0E6             >mirror_Ptr      defl    $
 877+ E0E6             >
 877+ E0E6 76 9E       >                dw      Dict_Ptr + 2        // xt
 877+ E0E8             >Heap_Ptr        defl    $ - $E000           // save current HP
 877+ E0E8             >
 877+ E0E8             >Current_HP      defl  $ - $E000             // used to set HP once!
 877+ E0E8             >
 877+ E0E8             >//              ______________________________________________________________________
 877+ E0E8             >//              Dictionary part
 877+ E0E8             >
 877+ E0E8             >                org     Dict_Ptr
 877+ 9E74             >
 877+ 9E74 E6 20       >                dw      mirror_Ptr - $E000 + Heap_offset
 877+ 9E76             >
 877+ 9E76             >CUR:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 877+ 9E76 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 877+ 9E76 ~           >
 877+ 9E76 ~           >
 877+ 9E76             >                endif           ; ok        // for other definitions it "points" the correct handler
 877+ 9E76             >                // Use of "; ok" to suppress "warning[fwdref]"
 877+ 9E76             >
 877+ 9E76             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 878+ 9E76
 879+ 9E76 C5                           push    bc                  // save Instruction Pointer
 880+ 9E77 D5                           push    de                  // save Return Stack Pointer
 881+ 9E78 DD E5                        push    ix
 882+ 9E7A ED 73 D0 9B                  ld      (SP_Saved), sp      // be sure to not to be paged out.
 883+ 9E7E 31 9F 9B                     ld      sp, Cold_origin - 5 // maybe $8000 in the future...
 884+ 9E81 FD CB 01 AE                  res     5, (iy + 1)         // FLAGS (5C3A+1)
 885+ 9E85
 886+ 9E85              Cur_Wait:
 887+ 9E85 76                               halt
 888+ 9E86 3E 02                            ld      a, 2                // selec channel #2 (Upper Video)
 889+ 9E88 CD 01 16                         call    $1601               // SELECT Standard-ROM Routine
 890+ 9E8B
 891+ 9E8B                                  // software-flash: flips face every 320 ms
 892+ 9E8B 3E 20                            ld      a, $20              // Timing based
 893+ 9E8D FD A6 3E                         and     (iy + $3E)          // FRAMES (5C3A+3E)
 894+ 9E90
 895+ 9E90 3A CC 9B                         ld      a, (Block_Face)     // see origin.asm
 896+ 9E93 20 0C                            jr      nz, Cur_Cursor
 897+ 9E95 3A CD 9B                             ld      a, (Half_Face)      // see origin.asm
 898+ 9E98 FD CB 30 5E                          bit     3, (iy + $30)       // FLAGS2 (5C3A+$30) that is CAPS-LOCK
 899+ 9E9C 28 03                                jr      z, Cur_Cursor
 900+ 9E9E 3A CE 9B                                 ld      a, (Underscore_Face) // see origin
 901+ 9EA1              Cur_Cursor:
 902+ 9EA1 D7                               rst     $10
 903+ 9EA2 3E 08                            ld      a, BACKSPACE_CHAR    // backspace
 904+ 9EA4 D7                               rst     $10
 905+ 9EA5
 906+ 9EA5 FD CB 01 6E                      bit     5, (iy + 1)         // FLAGS (5C3A+1)
 907+ 9EA9 28 DA                        jr      z, Cur_Wait
 908+ 9EAB
 909+ 9EAB 76                           halt    // this is to sync flashing cursor.
 910+ 9EAC
 911+ 9EAC 3E 20                        ld      a, BLANK_CHAR       // space to blank cursor
 912+ 9EAE D7                           rst     $10
 913+ 9EAF 3E 08                        ld      a, BACKSPACE_CHAR   // backspace
 914+ 9EB1 D7                           rst     $10
 915+ 9EB2
 916+ 9EB2 ED 7B D0 9B                  ld      sp, (SP_Saved)
 917+ 9EB6
 918+ 9EB6 DD E1                        pop     ix
 919+ 9EB8 D1                           pop     de                  // Restore Return Stack Pointer
 920+ 9EB9 C1                           pop     bc                  // Restore Instruction Pointer
 921+ 9EBA                              next
 921+ 9EBA DD E9       >                jp      (ix)
 922+ 9EBC
 923+ 9EBC
 924+ 9EBC              //  ______________________________________________________________________
 925+ 9EBC              //
 926+ 9EBC              // key          -- c
 927+ 9EBC              // This definition need Standard ROM Interrupt to be served
 928+ 9EBC
 929+ 9EBC                              New_Def KEY, "KEY", is_code, is_normal
 929+ 9EBC             >
 929+ 9EBC             >Dict_Ptr        defl    $
 929+ 9EBC             >
 929+ 9EBC             >//              ______________________________________________________________________
 929+ 9EBC             >//              Heap part
 929+ 9EBC             >
 929+ 9EBC             >
 929+ 9EBC             >                org     (Heap_Ptr & $1FFF) + $E000
 929+ E0E8             >
 929+ E0E8             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 929+ E0E8             >Latest_Definition defl  Heap_Ptr
 929+ E0E8             >
 929+ E0E8             >                // dummy db directives used to calculate length of namec
 929+ E0E8 4B 45 59    >                db      "KEY"
 929+ E0EB             >len_NFA         defl    $ - temp_NFA
 929+ E0EB             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 929+ E0E8             >
 929+ E0E8 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 929+ E0E9 4B 45 59    >                db      "KEY"               // name string in 7-bit ascii, but
 929+ E0EC             >                org     $-1                 // alter last byte of Name just above to set
 929+ E0EB D9          >                db      {b $} | END_BIT     // msb as name end
 929+ E0EC             >
 929+ E0EC DF 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 929+ E0EE             >Prev_Ptr        defl    Heap_Ptr
 929+ E0EE             >
 929+ E0EE             >mirror_Ptr      defl    $
 929+ E0EE             >
 929+ E0EE BE 9E       >                dw      Dict_Ptr + 2        // xt
 929+ E0F0             >Heap_Ptr        defl    $ - $E000           // save current HP
 929+ E0F0             >
 929+ E0F0             >Current_HP      defl  $ - $E000             // used to set HP once!
 929+ E0F0             >
 929+ E0F0             >//              ______________________________________________________________________
 929+ E0F0             >//              Dictionary part
 929+ E0F0             >
 929+ E0F0             >                org     Dict_Ptr
 929+ 9EBC             >
 929+ 9EBC EE 20       >                dw      mirror_Ptr - $E000 + Heap_offset
 929+ 9EBE             >
 929+ 9EBE             >KEY:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 929+ 9EBE ~           >                call    runcode ; ok        // for primitive definitions  actual code
 929+ 9EBE ~           >
 929+ 9EBE ~           >
 929+ 9EBE             >                endif           ; ok        // for other definitions it "points" the correct handler
 929+ 9EBE             >                // Use of "; ok" to suppress "warning[fwdref]"
 929+ 9EBE             >
 929+ 9EBE             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 930+ 9EBE
 931+ 9EBE C5                           push    bc                  // Save Instruction Pointer
 932+ 9EBF
 933+ 9EBF              Key_Wait:
 934+ 9EBF FD CB 01 6E                      bit     5, (iy + 1)         // FLAGS (5C3A+1)
 935+ 9EC3 28 FA                        jr      z, Key_Wait
 936+ 9EC5
 937+ 9EC5 3A 08 5C                     ld      a, (LASTK)          // get typed character (5C08)
 938+ 9EC8
 939+ 9EC8                              // decode character from above table
 940+ 9EC8 21 5E 9E                     ld      hl, Key_Table
 941+ 9ECB 01 0B 00                     ld      bc, $000B
 942+ 9ECE ED B1                        cpir
 943+ 9ED0 20 05                        jr      nz, Key_DontMap
 944+ 9ED2 21 69 9E                         ld      hl, Key_MapTo
 945+ 9ED5 09                               add     hl, bc
 946+ 9ED6 7E                               ld      a, (hl)
 947+ 9ED7 FE 06        Key_DontMap:    cp      $06                 // CAPS-LOCK management
 948+ 9ED9 20 09                        jr      nz, Key_NoCapsLock
 949+ 9EDB 21 6A 5C                         ld      hl, $5C6A           // FLAGS2
 950+ 9EDE 7E                               ld      a, (hl)
 951+ 9EDF EE 08                            xor     $08
 952+ 9EE1 77                               ld      (hl), a
 953+ 9EE2 3E 00                            ld      a, NUL_CHAR
 954+ 9EE4 6F           Key_NoCapsLock: ld      l, a
 955+ 9EE5 26 00                        ld      h, 0                // Prepare TOS
 956+ 9EE7
 957+ 9EE7 FD CB 01 AE                  res     5, (iy + 1)         // FLAGS (5C3A+1)
 958+ 9EEB
 959+ 9EEB C1                           pop     bc                  // Restore Instruction Pointer
 960+ 9EEC
 961+ 9EEC                              psh1
 961+ 9EEC E5          >                push    hl
 961+ 9EED DD E9       >                jp      (ix)
 962+ 9EEF
 963+ 9EEF
 964+ 9EEF              //  ______________________________________________________________________
 965+ 9EEF              //
 966+ 9EEF              // click        --
 967+ 9EEF              // This definition need Standard ROM Interrupt to be served
 968+ 9EEF              //
 969+ 9EEF              //              New_Def CLICK, "CLICK", is_code, is_normal
 970+ 9EEF              //
 971+ 9EEF              //                push    bc
 972+ 9EEF              //              ld      a, ($5C48)          // BORDCR system variable
 973+ 9EEF              //              rra
 974+ 9EEF              //              rra
 975+ 9EEF              //              rra
 976+ 9EEF              //              or      $18                 // quick'n'dirty click
 977+ 9EEF              //              out     ($fe), a
 978+ 9EEF              //              ld      b, 0
 979+ 9EEF              //              djnz    $                   // wait loop
 980+ 9EEF              //              xor     $18
 981+ 9EEF              //              out     ($fe), a
 982+ 9EEF              //                pop     bc
 983+ 9EEF
 984+ 9EEF              //              next
 985+ 9EEF
 986+ 9EEF              //  ______________________________________________________________________
 987+ 9EEF              //
 988+ 9EEF              // key?         -- f
 989+ 9EEF              // key available
 990+ 9EEF              //
 991+ 9EEF              //              New_Def KEY_Q, "KEY?", is_code, is_normal
 992+ 9EEF              //
 993+ 9EEF              //              ld      hl, 0000
 994+ 9EEF              //              bit     5, (iy + 1)         // FLAGS (5C3A+1)
 995+ 9EEF              //              jr      z, Key_Q
 996+ 9EEF              //                  dec     hl
 997+ 9EEF              // Key_Q:
 998+ 9EEF              //                psh1
 999+ 9EEF              //              next
1000+ 9EEF
1001+ 9EEF              //  ______________________________________________________________________
1002+ 9EEF              //
1003+ 9EEF              // ?terminal    -- FALSE | TRUE
1004+ 9EEF              // test for BREAK keypress
1005+ 9EEF                              New_Def QTERMINAL, "?TERMINAL", is_code, is_normal
1005+ 9EEF             >
1005+ 9EEF             >Dict_Ptr        defl    $
1005+ 9EEF             >
1005+ 9EEF             >//              ______________________________________________________________________
1005+ 9EEF             >//              Heap part
1005+ 9EEF             >
1005+ 9EEF             >
1005+ 9EEF             >                org     (Heap_Ptr & $1FFF) + $E000
1005+ E0F0             >
1005+ E0F0             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1005+ E0F0             >Latest_Definition defl  Heap_Ptr
1005+ E0F0             >
1005+ E0F0             >                // dummy db directives used to calculate length of namec
1005+ E0F0 3F 54 45 52 >                db      "?TERMINAL"
1005+ E0F4 4D 49 4E 41 >
1005+ E0F8 4C          >
1005+ E0F9             >len_NFA         defl    $ - temp_NFA
1005+ E0F9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1005+ E0F0             >
1005+ E0F0 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1005+ E0F1 3F 54 45 52 >                db      "?TERMINAL"               // name string in 7-bit ascii, but
1005+ E0F5 4D 49 4E 41 >
1005+ E0F9 4C          >
1005+ E0FA             >                org     $-1                 // alter last byte of Name just above to set
1005+ E0F9 CC          >                db      {b $} | END_BIT     // msb as name end
1005+ E0FA             >
1005+ E0FA E8 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1005+ E0FC             >Prev_Ptr        defl    Heap_Ptr
1005+ E0FC             >
1005+ E0FC             >mirror_Ptr      defl    $
1005+ E0FC             >
1005+ E0FC F1 9E       >                dw      Dict_Ptr + 2        // xt
1005+ E0FE             >Heap_Ptr        defl    $ - $E000           // save current HP
1005+ E0FE             >
1005+ E0FE             >Current_HP      defl  $ - $E000             // used to set HP once!
1005+ E0FE             >
1005+ E0FE             >//              ______________________________________________________________________
1005+ E0FE             >//              Dictionary part
1005+ E0FE             >
1005+ E0FE             >                org     Dict_Ptr
1005+ 9EEF             >
1005+ 9EEF FC 20       >                dw      mirror_Ptr - $E000 + Heap_offset
1005+ 9EF1             >
1005+ 9EF1             >QTERMINAL:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1005+ 9EF1 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1005+ 9EF1 ~           >
1005+ 9EF1 ~           >
1005+ 9EF1             >                endif           ; ok        // for other definitions it "points" the correct handler
1005+ 9EF1             >                // Use of "; ok" to suppress "warning[fwdref]"
1005+ 9EF1             >
1005+ 9EF1             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1006+ 9EF1 D9                           exx
1007+ 9EF2 01 FE 7F                     ld      bc, $7ffe
1008+ 9EF5 ED 50                        in      d, (c)
1009+ 9EF7 41                           ld      b, c
1010+ 9EF8 ED 78                        in      a, (c)
1011+ 9EFA B2                           or       d
1012+ 9EFB 1F                           rra
1013+ 9EFC 3F                           ccf
1014+ 9EFD ED 62                        sbc     hl, hl
1015+ 9EFF E5                           push    hl
1016+ 9F00 D9                           exx
1017+ 9F01                              next
1017+ 9F01 DD E9       >                jp      (ix)
1018+ 9F03
1019+ 9F03
1020+ 9F03              //  ______________________________________________________________________
1021+ 9F03              //
1022+ 9F03              // inkey        -- c | 0
1023+ 9F03              // call ROM inkey$ routine, returns c or "zero".
1024+ 9F03              //
1025+ 9F03              //              New_Def INKEY, "INKEY", is_code, is_normal
1026+ 9F03              //              push    bc
1027+ 9F03              //              push    de
1028+ 9F03              //              ld      (SP_Saved), sp
1029+ 9F03              //              ld      sp, Cold_origin - 5
1030+ 9F03              //              push    ix
1031+ 9F03              //              call    $15E6                   // instead of 15E9
1032+ 9F03              //              pop     ix
1033+ 9F03              //              ld      sp, (SP_Saved)
1034+ 9F03              //              ld      l, a
1035+ 9F03              //              ld      h, 0
1036+ 9F03              //              pop     de
1037+ 9F03              //              pop     bc
1038+ 9F03              //              psh1
1039+ 9F03
1040+ 9F03              //  ______________________________________________________________________
1041+ 9F03              //
1042+ 9F03              // select      n --
1043+ 9F03              // selects the given channel number
1044+ 9F03
1045+ 9F03                              New_Def SELECT, "SELECT", is_code, is_normal
1045+ 9F03             >
1045+ 9F03             >Dict_Ptr        defl    $
1045+ 9F03             >
1045+ 9F03             >//              ______________________________________________________________________
1045+ 9F03             >//              Heap part
1045+ 9F03             >
1045+ 9F03             >
1045+ 9F03             >                org     (Heap_Ptr & $1FFF) + $E000
1045+ E0FE             >
1045+ E0FE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1045+ E0FE             >Latest_Definition defl  Heap_Ptr
1045+ E0FE             >
1045+ E0FE             >                // dummy db directives used to calculate length of namec
1045+ E0FE 53 45 4C 45 >                db      "SELECT"
1045+ E102 43 54       >
1045+ E104             >len_NFA         defl    $ - temp_NFA
1045+ E104             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1045+ E0FE             >
1045+ E0FE 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1045+ E0FF 53 45 4C 45 >                db      "SELECT"               // name string in 7-bit ascii, but
1045+ E103 43 54       >
1045+ E105             >                org     $-1                 // alter last byte of Name just above to set
1045+ E104 D4          >                db      {b $} | END_BIT     // msb as name end
1045+ E105             >
1045+ E105 F0 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1045+ E107             >Prev_Ptr        defl    Heap_Ptr
1045+ E107             >
1045+ E107             >mirror_Ptr      defl    $
1045+ E107             >
1045+ E107 05 9F       >                dw      Dict_Ptr + 2        // xt
1045+ E109             >Heap_Ptr        defl    $ - $E000           // save current HP
1045+ E109             >
1045+ E109             >Current_HP      defl  $ - $E000             // used to set HP once!
1045+ E109             >
1045+ E109             >//              ______________________________________________________________________
1045+ E109             >//              Dictionary part
1045+ E109             >
1045+ E109             >                org     Dict_Ptr
1045+ 9F03             >
1045+ 9F03 07 21       >                dw      mirror_Ptr - $E000 + Heap_offset
1045+ 9F05             >
1045+ 9F05             >SELECT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1045+ 9F05 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1045+ 9F05 ~           >
1045+ 9F05 ~           >
1045+ 9F05             >                endif           ; ok        // for other definitions it "points" the correct handler
1045+ 9F05             >                // Use of "; ok" to suppress "warning[fwdref]"
1045+ 9F05             >
1045+ 9F05             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1046+ 9F05 E1                           pop     hl
1047+ 9F06 C5                           push    bc
1048+ 9F07 D5                           push    de
1049+ 9F08 7D                           ld      a, l
1050+ 9F09 ED 73 D0 9B                  ld      (SP_Saved), sp
1051+ 9F0D 31 9F 9B                     ld      sp, Cold_origin - 5
1052+ 9F10 DD E5                        push    ix
1053+ 9F12 CD 01 16                     call    $1601
1054+ 9F15 DD E1                        pop     ix
1055+ 9F17 ED 7B D0 9B                  ld      sp, (SP_Saved)
1056+ 9F1B D1                           pop     de
1057+ 9F1C C1                           pop     bc
1058+ 9F1D                              next
1058+ 9F1D DD E9       >                jp      (ix)
1059+ 9F1F
1060+ 9F1F              //  ______________________________________________________________________
1061+ 9F1F              //
1062+ 9F1F              // ZX Spectrum Next - Low Level disk primitives.
1063+ 9F1F              // this include is "here" for backward compatibility
1064+ 9F1F
1065+ 9F1F                              include "next-opt0.asm"
# file opened: C:\Zx\CSpect\Projects\vForth17_MMU7/source/next-opt0.asm
   1++9F1F              //  ______________________________________________________________________
   2++9F1F              //
   3++9F1F              //  next-opt.asm
   4++9F1F              //
   5++9F1F              //  ZX Spectrum Next - peculiar definitions
   6++9F1F              //  ______________________________________________________________________
   7++9F1F
   8++9F1F              //  ______________________________________________________________________
   9++9F1F              //
  10++9F1F              // f_seek       d u -- f
  11++9F1F              // Seek to position d in file-handle u.
  12++9F1F              // Return a false-flag 0 on success, True flag on error
  13++9F1F                              New_Def F_SEEK, "F_SEEK", is_code, is_normal
  13++9F1F             >
  13++9F1F             >Dict_Ptr        defl    $
  13++9F1F             >
  13++9F1F             >//              ______________________________________________________________________
  13++9F1F             >//              Heap part
  13++9F1F             >
  13++9F1F             >
  13++9F1F             >                org     (Heap_Ptr & $1FFF) + $E000
  13++E109             >
  13++E109             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  13++E109             >Latest_Definition defl  Heap_Ptr
  13++E109             >
  13++E109             >                // dummy db directives used to calculate length of namec
  13++E109 46 5F 53 45 >                db      "F_SEEK"
  13++E10D 45 4B       >
  13++E10F             >len_NFA         defl    $ - temp_NFA
  13++E10F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  13++E109             >
  13++E109 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  13++E10A 46 5F 53 45 >                db      "F_SEEK"               // name string in 7-bit ascii, but
  13++E10E 45 4B       >
  13++E110             >                org     $-1                 // alter last byte of Name just above to set
  13++E10F CB          >                db      {b $} | END_BIT     // msb as name end
  13++E110             >
  13++E110 FE 20       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
  13++E112             >Prev_Ptr        defl    Heap_Ptr
  13++E112             >
  13++E112             >mirror_Ptr      defl    $
  13++E112             >
  13++E112 21 9F       >                dw      Dict_Ptr + 2        // xt
  13++E114             >Heap_Ptr        defl    $ - $E000           // save current HP
  13++E114             >
  13++E114             >Current_HP      defl  $ - $E000             // used to set HP once!
  13++E114             >
  13++E114             >//              ______________________________________________________________________
  13++E114             >//              Dictionary part
  13++E114             >
  13++E114             >                org     Dict_Ptr
  13++9F1F             >
  13++9F1F 12 21       >                dw      mirror_Ptr - $E000 + Heap_offset
  13++9F21             >
  13++9F21             >F_SEEK:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
  13++9F21 ~           >                call    runcode ; ok        // for primitive definitions  actual code
  13++9F21 ~           >
  13++9F21 ~           >
  13++9F21             >                endif           ; ok        // for other definitions it "points" the correct handler
  13++9F21             >                // Use of "; ok" to suppress "warning[fwdref]"
  13++9F21             >
  13++9F21             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  14++9F21 D9                            exx
  15++9F22 E1                            pop     hl                  // file-handle
  16++9F23 7D                            ld      a, l
  17++9F24 C1                            pop     bc                  // bc has high-word of d
  18++9F25 D1                            pop     de
  19++9F26 D9                           exx
  20++9F27 DD E5                        push    ix
  21++9F29 D5                           push    de
  22++9F2A C5                           push    bc                  // save Instruction Pointer
  23++9F2B D9                            exx
  24++9F2C DD 21 00 00                   ld      ix, 0
  25++9F30 CF                            rst     $08
  26++9F31 9F                            db      $9F
  27++9F32              F_Seek_Exit:
  28++9F32 C1                           pop     bc                  // restore Instruction Pointer
  29++9F33 D1                           pop     de
  30++9F34 DD E1                        pop     ix
  31++9F36 ED 62                        sbc     hl, hl              // to get 0 or -1
  32++9F38
  33++9F38                              psh1
  33++9F38 E5          >                push    hl
  33++9F39 DD E9       >                jp      (ix)
  34++9F3B
  35++9F3B              //  ______________________________________________________________________
  36++9F3B              //
  37++9F3B              // f_close      u -- f
  38++9F3B              // Close file-handle u.
  39++9F3B              // Return 0 on success, True flag on error
  40++9F3B
  41++9F3B                              New_Def F_CLOSE, "F_CLOSE", is_code, is_normal
  41++9F3B             >
  41++9F3B             >Dict_Ptr        defl    $
  41++9F3B             >
  41++9F3B             >//              ______________________________________________________________________
  41++9F3B             >//              Heap part
  41++9F3B             >
  41++9F3B             >
  41++9F3B             >                org     (Heap_Ptr & $1FFF) + $E000
  41++E114             >
  41++E114             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  41++E114             >Latest_Definition defl  Heap_Ptr
  41++E114             >
  41++E114             >                // dummy db directives used to calculate length of namec
  41++E114 46 5F 43 4C >                db      "F_CLOSE"
  41++E118 4F 53 45    >
  41++E11B             >len_NFA         defl    $ - temp_NFA
  41++E11B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  41++E114             >
  41++E114 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  41++E115 46 5F 43 4C >                db      "F_CLOSE"               // name string in 7-bit ascii, but
  41++E119 4F 53 45    >
  41++E11C             >                org     $-1                 // alter last byte of Name just above to set
  41++E11B C5          >                db      {b $} | END_BIT     // msb as name end
  41++E11C             >
  41++E11C 09 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
  41++E11E             >Prev_Ptr        defl    Heap_Ptr
  41++E11E             >
  41++E11E             >mirror_Ptr      defl    $
  41++E11E             >
  41++E11E 3D 9F       >                dw      Dict_Ptr + 2        // xt
  41++E120             >Heap_Ptr        defl    $ - $E000           // save current HP
  41++E120             >
  41++E120             >Current_HP      defl  $ - $E000             // used to set HP once!
  41++E120             >
  41++E120             >//              ______________________________________________________________________
  41++E120             >//              Dictionary part
  41++E120             >
  41++E120             >                org     Dict_Ptr
  41++9F3B             >
  41++9F3B 1E 21       >                dw      mirror_Ptr - $E000 + Heap_offset
  41++9F3D             >
  41++9F3D             >F_CLOSE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
  41++9F3D ~           >                call    runcode ; ok        // for primitive definitions  actual code
  41++9F3D ~           >
  41++9F3D ~           >
  41++9F3D             >                endif           ; ok        // for other definitions it "points" the correct handler
  41++9F3D             >                // Use of "; ok" to suppress "warning[fwdref]"
  41++9F3D             >
  41++9F3D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  42++9F3D
  43++9F3D E1                           pop     hl
  44++9F3E 7D                           ld      a, l                // file-handle
  45++9F3F DD E5                        push    ix
  46++9F41 D5                           push    de
  47++9F42 C5                           push    bc                  // Save Instruction pointer
  48++9F43 CF                           rst     $08
  49++9F44 9B                           db      $9B
  50++9F45 18 EB                        jr      F_Seek_Exit
  51++9F47              //              pop     de
  52++9F47              //              pop     bc
  53++9F47              //              pop     ix
  54++9F47              //              sbc     hl, hl
  55++9F47              //              psh1
  56++9F47
  57++9F47              //  ______________________________________________________________________
  58++9F47              //
  59++9F47              // f_sync      u -- f
  60++9F47              // Close file-handle u.
  61++9F47              // Return 0 on success, True flag on error
  62++9F47
  63++9F47                              New_Def F_SYNC, "F_SYNC", is_code, is_normal
  63++9F47             >
  63++9F47             >Dict_Ptr        defl    $
  63++9F47             >
  63++9F47             >//              ______________________________________________________________________
  63++9F47             >//              Heap part
  63++9F47             >
  63++9F47             >
  63++9F47             >                org     (Heap_Ptr & $1FFF) + $E000
  63++E120             >
  63++E120             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  63++E120             >Latest_Definition defl  Heap_Ptr
  63++E120             >
  63++E120             >                // dummy db directives used to calculate length of namec
  63++E120 46 5F 53 59 >                db      "F_SYNC"
  63++E124 4E 43       >
  63++E126             >len_NFA         defl    $ - temp_NFA
  63++E126             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  63++E120             >
  63++E120 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  63++E121 46 5F 53 59 >                db      "F_SYNC"               // name string in 7-bit ascii, but
  63++E125 4E 43       >
  63++E127             >                org     $-1                 // alter last byte of Name just above to set
  63++E126 C3          >                db      {b $} | END_BIT     // msb as name end
  63++E127             >
  63++E127 14 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
  63++E129             >Prev_Ptr        defl    Heap_Ptr
  63++E129             >
  63++E129             >mirror_Ptr      defl    $
  63++E129             >
  63++E129 49 9F       >                dw      Dict_Ptr + 2        // xt
  63++E12B             >Heap_Ptr        defl    $ - $E000           // save current HP
  63++E12B             >
  63++E12B             >Current_HP      defl  $ - $E000             // used to set HP once!
  63++E12B             >
  63++E12B             >//              ______________________________________________________________________
  63++E12B             >//              Dictionary part
  63++E12B             >
  63++E12B             >                org     Dict_Ptr
  63++9F47             >
  63++9F47 29 21       >                dw      mirror_Ptr - $E000 + Heap_offset
  63++9F49             >
  63++9F49             >F_SYNC:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
  63++9F49 ~           >                call    runcode ; ok        // for primitive definitions  actual code
  63++9F49 ~           >
  63++9F49 ~           >
  63++9F49             >                endif           ; ok        // for other definitions it "points" the correct handler
  63++9F49             >                // Use of "; ok" to suppress "warning[fwdref]"
  63++9F49             >
  63++9F49             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  64++9F49 E1                           pop     hl
  65++9F4A 7D                           ld      a, l                // file-handle
  66++9F4B DD E5                        push    ix
  67++9F4D D5                           push    de
  68++9F4E C5                           push    bc
  69++9F4F CF                           rst     $08
  70++9F50 9C                           db      $9C
  71++9F51 18 DF                        jr      F_Seek_Exit
  72++9F53              //              pop     de
  73++9F53              //              pop     bc
  74++9F53              //              pop     ix
  75++9F53              //              sbc     hl, hl
  76++9F53              //              psh1
  77++9F53
  78++9F53              //  ______________________________________________________________________
  79++9F53              //
  80++9F53              // f_fgetpos    u -- d f
  81++9F53              // Seek to position d in file-handle u.
  82++9F53              // Return a false-flag 0 on success, True flag on error
  83++9F53                              New_Def F_FGETPOS, "F_FGETPOS", is_code, is_normal
  83++9F53             >
  83++9F53             >Dict_Ptr        defl    $
  83++9F53             >
  83++9F53             >//              ______________________________________________________________________
  83++9F53             >//              Heap part
  83++9F53             >
  83++9F53             >
  83++9F53             >                org     (Heap_Ptr & $1FFF) + $E000
  83++E12B             >
  83++E12B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  83++E12B             >Latest_Definition defl  Heap_Ptr
  83++E12B             >
  83++E12B             >                // dummy db directives used to calculate length of namec
  83++E12B 46 5F 46 47 >                db      "F_FGETPOS"
  83++E12F 45 54 50 4F >
  83++E133 53          >
  83++E134             >len_NFA         defl    $ - temp_NFA
  83++E134             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  83++E12B             >
  83++E12B 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  83++E12C 46 5F 46 47 >                db      "F_FGETPOS"               // name string in 7-bit ascii, but
  83++E130 45 54 50 4F >
  83++E134 53          >
  83++E135             >                org     $-1                 // alter last byte of Name just above to set
  83++E134 D3          >                db      {b $} | END_BIT     // msb as name end
  83++E135             >
  83++E135 20 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
  83++E137             >Prev_Ptr        defl    Heap_Ptr
  83++E137             >
  83++E137             >mirror_Ptr      defl    $
  83++E137             >
  83++E137 55 9F       >                dw      Dict_Ptr + 2        // xt
  83++E139             >Heap_Ptr        defl    $ - $E000           // save current HP
  83++E139             >
  83++E139             >Current_HP      defl  $ - $E000             // used to set HP once!
  83++E139             >
  83++E139             >//              ______________________________________________________________________
  83++E139             >//              Dictionary part
  83++E139             >
  83++E139             >                org     Dict_Ptr
  83++9F53             >
  83++9F53 37 21       >                dw      mirror_Ptr - $E000 + Heap_offset
  83++9F55             >
  83++9F55             >F_FGETPOS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
  83++9F55 ~           >                call    runcode ; ok        // for primitive definitions  actual code
  83++9F55 ~           >
  83++9F55 ~           >
  83++9F55             >                endif           ; ok        // for other definitions it "points" the correct handler
  83++9F55             >                // Use of "; ok" to suppress "warning[fwdref]"
  83++9F55             >
  83++9F55             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  84++9F55 E1                            pop     hl
  85++9F56 7D                            ld      a, l                // file-handle
  86++9F57 DD E5                         push    ix
  87++9F59 D5                            push    de
  88++9F5A C5                            push    bc
  89++9F5B CF                            rst     $08
  90++9F5C A0                            db      $A0
  91++9F5D D9                           exx
  92++9F5E C1                           pop     bc                  // IP
  93++9F5F D1                           pop     de                  // Return Stack Pointer
  94++9F60 DD E1                        pop     ix
  95++9F62 D9                            exx
  96++9F63 D5                            push    de
  97++9F64 C5                            push    bc
  98++9F65 ED 62                         sbc     hl, hl
  99++9F67 E5                            push    hl
 100++9F68 D9                           exx
 101++9F69                              next
 101++9F69 DD E9       >                jp      (ix)
 102++9F6B
 103++9F6B              //  ______________________________________________________________________
 104++9F6B              //
 105++9F6B              // f_read       a b u -- n f
 106++9F6B              // Read b bytes from file-handle u to address a
 107++9F6B              // Return the actual number n of bytes read
 108++9F6B              // Return 0 on success, True flag on error
 109++9F6B                              New_Def F_READ, "F_READ", is_code, is_normal
 109++9F6B             >
 109++9F6B             >Dict_Ptr        defl    $
 109++9F6B             >
 109++9F6B             >//              ______________________________________________________________________
 109++9F6B             >//              Heap part
 109++9F6B             >
 109++9F6B             >
 109++9F6B             >                org     (Heap_Ptr & $1FFF) + $E000
 109++E139             >
 109++E139             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 109++E139             >Latest_Definition defl  Heap_Ptr
 109++E139             >
 109++E139             >                // dummy db directives used to calculate length of namec
 109++E139 46 5F 52 45 >                db      "F_READ"
 109++E13D 41 44       >
 109++E13F             >len_NFA         defl    $ - temp_NFA
 109++E13F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 109++E139             >
 109++E139 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 109++E13A 46 5F 52 45 >                db      "F_READ"               // name string in 7-bit ascii, but
 109++E13E 41 44       >
 109++E140             >                org     $-1                 // alter last byte of Name just above to set
 109++E13F C4          >                db      {b $} | END_BIT     // msb as name end
 109++E140             >
 109++E140 2B 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 109++E142             >Prev_Ptr        defl    Heap_Ptr
 109++E142             >
 109++E142             >mirror_Ptr      defl    $
 109++E142             >
 109++E142 6D 9F       >                dw      Dict_Ptr + 2        // xt
 109++E144             >Heap_Ptr        defl    $ - $E000           // save current HP
 109++E144             >
 109++E144             >Current_HP      defl  $ - $E000             // used to set HP once!
 109++E144             >
 109++E144             >//              ______________________________________________________________________
 109++E144             >//              Dictionary part
 109++E144             >
 109++E144             >                org     Dict_Ptr
 109++9F6B             >
 109++9F6B 42 21       >                dw      mirror_Ptr - $E000 + Heap_offset
 109++9F6D             >
 109++9F6D             >F_READ:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 109++9F6D ~           >                call    runcode ; ok        // for primitive definitions  actual code
 109++9F6D ~           >
 109++9F6D ~           >
 109++9F6D             >                endif           ; ok        // for other definitions it "points" the correct handler
 109++9F6D             >                // Use of "; ok" to suppress "warning[fwdref]"
 109++9F6D             >
 109++9F6D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 110++9F6D D9                            exx
 111++9F6E E1                            pop     hl
 112++9F6F 7D                            ld      a, l                // file-handle
 113++9F70 C1                            pop     bc                  // bc has bytes to read
 114++9F71 DD E3                         ex      (sp), ix            // ix has address
 115++9F73 D9                           exx
 116++9F74 D5                           push    de                  // Save Return Stack pointer
 117++9F75 C5                           push    bc                  // Save Instruction pointer
 118++9F76 D9                            exx
 119++9F77 CF                            rst     $08
 120++9F78 9D                            db      $9D
 121++9F79              F_Read_Exit:
 122++9F79 D9                           exx
 123++9F7A C1                           pop     bc                  // Restore Instruction pointer
 124++9F7B D1                           pop     de                  // Restore Return Stack pointer
 125++9F7C DD E1                        pop     ix                  // Restore ix
 126++9F7E D9                            exx
 127++9F7F D5                            push    de                  // bytes involved in i/o operation
 128++9F80 ED 62                         sbc     hl, hl
 129++9F82 E5                            push    hl
 130++9F83 D9                           exx
 131++9F84                              next
 131++9F84 DD E9       >                jp      (ix)
 132++9F86
 133++9F86              //  ______________________________________________________________________
 134++9F86              //
 135++9F86              // f_write      a b u -- n f
 136++9F86              // Write bytes currently stored at address a to file-handle u.
 137++9F86              // Return the actual n bytes written and 0 on success, True flag on error.
 138++9F86                              New_Def F_WRITE, "F_WRITE", is_code, is_normal
 138++9F86             >
 138++9F86             >Dict_Ptr        defl    $
 138++9F86             >
 138++9F86             >//              ______________________________________________________________________
 138++9F86             >//              Heap part
 138++9F86             >
 138++9F86             >
 138++9F86             >                org     (Heap_Ptr & $1FFF) + $E000
 138++E144             >
 138++E144             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 138++E144             >Latest_Definition defl  Heap_Ptr
 138++E144             >
 138++E144             >                // dummy db directives used to calculate length of namec
 138++E144 46 5F 57 52 >                db      "F_WRITE"
 138++E148 49 54 45    >
 138++E14B             >len_NFA         defl    $ - temp_NFA
 138++E14B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 138++E144             >
 138++E144 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 138++E145 46 5F 57 52 >                db      "F_WRITE"               // name string in 7-bit ascii, but
 138++E149 49 54 45    >
 138++E14C             >                org     $-1                 // alter last byte of Name just above to set
 138++E14B C5          >                db      {b $} | END_BIT     // msb as name end
 138++E14C             >
 138++E14C 39 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 138++E14E             >Prev_Ptr        defl    Heap_Ptr
 138++E14E             >
 138++E14E             >mirror_Ptr      defl    $
 138++E14E             >
 138++E14E 88 9F       >                dw      Dict_Ptr + 2        // xt
 138++E150             >Heap_Ptr        defl    $ - $E000           // save current HP
 138++E150             >
 138++E150             >Current_HP      defl  $ - $E000             // used to set HP once!
 138++E150             >
 138++E150             >//              ______________________________________________________________________
 138++E150             >//              Dictionary part
 138++E150             >
 138++E150             >                org     Dict_Ptr
 138++9F86             >
 138++9F86 4E 21       >                dw      mirror_Ptr - $E000 + Heap_offset
 138++9F88             >
 138++9F88             >F_WRITE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 138++9F88 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 138++9F88 ~           >
 138++9F88 ~           >
 138++9F88             >                endif           ; ok        // for other definitions it "points" the correct handler
 138++9F88             >                // Use of "; ok" to suppress "warning[fwdref]"
 138++9F88             >
 138++9F88             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 139++9F88 D9                            exx
 140++9F89 E1                            pop     hl
 141++9F8A 7D                            ld      a, l                // file-handle
 142++9F8B C1                            pop     bc                  // bc has bytes to read
 143++9F8C DD E3                         ex      (sp), ix            // ix has address
 144++9F8E D9                           exx
 145++9F8F D5                           push    de                  // Save Return Stack pointer
 146++9F90 C5                           push    bc                  // Save Instruction pointer
 147++9F91 D9                            exx
 148++9F92 CF                            rst     $08
 149++9F93 9E                            db      $9E
 150++9F94 18 E3                         jr F_Read_Exit
 151++9F96              //                exx
 152++9F96              //                pop     de                  // Restore Return Stack pointer
 153++9F96              //                pop     bc                  // Restore Instruction pointer
 154++9F96              //                pop     ix                  // Restore ix
 155++9F96              //                 exx
 156++9F96              //                 push    de                  // bytes involved in i/o operation
 157++9F96              //                 sbc     hl, hl
 158++9F96              //                 push    hl
 159++9F96              //                exx
 160++9F96              //                next
 161++9F96
 162++9F96              //  ______________________________________________________________________
 163++9F96              //
 164++9F96              // f_open       a1 a2 b -- u f
 165++9F96              // open a file
 166++9F96              // a1 (filespec) is a null-terminated string, such as produced by ," definition
 167++9F96              // a2 is address to an 8-byte header data used in some cases.
 168++9F96              // b is access mode-byte, that is a combination of:
 169++9F96              // any/all of:
 170++9F96              //   esx_mode_read          $01 request read access
 171++9F96              //   esx_mode_write         $02 request write access
 172++9F96              //   esx_mode_use_header    $40 read/write +3DOS header
 173++9F96              // plus one of:
 174++9F96              //   esx_mode_open_exist    $00 only open existing file
 175++9F96              //   esx_mode_open_creat    $08 open existing or create file
 176++9F96              //   esx_mode_creat_noexist $04 create new file, error if exists
 177++9F96              //   esx_mode_creat_trunc   $0c create new file, delete existing
 178++9F96              // Return file-handle u and 0 on success, True flag on error
 179++9F96                              New_Def F_OPEN, "F_OPEN", is_code, is_normal
 179++9F96             >
 179++9F96             >Dict_Ptr        defl    $
 179++9F96             >
 179++9F96             >//              ______________________________________________________________________
 179++9F96             >//              Heap part
 179++9F96             >
 179++9F96             >
 179++9F96             >                org     (Heap_Ptr & $1FFF) + $E000
 179++E150             >
 179++E150             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 179++E150             >Latest_Definition defl  Heap_Ptr
 179++E150             >
 179++E150             >                // dummy db directives used to calculate length of namec
 179++E150 46 5F 4F 50 >                db      "F_OPEN"
 179++E154 45 4E       >
 179++E156             >len_NFA         defl    $ - temp_NFA
 179++E156             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 179++E150             >
 179++E150 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 179++E151 46 5F 4F 50 >                db      "F_OPEN"               // name string in 7-bit ascii, but
 179++E155 45 4E       >
 179++E157             >                org     $-1                 // alter last byte of Name just above to set
 179++E156 CE          >                db      {b $} | END_BIT     // msb as name end
 179++E157             >
 179++E157 44 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 179++E159             >Prev_Ptr        defl    Heap_Ptr
 179++E159             >
 179++E159             >mirror_Ptr      defl    $
 179++E159             >
 179++E159 98 9F       >                dw      Dict_Ptr + 2        // xt
 179++E15B             >Heap_Ptr        defl    $ - $E000           // save current HP
 179++E15B             >
 179++E15B             >Current_HP      defl  $ - $E000             // used to set HP once!
 179++E15B             >
 179++E15B             >//              ______________________________________________________________________
 179++E15B             >//              Dictionary part
 179++E15B             >
 179++E15B             >                org     Dict_Ptr
 179++9F96             >
 179++9F96 59 21       >                dw      mirror_Ptr - $E000 + Heap_offset
 179++9F98             >
 179++9F98             >F_OPEN:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 179++9F98 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 179++9F98 ~           >
 179++9F98 ~           >
 179++9F98             >                endif           ; ok        // for other definitions it "points" the correct handler
 179++9F98             >                // Use of "; ok" to suppress "warning[fwdref]"
 179++9F98             >
 179++9F98             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 180++9F98 D9                            exx
 181++9F99 C1                            pop     bc                  // file-mode
 182++9F9A 41                            ld      b, c                // file-mode
 183++9F9B D1                            pop     de                  // 8-bytes buffer if any
 184++9F9C DD E3                         ex      (sp), ix            // filespec nul-terminated
 185++9F9E D9                           exx
 186++9F9F D5                           push    de                  // Save Return Stack pointer
 187++9FA0 C5                           push    bc                  // Save Instruction pointer
 188++9FA1 D9                            exx
 189++9FA2 3E 2A                         ld      a, "*"
 190++9FA4 CF                            rst     $08
 191++9FA5 9A                            db      $9A
 192++9FA6              F_Open_Exit:
 193++9FA6 5F                            ld      e, a                // return the handle-number
 194++9FA7 16 00                         ld      d, 0
 195++9FA9 18 CE                        jr F_Read_Exit
 196++9FAB
 197++9FAB              //   \ CREATE FILENAME ," test.txt"   \ new Counted String
 198++9FAB              //   \ FILENAME 1+ PAD 1 F_OPEN
 199++9FAB              //   \ DROP
 200++9FAB              //   \ F_CLOSE
 201++9FAB
 202++9FAB
 203++9FAB              //  ______________________________________________________________________
 204++9FAB              //
 205++9FAB              // f_opendir    a1 -- u f
 206++9FAB              // open a file
 207++9FAB                              New_Def F_OPENDIR, "F_OPENDIR", is_code, is_normal
 207++9FAB             >
 207++9FAB             >Dict_Ptr        defl    $
 207++9FAB             >
 207++9FAB             >//              ______________________________________________________________________
 207++9FAB             >//              Heap part
 207++9FAB             >
 207++9FAB             >
 207++9FAB             >                org     (Heap_Ptr & $1FFF) + $E000
 207++E15B             >
 207++E15B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 207++E15B             >Latest_Definition defl  Heap_Ptr
 207++E15B             >
 207++E15B             >                // dummy db directives used to calculate length of namec
 207++E15B 46 5F 4F 50 >                db      "F_OPENDIR"
 207++E15F 45 4E 44 49 >
 207++E163 52          >
 207++E164             >len_NFA         defl    $ - temp_NFA
 207++E164             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 207++E15B             >
 207++E15B 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 207++E15C 46 5F 4F 50 >                db      "F_OPENDIR"               // name string in 7-bit ascii, but
 207++E160 45 4E 44 49 >
 207++E164 52          >
 207++E165             >                org     $-1                 // alter last byte of Name just above to set
 207++E164 D2          >                db      {b $} | END_BIT     // msb as name end
 207++E165             >
 207++E165 50 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 207++E167             >Prev_Ptr        defl    Heap_Ptr
 207++E167             >
 207++E167             >mirror_Ptr      defl    $
 207++E167             >
 207++E167 AD 9F       >                dw      Dict_Ptr + 2        // xt
 207++E169             >Heap_Ptr        defl    $ - $E000           // save current HP
 207++E169             >
 207++E169             >Current_HP      defl  $ - $E000             // used to set HP once!
 207++E169             >
 207++E169             >//              ______________________________________________________________________
 207++E169             >//              Dictionary part
 207++E169             >
 207++E169             >                org     Dict_Ptr
 207++9FAB             >
 207++9FAB 67 21       >                dw      mirror_Ptr - $E000 + Heap_offset
 207++9FAD             >
 207++9FAD             >F_OPENDIR:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 207++9FAD ~           >                call    runcode ; ok        // for primitive definitions  actual code
 207++9FAD ~           >
 207++9FAD ~           >
 207++9FAD             >                endif           ; ok        // for other definitions it "points" the correct handler
 207++9FAD             >                // Use of "; ok" to suppress "warning[fwdref]"
 207++9FAD             >
 207++9FAD             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 208++9FAD DD E3                        ex      (sp), ix            // filespec nul-terminated
 209++9FAF D5                           push    de                  // Save Return Stack pointer
 210++9FB0 C5                           push    bc                  // Save Instruction pointer
 211++9FB1 06 10                        ld      b, $10              // file-mode
 212++9FB3 3E 43                        ld      a, "C"
 213++9FB5 CF                           rst     $08
 214++9FB6 A3                           db      $A3
 215++9FB7 18 ED                        jr      F_Open_Exit
 216++9FB9
 217++9FB9
 218++9FB9              //  ______________________________________________________________________
 219++9FB9              //
 220++9FB9              // f_readdir    a1 a2 b -- u f
 221++9FB9              // open a file
 222++9FB9                              New_Def F_READDIR, "F_READDIR", is_code, is_normal
 222++9FB9             >
 222++9FB9             >Dict_Ptr        defl    $
 222++9FB9             >
 222++9FB9             >//              ______________________________________________________________________
 222++9FB9             >//              Heap part
 222++9FB9             >
 222++9FB9             >
 222++9FB9             >                org     (Heap_Ptr & $1FFF) + $E000
 222++E169             >
 222++E169             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 222++E169             >Latest_Definition defl  Heap_Ptr
 222++E169             >
 222++E169             >                // dummy db directives used to calculate length of namec
 222++E169 46 5F 52 45 >                db      "F_READDIR"
 222++E16D 41 44 44 49 >
 222++E171 52          >
 222++E172             >len_NFA         defl    $ - temp_NFA
 222++E172             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 222++E169             >
 222++E169 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 222++E16A 46 5F 52 45 >                db      "F_READDIR"               // name string in 7-bit ascii, but
 222++E16E 41 44 44 49 >
 222++E172 52          >
 222++E173             >                org     $-1                 // alter last byte of Name just above to set
 222++E172 D2          >                db      {b $} | END_BIT     // msb as name end
 222++E173             >
 222++E173 5B 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 222++E175             >Prev_Ptr        defl    Heap_Ptr
 222++E175             >
 222++E175             >mirror_Ptr      defl    $
 222++E175             >
 222++E175 BB 9F       >                dw      Dict_Ptr + 2        // xt
 222++E177             >Heap_Ptr        defl    $ - $E000           // save current HP
 222++E177             >
 222++E177             >Current_HP      defl  $ - $E000             // used to set HP once!
 222++E177             >
 222++E177             >//              ______________________________________________________________________
 222++E177             >//              Dictionary part
 222++E177             >
 222++E177             >                org     Dict_Ptr
 222++9FB9             >
 222++9FB9 75 21       >                dw      mirror_Ptr - $E000 + Heap_offset
 222++9FBB             >
 222++9FBB             >F_READDIR:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 222++9FBB ~           >                call    runcode ; ok        // for primitive definitions  actual code
 222++9FBB ~           >
 222++9FBB ~           >
 222++9FBB             >                endif           ; ok        // for other definitions it "points" the correct handler
 222++9FBB             >                // Use of "; ok" to suppress "warning[fwdref]"
 222++9FBB             >
 222++9FBB             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 223++9FBB D9                            exx
 224++9FBC E1                            pop     hl
 225++9FBD 7D                            ld      a, l
 226++9FBE D1                            pop     de
 227++9FBF DD E3                         ex      (sp), ix            // filespec nul-terminated
 228++9FC1 D9                           exx
 229++9FC2 D5                           push    de                  // Save Return Stack pointer
 230++9FC3 C5                           push    bc                  // Save Instruction pointer
 231++9FC4 D9                            exx
 232++9FC5 CF                            rst     $08
 233++9FC6 A4                            db      $A4
 234++9FC7 18 DD                         jr      F_Open_Exit
 235++9FC9
# file closed: C:\Zx\CSpect\Projects\vForth17_MMU7/source/next-opt0.asm
1066+ 9FC9
1067+ 9FC9
1068+ 9FC9              //  ______________________________________________________________________
1069+ 9FC9              //
1070+ 9FC9              // cmove    a1 a2 u --
1071+ 9FC9              // If u > 0, moves memory content starting at address a1 for n bytes long
1072+ 9FC9              // storing then starting at address addr2.
1073+ 9FC9              // The content of a1 is moved first. See CMOVE> also.
1074+ 9FC9                              New_Def CMOVE, "CMOVE", is_code, is_normal
1074+ 9FC9             >
1074+ 9FC9             >Dict_Ptr        defl    $
1074+ 9FC9             >
1074+ 9FC9             >//              ______________________________________________________________________
1074+ 9FC9             >//              Heap part
1074+ 9FC9             >
1074+ 9FC9             >
1074+ 9FC9             >                org     (Heap_Ptr & $1FFF) + $E000
1074+ E177             >
1074+ E177             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1074+ E177             >Latest_Definition defl  Heap_Ptr
1074+ E177             >
1074+ E177             >                // dummy db directives used to calculate length of namec
1074+ E177 43 4D 4F 56 >                db      "CMOVE"
1074+ E17B 45          >
1074+ E17C             >len_NFA         defl    $ - temp_NFA
1074+ E17C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1074+ E177             >
1074+ E177 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1074+ E178 43 4D 4F 56 >                db      "CMOVE"               // name string in 7-bit ascii, but
1074+ E17C 45          >
1074+ E17D             >                org     $-1                 // alter last byte of Name just above to set
1074+ E17C C5          >                db      {b $} | END_BIT     // msb as name end
1074+ E17D             >
1074+ E17D 69 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1074+ E17F             >Prev_Ptr        defl    Heap_Ptr
1074+ E17F             >
1074+ E17F             >mirror_Ptr      defl    $
1074+ E17F             >
1074+ E17F CB 9F       >                dw      Dict_Ptr + 2        // xt
1074+ E181             >Heap_Ptr        defl    $ - $E000           // save current HP
1074+ E181             >
1074+ E181             >Current_HP      defl  $ - $E000             // used to set HP once!
1074+ E181             >
1074+ E181             >//              ______________________________________________________________________
1074+ E181             >//              Dictionary part
1074+ E181             >
1074+ E181             >                org     Dict_Ptr
1074+ 9FC9             >
1074+ 9FC9 7F 21       >                dw      mirror_Ptr - $E000 + Heap_offset
1074+ 9FCB             >
1074+ 9FCB             >CMOVE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1074+ 9FCB ~           >                call    runcode ; ok        // for primitive definitions  actual code
1074+ 9FCB ~           >
1074+ 9FCB ~           >
1074+ 9FCB             >                endif           ; ok        // for other definitions it "points" the correct handler
1074+ 9FCB             >                // Use of "; ok" to suppress "warning[fwdref]"
1074+ 9FCB             >
1074+ 9FCB             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1075+ 9FCB D9                           exx
1076+ 9FCC
1077+ 9FCC C1                           pop     bc                  // bc has counter
1078+ 9FCD D1                           pop     de                  // de now has dest
1079+ 9FCE E1                           pop     hl                 // hl has source, save Instruction Pointer
1080+ 9FCF 78                           ld      a, b
1081+ 9FD0 B1                           or      c
1082+ 9FD1 28 02                        jr      z, Cmove_NoMove
1083+ 9FD3 ED B0                            ldir
1084+ 9FD5              Cmove_NoMove:
1085+ 9FD5 D9                           exx
1086+ 9FD6
1087+ 9FD6                              next
1087+ 9FD6 DD E9       >                jp      (ix)
1088+ 9FD8
1089+ 9FD8              //  ______________________________________________________________________
1090+ 9FD8              //
1091+ 9FD8              // cmove>    a1 a2 u --
1092+ 9FD8              // If u > 0, moves memory content starting at address a1 for n bytes long
1093+ 9FD8              // storing then starting at address addr2.
1094+ 9FD8              // The content of a1 is moved last. See cmove.
1095+ 9FD8                              New_Def CMOVE_TO, "CMOVE>", is_code, is_normal
1095+ 9FD8             >
1095+ 9FD8             >Dict_Ptr        defl    $
1095+ 9FD8             >
1095+ 9FD8             >//              ______________________________________________________________________
1095+ 9FD8             >//              Heap part
1095+ 9FD8             >
1095+ 9FD8             >
1095+ 9FD8             >                org     (Heap_Ptr & $1FFF) + $E000
1095+ E181             >
1095+ E181             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1095+ E181             >Latest_Definition defl  Heap_Ptr
1095+ E181             >
1095+ E181             >                // dummy db directives used to calculate length of namec
1095+ E181 43 4D 4F 56 >                db      "CMOVE>"
1095+ E185 45 3E       >
1095+ E187             >len_NFA         defl    $ - temp_NFA
1095+ E187             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1095+ E181             >
1095+ E181 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1095+ E182 43 4D 4F 56 >                db      "CMOVE>"               // name string in 7-bit ascii, but
1095+ E186 45 3E       >
1095+ E188             >                org     $-1                 // alter last byte of Name just above to set
1095+ E187 BE          >                db      {b $} | END_BIT     // msb as name end
1095+ E188             >
1095+ E188 77 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1095+ E18A             >Prev_Ptr        defl    Heap_Ptr
1095+ E18A             >
1095+ E18A             >mirror_Ptr      defl    $
1095+ E18A             >
1095+ E18A DA 9F       >                dw      Dict_Ptr + 2        // xt
1095+ E18C             >Heap_Ptr        defl    $ - $E000           // save current HP
1095+ E18C             >
1095+ E18C             >Current_HP      defl  $ - $E000             // used to set HP once!
1095+ E18C             >
1095+ E18C             >//              ______________________________________________________________________
1095+ E18C             >//              Dictionary part
1095+ E18C             >
1095+ E18C             >                org     Dict_Ptr
1095+ 9FD8             >
1095+ 9FD8 8A 21       >                dw      mirror_Ptr - $E000 + Heap_offset
1095+ 9FDA             >
1095+ 9FDA             >CMOVE_TO:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1095+ 9FDA ~           >                call    runcode ; ok        // for primitive definitions  actual code
1095+ 9FDA ~           >
1095+ 9FDA ~           >
1095+ 9FDA             >                endif           ; ok        // for other definitions it "points" the correct handler
1095+ 9FDA             >                // Use of "; ok" to suppress "warning[fwdref]"
1095+ 9FDA             >
1095+ 9FDA             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1096+ 9FDA D9                           exx
1097+ 9FDB
1098+ 9FDB C1                           pop     bc                  // bc has counter
1099+ 9FDC D1                           pop     de                  // de has dest
1100+ 9FDD E1                           pop     hl                  // hl has source, save Instruction Pointer
1101+ 9FDE 78                           ld      a, b
1102+ 9FDF B1                           or      c
1103+ 9FE0 28 08                        jr      z, CmoveV_NoMove
1104+ 9FE2 EB                               ex      de, hl              // compute address to
1105+ 9FE3 09                               add     hl, bc              // operate backward
1106+ 9FE4 2B                               dec     hl
1107+ 9FE5 EB                               ex      de, hl
1108+ 9FE6 09                               add     hl, bc
1109+ 9FE7 2B                               dec     hl
1110+ 9FE8 ED B8                            lddr                        // backward
1111+ 9FEA              CmoveV_NoMove:
1112+ 9FEA D9                           exx
1113+ 9FEB
1114+ 9FEB                              next
1114+ 9FEB DD E9       >                jp      (ix)
1115+ 9FED
1116+ 9FED              //  ______________________________________________________________________
1117+ 9FED              //
1118+ 9FED              // um*      u1 u2 -- ud
1119+ 9FED              // Unsigned multiplication
1120+ 9FED              // A double-integer is kept in CPU registers as DEHL then pushed on stack.
1121+ 9FED              // On the stack a double number is treated as two single numbers
1122+ 9FED              // where DE is on the top of the stack and HL is the second from top,
1123+ 9FED              // Instead, in 2VARIABLE a double number is stored as EDLH.
1124+ 9FED              // this definition could use "MUL" Z80N new op-code.
1125+ 9FED                              New_Def UM_MUL, "UM*", is_code, is_normal
1125+ 9FED             >
1125+ 9FED             >Dict_Ptr        defl    $
1125+ 9FED             >
1125+ 9FED             >//              ______________________________________________________________________
1125+ 9FED             >//              Heap part
1125+ 9FED             >
1125+ 9FED             >
1125+ 9FED             >                org     (Heap_Ptr & $1FFF) + $E000
1125+ E18C             >
1125+ E18C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1125+ E18C             >Latest_Definition defl  Heap_Ptr
1125+ E18C             >
1125+ E18C             >                // dummy db directives used to calculate length of namec
1125+ E18C 55 4D 2A    >                db      "UM*"
1125+ E18F             >len_NFA         defl    $ - temp_NFA
1125+ E18F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1125+ E18C             >
1125+ E18C 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1125+ E18D 55 4D 2A    >                db      "UM*"               // name string in 7-bit ascii, but
1125+ E190             >                org     $-1                 // alter last byte of Name just above to set
1125+ E18F AA          >                db      {b $} | END_BIT     // msb as name end
1125+ E190             >
1125+ E190 81 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1125+ E192             >Prev_Ptr        defl    Heap_Ptr
1125+ E192             >
1125+ E192             >mirror_Ptr      defl    $
1125+ E192             >
1125+ E192 EF 9F       >                dw      Dict_Ptr + 2        // xt
1125+ E194             >Heap_Ptr        defl    $ - $E000           // save current HP
1125+ E194             >
1125+ E194             >Current_HP      defl  $ - $E000             // used to set HP once!
1125+ E194             >
1125+ E194             >//              ______________________________________________________________________
1125+ E194             >//              Dictionary part
1125+ E194             >
1125+ E194             >                org     Dict_Ptr
1125+ 9FED             >
1125+ 9FED 92 21       >                dw      mirror_Ptr - $E000 + Heap_offset
1125+ 9FEF             >
1125+ 9FEF             >UM_MUL:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1125+ 9FEF ~           >                call    runcode ; ok        // for primitive definitions  actual code
1125+ 9FEF ~           >
1125+ 9FEF ~           >
1125+ 9FEF             >                endif           ; ok        // for other definitions it "points" the correct handler
1125+ 9FEF             >                // Use of "; ok" to suppress "warning[fwdref]"
1125+ 9FEF             >
1125+ 9FEF             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1126+ 9FEF D9                           exx
1127+ 9FF0 D1                           pop     de                    // de has u2 operand
1128+ 9FF1 E1                           pop     hl                    // hl has u1 operand
1129+ 9FF2 45                           ld      b, l
1130+ 9FF3 4B                           ld      c, e
1131+ 9FF4 5D                           ld      e, l
1132+ 9FF5 6A                           ld      l, d
1133+ 9FF6 E5                           push    hl
1134+ 9FF7 69                           ld      l, c
1135+ 9FF8 ED 30                        mul
1136+ 9FFA EB                           ex      de, hl
1137+ 9FFB ED 30                        mul
1138+ 9FFD AF                           xor     a
1139+ 9FFE 19                           add     hl, de
1140+ 9FFF 8F                           adc     a
1141+ A000 59                           ld      e, c
1142+ A001 50                           ld      d, b
1143+ A002 ED 30                        mul
1144+ A004 47                           ld      b, a
1145+ A005 4C                           ld      c, h
1146+ A006 7A                           ld      a, d
1147+ A007 85                           add     l
1148+ A008 67                           ld      h, a
1149+ A009 6B                           ld      l, e
1150+ A00A D1                           pop     de
1151+ A00B ED 30                        mul
1152+ A00D EB                           ex      de, hl
1153+ A00E ED 4A                        adc     hl, bc
1154+ A010 D5                           push    de
1155+ A011 E5                           push    hl
1156+ A012 D9                           exx
1157+ A013                              next
1157+ A013 DD E9       >                jp      (ix)
1158+ A015
1159+ A015              //  ______________________________________________________________________
1160+ A015              //
1161+ A015              // um/mod      ud u1 -- q r
1162+ A015              // divides ud into u1 giving quotient q and remainder r
1163+ A015              // algorithm takes 16 bit at a time starting from msb
1164+ A015              // DE grows from lsb upward with quotient result
1165+ A015              // HL keeps the remainder at each stage of division
1166+ A015              // each loop 'lowers' the next binary digit to form the current dividend
1167+ A015                              New_Def UMDIVMOD, "UM/MOD", is_code, is_normal
1167+ A015             >
1167+ A015             >Dict_Ptr        defl    $
1167+ A015             >
1167+ A015             >//              ______________________________________________________________________
1167+ A015             >//              Heap part
1167+ A015             >
1167+ A015             >
1167+ A015             >                org     (Heap_Ptr & $1FFF) + $E000
1167+ E194             >
1167+ E194             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1167+ E194             >Latest_Definition defl  Heap_Ptr
1167+ E194             >
1167+ E194             >                // dummy db directives used to calculate length of namec
1167+ E194 55 4D 2F 4D >                db      "UM/MOD"
1167+ E198 4F 44       >
1167+ E19A             >len_NFA         defl    $ - temp_NFA
1167+ E19A             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1167+ E194             >
1167+ E194 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1167+ E195 55 4D 2F 4D >                db      "UM/MOD"               // name string in 7-bit ascii, but
1167+ E199 4F 44       >
1167+ E19B             >                org     $-1                 // alter last byte of Name just above to set
1167+ E19A C4          >                db      {b $} | END_BIT     // msb as name end
1167+ E19B             >
1167+ E19B 8C 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1167+ E19D             >Prev_Ptr        defl    Heap_Ptr
1167+ E19D             >
1167+ E19D             >mirror_Ptr      defl    $
1167+ E19D             >
1167+ E19D 17 A0       >                dw      Dict_Ptr + 2        // xt
1167+ E19F             >Heap_Ptr        defl    $ - $E000           // save current HP
1167+ E19F             >
1167+ E19F             >Current_HP      defl  $ - $E000             // used to set HP once!
1167+ E19F             >
1167+ E19F             >//              ______________________________________________________________________
1167+ E19F             >//              Dictionary part
1167+ E19F             >
1167+ E19F             >                org     Dict_Ptr
1167+ A015             >
1167+ A015 9D 21       >                dw      mirror_Ptr - $E000 + Heap_offset
1167+ A017             >
1167+ A017             >UMDIVMOD:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1167+ A017 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1167+ A017 ~           >
1167+ A017 ~           >
1167+ A017             >                endif           ; ok        // for other definitions it "points" the correct handler
1167+ A017             >                // Use of "; ok" to suppress "warning[fwdref]"
1167+ A017             >
1167+ A017             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1168+ A017 D9                           exx
1169+ A018 C1                           pop     bc                      // divisor
1170+ A019
1171+ A019 E1                           pop     hl                      // < high part
1172+ A01A D1                           pop     de                      // < low part and
1173+ A01B
1174+ A01B 7D                           ld      a, l                    // check without changing arguments
1175+ A01C 91                           sub     c                       // if divisor is greater than high part
1176+ A01D 7C                           ld      a, h                    // so quotient will be in range
1177+ A01E 98                           sbc     a, b
1178+ A01F 30 20                        jr      nc, Um_DivMod_OutOfRange
1179+ A021 3E 10                            ld      a, 16
1180+ A023              Um_DivMod_Loop:
1181+ A023 CB 23                                sla     e
1182+ A025 CB 12                                rl      d
1183+ A027 ED 6A                                adc     hl, hl
1184+ A029 30 05                                jr      nc, Um_DivMod_Carry
1185+ A02B A7                                       and     a
1186+ A02C ED 42                                    sbc     hl, bc
1187+ A02E 18 07                                jr      Um_DivMod_Endif    // else
1188+ A030              Um_DivMod_Carry:
1189+ A030 A7                                       and     a
1190+ A031 ED 42                                    sbc     hl, bc
1191+ A033 30 02                                    jr      nc, Um_DivMod_Endif
1192+ A035 09                                           add     hl, bc
1193+ A036 1B                                           dec     de
1194+ A037              Um_DivMod_Endif:                                   // endif
1195+ A037 13                                   inc     de
1196+ A038 3D                                   dec     a
1197+ A039 20 E8                            jr      nz, Um_DivMod_Loop
1198+ A03B EB                               ex      de, hl
1199+ A03C              Um_DivMod_Bailout:
1200+ A03C D5                               push    de                  // de := remanider
1201+ A03D E5                               push    hl                  // hl := quotient
1202+ A03E D9                               exx
1203+ A03F                                  next
1203+ A03F DD E9       >                jp      (ix)
1204+ A041
1205+ A041              Um_DivMod_OutOfRange:
1206+ A041 21 FF FF                     ld      hl, -1
1207+ A044 54                           ld      d, h
1208+ A045 5D                           ld      e, l
1209+ A046 18 F4                        jr      Um_DivMod_Bailout
1210+ A048
1211+ A048              //  ______________________________________________________________________
1212+ A048              //
1213+ A048              // and          n1 n2 -- n3
1214+ A048              // bit logical AND. Returns n3 as n1 & n2
1215+ A048                              New_Def AND_OP, "AND", is_code, is_normal
1215+ A048             >
1215+ A048             >Dict_Ptr        defl    $
1215+ A048             >
1215+ A048             >//              ______________________________________________________________________
1215+ A048             >//              Heap part
1215+ A048             >
1215+ A048             >
1215+ A048             >                org     (Heap_Ptr & $1FFF) + $E000
1215+ E19F             >
1215+ E19F             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1215+ E19F             >Latest_Definition defl  Heap_Ptr
1215+ E19F             >
1215+ E19F             >                // dummy db directives used to calculate length of namec
1215+ E19F 41 4E 44    >                db      "AND"
1215+ E1A2             >len_NFA         defl    $ - temp_NFA
1215+ E1A2             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1215+ E19F             >
1215+ E19F 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1215+ E1A0 41 4E 44    >                db      "AND"               // name string in 7-bit ascii, but
1215+ E1A3             >                org     $-1                 // alter last byte of Name just above to set
1215+ E1A2 C4          >                db      {b $} | END_BIT     // msb as name end
1215+ E1A3             >
1215+ E1A3 94 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1215+ E1A5             >Prev_Ptr        defl    Heap_Ptr
1215+ E1A5             >
1215+ E1A5             >mirror_Ptr      defl    $
1215+ E1A5             >
1215+ E1A5 4A A0       >                dw      Dict_Ptr + 2        // xt
1215+ E1A7             >Heap_Ptr        defl    $ - $E000           // save current HP
1215+ E1A7             >
1215+ E1A7             >Current_HP      defl  $ - $E000             // used to set HP once!
1215+ E1A7             >
1215+ E1A7             >//              ______________________________________________________________________
1215+ E1A7             >//              Dictionary part
1215+ E1A7             >
1215+ E1A7             >                org     Dict_Ptr
1215+ A048             >
1215+ A048 A5 21       >                dw      mirror_Ptr - $E000 + Heap_offset
1215+ A04A             >
1215+ A04A             >AND_OP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1215+ A04A ~           >                call    runcode ; ok        // for primitive definitions  actual code
1215+ A04A ~           >
1215+ A04A ~           >
1215+ A04A             >                endif           ; ok        // for other definitions it "points" the correct handler
1215+ A04A             >                // Use of "; ok" to suppress "warning[fwdref]"
1215+ A04A             >
1215+ A04A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1216+ A04A D9                           exx
1217+ A04B D1                           pop     de
1218+ A04C E1                           pop     hl
1219+ A04D 7B                           ld      a, e
1220+ A04E A5                           and     l
1221+ A04F 6F                           ld      l, a
1222+ A050 7A                           ld      a, d
1223+ A051 A4                           and     h
1224+ A052 67                           ld      h, a
1225+ A053 E5                           push    hl
1226+ A054 D9                           exx
1227+ A055                              next
1227+ A055 DD E9       >                jp      (ix)
1228+ A057
1229+ A057              //  ______________________________________________________________________
1230+ A057              //
1231+ A057              // or           n1 n2 -- n3
1232+ A057              // bit logical OR. Returns n3 as n1 | n2
1233+ A057                              New_Def OR_OP, "OR", is_code, is_normal
1233+ A057             >
1233+ A057             >Dict_Ptr        defl    $
1233+ A057             >
1233+ A057             >//              ______________________________________________________________________
1233+ A057             >//              Heap part
1233+ A057             >
1233+ A057             >
1233+ A057             >                org     (Heap_Ptr & $1FFF) + $E000
1233+ E1A7             >
1233+ E1A7             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1233+ E1A7             >Latest_Definition defl  Heap_Ptr
1233+ E1A7             >
1233+ E1A7             >                // dummy db directives used to calculate length of namec
1233+ E1A7 4F 52       >                db      "OR"
1233+ E1A9             >len_NFA         defl    $ - temp_NFA
1233+ E1A9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1233+ E1A7             >
1233+ E1A7 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1233+ E1A8 4F 52       >                db      "OR"               // name string in 7-bit ascii, but
1233+ E1AA             >                org     $-1                 // alter last byte of Name just above to set
1233+ E1A9 D2          >                db      {b $} | END_BIT     // msb as name end
1233+ E1AA             >
1233+ E1AA 9F 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1233+ E1AC             >Prev_Ptr        defl    Heap_Ptr
1233+ E1AC             >
1233+ E1AC             >mirror_Ptr      defl    $
1233+ E1AC             >
1233+ E1AC 59 A0       >                dw      Dict_Ptr + 2        // xt
1233+ E1AE             >Heap_Ptr        defl    $ - $E000           // save current HP
1233+ E1AE             >
1233+ E1AE             >Current_HP      defl  $ - $E000             // used to set HP once!
1233+ E1AE             >
1233+ E1AE             >//              ______________________________________________________________________
1233+ E1AE             >//              Dictionary part
1233+ E1AE             >
1233+ E1AE             >                org     Dict_Ptr
1233+ A057             >
1233+ A057 AC 21       >                dw      mirror_Ptr - $E000 + Heap_offset
1233+ A059             >
1233+ A059             >OR_OP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1233+ A059 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1233+ A059 ~           >
1233+ A059 ~           >
1233+ A059             >                endif           ; ok        // for other definitions it "points" the correct handler
1233+ A059             >                // Use of "; ok" to suppress "warning[fwdref]"
1233+ A059             >
1233+ A059             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1234+ A059 D9                           exx
1235+ A05A D1                           pop     de
1236+ A05B E1                           pop     hl
1237+ A05C 7B                           ld      a, e
1238+ A05D B5                           or      l
1239+ A05E 6F                           ld      l, a
1240+ A05F 7A                           ld      a, d
1241+ A060 B4                           or      h
1242+ A061 67                           ld      h, a
1243+ A062 E5                           push    hl
1244+ A063 D9                           exx
1245+ A064                              next
1245+ A064 DD E9       >                jp      (ix)
1246+ A066
1247+ A066              //  ______________________________________________________________________
1248+ A066              //
1249+ A066              // xor          n1 n2 -- n3
1250+ A066              // bit logical OR. Returns n3 as n1 ^ n2
1251+ A066                              New_Def XOR_OP, "XOR", is_code, is_normal
1251+ A066             >
1251+ A066             >Dict_Ptr        defl    $
1251+ A066             >
1251+ A066             >//              ______________________________________________________________________
1251+ A066             >//              Heap part
1251+ A066             >
1251+ A066             >
1251+ A066             >                org     (Heap_Ptr & $1FFF) + $E000
1251+ E1AE             >
1251+ E1AE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1251+ E1AE             >Latest_Definition defl  Heap_Ptr
1251+ E1AE             >
1251+ E1AE             >                // dummy db directives used to calculate length of namec
1251+ E1AE 58 4F 52    >                db      "XOR"
1251+ E1B1             >len_NFA         defl    $ - temp_NFA
1251+ E1B1             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1251+ E1AE             >
1251+ E1AE 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1251+ E1AF 58 4F 52    >                db      "XOR"               // name string in 7-bit ascii, but
1251+ E1B2             >                org     $-1                 // alter last byte of Name just above to set
1251+ E1B1 D2          >                db      {b $} | END_BIT     // msb as name end
1251+ E1B2             >
1251+ E1B2 A7 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1251+ E1B4             >Prev_Ptr        defl    Heap_Ptr
1251+ E1B4             >
1251+ E1B4             >mirror_Ptr      defl    $
1251+ E1B4             >
1251+ E1B4 68 A0       >                dw      Dict_Ptr + 2        // xt
1251+ E1B6             >Heap_Ptr        defl    $ - $E000           // save current HP
1251+ E1B6             >
1251+ E1B6             >Current_HP      defl  $ - $E000             // used to set HP once!
1251+ E1B6             >
1251+ E1B6             >//              ______________________________________________________________________
1251+ E1B6             >//              Dictionary part
1251+ E1B6             >
1251+ E1B6             >                org     Dict_Ptr
1251+ A066             >
1251+ A066 B4 21       >                dw      mirror_Ptr - $E000 + Heap_offset
1251+ A068             >
1251+ A068             >XOR_OP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1251+ A068 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1251+ A068 ~           >
1251+ A068 ~           >
1251+ A068             >                endif           ; ok        // for other definitions it "points" the correct handler
1251+ A068             >                // Use of "; ok" to suppress "warning[fwdref]"
1251+ A068             >
1251+ A068             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1252+ A068 D9                           exx
1253+ A069 D1                           pop     de
1254+ A06A E1                           pop     hl
1255+ A06B 7B                           ld      a, e
1256+ A06C AD                           xor     l
1257+ A06D 6F                           ld      l, a
1258+ A06E 7A                           ld      a, d
1259+ A06F AC                           xor     h
1260+ A070 67                           ld      h, a
1261+ A071 E5                           push    hl
1262+ A072 D9                           exx
1263+ A073                              next
1263+ A073 DD E9       >                jp      (ix)
1264+ A075
1265+ A075              //  ______________________________________________________________________
1266+ A075              //
1267+ A075              // sp@      -- a
1268+ A075              // returns on top of stack the value of SP before execution
1269+ A075                              New_Def SPFETCH, "SP@", is_code, is_normal
1269+ A075             >
1269+ A075             >Dict_Ptr        defl    $
1269+ A075             >
1269+ A075             >//              ______________________________________________________________________
1269+ A075             >//              Heap part
1269+ A075             >
1269+ A075             >
1269+ A075             >                org     (Heap_Ptr & $1FFF) + $E000
1269+ E1B6             >
1269+ E1B6             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1269+ E1B6             >Latest_Definition defl  Heap_Ptr
1269+ E1B6             >
1269+ E1B6             >                // dummy db directives used to calculate length of namec
1269+ E1B6 53 50 40    >                db      "SP@"
1269+ E1B9             >len_NFA         defl    $ - temp_NFA
1269+ E1B9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1269+ E1B6             >
1269+ E1B6 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1269+ E1B7 53 50 40    >                db      "SP@"               // name string in 7-bit ascii, but
1269+ E1BA             >                org     $-1                 // alter last byte of Name just above to set
1269+ E1B9 C0          >                db      {b $} | END_BIT     // msb as name end
1269+ E1BA             >
1269+ E1BA AE 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1269+ E1BC             >Prev_Ptr        defl    Heap_Ptr
1269+ E1BC             >
1269+ E1BC             >mirror_Ptr      defl    $
1269+ E1BC             >
1269+ E1BC 77 A0       >                dw      Dict_Ptr + 2        // xt
1269+ E1BE             >Heap_Ptr        defl    $ - $E000           // save current HP
1269+ E1BE             >
1269+ E1BE             >Current_HP      defl  $ - $E000             // used to set HP once!
1269+ E1BE             >
1269+ E1BE             >//              ______________________________________________________________________
1269+ E1BE             >//              Dictionary part
1269+ E1BE             >
1269+ E1BE             >                org     Dict_Ptr
1269+ A075             >
1269+ A075 BC 21       >                dw      mirror_Ptr - $E000 + Heap_offset
1269+ A077             >
1269+ A077             >SPFETCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1269+ A077 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1269+ A077 ~           >
1269+ A077 ~           >
1269+ A077             >                endif           ; ok        // for other definitions it "points" the correct handler
1269+ A077             >                // Use of "; ok" to suppress "warning[fwdref]"
1269+ A077             >
1269+ A077             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1270+ A077
1271+ A077 21 00 00                     ld      hl, 0
1272+ A07A 39                           add     hl, sp
1273+ A07B
1274+ A07B                              psh1
1274+ A07B E5          >                push    hl
1274+ A07C DD E9       >                jp      (ix)
1275+ A07E
1276+ A07E              //  ______________________________________________________________________
1277+ A07E              //
1278+ A07E              // sp!      a --
1279+ A07E              // restore SP to the initial value passed
1280+ A07E              // normally it is S0, i.e. the word at offset 6 and 7 of user variabiles area.
1281+ A07E                              New_Def SPSTORE, "SP!", is_code, is_normal
1281+ A07E             >
1281+ A07E             >Dict_Ptr        defl    $
1281+ A07E             >
1281+ A07E             >//              ______________________________________________________________________
1281+ A07E             >//              Heap part
1281+ A07E             >
1281+ A07E             >
1281+ A07E             >                org     (Heap_Ptr & $1FFF) + $E000
1281+ E1BE             >
1281+ E1BE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1281+ E1BE             >Latest_Definition defl  Heap_Ptr
1281+ E1BE             >
1281+ E1BE             >                // dummy db directives used to calculate length of namec
1281+ E1BE 53 50 21    >                db      "SP!"
1281+ E1C1             >len_NFA         defl    $ - temp_NFA
1281+ E1C1             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1281+ E1BE             >
1281+ E1BE 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1281+ E1BF 53 50 21    >                db      "SP!"               // name string in 7-bit ascii, but
1281+ E1C2             >                org     $-1                 // alter last byte of Name just above to set
1281+ E1C1 A1          >                db      {b $} | END_BIT     // msb as name end
1281+ E1C2             >
1281+ E1C2 B6 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1281+ E1C4             >Prev_Ptr        defl    Heap_Ptr
1281+ E1C4             >
1281+ E1C4             >mirror_Ptr      defl    $
1281+ E1C4             >
1281+ E1C4 80 A0       >                dw      Dict_Ptr + 2        // xt
1281+ E1C6             >Heap_Ptr        defl    $ - $E000           // save current HP
1281+ E1C6             >
1281+ E1C6             >Current_HP      defl  $ - $E000             // used to set HP once!
1281+ E1C6             >
1281+ E1C6             >//              ______________________________________________________________________
1281+ E1C6             >//              Dictionary part
1281+ E1C6             >
1281+ E1C6             >                org     Dict_Ptr
1281+ A07E             >
1281+ A07E C4 21       >                dw      mirror_Ptr - $E000 + Heap_offset
1281+ A080             >
1281+ A080             >SPSTORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1281+ A080 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1281+ A080 ~           >
1281+ A080 ~           >
1281+ A080             >                endif           ; ok        // for other definitions it "points" the correct handler
1281+ A080             >                // Use of "; ok" to suppress "warning[fwdref]"
1281+ A080             >
1281+ A080             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1282+ A080 E1                           pop     hl
1283+ A081 F9                           ld      sp, hl
1284+ A082
1285+ A082                              next
1285+ A082 DD E9       >                jp      (ix)
1286+ A084
1287+ A084              //  ______________________________________________________________________
1288+ A084              //
1289+ A084              // rp@      -- a
1290+ A084              // returns on top of stack the value of Return-Pointer
1291+ A084                              New_Def RPFETCH, "RP@", is_code, is_normal
1291+ A084             >
1291+ A084             >Dict_Ptr        defl    $
1291+ A084             >
1291+ A084             >//              ______________________________________________________________________
1291+ A084             >//              Heap part
1291+ A084             >
1291+ A084             >
1291+ A084             >                org     (Heap_Ptr & $1FFF) + $E000
1291+ E1C6             >
1291+ E1C6             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1291+ E1C6             >Latest_Definition defl  Heap_Ptr
1291+ E1C6             >
1291+ E1C6             >                // dummy db directives used to calculate length of namec
1291+ E1C6 52 50 40    >                db      "RP@"
1291+ E1C9             >len_NFA         defl    $ - temp_NFA
1291+ E1C9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1291+ E1C6             >
1291+ E1C6 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1291+ E1C7 52 50 40    >                db      "RP@"               // name string in 7-bit ascii, but
1291+ E1CA             >                org     $-1                 // alter last byte of Name just above to set
1291+ E1C9 C0          >                db      {b $} | END_BIT     // msb as name end
1291+ E1CA             >
1291+ E1CA BE 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1291+ E1CC             >Prev_Ptr        defl    Heap_Ptr
1291+ E1CC             >
1291+ E1CC             >mirror_Ptr      defl    $
1291+ E1CC             >
1291+ E1CC 86 A0       >                dw      Dict_Ptr + 2        // xt
1291+ E1CE             >Heap_Ptr        defl    $ - $E000           // save current HP
1291+ E1CE             >
1291+ E1CE             >Current_HP      defl  $ - $E000             // used to set HP once!
1291+ E1CE             >
1291+ E1CE             >//              ______________________________________________________________________
1291+ E1CE             >//              Dictionary part
1291+ E1CE             >
1291+ E1CE             >                org     Dict_Ptr
1291+ A084             >
1291+ A084 CC 21       >                dw      mirror_Ptr - $E000 + Heap_offset
1291+ A086             >
1291+ A086             >RPFETCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1291+ A086 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1291+ A086 ~           >
1291+ A086 ~           >
1291+ A086             >                endif           ; ok        // for other definitions it "points" the correct handler
1291+ A086             >                // Use of "; ok" to suppress "warning[fwdref]"
1291+ A086             >
1291+ A086             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1292+ A086
1293+ A086                              // *** ldhlrp
1294+ A086                              // *** ex      de, hl
1295+ A086 D5                           push de
1296+ A087
1297+ A087                              next
1297+ A087 DD E9       >                jp      (ix)
1298+ A089
1299+ A089              //  ______________________________________________________________________
1300+ A089              //
1301+ A089              // rp!      a --
1302+ A089              // restore RP to the initial value passed
1303+ A089              // normally it is R0 @, i.e. the word at offset 8 of user variabiles area.
1304+ A089                              New_Def RPSTORE, "RP!", is_code, is_normal
1304+ A089             >
1304+ A089             >Dict_Ptr        defl    $
1304+ A089             >
1304+ A089             >//              ______________________________________________________________________
1304+ A089             >//              Heap part
1304+ A089             >
1304+ A089             >
1304+ A089             >                org     (Heap_Ptr & $1FFF) + $E000
1304+ E1CE             >
1304+ E1CE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1304+ E1CE             >Latest_Definition defl  Heap_Ptr
1304+ E1CE             >
1304+ E1CE             >                // dummy db directives used to calculate length of namec
1304+ E1CE 52 50 21    >                db      "RP!"
1304+ E1D1             >len_NFA         defl    $ - temp_NFA
1304+ E1D1             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1304+ E1CE             >
1304+ E1CE 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1304+ E1CF 52 50 21    >                db      "RP!"               // name string in 7-bit ascii, but
1304+ E1D2             >                org     $-1                 // alter last byte of Name just above to set
1304+ E1D1 A1          >                db      {b $} | END_BIT     // msb as name end
1304+ E1D2             >
1304+ E1D2 C6 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1304+ E1D4             >Prev_Ptr        defl    Heap_Ptr
1304+ E1D4             >
1304+ E1D4             >mirror_Ptr      defl    $
1304+ E1D4             >
1304+ E1D4 8B A0       >                dw      Dict_Ptr + 2        // xt
1304+ E1D6             >Heap_Ptr        defl    $ - $E000           // save current HP
1304+ E1D6             >
1304+ E1D6             >Current_HP      defl  $ - $E000             // used to set HP once!
1304+ E1D6             >
1304+ E1D6             >//              ______________________________________________________________________
1304+ E1D6             >//              Dictionary part
1304+ E1D6             >
1304+ E1D6             >                org     Dict_Ptr
1304+ A089             >
1304+ A089 D4 21       >                dw      mirror_Ptr - $E000 + Heap_offset
1304+ A08B             >
1304+ A08B             >RPSTORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1304+ A08B ~           >                call    runcode ; ok        // for primitive definitions  actual code
1304+ A08B ~           >
1304+ A08B ~           >
1304+ A08B             >                endif           ; ok        // for other definitions it "points" the correct handler
1304+ A08B             >                // Use of "; ok" to suppress "warning[fwdref]"
1304+ A08B             >
1304+ A08B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1305+ A08B D1                           pop     de
1306+ A08C                              // *** ex      de, hl
1307+ A08C                              // *** ldrphl
1308+ A08C
1309+ A08C                              next
1309+ A08C DD E9       >                jp      (ix)
1310+ A08E
1311+ A08E              //  ______________________________________________________________________
1312+ A08E              //
1313+ A08E              // exit       --
1314+ A08E              // exits back to the caller word
1315+ A08E                              New_Def EXIT, "EXIT", is_code, is_normal
1315+ A08E             >
1315+ A08E             >Dict_Ptr        defl    $
1315+ A08E             >
1315+ A08E             >//              ______________________________________________________________________
1315+ A08E             >//              Heap part
1315+ A08E             >
1315+ A08E             >
1315+ A08E             >                org     (Heap_Ptr & $1FFF) + $E000
1315+ E1D6             >
1315+ E1D6             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1315+ E1D6             >Latest_Definition defl  Heap_Ptr
1315+ E1D6             >
1315+ E1D6             >                // dummy db directives used to calculate length of namec
1315+ E1D6 45 58 49 54 >                db      "EXIT"
1315+ E1DA             >len_NFA         defl    $ - temp_NFA
1315+ E1DA             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1315+ E1D6             >
1315+ E1D6 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1315+ E1D7 45 58 49 54 >                db      "EXIT"               // name string in 7-bit ascii, but
1315+ E1DB             >                org     $-1                 // alter last byte of Name just above to set
1315+ E1DA D4          >                db      {b $} | END_BIT     // msb as name end
1315+ E1DB             >
1315+ E1DB CE 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1315+ E1DD             >Prev_Ptr        defl    Heap_Ptr
1315+ E1DD             >
1315+ E1DD             >mirror_Ptr      defl    $
1315+ E1DD             >
1315+ E1DD 90 A0       >                dw      Dict_Ptr + 2        // xt
1315+ E1DF             >Heap_Ptr        defl    $ - $E000           // save current HP
1315+ E1DF             >
1315+ E1DF             >Current_HP      defl  $ - $E000             // used to set HP once!
1315+ E1DF             >
1315+ E1DF             >//              ______________________________________________________________________
1315+ E1DF             >//              Dictionary part
1315+ E1DF             >
1315+ E1DF             >                org     Dict_Ptr
1315+ A08E             >
1315+ A08E DD 21       >                dw      mirror_Ptr - $E000 + Heap_offset
1315+ A090             >
1315+ A090             >EXIT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1315+ A090 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1315+ A090 ~           >
1315+ A090 ~           >
1315+ A090             >                endif           ; ok        // for other definitions it "points" the correct handler
1315+ A090             >                // Use of "; ok" to suppress "warning[fwdref]"
1315+ A090             >
1315+ A090             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1316+ A090 EB                           ex      de, hl
1317+ A091                              // *** ldhlrp                      // Get Return Stack Pointer
1318+ A091 4E                           ld      c, (hl)             // pop Instruction Pointer
1319+ A092 23                           inc     hl                  // from Return Stack
1320+ A093 46                           ld      b, (hl)
1321+ A094 23                           inc     hl
1322+ A095                              // *** ldrphl                      // Set Return Stack Pointer
1323+ A095 EB                           ex      de, hl
1324+ A096                              next
1324+ A096 DD E9       >                jp      (ix)
1325+ A098
1326+ A098              //  ______________________________________________________________________
1327+ A098              //
1328+ A098              // lastl      --
1329+ A098              // exits back to the caller word
1330+ A098              //              New_Def EXIT, "LASTL", is_code, is_normal
1331+ A098              //              push    de
1332+ A098              //              ex      de, hl //**
1333+ A098              //              // *** ldhlrp                      // Get Return Stack Pointer
1334+ A098              //              ld      e, (hl)             // pop Instruction Pointer
1335+ A098              //              inc     hl                  // from Return Stack
1336+ A098              //              ld      d, (hl)
1337+ A098              //              inc     hl
1338+ A098              //              ld      (hl), e
1339+ A098              //              inc     hl
1340+ A098              //              ld      (hl), d
1341+ A098              //              add     hl, -3
1342+ A098              //              pop     de
1343+ A098              //              next
1344+ A098
1345+ A098              //  ______________________________________________________________________
1346+ A098              //
1347+ A098              // >r      n --
1348+ A098              // pop from calculator-stack and push into return-stack
1349+ A098                              New_Def TO_R, ">R", is_code, is_normal
1349+ A098             >
1349+ A098             >Dict_Ptr        defl    $
1349+ A098             >
1349+ A098             >//              ______________________________________________________________________
1349+ A098             >//              Heap part
1349+ A098             >
1349+ A098             >
1349+ A098             >                org     (Heap_Ptr & $1FFF) + $E000
1349+ E1DF             >
1349+ E1DF             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1349+ E1DF             >Latest_Definition defl  Heap_Ptr
1349+ E1DF             >
1349+ E1DF             >                // dummy db directives used to calculate length of namec
1349+ E1DF 3E 52       >                db      ">R"
1349+ E1E1             >len_NFA         defl    $ - temp_NFA
1349+ E1E1             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1349+ E1DF             >
1349+ E1DF 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1349+ E1E0 3E 52       >                db      ">R"               // name string in 7-bit ascii, but
1349+ E1E2             >                org     $-1                 // alter last byte of Name just above to set
1349+ E1E1 D2          >                db      {b $} | END_BIT     // msb as name end
1349+ E1E2             >
1349+ E1E2 D6 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1349+ E1E4             >Prev_Ptr        defl    Heap_Ptr
1349+ E1E4             >
1349+ E1E4             >mirror_Ptr      defl    $
1349+ E1E4             >
1349+ E1E4 9A A0       >                dw      Dict_Ptr + 2        // xt
1349+ E1E6             >Heap_Ptr        defl    $ - $E000           // save current HP
1349+ E1E6             >
1349+ E1E6             >Current_HP      defl  $ - $E000             // used to set HP once!
1349+ E1E6             >
1349+ E1E6             >//              ______________________________________________________________________
1349+ E1E6             >//              Dictionary part
1349+ E1E6             >
1349+ E1E6             >                org     Dict_Ptr
1349+ A098             >
1349+ A098 E4 21       >                dw      mirror_Ptr - $E000 + Heap_offset
1349+ A09A             >
1349+ A09A             >TO_R:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1349+ A09A ~           >                call    runcode ; ok        // for primitive definitions  actual code
1349+ A09A ~           >
1349+ A09A ~           >
1349+ A09A             >                endif           ; ok        // for other definitions it "points" the correct handler
1349+ A09A             >                // Use of "; ok" to suppress "warning[fwdref]"
1349+ A09A             >
1349+ A09A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1350+ A09A E1                           pop     hl
1351+ A09B EB                           ex      de, hl //**
1352+ A09C                              // *** ldhlrp
1353+ A09C 2B                           dec     hl
1354+ A09D 72                           ld      (hl), d             // store current TOS
1355+ A09E 2B                           dec     hl                  // to Return Stack
1356+ A09F 73                           ld      (hl), e
1357+ A0A0                              // *** ldrphl
1358+ A0A0 EB                           ex      de, hl //**
1359+ A0A1                              next
1359+ A0A1 DD E9       >                jp      (ix)
1360+ A0A3
1361+ A0A3              //  ______________________________________________________________________
1362+ A0A3              //
1363+ A0A3              // r>      -- n
1364+ A0A3              // pop from return-stack and push into calculator-stack
1365+ A0A3                              New_Def R_TO, "R>", is_code, is_normal
1365+ A0A3             >
1365+ A0A3             >Dict_Ptr        defl    $
1365+ A0A3             >
1365+ A0A3             >//              ______________________________________________________________________
1365+ A0A3             >//              Heap part
1365+ A0A3             >
1365+ A0A3             >
1365+ A0A3             >                org     (Heap_Ptr & $1FFF) + $E000
1365+ E1E6             >
1365+ E1E6             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1365+ E1E6             >Latest_Definition defl  Heap_Ptr
1365+ E1E6             >
1365+ E1E6             >                // dummy db directives used to calculate length of namec
1365+ E1E6 52 3E       >                db      "R>"
1365+ E1E8             >len_NFA         defl    $ - temp_NFA
1365+ E1E8             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1365+ E1E6             >
1365+ E1E6 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1365+ E1E7 52 3E       >                db      "R>"               // name string in 7-bit ascii, but
1365+ E1E9             >                org     $-1                 // alter last byte of Name just above to set
1365+ E1E8 BE          >                db      {b $} | END_BIT     // msb as name end
1365+ E1E9             >
1365+ E1E9 DF 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1365+ E1EB             >Prev_Ptr        defl    Heap_Ptr
1365+ E1EB             >
1365+ E1EB             >mirror_Ptr      defl    $
1365+ E1EB             >
1365+ E1EB A5 A0       >                dw      Dict_Ptr + 2        // xt
1365+ E1ED             >Heap_Ptr        defl    $ - $E000           // save current HP
1365+ E1ED             >
1365+ E1ED             >Current_HP      defl  $ - $E000             // used to set HP once!
1365+ E1ED             >
1365+ E1ED             >//              ______________________________________________________________________
1365+ E1ED             >//              Dictionary part
1365+ E1ED             >
1365+ E1ED             >                org     Dict_Ptr
1365+ A0A3             >
1365+ A0A3 EB 21       >                dw      mirror_Ptr - $E000 + Heap_offset
1365+ A0A5             >
1365+ A0A5             >R_TO:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1365+ A0A5 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1365+ A0A5 ~           >
1365+ A0A5 ~           >
1365+ A0A5             >                endif           ; ok        // for other definitions it "points" the correct handler
1365+ A0A5             >                // Use of "; ok" to suppress "warning[fwdref]"
1365+ A0A5             >
1365+ A0A5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1366+ A0A5
1367+ A0A5 EB                           ex      de, hl //**
1368+ A0A6                              // *** ldhlrp
1369+ A0A6 5E                           ld      e, (hl)             // retrieve from Return Stack
1370+ A0A7 23                           inc     hl
1371+ A0A8 56                           ld      d, (hl)
1372+ A0A9 23                           inc     hl
1373+ A0AA                              // *** ldrphl
1374+ A0AA EB                           ex      de, hl //**
1375+ A0AB E5                           push    hl
1376+ A0AC                              next
1376+ A0AC DD E9       >                jp      (ix)
1377+ A0AE
1378+ A0AE              //  ______________________________________________________________________
1379+ A0AE              //
1380+ A0AE              // r@           -- n
1381+ A0AE              // return on top of stack the value of top of return-stack
1382+ A0AE              // Since this is the same as I, we alter R's CFA to jump there
1383+ A0AE                              New_Def R_OP, "R@", is_code, is_normal
1383+ A0AE             >
1383+ A0AE             >Dict_Ptr        defl    $
1383+ A0AE             >
1383+ A0AE             >//              ______________________________________________________________________
1383+ A0AE             >//              Heap part
1383+ A0AE             >
1383+ A0AE             >
1383+ A0AE             >                org     (Heap_Ptr & $1FFF) + $E000
1383+ E1ED             >
1383+ E1ED             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1383+ E1ED             >Latest_Definition defl  Heap_Ptr
1383+ E1ED             >
1383+ E1ED             >                // dummy db directives used to calculate length of namec
1383+ E1ED 52 40       >                db      "R@"
1383+ E1EF             >len_NFA         defl    $ - temp_NFA
1383+ E1EF             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1383+ E1ED             >
1383+ E1ED 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1383+ E1EE 52 40       >                db      "R@"               // name string in 7-bit ascii, but
1383+ E1F0             >                org     $-1                 // alter last byte of Name just above to set
1383+ E1EF C0          >                db      {b $} | END_BIT     // msb as name end
1383+ E1F0             >
1383+ E1F0 E6 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1383+ E1F2             >Prev_Ptr        defl    Heap_Ptr
1383+ E1F2             >
1383+ E1F2             >mirror_Ptr      defl    $
1383+ E1F2             >
1383+ E1F2 B0 A0       >                dw      Dict_Ptr + 2        // xt
1383+ E1F4             >Heap_Ptr        defl    $ - $E000           // save current HP
1383+ E1F4             >
1383+ E1F4             >Current_HP      defl  $ - $E000             // used to set HP once!
1383+ E1F4             >
1383+ E1F4             >//              ______________________________________________________________________
1383+ E1F4             >//              Dictionary part
1383+ E1F4             >
1383+ E1F4             >                org     Dict_Ptr
1383+ A0AE             >
1383+ A0AE F2 21       >                dw      mirror_Ptr - $E000 + Heap_offset
1383+ A0B0             >
1383+ A0B0             >R_OP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1383+ A0B0 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1383+ A0B0 ~           >
1383+ A0B0 ~           >
1383+ A0B0             >                endif           ; ok        // for other definitions it "points" the correct handler
1383+ A0B0             >                // Use of "; ok" to suppress "warning[fwdref]"
1383+ A0B0             >
1383+ A0B0             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1384+ A0B0 C3 78 9C                     jp      I_Ptr
1385+ A0B3
1386+ A0B3              //  ______________________________________________________________________
1387+ A0B3              //
1388+ A0B3              // r            -- n
1389+ A0B3              // return on top of stack the value of top of return-stack
1390+ A0B3              // Since this is the same as I, we alter R's CFA to jump there
1391+ A0B3              //              New_Def R_OLD, "R", is_code, is_normal
1392+ A0B3              //              jp      I_Ptr
1393+ A0B3
1394+ A0B3              //  ______________________________________________________________________
1395+ A0B3              //
1396+ A0B3              // 0=           n -- f
1397+ A0B3              // true (non zero) if n is zero, false (0) elsewere
1398+ A0B3                              New_Def ZEQUAL, "0=", is_code, is_normal
1398+ A0B3             >
1398+ A0B3             >Dict_Ptr        defl    $
1398+ A0B3             >
1398+ A0B3             >//              ______________________________________________________________________
1398+ A0B3             >//              Heap part
1398+ A0B3             >
1398+ A0B3             >
1398+ A0B3             >                org     (Heap_Ptr & $1FFF) + $E000
1398+ E1F4             >
1398+ E1F4             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1398+ E1F4             >Latest_Definition defl  Heap_Ptr
1398+ E1F4             >
1398+ E1F4             >                // dummy db directives used to calculate length of namec
1398+ E1F4 30 3D       >                db      "0="
1398+ E1F6             >len_NFA         defl    $ - temp_NFA
1398+ E1F6             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1398+ E1F4             >
1398+ E1F4 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1398+ E1F5 30 3D       >                db      "0="               // name string in 7-bit ascii, but
1398+ E1F7             >                org     $-1                 // alter last byte of Name just above to set
1398+ E1F6 BD          >                db      {b $} | END_BIT     // msb as name end
1398+ E1F7             >
1398+ E1F7 ED 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1398+ E1F9             >Prev_Ptr        defl    Heap_Ptr
1398+ E1F9             >
1398+ E1F9             >mirror_Ptr      defl    $
1398+ E1F9             >
1398+ E1F9 B5 A0       >                dw      Dict_Ptr + 2        // xt
1398+ E1FB             >Heap_Ptr        defl    $ - $E000           // save current HP
1398+ E1FB             >
1398+ E1FB             >Current_HP      defl  $ - $E000             // used to set HP once!
1398+ E1FB             >
1398+ E1FB             >//              ______________________________________________________________________
1398+ E1FB             >//              Dictionary part
1398+ E1FB             >
1398+ E1FB             >                org     Dict_Ptr
1398+ A0B3             >
1398+ A0B3 F9 21       >                dw      mirror_Ptr - $E000 + Heap_offset
1398+ A0B5             >
1398+ A0B5             >ZEQUAL:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1398+ A0B5 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1398+ A0B5 ~           >
1398+ A0B5 ~           >
1398+ A0B5             >                endif           ; ok        // for other definitions it "points" the correct handler
1398+ A0B5             >                // Use of "; ok" to suppress "warning[fwdref]"
1398+ A0B5             >
1398+ A0B5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1399+ A0B5              Zero_Equal:
1400+ A0B5 E1                           pop     hl
1401+ A0B6 7D                           ld      a, l
1402+ A0B7 B4                           or      h
1403+ A0B8 21 00 00                     ld      hl, FALSE_FLAG
1404+ A0BB 20 01                        jr      nz, ZEqual_Skip
1405+ A0BD 2B                               dec     hl
1406+ A0BE              ZEqual_Skip:
1407+ A0BE                              psh1
1407+ A0BE E5          >                push    hl
1407+ A0BF DD E9       >                jp      (ix)
1408+ A0C1
1409+ A0C1              //  ______________________________________________________________________
1410+ A0C1              //
1411+ A0C1              // not         a1 -- a2
1412+ A0C1              // increment by 2 top of stack
1413+ A0C1                              New_Def NOT_OP, "NOT", is_code, is_normal
1413+ A0C1             >
1413+ A0C1             >Dict_Ptr        defl    $
1413+ A0C1             >
1413+ A0C1             >//              ______________________________________________________________________
1413+ A0C1             >//              Heap part
1413+ A0C1             >
1413+ A0C1             >
1413+ A0C1             >                org     (Heap_Ptr & $1FFF) + $E000
1413+ E1FB             >
1413+ E1FB             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1413+ E1FB             >Latest_Definition defl  Heap_Ptr
1413+ E1FB             >
1413+ E1FB             >                // dummy db directives used to calculate length of namec
1413+ E1FB 4E 4F 54    >                db      "NOT"
1413+ E1FE             >len_NFA         defl    $ - temp_NFA
1413+ E1FE             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1413+ E1FB             >
1413+ E1FB 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1413+ E1FC 4E 4F 54    >                db      "NOT"               // name string in 7-bit ascii, but
1413+ E1FF             >                org     $-1                 // alter last byte of Name just above to set
1413+ E1FE D4          >                db      {b $} | END_BIT     // msb as name end
1413+ E1FF             >
1413+ E1FF F4 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1413+ E201             >Prev_Ptr        defl    Heap_Ptr
1413+ E201             >
1413+ E201             >mirror_Ptr      defl    $
1413+ E201             >
1413+ E201 C3 A0       >                dw      Dict_Ptr + 2        // xt
1413+ E203             >Heap_Ptr        defl    $ - $E000           // save current HP
1413+ E203             >
1413+ E203             >Current_HP      defl  $ - $E000             // used to set HP once!
1413+ E203             >
1413+ E203             >//              ______________________________________________________________________
1413+ E203             >//              Dictionary part
1413+ E203             >
1413+ E203             >                org     Dict_Ptr
1413+ A0C1             >
1413+ A0C1 01 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1413+ A0C3             >
1413+ A0C3             >NOT_OP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1413+ A0C3 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1413+ A0C3 ~           >
1413+ A0C3 ~           >
1413+ A0C3             >                endif           ; ok        // for other definitions it "points" the correct handler
1413+ A0C3             >                // Use of "; ok" to suppress "warning[fwdref]"
1413+ A0C3             >
1413+ A0C3             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1414+ A0C3 C3 B5 A0                     jp      Zero_Equal
1415+ A0C6
1416+ A0C6              //  ______________________________________________________________________
1417+ A0C6              //
1418+ A0C6              // 0<           n -- f
1419+ A0C6              // true (non zero) if n is less than zero, false (0) elsewere
1420+ A0C6                              New_Def ZLESS, "0<", is_code, is_normal
1420+ A0C6             >
1420+ A0C6             >Dict_Ptr        defl    $
1420+ A0C6             >
1420+ A0C6             >//              ______________________________________________________________________
1420+ A0C6             >//              Heap part
1420+ A0C6             >
1420+ A0C6             >
1420+ A0C6             >                org     (Heap_Ptr & $1FFF) + $E000
1420+ E203             >
1420+ E203             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1420+ E203             >Latest_Definition defl  Heap_Ptr
1420+ E203             >
1420+ E203             >                // dummy db directives used to calculate length of namec
1420+ E203 30 3C       >                db      "0<"
1420+ E205             >len_NFA         defl    $ - temp_NFA
1420+ E205             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1420+ E203             >
1420+ E203 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1420+ E204 30 3C       >                db      "0<"               // name string in 7-bit ascii, but
1420+ E206             >                org     $-1                 // alter last byte of Name just above to set
1420+ E205 BC          >                db      {b $} | END_BIT     // msb as name end
1420+ E206             >
1420+ E206 FB 21       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1420+ E208             >Prev_Ptr        defl    Heap_Ptr
1420+ E208             >
1420+ E208             >mirror_Ptr      defl    $
1420+ E208             >
1420+ E208 C8 A0       >                dw      Dict_Ptr + 2        // xt
1420+ E20A             >Heap_Ptr        defl    $ - $E000           // save current HP
1420+ E20A             >
1420+ E20A             >Current_HP      defl  $ - $E000             // used to set HP once!
1420+ E20A             >
1420+ E20A             >//              ______________________________________________________________________
1420+ E20A             >//              Dictionary part
1420+ E20A             >
1420+ E20A             >                org     Dict_Ptr
1420+ A0C6             >
1420+ A0C6 08 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1420+ A0C8             >
1420+ A0C8             >ZLESS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1420+ A0C8 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1420+ A0C8 ~           >
1420+ A0C8 ~           >
1420+ A0C8             >                endif           ; ok        // for other definitions it "points" the correct handler
1420+ A0C8             >                // Use of "; ok" to suppress "warning[fwdref]"
1420+ A0C8             >
1420+ A0C8             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1421+ A0C8 E1                           pop     hl
1422+ A0C9 29                           add     hl, hl
1423+ A0CA ED 62                        sbc     hl, hl
1424+ A0CC                              psh1
1424+ A0CC E5          >                push    hl
1424+ A0CD DD E9       >                jp      (ix)
1425+ A0CF
1426+ A0CF              //  ______________________________________________________________________
1427+ A0CF              //
1428+ A0CF              // 0>           n -- f
1429+ A0CF              // true (non zero) if n is less than zero, false (0) elsewere
1430+ A0CF                              New_Def ZGREATER, "0>", is_code, is_normal
1430+ A0CF             >
1430+ A0CF             >Dict_Ptr        defl    $
1430+ A0CF             >
1430+ A0CF             >//              ______________________________________________________________________
1430+ A0CF             >//              Heap part
1430+ A0CF             >
1430+ A0CF             >
1430+ A0CF             >                org     (Heap_Ptr & $1FFF) + $E000
1430+ E20A             >
1430+ E20A             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1430+ E20A             >Latest_Definition defl  Heap_Ptr
1430+ E20A             >
1430+ E20A             >                // dummy db directives used to calculate length of namec
1430+ E20A 30 3E       >                db      "0>"
1430+ E20C             >len_NFA         defl    $ - temp_NFA
1430+ E20C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1430+ E20A             >
1430+ E20A 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1430+ E20B 30 3E       >                db      "0>"               // name string in 7-bit ascii, but
1430+ E20D             >                org     $-1                 // alter last byte of Name just above to set
1430+ E20C BE          >                db      {b $} | END_BIT     // msb as name end
1430+ E20D             >
1430+ E20D 03 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1430+ E20F             >Prev_Ptr        defl    Heap_Ptr
1430+ E20F             >
1430+ E20F             >mirror_Ptr      defl    $
1430+ E20F             >
1430+ E20F D1 A0       >                dw      Dict_Ptr + 2        // xt
1430+ E211             >Heap_Ptr        defl    $ - $E000           // save current HP
1430+ E211             >
1430+ E211             >Current_HP      defl  $ - $E000             // used to set HP once!
1430+ E211             >
1430+ E211             >//              ______________________________________________________________________
1430+ E211             >//              Dictionary part
1430+ E211             >
1430+ E211             >                org     Dict_Ptr
1430+ A0CF             >
1430+ A0CF 0F 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1430+ A0D1             >
1430+ A0D1             >ZGREATER:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1430+ A0D1 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1430+ A0D1 ~           >
1430+ A0D1 ~           >
1430+ A0D1             >                endif           ; ok        // for other definitions it "points" the correct handler
1430+ A0D1             >                // Use of "; ok" to suppress "warning[fwdref]"
1430+ A0D1             >
1430+ A0D1             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1431+ A0D1 E1                           pop     hl
1432+ A0D2 7D                           ld      a, l
1433+ A0D3 B4                           or      h
1434+ A0D4 29                           add     hl, hl
1435+ A0D5 21 00 00                     ld      hl, FALSE_FLAG
1436+ A0D8 38 04                        jr      c, ZGreater_Skip
1437+ A0DA A7                               and     a
1438+ A0DB 28 01                            jr      z, ZGreater_Skip
1439+ A0DD 2B                                   dec     hl
1440+ A0DE              ZGreater_Skip:
1441+ A0DE                              psh1
1441+ A0DE E5          >                push    hl
1441+ A0DF DD E9       >                jp      (ix)
1442+ A0E1
1443+ A0E1              //  ______________________________________________________________________
1444+ A0E1              //
1445+ A0E1              // +            n1 n2 -- n3
1446+ A0E1              // returns the unsigned sum of two top values
1447+ A0E1                              New_Def PLUS, "+", is_code, is_normal
1447+ A0E1             >
1447+ A0E1             >Dict_Ptr        defl    $
1447+ A0E1             >
1447+ A0E1             >//              ______________________________________________________________________
1447+ A0E1             >//              Heap part
1447+ A0E1             >
1447+ A0E1             >
1447+ A0E1             >                org     (Heap_Ptr & $1FFF) + $E000
1447+ E211             >
1447+ E211             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1447+ E211             >Latest_Definition defl  Heap_Ptr
1447+ E211             >
1447+ E211             >                // dummy db directives used to calculate length of namec
1447+ E211 2B          >                db      "+"
1447+ E212             >len_NFA         defl    $ - temp_NFA
1447+ E212             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1447+ E211             >
1447+ E211 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1447+ E212 2B          >                db      "+"               // name string in 7-bit ascii, but
1447+ E213             >                org     $-1                 // alter last byte of Name just above to set
1447+ E212 AB          >                db      {b $} | END_BIT     // msb as name end
1447+ E213             >
1447+ E213 0A 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1447+ E215             >Prev_Ptr        defl    Heap_Ptr
1447+ E215             >
1447+ E215             >mirror_Ptr      defl    $
1447+ E215             >
1447+ E215 E3 A0       >                dw      Dict_Ptr + 2        // xt
1447+ E217             >Heap_Ptr        defl    $ - $E000           // save current HP
1447+ E217             >
1447+ E217             >Current_HP      defl  $ - $E000             // used to set HP once!
1447+ E217             >
1447+ E217             >//              ______________________________________________________________________
1447+ E217             >//              Dictionary part
1447+ E217             >
1447+ E217             >                org     Dict_Ptr
1447+ A0E1             >
1447+ A0E1 15 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1447+ A0E3             >
1447+ A0E3             >PLUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1447+ A0E3 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1447+ A0E3 ~           >
1447+ A0E3 ~           >
1447+ A0E3             >                endif           ; ok        // for other definitions it "points" the correct handler
1447+ A0E3             >                // Use of "; ok" to suppress "warning[fwdref]"
1447+ A0E3             >
1447+ A0E3             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1448+ A0E3 D9                           exx
1449+ A0E4 E1                           pop     hl
1450+ A0E5 D1                           pop     de
1451+ A0E6 19                           add     hl, de
1452+ A0E7 E5                           push    hl
1453+ A0E8 D9                           exx
1454+ A0E9                              next
1454+ A0E9 DD E9       >                jp      (ix)
1455+ A0EB
1456+ A0EB
1457+ A0EB              //  ______________________________________________________________________
1458+ A0EB              //
1459+ A0EB              // d+           d1 d2 -- d3
1460+ A0EB              // returns the unsigned sum of two top double-numbers
1461+ A0EB              //      d2  d1
1462+ A0EB              //      h l h l
1463+ A0EB              // SP   LHEDLHED
1464+ A0EB              // SP  +01234567
1465+ A0EB                              New_Def DPLUS, "D+", is_code, is_normal
1465+ A0EB             >
1465+ A0EB             >Dict_Ptr        defl    $
1465+ A0EB             >
1465+ A0EB             >//              ______________________________________________________________________
1465+ A0EB             >//              Heap part
1465+ A0EB             >
1465+ A0EB             >
1465+ A0EB             >                org     (Heap_Ptr & $1FFF) + $E000
1465+ E217             >
1465+ E217             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1465+ E217             >Latest_Definition defl  Heap_Ptr
1465+ E217             >
1465+ E217             >                // dummy db directives used to calculate length of namec
1465+ E217 44 2B       >                db      "D+"
1465+ E219             >len_NFA         defl    $ - temp_NFA
1465+ E219             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1465+ E217             >
1465+ E217 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1465+ E218 44 2B       >                db      "D+"               // name string in 7-bit ascii, but
1465+ E21A             >                org     $-1                 // alter last byte of Name just above to set
1465+ E219 AB          >                db      {b $} | END_BIT     // msb as name end
1465+ E21A             >
1465+ E21A 11 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1465+ E21C             >Prev_Ptr        defl    Heap_Ptr
1465+ E21C             >
1465+ E21C             >mirror_Ptr      defl    $
1465+ E21C             >
1465+ E21C ED A0       >                dw      Dict_Ptr + 2        // xt
1465+ E21E             >Heap_Ptr        defl    $ - $E000           // save current HP
1465+ E21E             >
1465+ E21E             >Current_HP      defl  $ - $E000             // used to set HP once!
1465+ E21E             >
1465+ E21E             >//              ______________________________________________________________________
1465+ E21E             >//              Dictionary part
1465+ E21E             >
1465+ E21E             >                org     Dict_Ptr
1465+ A0EB             >
1465+ A0EB 1C 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1465+ A0ED             >
1465+ A0ED             >DPLUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1465+ A0ED ~           >                call    runcode ; ok        // for primitive definitions  actual code
1465+ A0ED ~           >
1465+ A0ED ~           >
1465+ A0ED             >                endif           ; ok        // for other definitions it "points" the correct handler
1465+ A0ED             >                // Use of "; ok" to suppress "warning[fwdref]"
1465+ A0ED             >
1465+ A0ED             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1466+ A0ED
1467+ A0ED D9                           exx
1468+ A0EE C1                           pop     bc                  // bc := d2.H
1469+ A0EF D1                           pop     de                  // hl := d2.L
1470+ A0F0 E1                           pop     hl                  // d1.H
1471+ A0F1 E3                           ex      (sp), hl            // d1.L
1472+ A0F2 19                           add     hl, de              // hl := d2.L + d1.L
1473+ A0F3 E3                           ex      (sp), hl            // d1.H
1474+ A0F4 ED 4A                        adc     hl, bc              // d1.H + d2.H
1475+ A0F6 E5                           push    hl
1476+ A0F7 D9                           exx
1477+ A0F8                              next
1477+ A0F8 DD E9       >                jp      (ix)
1478+ A0FA
1479+ A0FA              //  ______________________________________________________________________
1480+ A0FA              //
1481+ A0FA              // 1+           n1 -- n2
1482+ A0FA              // increment by 1 top of stack
1483+ A0FA                              New_Def ONE_PLUS, "1+", is_code, is_normal
1483+ A0FA             >
1483+ A0FA             >Dict_Ptr        defl    $
1483+ A0FA             >
1483+ A0FA             >//              ______________________________________________________________________
1483+ A0FA             >//              Heap part
1483+ A0FA             >
1483+ A0FA             >
1483+ A0FA             >                org     (Heap_Ptr & $1FFF) + $E000
1483+ E21E             >
1483+ E21E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1483+ E21E             >Latest_Definition defl  Heap_Ptr
1483+ E21E             >
1483+ E21E             >                // dummy db directives used to calculate length of namec
1483+ E21E 31 2B       >                db      "1+"
1483+ E220             >len_NFA         defl    $ - temp_NFA
1483+ E220             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1483+ E21E             >
1483+ E21E 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1483+ E21F 31 2B       >                db      "1+"               // name string in 7-bit ascii, but
1483+ E221             >                org     $-1                 // alter last byte of Name just above to set
1483+ E220 AB          >                db      {b $} | END_BIT     // msb as name end
1483+ E221             >
1483+ E221 17 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1483+ E223             >Prev_Ptr        defl    Heap_Ptr
1483+ E223             >
1483+ E223             >mirror_Ptr      defl    $
1483+ E223             >
1483+ E223 FC A0       >                dw      Dict_Ptr + 2        // xt
1483+ E225             >Heap_Ptr        defl    $ - $E000           // save current HP
1483+ E225             >
1483+ E225             >Current_HP      defl  $ - $E000             // used to set HP once!
1483+ E225             >
1483+ E225             >//              ______________________________________________________________________
1483+ E225             >//              Dictionary part
1483+ E225             >
1483+ E225             >                org     Dict_Ptr
1483+ A0FA             >
1483+ A0FA 23 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1483+ A0FC             >
1483+ A0FC             >ONE_PLUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1483+ A0FC ~           >                call    runcode ; ok        // for primitive definitions  actual code
1483+ A0FC ~           >
1483+ A0FC ~           >
1483+ A0FC             >                endif           ; ok        // for other definitions it "points" the correct handler
1483+ A0FC             >                // Use of "; ok" to suppress "warning[fwdref]"
1483+ A0FC             >
1483+ A0FC             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1484+ A0FC E1                           pop     hl
1485+ A0FD 23                           inc     hl
1486+ A0FE
1487+ A0FE                              psh1
1487+ A0FE E5          >                push    hl
1487+ A0FF DD E9       >                jp      (ix)
1488+ A101
1489+ A101              //  ______________________________________________________________________
1490+ A101              //
1491+ A101              // 1-           n1 -- n2
1492+ A101              // decrement by 1 top of stack
1493+ A101                              New_Def ONE_SUBTRACT, "1-", is_code, is_normal
1493+ A101             >
1493+ A101             >Dict_Ptr        defl    $
1493+ A101             >
1493+ A101             >//              ______________________________________________________________________
1493+ A101             >//              Heap part
1493+ A101             >
1493+ A101             >
1493+ A101             >                org     (Heap_Ptr & $1FFF) + $E000
1493+ E225             >
1493+ E225             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1493+ E225             >Latest_Definition defl  Heap_Ptr
1493+ E225             >
1493+ E225             >                // dummy db directives used to calculate length of namec
1493+ E225 31 2D       >                db      "1-"
1493+ E227             >len_NFA         defl    $ - temp_NFA
1493+ E227             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1493+ E225             >
1493+ E225 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1493+ E226 31 2D       >                db      "1-"               // name string in 7-bit ascii, but
1493+ E228             >                org     $-1                 // alter last byte of Name just above to set
1493+ E227 AD          >                db      {b $} | END_BIT     // msb as name end
1493+ E228             >
1493+ E228 1E 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1493+ E22A             >Prev_Ptr        defl    Heap_Ptr
1493+ E22A             >
1493+ E22A             >mirror_Ptr      defl    $
1493+ E22A             >
1493+ E22A 03 A1       >                dw      Dict_Ptr + 2        // xt
1493+ E22C             >Heap_Ptr        defl    $ - $E000           // save current HP
1493+ E22C             >
1493+ E22C             >Current_HP      defl  $ - $E000             // used to set HP once!
1493+ E22C             >
1493+ E22C             >//              ______________________________________________________________________
1493+ E22C             >//              Dictionary part
1493+ E22C             >
1493+ E22C             >                org     Dict_Ptr
1493+ A101             >
1493+ A101 2A 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1493+ A103             >
1493+ A103             >ONE_SUBTRACT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1493+ A103 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1493+ A103 ~           >
1493+ A103 ~           >
1493+ A103             >                endif           ; ok        // for other definitions it "points" the correct handler
1493+ A103             >                // Use of "; ok" to suppress "warning[fwdref]"
1493+ A103             >
1493+ A103             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1494+ A103 E1                           pop     hl
1495+ A104 2B                           dec     hl
1496+ A105
1497+ A105                              psh1
1497+ A105 E5          >                push    hl
1497+ A106 DD E9       >                jp      (ix)
1498+ A108
1499+ A108              //  ______________________________________________________________________
1500+ A108              //
1501+ A108              // 2+           n1 -- n2
1502+ A108              // increment by 2 top of stack
1503+ A108                              New_Def TWO_PLUS, "2+", is_code, is_normal
1503+ A108             >
1503+ A108             >Dict_Ptr        defl    $
1503+ A108             >
1503+ A108             >//              ______________________________________________________________________
1503+ A108             >//              Heap part
1503+ A108             >
1503+ A108             >
1503+ A108             >                org     (Heap_Ptr & $1FFF) + $E000
1503+ E22C             >
1503+ E22C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1503+ E22C             >Latest_Definition defl  Heap_Ptr
1503+ E22C             >
1503+ E22C             >                // dummy db directives used to calculate length of namec
1503+ E22C 32 2B       >                db      "2+"
1503+ E22E             >len_NFA         defl    $ - temp_NFA
1503+ E22E             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1503+ E22C             >
1503+ E22C 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1503+ E22D 32 2B       >                db      "2+"               // name string in 7-bit ascii, but
1503+ E22F             >                org     $-1                 // alter last byte of Name just above to set
1503+ E22E AB          >                db      {b $} | END_BIT     // msb as name end
1503+ E22F             >
1503+ E22F 25 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1503+ E231             >Prev_Ptr        defl    Heap_Ptr
1503+ E231             >
1503+ E231             >mirror_Ptr      defl    $
1503+ E231             >
1503+ E231 0A A1       >                dw      Dict_Ptr + 2        // xt
1503+ E233             >Heap_Ptr        defl    $ - $E000           // save current HP
1503+ E233             >
1503+ E233             >Current_HP      defl  $ - $E000             // used to set HP once!
1503+ E233             >
1503+ E233             >//              ______________________________________________________________________
1503+ E233             >//              Dictionary part
1503+ E233             >
1503+ E233             >                org     Dict_Ptr
1503+ A108             >
1503+ A108 31 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1503+ A10A             >
1503+ A10A             >TWO_PLUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1503+ A10A ~           >                call    runcode ; ok        // for primitive definitions  actual code
1503+ A10A ~           >
1503+ A10A ~           >
1503+ A10A             >                endif           ; ok        // for other definitions it "points" the correct handler
1503+ A10A             >                // Use of "; ok" to suppress "warning[fwdref]"
1503+ A10A             >
1503+ A10A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1504+ A10A              Two_Plus:
1505+ A10A E1                           pop     hl
1506+ A10B 23                           inc     hl
1507+ A10C 23                           inc     hl
1508+ A10D
1509+ A10D                              psh1
1509+ A10D E5          >                push    hl
1509+ A10E DD E9       >                jp      (ix)
1510+ A110
1511+ A110              //  ______________________________________________________________________
1512+ A110              //
1513+ A110              // cell+        a1 -- a2
1514+ A110              // increment by 2 top of stack
1515+ A110                              New_Def CELL_PLUS, "CELL+", is_code, is_normal
1515+ A110             >
1515+ A110             >Dict_Ptr        defl    $
1515+ A110             >
1515+ A110             >//              ______________________________________________________________________
1515+ A110             >//              Heap part
1515+ A110             >
1515+ A110             >
1515+ A110             >                org     (Heap_Ptr & $1FFF) + $E000
1515+ E233             >
1515+ E233             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1515+ E233             >Latest_Definition defl  Heap_Ptr
1515+ E233             >
1515+ E233             >                // dummy db directives used to calculate length of namec
1515+ E233 43 45 4C 4C >                db      "CELL+"
1515+ E237 2B          >
1515+ E238             >len_NFA         defl    $ - temp_NFA
1515+ E238             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1515+ E233             >
1515+ E233 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1515+ E234 43 45 4C 4C >                db      "CELL+"               // name string in 7-bit ascii, but
1515+ E238 2B          >
1515+ E239             >                org     $-1                 // alter last byte of Name just above to set
1515+ E238 AB          >                db      {b $} | END_BIT     // msb as name end
1515+ E239             >
1515+ E239 2C 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1515+ E23B             >Prev_Ptr        defl    Heap_Ptr
1515+ E23B             >
1515+ E23B             >mirror_Ptr      defl    $
1515+ E23B             >
1515+ E23B 12 A1       >                dw      Dict_Ptr + 2        // xt
1515+ E23D             >Heap_Ptr        defl    $ - $E000           // save current HP
1515+ E23D             >
1515+ E23D             >Current_HP      defl  $ - $E000             // used to set HP once!
1515+ E23D             >
1515+ E23D             >//              ______________________________________________________________________
1515+ E23D             >//              Dictionary part
1515+ E23D             >
1515+ E23D             >                org     Dict_Ptr
1515+ A110             >
1515+ A110 3B 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1515+ A112             >
1515+ A112             >CELL_PLUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1515+ A112 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1515+ A112 ~           >
1515+ A112 ~           >
1515+ A112             >                endif           ; ok        // for other definitions it "points" the correct handler
1515+ A112             >                // Use of "; ok" to suppress "warning[fwdref]"
1515+ A112             >
1515+ A112             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1516+ A112 C3 0A A1                     jp      Two_Plus
1517+ A115
1518+ A115              //  ______________________________________________________________________
1519+ A115              //
1520+ A115              // align        a1 -- a2
1521+ A115              // align memory : not used
1522+ A115              //              New_Def ALIGN_ADDR, "ALIGN", is_code, is_normal
1523+ A115              //            next
1524+ A115
1525+ A115              //  ______________________________________________________________________
1526+ A115              //
1527+ A115              // cell-        a1 -- a2
1528+ A115              // decrement by 2 top of stack
1529+ A115                              New_Def CELL_MINUS, "CELL-", is_code, is_normal
1529+ A115             >
1529+ A115             >Dict_Ptr        defl    $
1529+ A115             >
1529+ A115             >//              ______________________________________________________________________
1529+ A115             >//              Heap part
1529+ A115             >
1529+ A115             >
1529+ A115             >                org     (Heap_Ptr & $1FFF) + $E000
1529+ E23D             >
1529+ E23D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1529+ E23D             >Latest_Definition defl  Heap_Ptr
1529+ E23D             >
1529+ E23D             >                // dummy db directives used to calculate length of namec
1529+ E23D 43 45 4C 4C >                db      "CELL-"
1529+ E241 2D          >
1529+ E242             >len_NFA         defl    $ - temp_NFA
1529+ E242             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1529+ E23D             >
1529+ E23D 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1529+ E23E 43 45 4C 4C >                db      "CELL-"               // name string in 7-bit ascii, but
1529+ E242 2D          >
1529+ E243             >                org     $-1                 // alter last byte of Name just above to set
1529+ E242 AD          >                db      {b $} | END_BIT     // msb as name end
1529+ E243             >
1529+ E243 33 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1529+ E245             >Prev_Ptr        defl    Heap_Ptr
1529+ E245             >
1529+ E245             >mirror_Ptr      defl    $
1529+ E245             >
1529+ E245 17 A1       >                dw      Dict_Ptr + 2        // xt
1529+ E247             >Heap_Ptr        defl    $ - $E000           // save current HP
1529+ E247             >
1529+ E247             >Current_HP      defl  $ - $E000             // used to set HP once!
1529+ E247             >
1529+ E247             >//              ______________________________________________________________________
1529+ E247             >//              Dictionary part
1529+ E247             >
1529+ E247             >                org     Dict_Ptr
1529+ A115             >
1529+ A115 45 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1529+ A117             >
1529+ A117             >CELL_MINUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1529+ A117 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1529+ A117 ~           >
1529+ A117 ~           >
1529+ A117             >                endif           ; ok        // for other definitions it "points" the correct handler
1529+ A117             >                // Use of "; ok" to suppress "warning[fwdref]"
1529+ A117             >
1529+ A117             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1530+ A117              CellMinus:
1531+ A117 E1                           pop     hl
1532+ A118 2B                           dec     hl
1533+ A119 2B                           dec     hl
1534+ A11A
1535+ A11A                              psh1
1535+ A11A E5          >                push    hl
1535+ A11B DD E9       >                jp      (ix)
1536+ A11D
1537+ A11D              //  ______________________________________________________________________
1538+ A11D              //
1539+ A11D              // 2-           a1 -- a2
1540+ A11D              // decrement by 2 top of stack
1541+ A11D                              New_Def TWO_MINUS, "2-", is_code, is_normal
1541+ A11D             >
1541+ A11D             >Dict_Ptr        defl    $
1541+ A11D             >
1541+ A11D             >//              ______________________________________________________________________
1541+ A11D             >//              Heap part
1541+ A11D             >
1541+ A11D             >
1541+ A11D             >                org     (Heap_Ptr & $1FFF) + $E000
1541+ E247             >
1541+ E247             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1541+ E247             >Latest_Definition defl  Heap_Ptr
1541+ E247             >
1541+ E247             >                // dummy db directives used to calculate length of namec
1541+ E247 32 2D       >                db      "2-"
1541+ E249             >len_NFA         defl    $ - temp_NFA
1541+ E249             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1541+ E247             >
1541+ E247 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1541+ E248 32 2D       >                db      "2-"               // name string in 7-bit ascii, but
1541+ E24A             >                org     $-1                 // alter last byte of Name just above to set
1541+ E249 AD          >                db      {b $} | END_BIT     // msb as name end
1541+ E24A             >
1541+ E24A 3D 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1541+ E24C             >Prev_Ptr        defl    Heap_Ptr
1541+ E24C             >
1541+ E24C             >mirror_Ptr      defl    $
1541+ E24C             >
1541+ E24C 1F A1       >                dw      Dict_Ptr + 2        // xt
1541+ E24E             >Heap_Ptr        defl    $ - $E000           // save current HP
1541+ E24E             >
1541+ E24E             >Current_HP      defl  $ - $E000             // used to set HP once!
1541+ E24E             >
1541+ E24E             >//              ______________________________________________________________________
1541+ E24E             >//              Dictionary part
1541+ E24E             >
1541+ E24E             >                org     Dict_Ptr
1541+ A11D             >
1541+ A11D 4C 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1541+ A11F             >
1541+ A11F             >TWO_MINUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1541+ A11F ~           >                call    runcode ; ok        // for primitive definitions  actual code
1541+ A11F ~           >
1541+ A11F ~           >
1541+ A11F             >                endif           ; ok        // for other definitions it "points" the correct handler
1541+ A11F             >                // Use of "; ok" to suppress "warning[fwdref]"
1541+ A11F             >
1541+ A11F             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1542+ A11F C3 17 A1                     jp      CellMinus
1543+ A122
1544+ A122              //  ______________________________________________________________________
1545+ A122              //
1546+ A122              // negate       n1 -- n2
1547+ A122              // change the sign of number
1548+ A122                              New_Def MINUS, "NEGATE", is_code, is_normal
1548+ A122             >
1548+ A122             >Dict_Ptr        defl    $
1548+ A122             >
1548+ A122             >//              ______________________________________________________________________
1548+ A122             >//              Heap part
1548+ A122             >
1548+ A122             >
1548+ A122             >                org     (Heap_Ptr & $1FFF) + $E000
1548+ E24E             >
1548+ E24E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1548+ E24E             >Latest_Definition defl  Heap_Ptr
1548+ E24E             >
1548+ E24E             >                // dummy db directives used to calculate length of namec
1548+ E24E 4E 45 47 41 >                db      "NEGATE"
1548+ E252 54 45       >
1548+ E254             >len_NFA         defl    $ - temp_NFA
1548+ E254             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1548+ E24E             >
1548+ E24E 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1548+ E24F 4E 45 47 41 >                db      "NEGATE"               // name string in 7-bit ascii, but
1548+ E253 54 45       >
1548+ E255             >                org     $-1                 // alter last byte of Name just above to set
1548+ E254 C5          >                db      {b $} | END_BIT     // msb as name end
1548+ E255             >
1548+ E255 47 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1548+ E257             >Prev_Ptr        defl    Heap_Ptr
1548+ E257             >
1548+ E257             >mirror_Ptr      defl    $
1548+ E257             >
1548+ E257 24 A1       >                dw      Dict_Ptr + 2        // xt
1548+ E259             >Heap_Ptr        defl    $ - $E000           // save current HP
1548+ E259             >
1548+ E259             >Current_HP      defl  $ - $E000             // used to set HP once!
1548+ E259             >
1548+ E259             >//              ______________________________________________________________________
1548+ E259             >//              Dictionary part
1548+ E259             >
1548+ E259             >                org     Dict_Ptr
1548+ A122             >
1548+ A122 57 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1548+ A124             >
1548+ A124             >MINUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1548+ A124 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1548+ A124 ~           >
1548+ A124 ~           >
1548+ A124             >                endif           ; ok        // for other definitions it "points" the correct handler
1548+ A124             >                // Use of "; ok" to suppress "warning[fwdref]"
1548+ A124             >
1548+ A124             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1549+ A124 D9                           exx
1550+ A125 21 00 00                     ld      hl, 0               // subtract from 0
1551+ A128 D1                           pop     de
1552+ A129 B7                           or      a
1553+ A12A ED 52                        sbc     hl, de
1554+ A12C E5                           push    hl
1555+ A12D D9                           exx
1556+ A12E                              next
1556+ A12E DD E9       >                jp      (ix)
1557+ A130
1558+ A130              //  ______________________________________________________________________
1559+ A130              //
1560+ A130              // dnegate      d1 -- d2
1561+ A130              // change the sign of a double number
1562+ A130                              New_Def DMINUS, "DNEGATE", is_code, is_normal
1562+ A130             >
1562+ A130             >Dict_Ptr        defl    $
1562+ A130             >
1562+ A130             >//              ______________________________________________________________________
1562+ A130             >//              Heap part
1562+ A130             >
1562+ A130             >
1562+ A130             >                org     (Heap_Ptr & $1FFF) + $E000
1562+ E259             >
1562+ E259             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1562+ E259             >Latest_Definition defl  Heap_Ptr
1562+ E259             >
1562+ E259             >                // dummy db directives used to calculate length of namec
1562+ E259 44 4E 45 47 >                db      "DNEGATE"
1562+ E25D 41 54 45    >
1562+ E260             >len_NFA         defl    $ - temp_NFA
1562+ E260             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1562+ E259             >
1562+ E259 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1562+ E25A 44 4E 45 47 >                db      "DNEGATE"               // name string in 7-bit ascii, but
1562+ E25E 41 54 45    >
1562+ E261             >                org     $-1                 // alter last byte of Name just above to set
1562+ E260 C5          >                db      {b $} | END_BIT     // msb as name end
1562+ E261             >
1562+ E261 4E 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1562+ E263             >Prev_Ptr        defl    Heap_Ptr
1562+ E263             >
1562+ E263             >mirror_Ptr      defl    $
1562+ E263             >
1562+ E263 32 A1       >                dw      Dict_Ptr + 2        // xt
1562+ E265             >Heap_Ptr        defl    $ - $E000           // save current HP
1562+ E265             >
1562+ E265             >Current_HP      defl  $ - $E000             // used to set HP once!
1562+ E265             >
1562+ E265             >//              ______________________________________________________________________
1562+ E265             >//              Dictionary part
1562+ E265             >
1562+ E265             >                org     Dict_Ptr
1562+ A130             >
1562+ A130 63 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1562+ A132             >
1562+ A132             >DMINUS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1562+ A132 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1562+ A132 ~           >
1562+ A132 ~           >
1562+ A132             >                endif           ; ok        // for other definitions it "points" the correct handler
1562+ A132             >                // Use of "; ok" to suppress "warning[fwdref]"
1562+ A132             >
1562+ A132             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1563+ A132 D9                           exx
1564+ A133 C1                           pop     bc                  // d1.H
1565+ A134 D1                           pop     de                  // d1.L
1566+ A135 AF                           xor     a
1567+ A136 67                           ld      h, a
1568+ A137 6F                           ld      l, a
1569+ A138 ED 52                        sbc     hl, de              // subtact from zero
1570+ A13A E5                           push    hl                  // > d2-L
1571+ A13B 67                           ld      h, a
1572+ A13C 6F                           ld      l, a
1573+ A13D ED 42                        sbc     hl, bc              // subtract from zero with carry
1574+ A13F                                                          // > d2-H
1575+ A13F E5                           push    hl
1576+ A140 D9                           exx
1577+ A141                              next
1577+ A141 DD E9       >                jp      (ix)
1578+ A143
1579+ A143              //  ______________________________________________________________________
1580+ A143              //
1581+ A143              // over         n1 n2 -- n1 n2 n1
1582+ A143              // copy the second value of stack and put it on top.
1583+ A143                              New_Def OVER, "OVER", is_code, is_normal
1583+ A143             >
1583+ A143             >Dict_Ptr        defl    $
1583+ A143             >
1583+ A143             >//              ______________________________________________________________________
1583+ A143             >//              Heap part
1583+ A143             >
1583+ A143             >
1583+ A143             >                org     (Heap_Ptr & $1FFF) + $E000
1583+ E265             >
1583+ E265             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1583+ E265             >Latest_Definition defl  Heap_Ptr
1583+ E265             >
1583+ E265             >                // dummy db directives used to calculate length of namec
1583+ E265 4F 56 45 52 >                db      "OVER"
1583+ E269             >len_NFA         defl    $ - temp_NFA
1583+ E269             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1583+ E265             >
1583+ E265 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1583+ E266 4F 56 45 52 >                db      "OVER"               // name string in 7-bit ascii, but
1583+ E26A             >                org     $-1                 // alter last byte of Name just above to set
1583+ E269 D2          >                db      {b $} | END_BIT     // msb as name end
1583+ E26A             >
1583+ E26A 59 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1583+ E26C             >Prev_Ptr        defl    Heap_Ptr
1583+ E26C             >
1583+ E26C             >mirror_Ptr      defl    $
1583+ E26C             >
1583+ E26C 45 A1       >                dw      Dict_Ptr + 2        // xt
1583+ E26E             >Heap_Ptr        defl    $ - $E000           // save current HP
1583+ E26E             >
1583+ E26E             >Current_HP      defl  $ - $E000             // used to set HP once!
1583+ E26E             >
1583+ E26E             >//              ______________________________________________________________________
1583+ E26E             >//              Dictionary part
1583+ E26E             >
1583+ E26E             >                org     Dict_Ptr
1583+ A143             >
1583+ A143 6C 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1583+ A145             >
1583+ A145             >OVER:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1583+ A145 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1583+ A145 ~           >
1583+ A145 ~           >
1583+ A145             >                endif           ; ok        // for other definitions it "points" the correct handler
1583+ A145             >                // Use of "; ok" to suppress "warning[fwdref]"
1583+ A145             >
1583+ A145             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1584+ A145                              // exx     // we can use af instead OPTIMIZATION possible
1585+ A145 F1                           pop     af                  //   n2
1586+ A146 E1                           pop     hl                  // < n1
1587+ A147 E5                           push    hl                  // > n1
1588+ A148 F5                           push    af                  // > n2
1589+ A149 E5                           push    hl                  // > n1
1590+ A14A                              // exx
1591+ A14A                              next
1591+ A14A DD E9       >                jp      (ix)
1592+ A14C
1593+ A14C              //  ______________________________________________________________________
1594+ A14C              //
1595+ A14C              // drop         n1 --
1596+ A14C              // drops the top of stack
1597+ A14C                              New_Def DROP, "DROP", is_code, is_normal
1597+ A14C             >
1597+ A14C             >Dict_Ptr        defl    $
1597+ A14C             >
1597+ A14C             >//              ______________________________________________________________________
1597+ A14C             >//              Heap part
1597+ A14C             >
1597+ A14C             >
1597+ A14C             >                org     (Heap_Ptr & $1FFF) + $E000
1597+ E26E             >
1597+ E26E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1597+ E26E             >Latest_Definition defl  Heap_Ptr
1597+ E26E             >
1597+ E26E             >                // dummy db directives used to calculate length of namec
1597+ E26E 44 52 4F 50 >                db      "DROP"
1597+ E272             >len_NFA         defl    $ - temp_NFA
1597+ E272             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1597+ E26E             >
1597+ E26E 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1597+ E26F 44 52 4F 50 >                db      "DROP"               // name string in 7-bit ascii, but
1597+ E273             >                org     $-1                 // alter last byte of Name just above to set
1597+ E272 D0          >                db      {b $} | END_BIT     // msb as name end
1597+ E273             >
1597+ E273 65 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1597+ E275             >Prev_Ptr        defl    Heap_Ptr
1597+ E275             >
1597+ E275             >mirror_Ptr      defl    $
1597+ E275             >
1597+ E275 4E A1       >                dw      Dict_Ptr + 2        // xt
1597+ E277             >Heap_Ptr        defl    $ - $E000           // save current HP
1597+ E277             >
1597+ E277             >Current_HP      defl  $ - $E000             // used to set HP once!
1597+ E277             >
1597+ E277             >//              ______________________________________________________________________
1597+ E277             >//              Dictionary part
1597+ E277             >
1597+ E277             >                org     Dict_Ptr
1597+ A14C             >
1597+ A14C 75 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1597+ A14E             >
1597+ A14E             >DROP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1597+ A14E ~           >                call    runcode ; ok        // for primitive definitions  actual code
1597+ A14E ~           >
1597+ A14E ~           >
1597+ A14E             >                endif           ; ok        // for other definitions it "points" the correct handler
1597+ A14E             >                // Use of "; ok" to suppress "warning[fwdref]"
1597+ A14E             >
1597+ A14E             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1598+ A14E E1                           pop     hl                  // < n1 and discard previous TOS
1599+ A14F                              next
1599+ A14F DD E9       >                jp      (ix)
1600+ A151
1601+ A151              //  ______________________________________________________________________
1602+ A151              //
1603+ A151              // nip          n1 n2 -- n2
1604+ A151              // drops the second elemento on the stack
1605+ A151                              New_Def NIP, "NIP", is_code, is_normal
1605+ A151             >
1605+ A151             >Dict_Ptr        defl    $
1605+ A151             >
1605+ A151             >//              ______________________________________________________________________
1605+ A151             >//              Heap part
1605+ A151             >
1605+ A151             >
1605+ A151             >                org     (Heap_Ptr & $1FFF) + $E000
1605+ E277             >
1605+ E277             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1605+ E277             >Latest_Definition defl  Heap_Ptr
1605+ E277             >
1605+ E277             >                // dummy db directives used to calculate length of namec
1605+ E277 4E 49 50    >                db      "NIP"
1605+ E27A             >len_NFA         defl    $ - temp_NFA
1605+ E27A             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1605+ E277             >
1605+ E277 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1605+ E278 4E 49 50    >                db      "NIP"               // name string in 7-bit ascii, but
1605+ E27B             >                org     $-1                 // alter last byte of Name just above to set
1605+ E27A D0          >                db      {b $} | END_BIT     // msb as name end
1605+ E27B             >
1605+ E27B 6E 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1605+ E27D             >Prev_Ptr        defl    Heap_Ptr
1605+ E27D             >
1605+ E27D             >mirror_Ptr      defl    $
1605+ E27D             >
1605+ E27D 53 A1       >                dw      Dict_Ptr + 2        // xt
1605+ E27F             >Heap_Ptr        defl    $ - $E000           // save current HP
1605+ E27F             >
1605+ E27F             >Current_HP      defl  $ - $E000             // used to set HP once!
1605+ E27F             >
1605+ E27F             >//              ______________________________________________________________________
1605+ E27F             >//              Dictionary part
1605+ E27F             >
1605+ E27F             >                org     Dict_Ptr
1605+ A151             >
1605+ A151 7D 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1605+ A153             >
1605+ A153             >NIP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1605+ A153 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1605+ A153 ~           >
1605+ A153 ~           >
1605+ A153             >                endif           ; ok        // for other definitions it "points" the correct handler
1605+ A153             >                // Use of "; ok" to suppress "warning[fwdref]"
1605+ A153             >
1605+ A153             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1606+ A153
1607+ A153 E1                           pop     hl                  // < n1 discarded
1608+ A154 E3                           ex      (sp), hl
1609+ A155                              next
1609+ A155 DD E9       >                jp      (ix)
1610+ A157
1611+ A157              //  ______________________________________________________________________
1612+ A157              //
1613+ A157              // tuck         n1 n2 -- n2 n1 n2
1614+ A157              // copy the top element after the second.
1615+ A157                              New_Def TUCK, "TUCK", is_code, is_normal
1615+ A157             >
1615+ A157             >Dict_Ptr        defl    $
1615+ A157             >
1615+ A157             >//              ______________________________________________________________________
1615+ A157             >//              Heap part
1615+ A157             >
1615+ A157             >
1615+ A157             >                org     (Heap_Ptr & $1FFF) + $E000
1615+ E27F             >
1615+ E27F             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1615+ E27F             >Latest_Definition defl  Heap_Ptr
1615+ E27F             >
1615+ E27F             >                // dummy db directives used to calculate length of namec
1615+ E27F 54 55 43 4B >                db      "TUCK"
1615+ E283             >len_NFA         defl    $ - temp_NFA
1615+ E283             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1615+ E27F             >
1615+ E27F 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1615+ E280 54 55 43 4B >                db      "TUCK"               // name string in 7-bit ascii, but
1615+ E284             >                org     $-1                 // alter last byte of Name just above to set
1615+ E283 CB          >                db      {b $} | END_BIT     // msb as name end
1615+ E284             >
1615+ E284 77 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1615+ E286             >Prev_Ptr        defl    Heap_Ptr
1615+ E286             >
1615+ E286             >mirror_Ptr      defl    $
1615+ E286             >
1615+ E286 59 A1       >                dw      Dict_Ptr + 2        // xt
1615+ E288             >Heap_Ptr        defl    $ - $E000           // save current HP
1615+ E288             >
1615+ E288             >Current_HP      defl  $ - $E000             // used to set HP once!
1615+ E288             >
1615+ E288             >//              ______________________________________________________________________
1615+ E288             >//              Dictionary part
1615+ E288             >
1615+ E288             >                org     Dict_Ptr
1615+ A157             >
1615+ A157 86 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1615+ A159             >
1615+ A159             >TUCK:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1615+ A159 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1615+ A159 ~           >
1615+ A159 ~           >
1615+ A159             >                endif           ; ok        // for other definitions it "points" the correct handler
1615+ A159             >                // Use of "; ok" to suppress "warning[fwdref]"
1615+ A159             >
1615+ A159             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1616+ A159 E1                           pop     hl
1617+ A15A F1                           pop     af                  // < n1
1618+ A15B E5                           push    hl                  // > n2  and TOS
1619+ A15C F5                           push    af                  // > n1
1620+ A15D E5                           push    hl
1621+ A15E                              next
1621+ A15E DD E9       >                jp      (ix)
1622+ A160
1623+ A160              //  ______________________________________________________________________
1624+ A160              //
1625+ A160              // swap         n1 n2 -- n2 n1
1626+ A160              // swaps the two values on top of stack
1627+ A160                              New_Def SWAP, "SWAP", is_code, is_normal
1627+ A160             >
1627+ A160             >Dict_Ptr        defl    $
1627+ A160             >
1627+ A160             >//              ______________________________________________________________________
1627+ A160             >//              Heap part
1627+ A160             >
1627+ A160             >
1627+ A160             >                org     (Heap_Ptr & $1FFF) + $E000
1627+ E288             >
1627+ E288             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1627+ E288             >Latest_Definition defl  Heap_Ptr
1627+ E288             >
1627+ E288             >                // dummy db directives used to calculate length of namec
1627+ E288 53 57 41 50 >                db      "SWAP"
1627+ E28C             >len_NFA         defl    $ - temp_NFA
1627+ E28C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1627+ E288             >
1627+ E288 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1627+ E289 53 57 41 50 >                db      "SWAP"               // name string in 7-bit ascii, but
1627+ E28D             >                org     $-1                 // alter last byte of Name just above to set
1627+ E28C D0          >                db      {b $} | END_BIT     // msb as name end
1627+ E28D             >
1627+ E28D 7F 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1627+ E28F             >Prev_Ptr        defl    Heap_Ptr
1627+ E28F             >
1627+ E28F             >mirror_Ptr      defl    $
1627+ E28F             >
1627+ E28F 62 A1       >                dw      Dict_Ptr + 2        // xt
1627+ E291             >Heap_Ptr        defl    $ - $E000           // save current HP
1627+ E291             >
1627+ E291             >Current_HP      defl  $ - $E000             // used to set HP once!
1627+ E291             >
1627+ E291             >//              ______________________________________________________________________
1627+ E291             >//              Dictionary part
1627+ E291             >
1627+ E291             >                org     Dict_Ptr
1627+ A160             >
1627+ A160 8F 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1627+ A162             >
1627+ A162             >SWAP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1627+ A162 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1627+ A162 ~           >
1627+ A162 ~           >
1627+ A162             >                endif           ; ok        // for other definitions it "points" the correct handler
1627+ A162             >                // Use of "; ok" to suppress "warning[fwdref]"
1627+ A162             >
1627+ A162             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1628+ A162 E1                           pop     hl                  // < n1
1629+ A163 E3                           ex      (sp),hl             // > n2
1630+ A164 E5                           push    hl                  // copy n1 to TOS
1631+ A165                              next
1631+ A165 DD E9       >                jp      (ix)
1632+ A167
1633+ A167              //  ______________________________________________________________________
1634+ A167              //
1635+ A167              // dup         n -- n n
1636+ A167              // duplicates the top value of stack
1637+ A167                              New_Def DUP, "DUP", is_code, is_normal
1637+ A167             >
1637+ A167             >Dict_Ptr        defl    $
1637+ A167             >
1637+ A167             >//              ______________________________________________________________________
1637+ A167             >//              Heap part
1637+ A167             >
1637+ A167             >
1637+ A167             >                org     (Heap_Ptr & $1FFF) + $E000
1637+ E291             >
1637+ E291             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1637+ E291             >Latest_Definition defl  Heap_Ptr
1637+ E291             >
1637+ E291             >                // dummy db directives used to calculate length of namec
1637+ E291 44 55 50    >                db      "DUP"
1637+ E294             >len_NFA         defl    $ - temp_NFA
1637+ E294             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1637+ E291             >
1637+ E291 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1637+ E292 44 55 50    >                db      "DUP"               // name string in 7-bit ascii, but
1637+ E295             >                org     $-1                 // alter last byte of Name just above to set
1637+ E294 D0          >                db      {b $} | END_BIT     // msb as name end
1637+ E295             >
1637+ E295 88 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1637+ E297             >Prev_Ptr        defl    Heap_Ptr
1637+ E297             >
1637+ E297             >mirror_Ptr      defl    $
1637+ E297             >
1637+ E297 69 A1       >                dw      Dict_Ptr + 2        // xt
1637+ E299             >Heap_Ptr        defl    $ - $E000           // save current HP
1637+ E299             >
1637+ E299             >Current_HP      defl  $ - $E000             // used to set HP once!
1637+ E299             >
1637+ E299             >//              ______________________________________________________________________
1637+ E299             >//              Dictionary part
1637+ E299             >
1637+ E299             >                org     Dict_Ptr
1637+ A167             >
1637+ A167 97 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1637+ A169             >
1637+ A169             >DUP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1637+ A169 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1637+ A169 ~           >
1637+ A169 ~           >
1637+ A169             >                endif           ; ok        // for other definitions it "points" the correct handler
1637+ A169             >                // Use of "; ok" to suppress "warning[fwdref]"
1637+ A169             >
1637+ A169             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1638+ A169 E1                           pop     hl
1639+ A16A E5                           push    hl                  // > n duplicate TOS
1640+ A16B E5                           push    hl
1641+ A16C                              next
1641+ A16C DD E9       >                jp      (ix)
1642+ A16E
1643+ A16E              //  ______________________________________________________________________
1644+ A16E              //
1645+ A16E              // rot         n1 n2 n3 -- n2 n3 n1
1646+ A16E              // Rotates the 3 top values of stack by picking the 3rd in access-order
1647+ A16E              // and putting it on top. The other two are shifted down one place.
1648+ A16E                              New_Def ROT, "ROT", is_code, is_normal
1648+ A16E             >
1648+ A16E             >Dict_Ptr        defl    $
1648+ A16E             >
1648+ A16E             >//              ______________________________________________________________________
1648+ A16E             >//              Heap part
1648+ A16E             >
1648+ A16E             >
1648+ A16E             >                org     (Heap_Ptr & $1FFF) + $E000
1648+ E299             >
1648+ E299             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1648+ E299             >Latest_Definition defl  Heap_Ptr
1648+ E299             >
1648+ E299             >                // dummy db directives used to calculate length of namec
1648+ E299 52 4F 54    >                db      "ROT"
1648+ E29C             >len_NFA         defl    $ - temp_NFA
1648+ E29C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1648+ E299             >
1648+ E299 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1648+ E29A 52 4F 54    >                db      "ROT"               // name string in 7-bit ascii, but
1648+ E29D             >                org     $-1                 // alter last byte of Name just above to set
1648+ E29C D4          >                db      {b $} | END_BIT     // msb as name end
1648+ E29D             >
1648+ E29D 91 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1648+ E29F             >Prev_Ptr        defl    Heap_Ptr
1648+ E29F             >
1648+ E29F             >mirror_Ptr      defl    $
1648+ E29F             >
1648+ E29F 70 A1       >                dw      Dict_Ptr + 2        // xt
1648+ E2A1             >Heap_Ptr        defl    $ - $E000           // save current HP
1648+ E2A1             >
1648+ E2A1             >Current_HP      defl  $ - $E000             // used to set HP once!
1648+ E2A1             >
1648+ E2A1             >//              ______________________________________________________________________
1648+ E2A1             >//              Dictionary part
1648+ E2A1             >
1648+ E2A1             >                org     Dict_Ptr
1648+ A16E             >
1648+ A16E 9F 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1648+ A170             >
1648+ A170             >ROT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1648+ A170 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1648+ A170 ~           >
1648+ A170 ~           >
1648+ A170             >                endif           ; ok        // for other definitions it "points" the correct handler
1648+ A170             >                // Use of "; ok" to suppress "warning[fwdref]"
1648+ A170             >
1648+ A170             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1649+ A170 D9                           exx
1650+ A171 D1                           pop     de                  // < n3
1651+ A172 E1                           pop     hl                  // < n2
1652+ A173 E3                           ex      (sp),hl             // > n2 < n1
1653+ A174 D5                           push    de                  // > n3
1654+ A175 E5                           push    hl                  // copy n1 to TOS
1655+ A176 D9                           exx
1656+ A177                              next
1656+ A177 DD E9       >                jp      (ix)
1657+ A179
1658+ A179              //  ______________________________________________________________________
1659+ A179              //
1660+ A179              // -rot         n1 n2 n3 -- n3 n1 n2
1661+ A179              // Rotates the 3 top values of stack by picking the 1st in access-order
1662+ A179              // and putting back to 3rd place. The other two are shifted down one place.
1663+ A179                              New_Def DASH_ROT, "-ROT", is_code, is_normal
1663+ A179             >
1663+ A179             >Dict_Ptr        defl    $
1663+ A179             >
1663+ A179             >//              ______________________________________________________________________
1663+ A179             >//              Heap part
1663+ A179             >
1663+ A179             >
1663+ A179             >                org     (Heap_Ptr & $1FFF) + $E000
1663+ E2A1             >
1663+ E2A1             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1663+ E2A1             >Latest_Definition defl  Heap_Ptr
1663+ E2A1             >
1663+ E2A1             >                // dummy db directives used to calculate length of namec
1663+ E2A1 2D 52 4F 54 >                db      "-ROT"
1663+ E2A5             >len_NFA         defl    $ - temp_NFA
1663+ E2A5             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1663+ E2A1             >
1663+ E2A1 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1663+ E2A2 2D 52 4F 54 >                db      "-ROT"               // name string in 7-bit ascii, but
1663+ E2A6             >                org     $-1                 // alter last byte of Name just above to set
1663+ E2A5 D4          >                db      {b $} | END_BIT     // msb as name end
1663+ E2A6             >
1663+ E2A6 99 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1663+ E2A8             >Prev_Ptr        defl    Heap_Ptr
1663+ E2A8             >
1663+ E2A8             >mirror_Ptr      defl    $
1663+ E2A8             >
1663+ E2A8 7B A1       >                dw      Dict_Ptr + 2        // xt
1663+ E2AA             >Heap_Ptr        defl    $ - $E000           // save current HP
1663+ E2AA             >
1663+ E2AA             >Current_HP      defl  $ - $E000             // used to set HP once!
1663+ E2AA             >
1663+ E2AA             >//              ______________________________________________________________________
1663+ E2AA             >//              Dictionary part
1663+ E2AA             >
1663+ E2AA             >                org     Dict_Ptr
1663+ A179             >
1663+ A179 A8 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1663+ A17B             >
1663+ A17B             >DASH_ROT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1663+ A17B ~           >                call    runcode ; ok        // for primitive definitions  actual code
1663+ A17B ~           >
1663+ A17B ~           >
1663+ A17B             >                endif           ; ok        // for other definitions it "points" the correct handler
1663+ A17B             >                // Use of "; ok" to suppress "warning[fwdref]"
1663+ A17B             >
1663+ A17B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1664+ A17B D9                           exx
1665+ A17C E1                           pop     hl                  // < n3
1666+ A17D D1                           pop     de                  // < n2
1667+ A17E E3                           ex      (sp),hl             // > n3 < n1
1668+ A17F E5                           push    hl                  // > n1
1669+ A180 D5                           push    de                  // copy n3 to TOS
1670+ A181 D9                           exx
1671+ A182                              next
1671+ A182 DD E9       >                jp      (ix)
1672+ A184
1673+ A184              //  ______________________________________________________________________
1674+ A184              //
1675+ A184              // pick        n1 -- nx
1676+ A184              // picks the nth element from TOS
1677+ A184                              New_Def PICK, "PICK", is_code, is_normal
1677+ A184             >
1677+ A184             >Dict_Ptr        defl    $
1677+ A184             >
1677+ A184             >//              ______________________________________________________________________
1677+ A184             >//              Heap part
1677+ A184             >
1677+ A184             >
1677+ A184             >                org     (Heap_Ptr & $1FFF) + $E000
1677+ E2AA             >
1677+ E2AA             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1677+ E2AA             >Latest_Definition defl  Heap_Ptr
1677+ E2AA             >
1677+ E2AA             >                // dummy db directives used to calculate length of namec
1677+ E2AA 50 49 43 4B >                db      "PICK"
1677+ E2AE             >len_NFA         defl    $ - temp_NFA
1677+ E2AE             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1677+ E2AA             >
1677+ E2AA 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1677+ E2AB 50 49 43 4B >                db      "PICK"               // name string in 7-bit ascii, but
1677+ E2AF             >                org     $-1                 // alter last byte of Name just above to set
1677+ E2AE CB          >                db      {b $} | END_BIT     // msb as name end
1677+ E2AF             >
1677+ E2AF A1 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1677+ E2B1             >Prev_Ptr        defl    Heap_Ptr
1677+ E2B1             >
1677+ E2B1             >mirror_Ptr      defl    $
1677+ E2B1             >
1677+ E2B1 86 A1       >                dw      Dict_Ptr + 2        // xt
1677+ E2B3             >Heap_Ptr        defl    $ - $E000           // save current HP
1677+ E2B3             >
1677+ E2B3             >Current_HP      defl  $ - $E000             // used to set HP once!
1677+ E2B3             >
1677+ E2B3             >//              ______________________________________________________________________
1677+ E2B3             >//              Dictionary part
1677+ E2B3             >
1677+ E2B3             >                org     Dict_Ptr
1677+ A184             >
1677+ A184 B1 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1677+ A186             >
1677+ A186             >PICK:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1677+ A186 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1677+ A186 ~           >
1677+ A186 ~           >
1677+ A186             >                endif           ; ok        // for other definitions it "points" the correct handler
1677+ A186             >                // Use of "; ok" to suppress "warning[fwdref]"
1677+ A186             >
1677+ A186             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1678+ A186 E1                           pop     hl                  // take TOS as index
1679+ A187 29                           add     hl, hl              // as cells
1680+ A188 39                           add     hl, sp              // from Stack Pointer
1681+ A189 7E                           ld      a, (hl)             // replace TOS
1682+ A18A 23                           inc     hl
1683+ A18B 66                           ld      h, (hl)
1684+ A18C 6F                           ld      l, a
1685+ A18D E5                           push    hl
1686+ A18E                              next
1686+ A18E DD E9       >                jp      (ix)
1687+ A190
1688+ A190
1689+ A190              //  ______________________________________________________________________
1690+ A190              //
1691+ A190              // roll        n1 n2 n3 ... n -- n2 n3 ... n1
1692+ A190              // picks the nth element from TOS
1693+ A190              //              New_Def ROLL, "ROLL", is_code, is_normal
1694+ A190              //              exx                     // we need all registers free
1695+ A190              //              pop     hl              // number of cells to roll
1696+ A190              //              ld      a, h
1697+ A190              //              or       l
1698+ A190              //              jr      z, Roll_Zero
1699+ A190              //                  add     hl, hl              // number of bytes to move
1700+ A190              //                  ld      b, h
1701+ A190              //                  ld      c, l
1702+ A190              //                  add     hl, sp          // address of n1
1703+ A190              //                  ld      a, (hl)         // take n1 into a and a,
1704+ A190              //                  inc     hl
1705+ A190              //                  ex      af, af'
1706+ A190              //                  ld      a, (hl)         // take n1 into a and a,
1707+ A190              //                  ld      d, h
1708+ A190              //                  ld      e, l
1709+ A190              //                  dec     hl
1710+ A190              //                  dec     hl
1711+ A190              //                  lddr
1712+ A190              //                  ex      de, hl
1713+ A190              //                  ld      (hl), a
1714+ A190              //                  dec     hl
1715+ A190              //                  ex      af, af'
1716+ A190              //                  ld      (hl), a
1717+ A190              //Roll_Zero:
1718+ A190              //              exx
1719+ A190              //              next
1720+ A190
1721+ A190
1722+ A190              //  ______________________________________________________________________
1723+ A190              //
1724+ A190              // 2over        d1 d2 -- d1 d2 d1
1725+ A190              //              n1 n2 n3 n4 -- n1 n2 n3 n4 n1 n2
1726+ A190              // copy the second double of stack and put on top.
1727+ A190              //              New_Def TWO_OVER, "2OVER", is_code, is_normal
1728+ A190              //              exx
1729+ A190              //              ld      hl, 7
1730+ A190              //              add     hl, sp
1731+ A190              //              ld      d, (hl)
1732+ A190              //              dec     hl
1733+ A190              //              ld      e, (hl)             // d1-L
1734+ A190              //              push    de
1735+ A190              //              dec     hl
1736+ A190              //              ld      d, (hl)
1737+ A190              //              dec     hl
1738+ A190              //              ld      e, (hl)             // d1-H
1739+ A190              //              push    de
1740+ A190              //              exx
1741+ A190              //              next
1742+ A190
1743+ A190              //  ______________________________________________________________________
1744+ A190              //
1745+ A190              // 2drop        d --
1746+ A190              //              n1 n2 --
1747+ A190              // drops the top double from stack
1748+ A190                              New_Def TWO_DROP, "2DROP", is_code, is_normal
1748+ A190             >
1748+ A190             >Dict_Ptr        defl    $
1748+ A190             >
1748+ A190             >//              ______________________________________________________________________
1748+ A190             >//              Heap part
1748+ A190             >
1748+ A190             >
1748+ A190             >                org     (Heap_Ptr & $1FFF) + $E000
1748+ E2B3             >
1748+ E2B3             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1748+ E2B3             >Latest_Definition defl  Heap_Ptr
1748+ E2B3             >
1748+ E2B3             >                // dummy db directives used to calculate length of namec
1748+ E2B3 32 44 52 4F >                db      "2DROP"
1748+ E2B7 50          >
1748+ E2B8             >len_NFA         defl    $ - temp_NFA
1748+ E2B8             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1748+ E2B3             >
1748+ E2B3 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1748+ E2B4 32 44 52 4F >                db      "2DROP"               // name string in 7-bit ascii, but
1748+ E2B8 50          >
1748+ E2B9             >                org     $-1                 // alter last byte of Name just above to set
1748+ E2B8 D0          >                db      {b $} | END_BIT     // msb as name end
1748+ E2B9             >
1748+ E2B9 AA 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1748+ E2BB             >Prev_Ptr        defl    Heap_Ptr
1748+ E2BB             >
1748+ E2BB             >mirror_Ptr      defl    $
1748+ E2BB             >
1748+ E2BB 92 A1       >                dw      Dict_Ptr + 2        // xt
1748+ E2BD             >Heap_Ptr        defl    $ - $E000           // save current HP
1748+ E2BD             >
1748+ E2BD             >Current_HP      defl  $ - $E000             // used to set HP once!
1748+ E2BD             >
1748+ E2BD             >//              ______________________________________________________________________
1748+ E2BD             >//              Dictionary part
1748+ E2BD             >
1748+ E2BD             >                org     Dict_Ptr
1748+ A190             >
1748+ A190 BB 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1748+ A192             >
1748+ A192             >TWO_DROP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1748+ A192 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1748+ A192 ~           >
1748+ A192 ~           >
1748+ A192             >                endif           ; ok        // for other definitions it "points" the correct handler
1748+ A192             >                // Use of "; ok" to suppress "warning[fwdref]"
1748+ A192             >
1748+ A192             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1749+ A192 E1                           pop     hl
1750+ A193 E1                           pop     hl
1751+ A194                              next
1751+ A194 DD E9       >                jp      (ix)
1752+ A196
1753+ A196              //  ______________________________________________________________________
1754+ A196              //
1755+ A196              // 2nip         d1 d2 -- d2
1756+ A196              //              n1 n2 n3 n4 -- n3 n4
1757+ A196              // drops the second double on the stack
1758+ A196              //              New_Def TWO_NIP, 4, "2nip"
1759+ A196              //              ...
1760+ A196
1761+ A196              //  ______________________________________________________________________
1762+ A196              //
1763+ A196              // 2tuck         d1 d2 -- d2 d1 d2
1764+ A196              // copy the top element after the second.
1765+ A196              //              New_Def TWO_TUCK, 5, "2tuck"
1766+ A196              //              ...
1767+ A196
1768+ A196              //  ______________________________________________________________________
1769+ A196              //
1770+ A196              // 2swap         d1 d2 -- d2 d1
1771+ A196              //               n1 n2 n3 n4 -- n3 n4 n1 n2
1772+ A196              // swaps the two doubles on top of stack
1773+ A196                              New_Def TWO_SWAP, "2SWAP", is_code, is_normal
1773+ A196             >
1773+ A196             >Dict_Ptr        defl    $
1773+ A196             >
1773+ A196             >//              ______________________________________________________________________
1773+ A196             >//              Heap part
1773+ A196             >
1773+ A196             >
1773+ A196             >                org     (Heap_Ptr & $1FFF) + $E000
1773+ E2BD             >
1773+ E2BD             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1773+ E2BD             >Latest_Definition defl  Heap_Ptr
1773+ E2BD             >
1773+ E2BD             >                // dummy db directives used to calculate length of namec
1773+ E2BD 32 53 57 41 >                db      "2SWAP"
1773+ E2C1 50          >
1773+ E2C2             >len_NFA         defl    $ - temp_NFA
1773+ E2C2             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1773+ E2BD             >
1773+ E2BD 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1773+ E2BE 32 53 57 41 >                db      "2SWAP"               // name string in 7-bit ascii, but
1773+ E2C2 50          >
1773+ E2C3             >                org     $-1                 // alter last byte of Name just above to set
1773+ E2C2 D0          >                db      {b $} | END_BIT     // msb as name end
1773+ E2C3             >
1773+ E2C3 B3 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1773+ E2C5             >Prev_Ptr        defl    Heap_Ptr
1773+ E2C5             >
1773+ E2C5             >mirror_Ptr      defl    $
1773+ E2C5             >
1773+ E2C5 98 A1       >                dw      Dict_Ptr + 2        // xt
1773+ E2C7             >Heap_Ptr        defl    $ - $E000           // save current HP
1773+ E2C7             >
1773+ E2C7             >Current_HP      defl  $ - $E000             // used to set HP once!
1773+ E2C7             >
1773+ E2C7             >//              ______________________________________________________________________
1773+ E2C7             >//              Dictionary part
1773+ E2C7             >
1773+ E2C7             >                org     Dict_Ptr
1773+ A196             >
1773+ A196 C5 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1773+ A198             >
1773+ A198             >TWO_SWAP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1773+ A198 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1773+ A198 ~           >
1773+ A198 ~           >
1773+ A198             >                endif           ; ok        // for other definitions it "points" the correct handler
1773+ A198             >                // Use of "; ok" to suppress "warning[fwdref]"
1773+ A198             >
1773+ A198             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1774+ A198 D9                           exx
1775+ A199 F1                           pop     af                  //   d2-H
1776+ A19A E1                           pop     hl                  // < d2-L
1777+ A19B D1                           pop     de                  // < d1-H
1778+ A19C E3                           ex      (sp), hl            // < d1-L > d2-L
1779+ A19D F5                           push    af                  // > d2-H
1780+ A19E E5                           push    hl                  // > d1-L
1781+ A19F D5                           push    de
1782+ A1A0 D9                           exx
1783+ A1A1                              next
1783+ A1A1 DD E9       >                jp      (ix)
1784+ A1A3
1785+ A1A3              //  ______________________________________________________________________
1786+ A1A3              //
1787+ A1A3              // 2dup         d -- d d
1788+ A1A3              //              n1 n2 -- n1 n2 n1 n2
1789+ A1A3              // duplicates the top double of stack
1790+ A1A3                              New_Def TWO_DUP, "2DUP", is_code, is_normal
1790+ A1A3             >
1790+ A1A3             >Dict_Ptr        defl    $
1790+ A1A3             >
1790+ A1A3             >//              ______________________________________________________________________
1790+ A1A3             >//              Heap part
1790+ A1A3             >
1790+ A1A3             >
1790+ A1A3             >                org     (Heap_Ptr & $1FFF) + $E000
1790+ E2C7             >
1790+ E2C7             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1790+ E2C7             >Latest_Definition defl  Heap_Ptr
1790+ E2C7             >
1790+ E2C7             >                // dummy db directives used to calculate length of namec
1790+ E2C7 32 44 55 50 >                db      "2DUP"
1790+ E2CB             >len_NFA         defl    $ - temp_NFA
1790+ E2CB             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1790+ E2C7             >
1790+ E2C7 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1790+ E2C8 32 44 55 50 >                db      "2DUP"               // name string in 7-bit ascii, but
1790+ E2CC             >                org     $-1                 // alter last byte of Name just above to set
1790+ E2CB D0          >                db      {b $} | END_BIT     // msb as name end
1790+ E2CC             >
1790+ E2CC BD 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1790+ E2CE             >Prev_Ptr        defl    Heap_Ptr
1790+ E2CE             >
1790+ E2CE             >mirror_Ptr      defl    $
1790+ E2CE             >
1790+ E2CE A5 A1       >                dw      Dict_Ptr + 2        // xt
1790+ E2D0             >Heap_Ptr        defl    $ - $E000           // save current HP
1790+ E2D0             >
1790+ E2D0             >Current_HP      defl  $ - $E000             // used to set HP once!
1790+ E2D0             >
1790+ E2D0             >//              ______________________________________________________________________
1790+ E2D0             >//              Dictionary part
1790+ E2D0             >
1790+ E2D0             >                org     Dict_Ptr
1790+ A1A3             >
1790+ A1A3 CE 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1790+ A1A5             >
1790+ A1A5             >TWO_DUP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1790+ A1A5 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1790+ A1A5 ~           >
1790+ A1A5 ~           >
1790+ A1A5             >                endif           ; ok        // for other definitions it "points" the correct handler
1790+ A1A5             >                // Use of "; ok" to suppress "warning[fwdref]"
1790+ A1A5             >
1790+ A1A5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1791+ A1A5 E1                           pop     hl                  // < d-H
1792+ A1A6 F1                           pop     af                  // < d-L
1793+ A1A7 F5                           push    af                  // < d-L
1794+ A1A8 E5                           push    hl                  // > d-H
1795+ A1A9 F5                           push    af                  // > d-L
1796+ A1AA E5                           push    hl                  // > d-H
1797+ A1AB                              next
1797+ A1AB DD E9       >                jp      (ix)
1798+ A1AD
1799+ A1AD              //  ______________________________________________________________________
1800+ A1AD              //
1801+ A1AD              // 2rot         d1 d2 d3 -- d2 d3 d1
1802+ A1AD              //              n1 n2 n3 n4 n5 n6 -- n3 n4 n5 n6 n1 n2
1803+ A1AD              // Rotates the 3 top doubles of stack by picking the 3rd in access-order
1804+ A1AD              // and putting it on top. The other two are shifted down one place.
1805+ A1AD              //              New_Def TWO?ROT, 4, "2rot"
1806+ A1AD              //              ...
1807+ A1AD              //              New_Def TWO_ROT, "2ROT", is_code, is_normal
1808+ A1AD              //
1809+ A1AD              //      d3  |d2  |d1  |
1810+ A1AD              //      h l |h l |h l |
1811+ A1AD              // SP   LHED|LHED|LHED|
1812+ A1AD              // SP  +0123|4567|89ab|
1813+ A1AD              //              ld      hl, $000B
1814+ A1AD              //              add     hl, sp
1815+ A1AD              //              ld      d, (hl)
1816+ A1AD              //              dec     hl
1817+ A1AD              //              ld      e, (hl)
1818+ A1AD              //              dec     hl
1819+ A1AD              //              push    de
1820+ A1AD              //              ld      d, (hl)
1821+ A1AD              //              dec     hl
1822+ A1AD              //              ld      e, (hl)
1823+ A1AD              //              dec     hl
1824+ A1AD              //              push    de
1825+ A1AD
1826+ A1AD              //      d1  |d3  |d2  |d1  |
1827+ A1AD              //      h l |h l |h l |h l |
1828+ A1AD              // SP   LHED|LHED|LHED|LHED|
1829+ A1AD              // SP       +0123|4567|89ab|
1830+ A1AD
1831+ A1AD              //              ld      d, h
1832+ A1AD              //              ld      e, l
1833+ A1AD              //              inc     de
1834+ A1AD              //              inc     de
1835+ A1AD              //              inc     de
1836+ A1AD              //              inc     de
1837+ A1AD              //              push    bc
1838+ A1AD              //              ld      bc, $000C
1839+ A1AD              //              lddr
1840+ A1AD              //              pop     bc
1841+ A1AD              //              pop     de
1842+ A1AD              //              pop     de
1843+ A1AD              //
1844+ A1AD              //              next
1845+ A1AD
1846+ A1AD
1847+ A1AD              //  ______________________________________________________________________
1848+ A1AD              //
1849+ A1AD              // +!           n a --
1850+ A1AD              // Sums to the content of address a the number n.
1851+ A1AD              // It is the same of  a @ n + a !
1852+ A1AD                              New_Def PLUSSTORE, "+!", is_code, is_normal
1852+ A1AD             >
1852+ A1AD             >Dict_Ptr        defl    $
1852+ A1AD             >
1852+ A1AD             >//              ______________________________________________________________________
1852+ A1AD             >//              Heap part
1852+ A1AD             >
1852+ A1AD             >
1852+ A1AD             >                org     (Heap_Ptr & $1FFF) + $E000
1852+ E2D0             >
1852+ E2D0             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1852+ E2D0             >Latest_Definition defl  Heap_Ptr
1852+ E2D0             >
1852+ E2D0             >                // dummy db directives used to calculate length of namec
1852+ E2D0 2B 21       >                db      "+!"
1852+ E2D2             >len_NFA         defl    $ - temp_NFA
1852+ E2D2             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1852+ E2D0             >
1852+ E2D0 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1852+ E2D1 2B 21       >                db      "+!"               // name string in 7-bit ascii, but
1852+ E2D3             >                org     $-1                 // alter last byte of Name just above to set
1852+ E2D2 A1          >                db      {b $} | END_BIT     // msb as name end
1852+ E2D3             >
1852+ E2D3 C7 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1852+ E2D5             >Prev_Ptr        defl    Heap_Ptr
1852+ E2D5             >
1852+ E2D5             >mirror_Ptr      defl    $
1852+ E2D5             >
1852+ E2D5 AF A1       >                dw      Dict_Ptr + 2        // xt
1852+ E2D7             >Heap_Ptr        defl    $ - $E000           // save current HP
1852+ E2D7             >
1852+ E2D7             >Current_HP      defl  $ - $E000             // used to set HP once!
1852+ E2D7             >
1852+ E2D7             >//              ______________________________________________________________________
1852+ E2D7             >//              Dictionary part
1852+ E2D7             >
1852+ E2D7             >                org     Dict_Ptr
1852+ A1AD             >
1852+ A1AD D5 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1852+ A1AF             >
1852+ A1AF             >PLUSSTORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1852+ A1AF ~           >                call    runcode ; ok        // for primitive definitions  actual code
1852+ A1AF ~           >
1852+ A1AF ~           >
1852+ A1AF             >                endif           ; ok        // for other definitions it "points" the correct handler
1852+ A1AF             >                // Use of "; ok" to suppress "warning[fwdref]"
1852+ A1AF             >
1852+ A1AF             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1853+ A1AF D9                           exx
1854+ A1B0 E1                           pop     hl                  // hl is the address
1855+ A1B1 D1                           pop     de                  // de is the number
1856+ A1B2 7E                           ld      a, (hl)
1857+ A1B3 83                           add     e
1858+ A1B4 77                           ld      (hl), a
1859+ A1B5 23                           inc     hl
1860+ A1B6 7E                           ld      a, (hl)
1861+ A1B7 8A                           adc     d
1862+ A1B8 77                           ld      (hl), a
1863+ A1B9 D9                           exx
1864+ A1BA                              next
1864+ A1BA DD E9       >                jp      (ix)
1865+ A1BC
1866+ A1BC              //  ______________________________________________________________________
1867+ A1BC              //
1868+ A1BC              // toggle       a n --
1869+ A1BC              // Complements (xor) the byte at addrress  a  with the model n.
1870+ A1BC                              New_Def TOGGLE, "TOGGLE", is_code, is_normal
1870+ A1BC             >
1870+ A1BC             >Dict_Ptr        defl    $
1870+ A1BC             >
1870+ A1BC             >//              ______________________________________________________________________
1870+ A1BC             >//              Heap part
1870+ A1BC             >
1870+ A1BC             >
1870+ A1BC             >                org     (Heap_Ptr & $1FFF) + $E000
1870+ E2D7             >
1870+ E2D7             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1870+ E2D7             >Latest_Definition defl  Heap_Ptr
1870+ E2D7             >
1870+ E2D7             >                // dummy db directives used to calculate length of namec
1870+ E2D7 54 4F 47 47 >                db      "TOGGLE"
1870+ E2DB 4C 45       >
1870+ E2DD             >len_NFA         defl    $ - temp_NFA
1870+ E2DD             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1870+ E2D7             >
1870+ E2D7 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1870+ E2D8 54 4F 47 47 >                db      "TOGGLE"               // name string in 7-bit ascii, but
1870+ E2DC 4C 45       >
1870+ E2DE             >                org     $-1                 // alter last byte of Name just above to set
1870+ E2DD C5          >                db      {b $} | END_BIT     // msb as name end
1870+ E2DE             >
1870+ E2DE D0 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1870+ E2E0             >Prev_Ptr        defl    Heap_Ptr
1870+ E2E0             >
1870+ E2E0             >mirror_Ptr      defl    $
1870+ E2E0             >
1870+ E2E0 BE A1       >                dw      Dict_Ptr + 2        // xt
1870+ E2E2             >Heap_Ptr        defl    $ - $E000           // save current HP
1870+ E2E2             >
1870+ E2E2             >Current_HP      defl  $ - $E000             // used to set HP once!
1870+ E2E2             >
1870+ E2E2             >//              ______________________________________________________________________
1870+ E2E2             >//              Dictionary part
1870+ E2E2             >
1870+ E2E2             >                org     Dict_Ptr
1870+ A1BC             >
1870+ A1BC E0 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1870+ A1BE             >
1870+ A1BE             >TOGGLE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1870+ A1BE ~           >                call    runcode ; ok        // for primitive definitions  actual code
1870+ A1BE ~           >
1870+ A1BE ~           >
1870+ A1BE             >                endif           ; ok        // for other definitions it "points" the correct handler
1870+ A1BE             >                // Use of "; ok" to suppress "warning[fwdref]"
1870+ A1BE             >
1870+ A1BE             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1871+ A1BE E1                           pop     hl
1872+ A1BF 7D                           ld      a, l
1873+ A1C0 E1                           pop     hl
1874+ A1C1 AE                           xor     (hl)
1875+ A1C2 77                           ld      (hl), a
1876+ A1C3
1877+ A1C3                              next
1877+ A1C3 DD E9       >                jp      (ix)
1878+ A1C5
1879+ A1C5              //  ______________________________________________________________________
1880+ A1C5              //
1881+ A1C5              // @            a -- n
1882+ A1C5              // fetch 16 bit number n from address a. Z80 keeps high byte is in high memory
1883+ A1C5                              New_Def FETCH, "@", is_code, is_normal
1883+ A1C5             >
1883+ A1C5             >Dict_Ptr        defl    $
1883+ A1C5             >
1883+ A1C5             >//              ______________________________________________________________________
1883+ A1C5             >//              Heap part
1883+ A1C5             >
1883+ A1C5             >
1883+ A1C5             >                org     (Heap_Ptr & $1FFF) + $E000
1883+ E2E2             >
1883+ E2E2             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1883+ E2E2             >Latest_Definition defl  Heap_Ptr
1883+ E2E2             >
1883+ E2E2             >                // dummy db directives used to calculate length of namec
1883+ E2E2 40          >                db      "@"
1883+ E2E3             >len_NFA         defl    $ - temp_NFA
1883+ E2E3             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1883+ E2E2             >
1883+ E2E2 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1883+ E2E3 40          >                db      "@"               // name string in 7-bit ascii, but
1883+ E2E4             >                org     $-1                 // alter last byte of Name just above to set
1883+ E2E3 C0          >                db      {b $} | END_BIT     // msb as name end
1883+ E2E4             >
1883+ E2E4 D7 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1883+ E2E6             >Prev_Ptr        defl    Heap_Ptr
1883+ E2E6             >
1883+ E2E6             >mirror_Ptr      defl    $
1883+ E2E6             >
1883+ E2E6 C7 A1       >                dw      Dict_Ptr + 2        // xt
1883+ E2E8             >Heap_Ptr        defl    $ - $E000           // save current HP
1883+ E2E8             >
1883+ E2E8             >Current_HP      defl  $ - $E000             // used to set HP once!
1883+ E2E8             >
1883+ E2E8             >//              ______________________________________________________________________
1883+ E2E8             >//              Dictionary part
1883+ E2E8             >
1883+ E2E8             >                org     Dict_Ptr
1883+ A1C5             >
1883+ A1C5 E6 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1883+ A1C7             >
1883+ A1C7             >FETCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1883+ A1C7 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1883+ A1C7 ~           >
1883+ A1C7 ~           >
1883+ A1C7             >                endif           ; ok        // for other definitions it "points" the correct handler
1883+ A1C7             >                // Use of "; ok" to suppress "warning[fwdref]"
1883+ A1C7             >
1883+ A1C7             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1884+ A1C7 E1                           pop     hl
1885+ A1C8 7E                           ld      a, (hl)             // low-byte
1886+ A1C9 23                           inc     hl
1887+ A1CA 66                           ld      h, (hl)             // high-byte
1888+ A1CB 6F                           ld      l, a
1889+ A1CC E5                           push    hl
1890+ A1CD                              next
1890+ A1CD DD E9       >                jp      (ix)
1891+ A1CF
1892+ A1CF              //  ______________________________________________________________________
1893+ A1CF              //
1894+ A1CF              // !            n a --
1895+ A1CF              // store 16 bit number n from address a. Z80 keeps high byte is in high memory
1896+ A1CF                              New_Def STORE, "!", is_code, is_normal
1896+ A1CF             >
1896+ A1CF             >Dict_Ptr        defl    $
1896+ A1CF             >
1896+ A1CF             >//              ______________________________________________________________________
1896+ A1CF             >//              Heap part
1896+ A1CF             >
1896+ A1CF             >
1896+ A1CF             >                org     (Heap_Ptr & $1FFF) + $E000
1896+ E2E8             >
1896+ E2E8             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1896+ E2E8             >Latest_Definition defl  Heap_Ptr
1896+ E2E8             >
1896+ E2E8             >                // dummy db directives used to calculate length of namec
1896+ E2E8 21          >                db      "!"
1896+ E2E9             >len_NFA         defl    $ - temp_NFA
1896+ E2E9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1896+ E2E8             >
1896+ E2E8 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1896+ E2E9 21          >                db      "!"               // name string in 7-bit ascii, but
1896+ E2EA             >                org     $-1                 // alter last byte of Name just above to set
1896+ E2E9 A1          >                db      {b $} | END_BIT     // msb as name end
1896+ E2EA             >
1896+ E2EA E2 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1896+ E2EC             >Prev_Ptr        defl    Heap_Ptr
1896+ E2EC             >
1896+ E2EC             >mirror_Ptr      defl    $
1896+ E2EC             >
1896+ E2EC D1 A1       >                dw      Dict_Ptr + 2        // xt
1896+ E2EE             >Heap_Ptr        defl    $ - $E000           // save current HP
1896+ E2EE             >
1896+ E2EE             >Current_HP      defl  $ - $E000             // used to set HP once!
1896+ E2EE             >
1896+ E2EE             >//              ______________________________________________________________________
1896+ E2EE             >//              Dictionary part
1896+ E2EE             >
1896+ E2EE             >                org     Dict_Ptr
1896+ A1CF             >
1896+ A1CF EC 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1896+ A1D1             >
1896+ A1D1             >STORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1896+ A1D1 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1896+ A1D1 ~           >
1896+ A1D1 ~           >
1896+ A1D1             >                endif           ; ok        // for other definitions it "points" the correct handler
1896+ A1D1             >                // Use of "; ok" to suppress "warning[fwdref]"
1896+ A1D1             >
1896+ A1D1             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1897+ A1D1 D9                           exx
1898+ A1D2 E1                           pop     hl                  // address
1899+ A1D3 D1                           pop     de                  // < n
1900+ A1D4 73                           ld      (hl), e             // low-byte
1901+ A1D5 23                           inc     hl
1902+ A1D6 72                           ld      (hl), d             // high-byte
1903+ A1D7 D9                           exx
1904+ A1D8                              next
1904+ A1D8 DD E9       >                jp      (ix)
1905+ A1DA
1906+ A1DA              //  ______________________________________________________________________
1907+ A1DA              //
1908+ A1DA              // c@           a -- c
1909+ A1DA              // fetch a character n from address a
1910+ A1DA                              New_Def CFETCH, "C@", is_code, is_normal
1910+ A1DA             >
1910+ A1DA             >Dict_Ptr        defl    $
1910+ A1DA             >
1910+ A1DA             >//              ______________________________________________________________________
1910+ A1DA             >//              Heap part
1910+ A1DA             >
1910+ A1DA             >
1910+ A1DA             >                org     (Heap_Ptr & $1FFF) + $E000
1910+ E2EE             >
1910+ E2EE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1910+ E2EE             >Latest_Definition defl  Heap_Ptr
1910+ E2EE             >
1910+ E2EE             >                // dummy db directives used to calculate length of namec
1910+ E2EE 43 40       >                db      "C@"
1910+ E2F0             >len_NFA         defl    $ - temp_NFA
1910+ E2F0             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1910+ E2EE             >
1910+ E2EE 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1910+ E2EF 43 40       >                db      "C@"               // name string in 7-bit ascii, but
1910+ E2F1             >                org     $-1                 // alter last byte of Name just above to set
1910+ E2F0 C0          >                db      {b $} | END_BIT     // msb as name end
1910+ E2F1             >
1910+ E2F1 E8 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1910+ E2F3             >Prev_Ptr        defl    Heap_Ptr
1910+ E2F3             >
1910+ E2F3             >mirror_Ptr      defl    $
1910+ E2F3             >
1910+ E2F3 DC A1       >                dw      Dict_Ptr + 2        // xt
1910+ E2F5             >Heap_Ptr        defl    $ - $E000           // save current HP
1910+ E2F5             >
1910+ E2F5             >Current_HP      defl  $ - $E000             // used to set HP once!
1910+ E2F5             >
1910+ E2F5             >//              ______________________________________________________________________
1910+ E2F5             >//              Dictionary part
1910+ E2F5             >
1910+ E2F5             >                org     Dict_Ptr
1910+ A1DA             >
1910+ A1DA F3 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1910+ A1DC             >
1910+ A1DC             >CFETCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1910+ A1DC ~           >                call    runcode ; ok        // for primitive definitions  actual code
1910+ A1DC ~           >
1910+ A1DC ~           >
1910+ A1DC             >                endif           ; ok        // for other definitions it "points" the correct handler
1910+ A1DC             >                // Use of "; ok" to suppress "warning[fwdref]"
1910+ A1DC             >
1910+ A1DC             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1911+ A1DC E1                           pop     hl
1912+ A1DD 6E                           ld      l, (hl)             // low-byte
1913+ A1DE 26 00                        ld      h, 0
1914+ A1E0
1915+ A1E0                              psh1
1915+ A1E0 E5          >                push    hl
1915+ A1E1 DD E9       >                jp      (ix)
1916+ A1E3
1917+ A1E3              //  ______________________________________________________________________
1918+ A1E3              //
1919+ A1E3              // c!           c a --
1920+ A1E3              // fetch 16 bit number n from address a. Z80 keeps high byte is in high memory
1921+ A1E3                              New_Def CSTORE, "C!", is_code, is_normal
1921+ A1E3             >
1921+ A1E3             >Dict_Ptr        defl    $
1921+ A1E3             >
1921+ A1E3             >//              ______________________________________________________________________
1921+ A1E3             >//              Heap part
1921+ A1E3             >
1921+ A1E3             >
1921+ A1E3             >                org     (Heap_Ptr & $1FFF) + $E000
1921+ E2F5             >
1921+ E2F5             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1921+ E2F5             >Latest_Definition defl  Heap_Ptr
1921+ E2F5             >
1921+ E2F5             >                // dummy db directives used to calculate length of namec
1921+ E2F5 43 21       >                db      "C!"
1921+ E2F7             >len_NFA         defl    $ - temp_NFA
1921+ E2F7             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1921+ E2F5             >
1921+ E2F5 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1921+ E2F6 43 21       >                db      "C!"               // name string in 7-bit ascii, but
1921+ E2F8             >                org     $-1                 // alter last byte of Name just above to set
1921+ E2F7 A1          >                db      {b $} | END_BIT     // msb as name end
1921+ E2F8             >
1921+ E2F8 EE 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1921+ E2FA             >Prev_Ptr        defl    Heap_Ptr
1921+ E2FA             >
1921+ E2FA             >mirror_Ptr      defl    $
1921+ E2FA             >
1921+ E2FA E5 A1       >                dw      Dict_Ptr + 2        // xt
1921+ E2FC             >Heap_Ptr        defl    $ - $E000           // save current HP
1921+ E2FC             >
1921+ E2FC             >Current_HP      defl  $ - $E000             // used to set HP once!
1921+ E2FC             >
1921+ E2FC             >//              ______________________________________________________________________
1921+ E2FC             >//              Dictionary part
1921+ E2FC             >
1921+ E2FC             >                org     Dict_Ptr
1921+ A1E3             >
1921+ A1E3 FA 22       >                dw      mirror_Ptr - $E000 + Heap_offset
1921+ A1E5             >
1921+ A1E5             >CSTORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1921+ A1E5 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1921+ A1E5 ~           >
1921+ A1E5 ~           >
1921+ A1E5             >                endif           ; ok        // for other definitions it "points" the correct handler
1921+ A1E5             >                // Use of "; ok" to suppress "warning[fwdref]"
1921+ A1E5             >
1921+ A1E5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1922+ A1E5 D9                           exx
1923+ A1E6 E1                           pop     hl                  // < address
1924+ A1E7 D1                           pop     de
1925+ A1E8 73                           ld      (hl), e             // low-byte
1926+ A1E9 D9                           exx
1927+ A1EA                              next
1927+ A1EA DD E9       >                jp      (ix)
1928+ A1EC
1929+ A1EC              //  ______________________________________________________________________
1930+ A1EC              //
1931+ A1EC              // 2@           a -- d
1932+ A1EC              // fetch a 32 bits number d from address a and leaves it on top of the
1933+ A1EC              // stack as two single numbers, high part as top of the stack.
1934+ A1EC              // A double number is normally kept in CPU registers as HLDE.
1935+ A1EC              // On stack a double number is treated as two single numbers
1936+ A1EC              // where BC is on the top of the stack and HL is the second from top,
1937+ A1EC              // so the sign of the number can be checked on top of stack
1938+ A1EC              // and in the stack memory it appears as LHED.
1939+ A1EC                              New_Def TWO_FETCH, "2@", is_code, is_normal
1939+ A1EC             >
1939+ A1EC             >Dict_Ptr        defl    $
1939+ A1EC             >
1939+ A1EC             >//              ______________________________________________________________________
1939+ A1EC             >//              Heap part
1939+ A1EC             >
1939+ A1EC             >
1939+ A1EC             >                org     (Heap_Ptr & $1FFF) + $E000
1939+ E2FC             >
1939+ E2FC             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1939+ E2FC             >Latest_Definition defl  Heap_Ptr
1939+ E2FC             >
1939+ E2FC             >                // dummy db directives used to calculate length of namec
1939+ E2FC 32 40       >                db      "2@"
1939+ E2FE             >len_NFA         defl    $ - temp_NFA
1939+ E2FE             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1939+ E2FC             >
1939+ E2FC 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1939+ E2FD 32 40       >                db      "2@"               // name string in 7-bit ascii, but
1939+ E2FF             >                org     $-1                 // alter last byte of Name just above to set
1939+ E2FE C0          >                db      {b $} | END_BIT     // msb as name end
1939+ E2FF             >
1939+ E2FF F5 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1939+ E301             >Prev_Ptr        defl    Heap_Ptr
1939+ E301             >
1939+ E301             >mirror_Ptr      defl    $
1939+ E301             >
1939+ E301 EE A1       >                dw      Dict_Ptr + 2        // xt
1939+ E303             >Heap_Ptr        defl    $ - $E000           // save current HP
1939+ E303             >
1939+ E303             >Current_HP      defl  $ - $E000             // used to set HP once!
1939+ E303             >
1939+ E303             >//              ______________________________________________________________________
1939+ E303             >//              Dictionary part
1939+ E303             >
1939+ E303             >                org     Dict_Ptr
1939+ A1EC             >
1939+ A1EC 01 23       >                dw      mirror_Ptr - $E000 + Heap_offset
1939+ A1EE             >
1939+ A1EE             >TWO_FETCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1939+ A1EE ~           >                call    runcode ; ok        // for primitive definitions  actual code
1939+ A1EE ~           >
1939+ A1EE ~           >
1939+ A1EE             >                endif           ; ok        // for other definitions it "points" the correct handler
1939+ A1EE             >                // Use of "; ok" to suppress "warning[fwdref]"
1939+ A1EE             >
1939+ A1EE             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1940+ A1EE D9                           exx
1941+ A1EF E1                           pop     hl                  // address
1942+ A1F0 5E                           ld      e, (hl)             // low-byte
1943+ A1F1 23                           inc     hl
1944+ A1F2 56                           ld      d, (hl)             // high-byte
1945+ A1F3 23                           inc     hl
1946+ A1F4 7E                           ld      a, (hl)             // low-byte
1947+ A1F5 23                           inc     hl
1948+ A1F6 66                           ld      h, (hl)             // high-byte
1949+ A1F7 6F                           ld      l, a
1950+ A1F8 E5                           push    hl
1951+ A1F9 D5                           push    de
1952+ A1FA D9                           exx
1953+ A1FB                              next
1953+ A1FB DD E9       >                jp      (ix)
1954+ A1FD
1955+ A1FD              //  ______________________________________________________________________
1956+ A1FD              //
1957+ A1FD              // 2!           d a --
1958+ A1FD              // stores a 32 bits number d from address a and leaves it on top of the
1959+ A1FD              // stack as two single numbers, high part as top of the stack.
1960+ A1FD              // A double number is normally kept in CPU registers as HLDE.
1961+ A1FD              // On stack a double number is treated as two single numbers
1962+ A1FD              // where BC is on the top of the stack and HL is the second from top,
1963+ A1FD              // so the sign of the number can be checked on top of stack
1964+ A1FD              // and in the stack memory it appears as LHED.
1965+ A1FD                              New_Def TWO_STORE, "2!", is_code, is_normal
1965+ A1FD             >
1965+ A1FD             >Dict_Ptr        defl    $
1965+ A1FD             >
1965+ A1FD             >//              ______________________________________________________________________
1965+ A1FD             >//              Heap part
1965+ A1FD             >
1965+ A1FD             >
1965+ A1FD             >                org     (Heap_Ptr & $1FFF) + $E000
1965+ E303             >
1965+ E303             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1965+ E303             >Latest_Definition defl  Heap_Ptr
1965+ E303             >
1965+ E303             >                // dummy db directives used to calculate length of namec
1965+ E303 32 21       >                db      "2!"
1965+ E305             >len_NFA         defl    $ - temp_NFA
1965+ E305             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1965+ E303             >
1965+ E303 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1965+ E304 32 21       >                db      "2!"               // name string in 7-bit ascii, but
1965+ E306             >                org     $-1                 // alter last byte of Name just above to set
1965+ E305 A1          >                db      {b $} | END_BIT     // msb as name end
1965+ E306             >
1965+ E306 FC 22       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1965+ E308             >Prev_Ptr        defl    Heap_Ptr
1965+ E308             >
1965+ E308             >mirror_Ptr      defl    $
1965+ E308             >
1965+ E308 FF A1       >                dw      Dict_Ptr + 2        // xt
1965+ E30A             >Heap_Ptr        defl    $ - $E000           // save current HP
1965+ E30A             >
1965+ E30A             >Current_HP      defl  $ - $E000             // used to set HP once!
1965+ E30A             >
1965+ E30A             >//              ______________________________________________________________________
1965+ E30A             >//              Dictionary part
1965+ E30A             >
1965+ E30A             >                org     Dict_Ptr
1965+ A1FD             >
1965+ A1FD 08 23       >                dw      mirror_Ptr - $E000 + Heap_offset
1965+ A1FF             >
1965+ A1FF             >TWO_STORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1965+ A1FF ~           >                call    runcode ; ok        // for primitive definitions  actual code
1965+ A1FF ~           >
1965+ A1FF ~           >
1965+ A1FF             >                endif           ; ok        // for other definitions it "points" the correct handler
1965+ A1FF             >                // Use of "; ok" to suppress "warning[fwdref]"
1965+ A1FF             >
1965+ A1FF             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1966+ A1FF D9                           exx
1967+ A200 E1                           pop     hl                  // address
1968+ A201 C1                           pop     bc                  // < high-part
1969+ A202 D1                           pop     de                  // < low-part > Instruction Pointer
1970+ A203 71                           ld      (hl), c
1971+ A204 23                           inc     hl
1972+ A205 70                           ld      (hl), b
1973+ A206 23                           inc     hl
1974+ A207 73                           ld      (hl), e
1975+ A208 23                           inc     hl
1976+ A209 72                           ld      (hl), d
1977+ A20A D9                           exx
1978+ A20B                              next
1978+ A20B DD E9       >                jp      (ix)
1979+ A20D
1980+ A20D              //  ______________________________________________________________________
1981+ A20D              //
1982+ A20D              // p@           a -- c
1983+ A20D              // Read one byte from port a and leave the result on top of stack
1984+ A20D                              New_Def PFETCH, "P@", is_code, is_normal
1984+ A20D             >
1984+ A20D             >Dict_Ptr        defl    $
1984+ A20D             >
1984+ A20D             >//              ______________________________________________________________________
1984+ A20D             >//              Heap part
1984+ A20D             >
1984+ A20D             >
1984+ A20D             >                org     (Heap_Ptr & $1FFF) + $E000
1984+ E30A             >
1984+ E30A             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1984+ E30A             >Latest_Definition defl  Heap_Ptr
1984+ E30A             >
1984+ E30A             >                // dummy db directives used to calculate length of namec
1984+ E30A 50 40       >                db      "P@"
1984+ E30C             >len_NFA         defl    $ - temp_NFA
1984+ E30C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1984+ E30A             >
1984+ E30A 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1984+ E30B 50 40       >                db      "P@"               // name string in 7-bit ascii, but
1984+ E30D             >                org     $-1                 // alter last byte of Name just above to set
1984+ E30C C0          >                db      {b $} | END_BIT     // msb as name end
1984+ E30D             >
1984+ E30D 03 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1984+ E30F             >Prev_Ptr        defl    Heap_Ptr
1984+ E30F             >
1984+ E30F             >mirror_Ptr      defl    $
1984+ E30F             >
1984+ E30F 0F A2       >                dw      Dict_Ptr + 2        // xt
1984+ E311             >Heap_Ptr        defl    $ - $E000           // save current HP
1984+ E311             >
1984+ E311             >Current_HP      defl  $ - $E000             // used to set HP once!
1984+ E311             >
1984+ E311             >//              ______________________________________________________________________
1984+ E311             >//              Dictionary part
1984+ E311             >
1984+ E311             >                org     Dict_Ptr
1984+ A20D             >
1984+ A20D 0F 23       >                dw      mirror_Ptr - $E000 + Heap_offset
1984+ A20F             >
1984+ A20F             >PFETCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1984+ A20F ~           >                call    runcode ; ok        // for primitive definitions  actual code
1984+ A20F ~           >
1984+ A20F ~           >
1984+ A20F             >                endif           ; ok        // for other definitions it "points" the correct handler
1984+ A20F             >                // Use of "; ok" to suppress "warning[fwdref]"
1984+ A20F             >
1984+ A20F             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1985+ A20F D9                           exx
1986+ A210 C1                           pop     bc
1987+ A211 26 00                        ld      h, 0
1988+ A213 ED 68                        in      l, (c)
1989+ A215 E5                           push    hl
1990+ A216 D9                           exx
1991+ A217                              next
1991+ A217 DD E9       >                jp      (ix)
1992+ A219
1993+ A219              //  ______________________________________________________________________
1994+ A219              //
1995+ A219              // p!           c a --
1996+ A219              // Send one byte (top of stack) to port a
1997+ A219                              New_Def PSTORE, "P!", is_code, is_normal
1997+ A219             >
1997+ A219             >Dict_Ptr        defl    $
1997+ A219             >
1997+ A219             >//              ______________________________________________________________________
1997+ A219             >//              Heap part
1997+ A219             >
1997+ A219             >
1997+ A219             >                org     (Heap_Ptr & $1FFF) + $E000
1997+ E311             >
1997+ E311             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1997+ E311             >Latest_Definition defl  Heap_Ptr
1997+ E311             >
1997+ E311             >                // dummy db directives used to calculate length of namec
1997+ E311 50 21       >                db      "P!"
1997+ E313             >len_NFA         defl    $ - temp_NFA
1997+ E313             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1997+ E311             >
1997+ E311 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1997+ E312 50 21       >                db      "P!"               // name string in 7-bit ascii, but
1997+ E314             >                org     $-1                 // alter last byte of Name just above to set
1997+ E313 A1          >                db      {b $} | END_BIT     // msb as name end
1997+ E314             >
1997+ E314 0A 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1997+ E316             >Prev_Ptr        defl    Heap_Ptr
1997+ E316             >
1997+ E316             >mirror_Ptr      defl    $
1997+ E316             >
1997+ E316 1B A2       >                dw      Dict_Ptr + 2        // xt
1997+ E318             >Heap_Ptr        defl    $ - $E000           // save current HP
1997+ E318             >
1997+ E318             >Current_HP      defl  $ - $E000             // used to set HP once!
1997+ E318             >
1997+ E318             >//              ______________________________________________________________________
1997+ E318             >//              Dictionary part
1997+ E318             >
1997+ E318             >                org     Dict_Ptr
1997+ A219             >
1997+ A219 16 23       >                dw      mirror_Ptr - $E000 + Heap_offset
1997+ A21B             >
1997+ A21B             >PSTORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1997+ A21B ~           >                call    runcode ; ok        // for primitive definitions  actual code
1997+ A21B ~           >
1997+ A21B ~           >
1997+ A21B             >                endif           ; ok        // for other definitions it "points" the correct handler
1997+ A21B             >                // Use of "; ok" to suppress "warning[fwdref]"
1997+ A21B             >
1997+ A21B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1998+ A21B D9                           exx
1999+ A21C C1                           pop     bc
2000+ A21D E1                           pop     hl                  // < c
2001+ A21E ED 69                        out     (c), l              // low-byte
2002+ A220 D9                           exx
2003+ A221                              next
2003+ A221 DD E9       >                jp      (ix)
2004+ A223
2005+ A223
2006+ A223              //  ______________________________________________________________________
2007+ A223              //
2008+ A223              // 2*           n1 -- n2
2009+ A223              // doubles the number at top of stack
2010+ A223                              New_Def TWO_MUL, "2*", is_code, is_normal
2010+ A223             >
2010+ A223             >Dict_Ptr        defl    $
2010+ A223             >
2010+ A223             >//              ______________________________________________________________________
2010+ A223             >//              Heap part
2010+ A223             >
2010+ A223             >
2010+ A223             >                org     (Heap_Ptr & $1FFF) + $E000
2010+ E318             >
2010+ E318             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
2010+ E318             >Latest_Definition defl  Heap_Ptr
2010+ E318             >
2010+ E318             >                // dummy db directives used to calculate length of namec
2010+ E318 32 2A       >                db      "2*"
2010+ E31A             >len_NFA         defl    $ - temp_NFA
2010+ E31A             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
2010+ E318             >
2010+ E318 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
2010+ E319 32 2A       >                db      "2*"               // name string in 7-bit ascii, but
2010+ E31B             >                org     $-1                 // alter last byte of Name just above to set
2010+ E31A AA          >                db      {b $} | END_BIT     // msb as name end
2010+ E31B             >
2010+ E31B 11 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
2010+ E31D             >Prev_Ptr        defl    Heap_Ptr
2010+ E31D             >
2010+ E31D             >mirror_Ptr      defl    $
2010+ E31D             >
2010+ E31D 25 A2       >                dw      Dict_Ptr + 2        // xt
2010+ E31F             >Heap_Ptr        defl    $ - $E000           // save current HP
2010+ E31F             >
2010+ E31F             >Current_HP      defl  $ - $E000             // used to set HP once!
2010+ E31F             >
2010+ E31F             >//              ______________________________________________________________________
2010+ E31F             >//              Dictionary part
2010+ E31F             >
2010+ E31F             >                org     Dict_Ptr
2010+ A223             >
2010+ A223 1D 23       >                dw      mirror_Ptr - $E000 + Heap_offset
2010+ A225             >
2010+ A225             >TWO_MUL:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
2010+ A225 ~           >                call    runcode ; ok        // for primitive definitions  actual code
2010+ A225 ~           >
2010+ A225 ~           >
2010+ A225             >                endif           ; ok        // for other definitions it "points" the correct handler
2010+ A225             >                // Use of "; ok" to suppress "warning[fwdref]"
2010+ A225             >
2010+ A225             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
2011+ A225              Two_Mul_Ptr:
2012+ A225 E1                           pop     hl
2013+ A226 29                           add     hl, hl
2014+ A227
2015+ A227                              psh1
2015+ A227 E5          >                push    hl
2015+ A228 DD E9       >                jp      (ix)
2016+ A22A
2017+ A22A              //  ______________________________________________________________________
2018+ A22A              //
2019+ A22A              // 2/           n1 -- n2
2020+ A22A              // halves the top of stack, sign is unchanged
2021+ A22A                              New_Def TWO_DIV, "2/", is_code, is_normal
2021+ A22A             >
2021+ A22A             >Dict_Ptr        defl    $
2021+ A22A             >
2021+ A22A             >//              ______________________________________________________________________
2021+ A22A             >//              Heap part
2021+ A22A             >
2021+ A22A             >
2021+ A22A             >                org     (Heap_Ptr & $1FFF) + $E000
2021+ E31F             >
2021+ E31F             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
2021+ E31F             >Latest_Definition defl  Heap_Ptr
2021+ E31F             >
2021+ E31F             >                // dummy db directives used to calculate length of namec
2021+ E31F 32 2F       >                db      "2/"
2021+ E321             >len_NFA         defl    $ - temp_NFA
2021+ E321             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
2021+ E31F             >
2021+ E31F 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
2021+ E320 32 2F       >                db      "2/"               // name string in 7-bit ascii, but
2021+ E322             >                org     $-1                 // alter last byte of Name just above to set
2021+ E321 AF          >                db      {b $} | END_BIT     // msb as name end
2021+ E322             >
2021+ E322 18 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
2021+ E324             >Prev_Ptr        defl    Heap_Ptr
2021+ E324             >
2021+ E324             >mirror_Ptr      defl    $
2021+ E324             >
2021+ E324 2C A2       >                dw      Dict_Ptr + 2        // xt
2021+ E326             >Heap_Ptr        defl    $ - $E000           // save current HP
2021+ E326             >
2021+ E326             >Current_HP      defl  $ - $E000             // used to set HP once!
2021+ E326             >
2021+ E326             >//              ______________________________________________________________________
2021+ E326             >//              Dictionary part
2021+ E326             >
2021+ E326             >                org     Dict_Ptr
2021+ A22A             >
2021+ A22A 24 23       >                dw      mirror_Ptr - $E000 + Heap_offset
2021+ A22C             >
2021+ A22C             >TWO_DIV:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
2021+ A22C ~           >                call    runcode ; ok        // for primitive definitions  actual code
2021+ A22C ~           >
2021+ A22C ~           >
2021+ A22C             >                endif           ; ok        // for other definitions it "points" the correct handler
2021+ A22C             >                // Use of "; ok" to suppress "warning[fwdref]"
2021+ A22C             >
2021+ A22C             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
2022+ A22C E1                           pop     hl
2023+ A22D CB 2C                        sra     h
2024+ A22F CB 1D                        rr      l
2025+ A231
2026+ A231                              psh1
2026+ A231 E5          >                push    hl
2026+ A232 DD E9       >                jp      (ix)
2027+ A234
2028+ A234              //  ______________________________________________________________________
2029+ A234              //
2030+ A234              // lshift       n1 u -- n2
2031+ A234              // bit left shift of u bits
2032+ A234                              New_Def LSHIFT, "LSHIFT", is_code, is_normal
2032+ A234             >
2032+ A234             >Dict_Ptr        defl    $
2032+ A234             >
2032+ A234             >//              ______________________________________________________________________
2032+ A234             >//              Heap part
2032+ A234             >
2032+ A234             >
2032+ A234             >                org     (Heap_Ptr & $1FFF) + $E000
2032+ E326             >
2032+ E326             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
2032+ E326             >Latest_Definition defl  Heap_Ptr
2032+ E326             >
2032+ E326             >                // dummy db directives used to calculate length of namec
2032+ E326 4C 53 48 49 >                db      "LSHIFT"
2032+ E32A 46 54       >
2032+ E32C             >len_NFA         defl    $ - temp_NFA
2032+ E32C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
2032+ E326             >
2032+ E326 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
2032+ E327 4C 53 48 49 >                db      "LSHIFT"               // name string in 7-bit ascii, but
2032+ E32B 46 54       >
2032+ E32D             >                org     $-1                 // alter last byte of Name just above to set
2032+ E32C D4          >                db      {b $} | END_BIT     // msb as name end
2032+ E32D             >
2032+ E32D 1F 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
2032+ E32F             >Prev_Ptr        defl    Heap_Ptr
2032+ E32F             >
2032+ E32F             >mirror_Ptr      defl    $
2032+ E32F             >
2032+ E32F 36 A2       >                dw      Dict_Ptr + 2        // xt
2032+ E331             >Heap_Ptr        defl    $ - $E000           // save current HP
2032+ E331             >
2032+ E331             >Current_HP      defl  $ - $E000             // used to set HP once!
2032+ E331             >
2032+ E331             >//              ______________________________________________________________________
2032+ E331             >//              Dictionary part
2032+ E331             >
2032+ E331             >                org     Dict_Ptr
2032+ A234             >
2032+ A234 2F 23       >                dw      mirror_Ptr - $E000 + Heap_offset
2032+ A236             >
2032+ A236             >LSHIFT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
2032+ A236 ~           >                call    runcode ; ok        // for primitive definitions  actual code
2032+ A236 ~           >
2032+ A236 ~           >
2032+ A236             >                endif           ; ok        // for other definitions it "points" the correct handler
2032+ A236             >                // Use of "; ok" to suppress "warning[fwdref]"
2032+ A236             >
2032+ A236             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
2033+ A236 D9                           exx
2034+ A237 C1                           pop     bc
2035+ A238 41                           ld      b, c
2036+ A239 D1                           pop     de
2037+ A23A ED 28                        bsla    de, b
2038+ A23C D5                           push    de
2039+ A23D D9                           exx
2040+ A23E                              next
2040+ A23E DD E9       >                jp      (ix)
2041+ A240
2042+ A240              //  ______________________________________________________________________
2043+ A240              //
2044+ A240              // rshift       n1 u -- n2
2045+ A240              // bit right shift of u bits
2046+ A240                              New_Def RSHIFT, "RSHIFT", is_code, is_normal
2046+ A240             >
2046+ A240             >Dict_Ptr        defl    $
2046+ A240             >
2046+ A240             >//              ______________________________________________________________________
2046+ A240             >//              Heap part
2046+ A240             >
2046+ A240             >
2046+ A240             >                org     (Heap_Ptr & $1FFF) + $E000
2046+ E331             >
2046+ E331             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
2046+ E331             >Latest_Definition defl  Heap_Ptr
2046+ E331             >
2046+ E331             >                // dummy db directives used to calculate length of namec
2046+ E331 52 53 48 49 >                db      "RSHIFT"
2046+ E335 46 54       >
2046+ E337             >len_NFA         defl    $ - temp_NFA
2046+ E337             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
2046+ E331             >
2046+ E331 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
2046+ E332 52 53 48 49 >                db      "RSHIFT"               // name string in 7-bit ascii, but
2046+ E336 46 54       >
2046+ E338             >                org     $-1                 // alter last byte of Name just above to set
2046+ E337 D4          >                db      {b $} | END_BIT     // msb as name end
2046+ E338             >
2046+ E338 26 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
2046+ E33A             >Prev_Ptr        defl    Heap_Ptr
2046+ E33A             >
2046+ E33A             >mirror_Ptr      defl    $
2046+ E33A             >
2046+ E33A 42 A2       >                dw      Dict_Ptr + 2        // xt
2046+ E33C             >Heap_Ptr        defl    $ - $E000           // save current HP
2046+ E33C             >
2046+ E33C             >Current_HP      defl  $ - $E000             // used to set HP once!
2046+ E33C             >
2046+ E33C             >//              ______________________________________________________________________
2046+ E33C             >//              Dictionary part
2046+ E33C             >
2046+ E33C             >                org     Dict_Ptr
2046+ A240             >
2046+ A240 3A 23       >                dw      mirror_Ptr - $E000 + Heap_offset
2046+ A242             >
2046+ A242             >RSHIFT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
2046+ A242 ~           >                call    runcode ; ok        // for primitive definitions  actual code
2046+ A242 ~           >
2046+ A242 ~           >
2046+ A242             >                endif           ; ok        // for other definitions it "points" the correct handler
2046+ A242             >                // Use of "; ok" to suppress "warning[fwdref]"
2046+ A242             >
2046+ A242             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
2047+ A242 D9                           exx
2048+ A243 C1                           pop     bc
2049+ A244 41                           ld      b, c
2050+ A245 D1                           pop     de
2051+ A246 ED 2A                        bsrl    de, b
2052+ A248 D5                           push    de
2053+ A249 D9                           exx
2054+ A24A                              next
2054+ A24A DD E9       >                jp      (ix)
2055+ A24C
2056+ A24C              //  ______________________________________________________________________
2057+ A24C              //
2058+ A24C              // cells        n1 -- n2
2059+ A24C              // decrement by 2 top of stack
2060+ A24C                              New_Def CELLS, "CELLS", is_code, is_normal
2060+ A24C             >
2060+ A24C             >Dict_Ptr        defl    $
2060+ A24C             >
2060+ A24C             >//              ______________________________________________________________________
2060+ A24C             >//              Heap part
2060+ A24C             >
2060+ A24C             >
2060+ A24C             >                org     (Heap_Ptr & $1FFF) + $E000
2060+ E33C             >
2060+ E33C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
2060+ E33C             >Latest_Definition defl  Heap_Ptr
2060+ E33C             >
2060+ E33C             >                // dummy db directives used to calculate length of namec
2060+ E33C 43 45 4C 4C >                db      "CELLS"
2060+ E340 53          >
2060+ E341             >len_NFA         defl    $ - temp_NFA
2060+ E341             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
2060+ E33C             >
2060+ E33C 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
2060+ E33D 43 45 4C 4C >                db      "CELLS"               // name string in 7-bit ascii, but
2060+ E341 53          >
2060+ E342             >                org     $-1                 // alter last byte of Name just above to set
2060+ E341 D3          >                db      {b $} | END_BIT     // msb as name end
2060+ E342             >
2060+ E342 31 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
2060+ E344             >Prev_Ptr        defl    Heap_Ptr
2060+ E344             >
2060+ E344             >mirror_Ptr      defl    $
2060+ E344             >
2060+ E344 4E A2       >                dw      Dict_Ptr + 2        // xt
2060+ E346             >Heap_Ptr        defl    $ - $E000           // save current HP
2060+ E346             >
2060+ E346             >Current_HP      defl  $ - $E000             // used to set HP once!
2060+ E346             >
2060+ E346             >//              ______________________________________________________________________
2060+ E346             >//              Dictionary part
2060+ E346             >
2060+ E346             >                org     Dict_Ptr
2060+ A24C             >
2060+ A24C 44 23       >                dw      mirror_Ptr - $E000 + Heap_offset
2060+ A24E             >
2060+ A24E             >CELLS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
2060+ A24E ~           >                call    runcode ; ok        // for primitive definitions  actual code
2060+ A24E ~           >
2060+ A24E ~           >
2060+ A24E             >                endif           ; ok        // for other definitions it "points" the correct handler
2060+ A24E             >                // Use of "; ok" to suppress "warning[fwdref]"
2060+ A24E             >
2060+ A24E             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
2061+ A24E C3 25 A2                     jp      Two_Mul_Ptr
2062+ A251
2063+ A251
2064+ A251              //  ______________________________________________________________________
2065+ A251
# file closed: C:\Zx\CSpect\Projects\vForth17_MMU7/source/L0.asm
 121  A251                              include "L1.asm"
# file opened: C:\Zx\CSpect\Projects\vForth17_MMU7/source/L1.asm
   1+ A251              //  ______________________________________________________________________
   2+ A251              //
   3+ A251              //  L1.asm
   4+ A251              //
   5+ A251              //  Level-1 definitions and derivate
   6+ A251              //  ______________________________________________________________________
   7+ A251
   8+ A251              //  ______________________________________________________________________
   9+ A251              //
  10+ A251              // :            -- cccc     ( compile time )
  11+ A251              //              i*x -- j*x  ( run time )
  12+ A251              // Colon Definition
  13+ A251                              Colon_Def COLON, ":", is_normal      // has forward-ref
  13+ A251             >                New_Def  COLON, ":", Enter_Ptr, is_normal ; ok
  13+ A251             >
  13+ A251             >Dict_Ptr        defl    $
  13+ A251             >
  13+ A251             >//              ______________________________________________________________________
  13+ A251             >//              Heap part
  13+ A251             >
  13+ A251             >
  13+ A251             >                org     (Heap_Ptr & $1FFF) + $E000
  13+ E346             >
  13+ E346             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  13+ E346             >Latest_Definition defl  Heap_Ptr
  13+ E346             >
  13+ E346             >                // dummy db directives used to calculate length of namec
  13+ E346 3A          >                db      ":"
  13+ E347             >len_NFA         defl    $ - temp_NFA
  13+ E347             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  13+ E346             >
  13+ E346 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  13+ E347 3A          >                db      ":"               // name string in 7-bit ascii, but
  13+ E348             >                org     $-1                 // alter last byte of Name just above to set
  13+ E347 BA          >                db      {b $} | END_BIT     // msb as name end
  13+ E348             >
  13+ E348 3C 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
  13+ E34A             >Prev_Ptr        defl    Heap_Ptr
  13+ E34A             >
  13+ E34A             >mirror_Ptr      defl    $
  13+ E34A             >
  13+ E34A 53 A2       >                dw      Dict_Ptr + 2        // xt
  13+ E34C             >Heap_Ptr        defl    $ - $E000           // save current HP
  13+ E34C             >
  13+ E34C             >Current_HP      defl  $ - $E000             // used to set HP once!
  13+ E34C             >
  13+ E34C             >//              ______________________________________________________________________
  13+ E34C             >//              Dictionary part
  13+ E34C             >
  13+ E34C             >                org     Dict_Ptr
  13+ A251             >
  13+ A251 4A 23       >                dw      mirror_Ptr - $E000 + Heap_offset
  13+ A253             >
  13+ A253             >COLON:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
  13+ A253 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
  13+ A256             >
  13+ A256             >
  13+ A256             >                endif           ; ok        // for other definitions it "points" the correct handler
  13+ A256             >                // Use of "; ok" to suppress "warning[fwdref]"
  13+ A256             >
  13+ A256             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  14+ A256
  15+ A256 48 A6                        dw      QEXEC                   // ?exec
  16+ A258 13 A6                        dw      STORE_CSP               // !csp
  17+ A25A 84 A3 C7 A1                  dw      CURRENT, FETCH          // current @
  18+ A25E 7E A3 D1 A1                  dw      CONTEXT, STORE          // context !
  19+ A262 EE AB                        dw      CREATE                  // create  ( forward )
  20+ A264 CC A6                        dw      SMUDGE                  // dmudge
  21+ A266 BD A6                        dw      SQUARED_CLOSE           // ]
  22+ A268 08 A7                        dw      C_SEMICOLON_CODE        // ;code ( change the 3-bytes CFA of defining word to call Enter_Ptr )
  23+ A26A                                                              // ... immediate
  24+ A26A              Enter_Ptr:
  25+ A26A                              // via call coded in CFA
  26+ A26A EB                           ex      de, hl //**
  27+ A26B                              // *** ldhlrp
  28+ A26B 2B                           dec     hl                  // push on Return-Stack current Instruction-Pointer
  29+ A26C 70                           ld      (hl), b
  30+ A26D 2B                           dec     hl
  31+ A26E 71                           ld      (hl), c
  32+ A26F                              // *** ldrphl
  33+ A26F EB                           ex      de, hl //**
  34+ A270
  35+ A270
  36+ A270 C1                           pop     bc                  // points to PFA of "this" word
  37+ A271                              next
  37+ A271 DD E9       >                jp      (ix)
  38+ A273
  39+ A273              //  ______________________________________________________________________
  40+ A273              //
  41+ A273              // ;            --
  42+ A273              // Semicolon. End of Colon-Definition. Stack must be balanced.
  43+ A273                              Colon_Def SEMICOLON, ";", is_immediate   // has forward-ref
  43+ A273             >                New_Def  SEMICOLON, ";", Enter_Ptr, is_immediate ; ok
  43+ A273             >
  43+ A273             >Dict_Ptr        defl    $
  43+ A273             >
  43+ A273             >//              ______________________________________________________________________
  43+ A273             >//              Heap part
  43+ A273             >
  43+ A273             >
  43+ A273             >                org     (Heap_Ptr & $1FFF) + $E000
  43+ E34C             >
  43+ E34C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  43+ E34C             >Latest_Definition defl  Heap_Ptr
  43+ E34C             >
  43+ E34C             >                // dummy db directives used to calculate length of namec
  43+ E34C 3B          >                db      ";"
  43+ E34D             >len_NFA         defl    $ - temp_NFA
  43+ E34D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  43+ E34C             >
  43+ E34C C1          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
  43+ E34D 3B          >                db      ";"               // name string in 7-bit ascii, but
  43+ E34E             >                org     $-1                 // alter last byte of Name just above to set
  43+ E34D BB          >                db      {b $} | END_BIT     // msb as name end
  43+ E34E             >
  43+ E34E 46 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
  43+ E350             >Prev_Ptr        defl    Heap_Ptr
  43+ E350             >
  43+ E350             >mirror_Ptr      defl    $
  43+ E350             >
  43+ E350 75 A2       >                dw      Dict_Ptr + 2        // xt
  43+ E352             >Heap_Ptr        defl    $ - $E000           // save current HP
  43+ E352             >
  43+ E352             >Current_HP      defl  $ - $E000             // used to set HP once!
  43+ E352             >
  43+ E352             >//              ______________________________________________________________________
  43+ E352             >//              Dictionary part
  43+ E352             >
  43+ E352             >                org     Dict_Ptr
  43+ A273             >
  43+ A273 50 23       >                dw      mirror_Ptr - $E000 + Heap_offset
  43+ A275             >
  43+ A275             >SEMICOLON:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
  43+ A275 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
  43+ A278             >
  43+ A278             >
  43+ A278             >                endif           ; ok        // for other definitions it "points" the correct handler
  43+ A278             >                // Use of "; ok" to suppress "warning[fwdref]"
  43+ A278             >
  43+ A278             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  44+ A278
  45+ A278 68 A6                        dw      QCSP                    // ?csp
  46+ A27A 90 A6 90 A0                  dw      COMPILE, EXIT           // [compile] ;s
  47+ A27E CC A6                        dw      SMUDGE                  // smudge
  48+ A280 B0 A6                        dw      SQUARED_OPEN            // [
  49+ A282 90 A0                        dw      EXIT                    // ; immediate
  50+ A284
  51+ A284              //  ______________________________________________________________________
  52+ A284              //
  53+ A284              // noop         --
  54+ A284
  55+ A284                              New_Def NOOP, "NOOP", is_code, is_normal
  55+ A284             >
  55+ A284             >Dict_Ptr        defl    $
  55+ A284             >
  55+ A284             >//              ______________________________________________________________________
  55+ A284             >//              Heap part
  55+ A284             >
  55+ A284             >
  55+ A284             >                org     (Heap_Ptr & $1FFF) + $E000
  55+ E352             >
  55+ E352             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  55+ E352             >Latest_Definition defl  Heap_Ptr
  55+ E352             >
  55+ E352             >                // dummy db directives used to calculate length of namec
  55+ E352 4E 4F 4F 50 >                db      "NOOP"
  55+ E356             >len_NFA         defl    $ - temp_NFA
  55+ E356             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  55+ E352             >
  55+ E352 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  55+ E353 4E 4F 4F 50 >                db      "NOOP"               // name string in 7-bit ascii, but
  55+ E357             >                org     $-1                 // alter last byte of Name just above to set
  55+ E356 D0          >                db      {b $} | END_BIT     // msb as name end
  55+ E357             >
  55+ E357 4C 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
  55+ E359             >Prev_Ptr        defl    Heap_Ptr
  55+ E359             >
  55+ E359             >mirror_Ptr      defl    $
  55+ E359             >
  55+ E359 86 A2       >                dw      Dict_Ptr + 2        // xt
  55+ E35B             >Heap_Ptr        defl    $ - $E000           // save current HP
  55+ E35B             >
  55+ E35B             >Current_HP      defl  $ - $E000             // used to set HP once!
  55+ E35B             >
  55+ E35B             >//              ______________________________________________________________________
  55+ E35B             >//              Dictionary part
  55+ E35B             >
  55+ E35B             >                org     Dict_Ptr
  55+ A284             >
  55+ A284 59 23       >                dw      mirror_Ptr - $E000 + Heap_offset
  55+ A286             >
  55+ A286             >NOOP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
  55+ A286 ~           >                call    runcode ; ok        // for primitive definitions  actual code
  55+ A286 ~           >
  55+ A286 ~           >
  55+ A286             >                endif           ; ok        // for other definitions it "points" the correct handler
  55+ A286             >                // Use of "; ok" to suppress "warning[fwdref]"
  55+ A286             >
  55+ A286             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  56+ A286                              next
  56+ A286 DD E9       >                jp      (ix)
  57+ A288
  58+ A288              //  ______________________________________________________________________
  59+ A288              //
  60+ A288              // constant     n -- cccc     ( compile time )
  61+ A288              //              -- n          ( run time )
  62+ A288              // Constant definition.
  63+ A288                              Colon_Def CONSTANT, "CONSTANT", is_normal   // has forward-ref
  63+ A288             >                New_Def  CONSTANT, "CONSTANT", Enter_Ptr, is_normal ; ok
  63+ A288             >
  63+ A288             >Dict_Ptr        defl    $
  63+ A288             >
  63+ A288             >//              ______________________________________________________________________
  63+ A288             >//              Heap part
  63+ A288             >
  63+ A288             >
  63+ A288             >                org     (Heap_Ptr & $1FFF) + $E000
  63+ E35B             >
  63+ E35B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  63+ E35B             >Latest_Definition defl  Heap_Ptr
  63+ E35B             >
  63+ E35B             >                // dummy db directives used to calculate length of namec
  63+ E35B 43 4F 4E 53 >                db      "CONSTANT"
  63+ E35F 54 41 4E 54 >
  63+ E363             >len_NFA         defl    $ - temp_NFA
  63+ E363             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  63+ E35B             >
  63+ E35B 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  63+ E35C 43 4F 4E 53 >                db      "CONSTANT"               // name string in 7-bit ascii, but
  63+ E360 54 41 4E 54 >
  63+ E364             >                org     $-1                 // alter last byte of Name just above to set
  63+ E363 D4          >                db      {b $} | END_BIT     // msb as name end
  63+ E364             >
  63+ E364 52 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
  63+ E366             >Prev_Ptr        defl    Heap_Ptr
  63+ E366             >
  63+ E366             >mirror_Ptr      defl    $
  63+ E366             >
  63+ E366 8A A2       >                dw      Dict_Ptr + 2        // xt
  63+ E368             >Heap_Ptr        defl    $ - $E000           // save current HP
  63+ E368             >
  63+ E368             >Current_HP      defl  $ - $E000             // used to set HP once!
  63+ E368             >
  63+ E368             >//              ______________________________________________________________________
  63+ E368             >//              Dictionary part
  63+ E368             >
  63+ E368             >                org     Dict_Ptr
  63+ A288             >
  63+ A288 66 23       >                dw      mirror_Ptr - $E000 + Heap_offset
  63+ A28A             >
  63+ A28A             >CONSTANT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
  63+ A28A CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
  63+ A28D             >
  63+ A28D             >
  63+ A28D             >                endif           ; ok        // for other definitions it "points" the correct handler
  63+ A28D             >                // Use of "; ok" to suppress "warning[fwdref]"
  63+ A28D             >
  63+ A28D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  64+ A28D EE AB                        dw      CREATE                  // create
  65+ A28F FA A3                        dw      COMMA                   // ,    ( at PFA then, store the value )
  66+ A291 08 A7                        dw      C_SEMICOLON_CODE        // ;code (  changes the 3-bytes CFA to call Constant_Ptr )
  67+ A293              Constant_Ptr:
  68+ A293
  69+ A293
  70+ A293 E1                           pop     hl
  71+ A294
  72+ A294 7E                           ld      a, (hl)
  73+ A295 23                           inc     hl
  74+ A296 66                           ld      h, (hl)
  75+ A297 6F                           ld      l, a
  76+ A298 E5                           push    hl
  77+ A299                              next
  77+ A299 DD E9       >                jp      (ix)
  78+ A29B
  79+ A29B              //  ______________________________________________________________________
  80+ A29B              //
  81+ A29B              // variable     n -- cccc     ( compile time )
  82+ A29B              //              -- a          ( run time )
  83+ A29B              // Variable definition, n is the initial value.
  84+ A29B                              Colon_Def VARIABLE, "VARIABLE", is_normal   // has forward-ref
  84+ A29B             >                New_Def  VARIABLE, "VARIABLE", Enter_Ptr, is_normal ; ok
  84+ A29B             >
  84+ A29B             >Dict_Ptr        defl    $
  84+ A29B             >
  84+ A29B             >//              ______________________________________________________________________
  84+ A29B             >//              Heap part
  84+ A29B             >
  84+ A29B             >
  84+ A29B             >                org     (Heap_Ptr & $1FFF) + $E000
  84+ E368             >
  84+ E368             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  84+ E368             >Latest_Definition defl  Heap_Ptr
  84+ E368             >
  84+ E368             >                // dummy db directives used to calculate length of namec
  84+ E368 56 41 52 49 >                db      "VARIABLE"
  84+ E36C 41 42 4C 45 >
  84+ E370             >len_NFA         defl    $ - temp_NFA
  84+ E370             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  84+ E368             >
  84+ E368 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  84+ E369 56 41 52 49 >                db      "VARIABLE"               // name string in 7-bit ascii, but
  84+ E36D 41 42 4C 45 >
  84+ E371             >                org     $-1                 // alter last byte of Name just above to set
  84+ E370 C5          >                db      {b $} | END_BIT     // msb as name end
  84+ E371             >
  84+ E371 5B 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
  84+ E373             >Prev_Ptr        defl    Heap_Ptr
  84+ E373             >
  84+ E373             >mirror_Ptr      defl    $
  84+ E373             >
  84+ E373 9D A2       >                dw      Dict_Ptr + 2        // xt
  84+ E375             >Heap_Ptr        defl    $ - $E000           // save current HP
  84+ E375             >
  84+ E375             >Current_HP      defl  $ - $E000             // used to set HP once!
  84+ E375             >
  84+ E375             >//              ______________________________________________________________________
  84+ E375             >//              Dictionary part
  84+ E375             >
  84+ E375             >                org     Dict_Ptr
  84+ A29B             >
  84+ A29B 73 23       >                dw      mirror_Ptr - $E000 + Heap_offset
  84+ A29D             >
  84+ A29D             >VARIABLE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
  84+ A29D CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
  84+ A2A0             >
  84+ A2A0             >
  84+ A2A0             >                endif           ; ok        // for other definitions it "points" the correct handler
  84+ A2A0             >                // Use of "; ok" to suppress "warning[fwdref]"
  84+ A2A0             >
  84+ A2A0             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  85+ A2A0
  86+ A2A0 BF A2                        dw      ZERO
  87+ A2A2 8A A2                        dw      CONSTANT                // constant
  88+ A2A4 08 A7                        dw      C_SEMICOLON_CODE        // ;code ( changes the 3-bytes CFA to call Variable_Ptr )
  89+ A2A6              Variable_Ptr:
  90+ A2A6
  91+ A2A6
  92+ A2A6
  93+ A2A6
  94+ A2A6                              next
  94+ A2A6 DD E9       >                jp      (ix)
  95+ A2A8
  96+ A2A8              //  ______________________________________________________________________
  97+ A2A8              //
  98+ A2A8              // user         b -- cccc     ( compile time )
  99+ A2A8              //              -- a          ( run time )
 100+ A2A8              // User variable definition
 101+ A2A8                              Colon_Def USER, "USER", is_normal
 101+ A2A8             >                New_Def  USER, "USER", Enter_Ptr, is_normal ; ok
 101+ A2A8             >
 101+ A2A8             >Dict_Ptr        defl    $
 101+ A2A8             >
 101+ A2A8             >//              ______________________________________________________________________
 101+ A2A8             >//              Heap part
 101+ A2A8             >
 101+ A2A8             >
 101+ A2A8             >                org     (Heap_Ptr & $1FFF) + $E000
 101+ E375             >
 101+ E375             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 101+ E375             >Latest_Definition defl  Heap_Ptr
 101+ E375             >
 101+ E375             >                // dummy db directives used to calculate length of namec
 101+ E375 55 53 45 52 >                db      "USER"
 101+ E379             >len_NFA         defl    $ - temp_NFA
 101+ E379             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 101+ E375             >
 101+ E375 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 101+ E376 55 53 45 52 >                db      "USER"               // name string in 7-bit ascii, but
 101+ E37A             >                org     $-1                 // alter last byte of Name just above to set
 101+ E379 D2          >                db      {b $} | END_BIT     // msb as name end
 101+ E37A             >
 101+ E37A 68 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 101+ E37C             >Prev_Ptr        defl    Heap_Ptr
 101+ E37C             >
 101+ E37C             >mirror_Ptr      defl    $
 101+ E37C             >
 101+ E37C AA A2       >                dw      Dict_Ptr + 2        // xt
 101+ E37E             >Heap_Ptr        defl    $ - $E000           // save current HP
 101+ E37E             >
 101+ E37E             >Current_HP      defl  $ - $E000             // used to set HP once!
 101+ E37E             >
 101+ E37E             >//              ______________________________________________________________________
 101+ E37E             >//              Dictionary part
 101+ E37E             >
 101+ E37E             >                org     Dict_Ptr
 101+ A2A8             >
 101+ A2A8 7C 23       >                dw      mirror_Ptr - $E000 + Heap_offset
 101+ A2AA             >
 101+ A2AA             >USER:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 101+ A2AA CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 101+ A2AD             >
 101+ A2AD             >
 101+ A2AD             >                endif           ; ok        // for other definitions it "points" the correct handler
 101+ A2AD             >                // Use of "; ok" to suppress "warning[fwdref]"
 101+ A2AD             >
 101+ A2AD             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 102+ A2AD
 103+ A2AD EE AB                        dw      CREATE                  // create
 104+ A2AF 09 A4                        dw      CCOMMA                  // c,
 105+ A2B1 08 A7                        dw      C_SEMICOLON_CODE        // ;code () changes the 3-bytes CFA to call User_Ptr )
 106+ A2B3
 107+ A2B3
 108+ A2B3              User_Ptr:
 109+ A2B3                              // via call coded in CFA
 110+ A2B3 E1                           pop     hl
 111+ A2B4
 112+ A2B4 7E                           ld      a, (hl)
 113+ A2B5 2A D2 9B                     ld      hl, (USER_Pointer)
 114+ A2B8 ED 31                        add     hl, a
 115+ A2BA E5                           push    hl
 116+ A2BB                              next
 116+ A2BB DD E9       >                jp      (ix)
 117+ A2BD
 118+ A2BD              //  ______________________________________________________________________
 119+ A2BD              //
 120+ A2BD                              Constant_Def ZERO       ,   "0"     ,   0
 120+ A2BD             >                New_Def  ZERO, "0", Constant_Ptr, is_normal
 120+ A2BD             >
 120+ A2BD             >Dict_Ptr        defl    $
 120+ A2BD             >
 120+ A2BD             >//              ______________________________________________________________________
 120+ A2BD             >//              Heap part
 120+ A2BD             >
 120+ A2BD             >
 120+ A2BD             >                org     (Heap_Ptr & $1FFF) + $E000
 120+ E37E             >
 120+ E37E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 120+ E37E             >Latest_Definition defl  Heap_Ptr
 120+ E37E             >
 120+ E37E             >                // dummy db directives used to calculate length of namec
 120+ E37E 30          >                db      "0"
 120+ E37F             >len_NFA         defl    $ - temp_NFA
 120+ E37F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 120+ E37E             >
 120+ E37E 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 120+ E37F 30          >                db      "0"               // name string in 7-bit ascii, but
 120+ E380             >                org     $-1                 // alter last byte of Name just above to set
 120+ E37F B0          >                db      {b $} | END_BIT     // msb as name end
 120+ E380             >
 120+ E380 75 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 120+ E382             >Prev_Ptr        defl    Heap_Ptr
 120+ E382             >
 120+ E382             >mirror_Ptr      defl    $
 120+ E382             >
 120+ E382 BF A2       >                dw      Dict_Ptr + 2        // xt
 120+ E384             >Heap_Ptr        defl    $ - $E000           // save current HP
 120+ E384             >
 120+ E384             >Current_HP      defl  $ - $E000             // used to set HP once!
 120+ E384             >
 120+ E384             >//              ______________________________________________________________________
 120+ E384             >//              Dictionary part
 120+ E384             >
 120+ E384             >                org     Dict_Ptr
 120+ A2BD             >
 120+ A2BD 82 23       >                dw      mirror_Ptr - $E000 + Heap_offset
 120+ A2BF             >
 120+ A2BF             >ZERO:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 120+ A2BF CD 93 A2    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 120+ A2C2             >
 120+ A2C2             >
 120+ A2C2             >                endif           ; ok        // for other definitions it "points" the correct handler
 120+ A2C2             >                // Use of "; ok" to suppress "warning[fwdref]"
 120+ A2C2             >
 120+ A2C2             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 120+ A2C2 00 00       >                dw      0
 121+ A2C4                              Constant_Def ONE        ,   "1"     ,   1
 121+ A2C4             >                New_Def  ONE, "1", Constant_Ptr, is_normal
 121+ A2C4             >
 121+ A2C4             >Dict_Ptr        defl    $
 121+ A2C4             >
 121+ A2C4             >//              ______________________________________________________________________
 121+ A2C4             >//              Heap part
 121+ A2C4             >
 121+ A2C4             >
 121+ A2C4             >                org     (Heap_Ptr & $1FFF) + $E000
 121+ E384             >
 121+ E384             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 121+ E384             >Latest_Definition defl  Heap_Ptr
 121+ E384             >
 121+ E384             >                // dummy db directives used to calculate length of namec
 121+ E384 31          >                db      "1"
 121+ E385             >len_NFA         defl    $ - temp_NFA
 121+ E385             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 121+ E384             >
 121+ E384 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 121+ E385 31          >                db      "1"               // name string in 7-bit ascii, but
 121+ E386             >                org     $-1                 // alter last byte of Name just above to set
 121+ E385 B1          >                db      {b $} | END_BIT     // msb as name end
 121+ E386             >
 121+ E386 7E 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 121+ E388             >Prev_Ptr        defl    Heap_Ptr
 121+ E388             >
 121+ E388             >mirror_Ptr      defl    $
 121+ E388             >
 121+ E388 C6 A2       >                dw      Dict_Ptr + 2        // xt
 121+ E38A             >Heap_Ptr        defl    $ - $E000           // save current HP
 121+ E38A             >
 121+ E38A             >Current_HP      defl  $ - $E000             // used to set HP once!
 121+ E38A             >
 121+ E38A             >//              ______________________________________________________________________
 121+ E38A             >//              Dictionary part
 121+ E38A             >
 121+ E38A             >                org     Dict_Ptr
 121+ A2C4             >
 121+ A2C4 88 23       >                dw      mirror_Ptr - $E000 + Heap_offset
 121+ A2C6             >
 121+ A2C6             >ONE:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 121+ A2C6 CD 93 A2    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 121+ A2C9             >
 121+ A2C9             >
 121+ A2C9             >                endif           ; ok        // for other definitions it "points" the correct handler
 121+ A2C9             >                // Use of "; ok" to suppress "warning[fwdref]"
 121+ A2C9             >
 121+ A2C9             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 121+ A2C9 01 00       >                dw      1
 122+ A2CB                              Constant_Def TWO        ,   "2"     ,   2
 122+ A2CB             >                New_Def  TWO, "2", Constant_Ptr, is_normal
 122+ A2CB             >
 122+ A2CB             >Dict_Ptr        defl    $
 122+ A2CB             >
 122+ A2CB             >//              ______________________________________________________________________
 122+ A2CB             >//              Heap part
 122+ A2CB             >
 122+ A2CB             >
 122+ A2CB             >                org     (Heap_Ptr & $1FFF) + $E000
 122+ E38A             >
 122+ E38A             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 122+ E38A             >Latest_Definition defl  Heap_Ptr
 122+ E38A             >
 122+ E38A             >                // dummy db directives used to calculate length of namec
 122+ E38A 32          >                db      "2"
 122+ E38B             >len_NFA         defl    $ - temp_NFA
 122+ E38B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 122+ E38A             >
 122+ E38A 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 122+ E38B 32          >                db      "2"               // name string in 7-bit ascii, but
 122+ E38C             >                org     $-1                 // alter last byte of Name just above to set
 122+ E38B B2          >                db      {b $} | END_BIT     // msb as name end
 122+ E38C             >
 122+ E38C 84 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 122+ E38E             >Prev_Ptr        defl    Heap_Ptr
 122+ E38E             >
 122+ E38E             >mirror_Ptr      defl    $
 122+ E38E             >
 122+ E38E CD A2       >                dw      Dict_Ptr + 2        // xt
 122+ E390             >Heap_Ptr        defl    $ - $E000           // save current HP
 122+ E390             >
 122+ E390             >Current_HP      defl  $ - $E000             // used to set HP once!
 122+ E390             >
 122+ E390             >//              ______________________________________________________________________
 122+ E390             >//              Dictionary part
 122+ E390             >
 122+ E390             >                org     Dict_Ptr
 122+ A2CB             >
 122+ A2CB 8E 23       >                dw      mirror_Ptr - $E000 + Heap_offset
 122+ A2CD             >
 122+ A2CD             >TWO:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 122+ A2CD CD 93 A2    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 122+ A2D0             >
 122+ A2D0             >
 122+ A2D0             >                endif           ; ok        // for other definitions it "points" the correct handler
 122+ A2D0             >                // Use of "; ok" to suppress "warning[fwdref]"
 122+ A2D0             >
 122+ A2D0             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 122+ A2D0 02 00       >                dw      2
 123+ A2D2                              Constant_Def THREE      ,   "3"     ,   3
 123+ A2D2             >                New_Def  THREE, "3", Constant_Ptr, is_normal
 123+ A2D2             >
 123+ A2D2             >Dict_Ptr        defl    $
 123+ A2D2             >
 123+ A2D2             >//              ______________________________________________________________________
 123+ A2D2             >//              Heap part
 123+ A2D2             >
 123+ A2D2             >
 123+ A2D2             >                org     (Heap_Ptr & $1FFF) + $E000
 123+ E390             >
 123+ E390             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 123+ E390             >Latest_Definition defl  Heap_Ptr
 123+ E390             >
 123+ E390             >                // dummy db directives used to calculate length of namec
 123+ E390 33          >                db      "3"
 123+ E391             >len_NFA         defl    $ - temp_NFA
 123+ E391             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 123+ E390             >
 123+ E390 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 123+ E391 33          >                db      "3"               // name string in 7-bit ascii, but
 123+ E392             >                org     $-1                 // alter last byte of Name just above to set
 123+ E391 B3          >                db      {b $} | END_BIT     // msb as name end
 123+ E392             >
 123+ E392 8A 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 123+ E394             >Prev_Ptr        defl    Heap_Ptr
 123+ E394             >
 123+ E394             >mirror_Ptr      defl    $
 123+ E394             >
 123+ E394 D4 A2       >                dw      Dict_Ptr + 2        // xt
 123+ E396             >Heap_Ptr        defl    $ - $E000           // save current HP
 123+ E396             >
 123+ E396             >Current_HP      defl  $ - $E000             // used to set HP once!
 123+ E396             >
 123+ E396             >//              ______________________________________________________________________
 123+ E396             >//              Dictionary part
 123+ E396             >
 123+ E396             >                org     Dict_Ptr
 123+ A2D2             >
 123+ A2D2 94 23       >                dw      mirror_Ptr - $E000 + Heap_offset
 123+ A2D4             >
 123+ A2D4             >THREE:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 123+ A2D4 CD 93 A2    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 123+ A2D7             >
 123+ A2D7             >
 123+ A2D7             >                endif           ; ok        // for other definitions it "points" the correct handler
 123+ A2D7             >                // Use of "; ok" to suppress "warning[fwdref]"
 123+ A2D7             >
 123+ A2D7             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 123+ A2D7 03 00       >                dw      3
 124+ A2D9                              Constant_Def NEG_ONE    ,   "-1"    ,  -1
 124+ A2D9             >                New_Def  NEG_ONE, "-1", Constant_Ptr, is_normal
 124+ A2D9             >
 124+ A2D9             >Dict_Ptr        defl    $
 124+ A2D9             >
 124+ A2D9             >//              ______________________________________________________________________
 124+ A2D9             >//              Heap part
 124+ A2D9             >
 124+ A2D9             >
 124+ A2D9             >                org     (Heap_Ptr & $1FFF) + $E000
 124+ E396             >
 124+ E396             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 124+ E396             >Latest_Definition defl  Heap_Ptr
 124+ E396             >
 124+ E396             >                // dummy db directives used to calculate length of namec
 124+ E396 2D 31       >                db      "-1"
 124+ E398             >len_NFA         defl    $ - temp_NFA
 124+ E398             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 124+ E396             >
 124+ E396 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 124+ E397 2D 31       >                db      "-1"               // name string in 7-bit ascii, but
 124+ E399             >                org     $-1                 // alter last byte of Name just above to set
 124+ E398 B1          >                db      {b $} | END_BIT     // msb as name end
 124+ E399             >
 124+ E399 90 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 124+ E39B             >Prev_Ptr        defl    Heap_Ptr
 124+ E39B             >
 124+ E39B             >mirror_Ptr      defl    $
 124+ E39B             >
 124+ E39B DB A2       >                dw      Dict_Ptr + 2        // xt
 124+ E39D             >Heap_Ptr        defl    $ - $E000           // save current HP
 124+ E39D             >
 124+ E39D             >Current_HP      defl  $ - $E000             // used to set HP once!
 124+ E39D             >
 124+ E39D             >//              ______________________________________________________________________
 124+ E39D             >//              Dictionary part
 124+ E39D             >
 124+ E39D             >                org     Dict_Ptr
 124+ A2D9             >
 124+ A2D9 9B 23       >                dw      mirror_Ptr - $E000 + Heap_offset
 124+ A2DB             >
 124+ A2DB             >NEG_ONE:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 124+ A2DB CD 93 A2    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 124+ A2DE             >
 124+ A2DE             >
 124+ A2DE             >                endif           ; ok        // for other definitions it "points" the correct handler
 124+ A2DE             >                // Use of "; ok" to suppress "warning[fwdref]"
 124+ A2DE             >
 124+ A2DE             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 124+ A2DE FF FF       >                dw      -1
 125+ A2E0                              Constant_Def BL         ,   "BL"    , $20
 125+ A2E0             >                New_Def  BL, "BL", Constant_Ptr, is_normal
 125+ A2E0             >
 125+ A2E0             >Dict_Ptr        defl    $
 125+ A2E0             >
 125+ A2E0             >//              ______________________________________________________________________
 125+ A2E0             >//              Heap part
 125+ A2E0             >
 125+ A2E0             >
 125+ A2E0             >                org     (Heap_Ptr & $1FFF) + $E000
 125+ E39D             >
 125+ E39D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 125+ E39D             >Latest_Definition defl  Heap_Ptr
 125+ E39D             >
 125+ E39D             >                // dummy db directives used to calculate length of namec
 125+ E39D 42 4C       >                db      "BL"
 125+ E39F             >len_NFA         defl    $ - temp_NFA
 125+ E39F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 125+ E39D             >
 125+ E39D 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 125+ E39E 42 4C       >                db      "BL"               // name string in 7-bit ascii, but
 125+ E3A0             >                org     $-1                 // alter last byte of Name just above to set
 125+ E39F CC          >                db      {b $} | END_BIT     // msb as name end
 125+ E3A0             >
 125+ E3A0 96 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 125+ E3A2             >Prev_Ptr        defl    Heap_Ptr
 125+ E3A2             >
 125+ E3A2             >mirror_Ptr      defl    $
 125+ E3A2             >
 125+ E3A2 E2 A2       >                dw      Dict_Ptr + 2        // xt
 125+ E3A4             >Heap_Ptr        defl    $ - $E000           // save current HP
 125+ E3A4             >
 125+ E3A4             >Current_HP      defl  $ - $E000             // used to set HP once!
 125+ E3A4             >
 125+ E3A4             >//              ______________________________________________________________________
 125+ E3A4             >//              Dictionary part
 125+ E3A4             >
 125+ E3A4             >                org     Dict_Ptr
 125+ A2E0             >
 125+ A2E0 A2 23       >                dw      mirror_Ptr - $E000 + Heap_offset
 125+ A2E2             >
 125+ A2E2             >BL:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 125+ A2E2 CD 93 A2    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 125+ A2E5             >
 125+ A2E5             >
 125+ A2E5             >                endif           ; ok        // for other definitions it "points" the correct handler
 125+ A2E5             >                // Use of "; ok" to suppress "warning[fwdref]"
 125+ A2E5             >
 125+ A2E5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 125+ A2E5 20 00       >                dw      $20
 126+ A2E7                              Constant_Def CL         ,   "C/L"   ,  64
 126+ A2E7             >                New_Def  CL, "C/L", Constant_Ptr, is_normal
 126+ A2E7             >
 126+ A2E7             >Dict_Ptr        defl    $
 126+ A2E7             >
 126+ A2E7             >//              ______________________________________________________________________
 126+ A2E7             >//              Heap part
 126+ A2E7             >
 126+ A2E7             >
 126+ A2E7             >                org     (Heap_Ptr & $1FFF) + $E000
 126+ E3A4             >
 126+ E3A4             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 126+ E3A4             >Latest_Definition defl  Heap_Ptr
 126+ E3A4             >
 126+ E3A4             >                // dummy db directives used to calculate length of namec
 126+ E3A4 43 2F 4C    >                db      "C/L"
 126+ E3A7             >len_NFA         defl    $ - temp_NFA
 126+ E3A7             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 126+ E3A4             >
 126+ E3A4 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 126+ E3A5 43 2F 4C    >                db      "C/L"               // name string in 7-bit ascii, but
 126+ E3A8             >                org     $-1                 // alter last byte of Name just above to set
 126+ E3A7 CC          >                db      {b $} | END_BIT     // msb as name end
 126+ E3A8             >
 126+ E3A8 9D 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 126+ E3AA             >Prev_Ptr        defl    Heap_Ptr
 126+ E3AA             >
 126+ E3AA             >mirror_Ptr      defl    $
 126+ E3AA             >
 126+ E3AA E9 A2       >                dw      Dict_Ptr + 2        // xt
 126+ E3AC             >Heap_Ptr        defl    $ - $E000           // save current HP
 126+ E3AC             >
 126+ E3AC             >Current_HP      defl  $ - $E000             // used to set HP once!
 126+ E3AC             >
 126+ E3AC             >//              ______________________________________________________________________
 126+ E3AC             >//              Dictionary part
 126+ E3AC             >
 126+ E3AC             >                org     Dict_Ptr
 126+ A2E7             >
 126+ A2E7 AA 23       >                dw      mirror_Ptr - $E000 + Heap_offset
 126+ A2E9             >
 126+ A2E9             >CL:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 126+ A2E9 CD 93 A2    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 126+ A2EC             >
 126+ A2EC             >
 126+ A2EC             >                endif           ; ok        // for other definitions it "points" the correct handler
 126+ A2EC             >                // Use of "; ok" to suppress "warning[fwdref]"
 126+ A2EC             >
 126+ A2EC             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 126+ A2EC 40 00       >                dw      64
 127+ A2EE                              Constant_Def BBUF       ,   "B/BUF" , 512
 127+ A2EE             >                New_Def  BBUF, "B/BUF", Constant_Ptr, is_normal
 127+ A2EE             >
 127+ A2EE             >Dict_Ptr        defl    $
 127+ A2EE             >
 127+ A2EE             >//              ______________________________________________________________________
 127+ A2EE             >//              Heap part
 127+ A2EE             >
 127+ A2EE             >
 127+ A2EE             >                org     (Heap_Ptr & $1FFF) + $E000
 127+ E3AC             >
 127+ E3AC             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 127+ E3AC             >Latest_Definition defl  Heap_Ptr
 127+ E3AC             >
 127+ E3AC             >                // dummy db directives used to calculate length of namec
 127+ E3AC 42 2F 42 55 >                db      "B/BUF"
 127+ E3B0 46          >
 127+ E3B1             >len_NFA         defl    $ - temp_NFA
 127+ E3B1             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 127+ E3AC             >
 127+ E3AC 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 127+ E3AD 42 2F 42 55 >                db      "B/BUF"               // name string in 7-bit ascii, but
 127+ E3B1 46          >
 127+ E3B2             >                org     $-1                 // alter last byte of Name just above to set
 127+ E3B1 C6          >                db      {b $} | END_BIT     // msb as name end
 127+ E3B2             >
 127+ E3B2 A4 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 127+ E3B4             >Prev_Ptr        defl    Heap_Ptr
 127+ E3B4             >
 127+ E3B4             >mirror_Ptr      defl    $
 127+ E3B4             >
 127+ E3B4 F0 A2       >                dw      Dict_Ptr + 2        // xt
 127+ E3B6             >Heap_Ptr        defl    $ - $E000           // save current HP
 127+ E3B6             >
 127+ E3B6             >Current_HP      defl  $ - $E000             // used to set HP once!
 127+ E3B6             >
 127+ E3B6             >//              ______________________________________________________________________
 127+ E3B6             >//              Dictionary part
 127+ E3B6             >
 127+ E3B6             >                org     Dict_Ptr
 127+ A2EE             >
 127+ A2EE B4 23       >                dw      mirror_Ptr - $E000 + Heap_offset
 127+ A2F0             >
 127+ A2F0             >BBUF:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 127+ A2F0 CD 93 A2    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 127+ A2F3             >
 127+ A2F3             >
 127+ A2F3             >                endif           ; ok        // for other definitions it "points" the correct handler
 127+ A2F3             >                // Use of "; ok" to suppress "warning[fwdref]"
 127+ A2F3             >
 127+ A2F3             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 127+ A2F3 00 02       >                dw      512
 128+ A2F5                              Constant_Def BSCR       ,   "B/SCR" ,   2
 128+ A2F5             >                New_Def  BSCR, "B/SCR", Constant_Ptr, is_normal
 128+ A2F5             >
 128+ A2F5             >Dict_Ptr        defl    $
 128+ A2F5             >
 128+ A2F5             >//              ______________________________________________________________________
 128+ A2F5             >//              Heap part
 128+ A2F5             >
 128+ A2F5             >
 128+ A2F5             >                org     (Heap_Ptr & $1FFF) + $E000
 128+ E3B6             >
 128+ E3B6             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 128+ E3B6             >Latest_Definition defl  Heap_Ptr
 128+ E3B6             >
 128+ E3B6             >                // dummy db directives used to calculate length of namec
 128+ E3B6 42 2F 53 43 >                db      "B/SCR"
 128+ E3BA 52          >
 128+ E3BB             >len_NFA         defl    $ - temp_NFA
 128+ E3BB             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 128+ E3B6             >
 128+ E3B6 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 128+ E3B7 42 2F 53 43 >                db      "B/SCR"               // name string in 7-bit ascii, but
 128+ E3BB 52          >
 128+ E3BC             >                org     $-1                 // alter last byte of Name just above to set
 128+ E3BB D2          >                db      {b $} | END_BIT     // msb as name end
 128+ E3BC             >
 128+ E3BC AC 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 128+ E3BE             >Prev_Ptr        defl    Heap_Ptr
 128+ E3BE             >
 128+ E3BE             >mirror_Ptr      defl    $
 128+ E3BE             >
 128+ E3BE F7 A2       >                dw      Dict_Ptr + 2        // xt
 128+ E3C0             >Heap_Ptr        defl    $ - $E000           // save current HP
 128+ E3C0             >
 128+ E3C0             >Current_HP      defl  $ - $E000             // used to set HP once!
 128+ E3C0             >
 128+ E3C0             >//              ______________________________________________________________________
 128+ E3C0             >//              Dictionary part
 128+ E3C0             >
 128+ E3C0             >                org     Dict_Ptr
 128+ A2F5             >
 128+ A2F5 BE 23       >                dw      mirror_Ptr - $E000 + Heap_offset
 128+ A2F7             >
 128+ A2F7             >BSCR:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 128+ A2F7 CD 93 A2    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 128+ A2FA             >
 128+ A2FA             >
 128+ A2FA             >                endif           ; ok        // for other definitions it "points" the correct handler
 128+ A2FA             >                // Use of "; ok" to suppress "warning[fwdref]"
 128+ A2FA             >
 128+ A2FA             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 128+ A2FA 02 00       >                dw      2
 129+ A2FC                              Constant_Def LSCR       ,   "L/SCR" ,  16
 129+ A2FC             >                New_Def  LSCR, "L/SCR", Constant_Ptr, is_normal
 129+ A2FC             >
 129+ A2FC             >Dict_Ptr        defl    $
 129+ A2FC             >
 129+ A2FC             >//              ______________________________________________________________________
 129+ A2FC             >//              Heap part
 129+ A2FC             >
 129+ A2FC             >
 129+ A2FC             >                org     (Heap_Ptr & $1FFF) + $E000
 129+ E3C0             >
 129+ E3C0             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 129+ E3C0             >Latest_Definition defl  Heap_Ptr
 129+ E3C0             >
 129+ E3C0             >                // dummy db directives used to calculate length of namec
 129+ E3C0 4C 2F 53 43 >                db      "L/SCR"
 129+ E3C4 52          >
 129+ E3C5             >len_NFA         defl    $ - temp_NFA
 129+ E3C5             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 129+ E3C0             >
 129+ E3C0 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 129+ E3C1 4C 2F 53 43 >                db      "L/SCR"               // name string in 7-bit ascii, but
 129+ E3C5 52          >
 129+ E3C6             >                org     $-1                 // alter last byte of Name just above to set
 129+ E3C5 D2          >                db      {b $} | END_BIT     // msb as name end
 129+ E3C6             >
 129+ E3C6 B6 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 129+ E3C8             >Prev_Ptr        defl    Heap_Ptr
 129+ E3C8             >
 129+ E3C8             >mirror_Ptr      defl    $
 129+ E3C8             >
 129+ E3C8 FE A2       >                dw      Dict_Ptr + 2        // xt
 129+ E3CA             >Heap_Ptr        defl    $ - $E000           // save current HP
 129+ E3CA             >
 129+ E3CA             >Current_HP      defl  $ - $E000             // used to set HP once!
 129+ E3CA             >
 129+ E3CA             >//              ______________________________________________________________________
 129+ E3CA             >//              Dictionary part
 129+ E3CA             >
 129+ E3CA             >                org     Dict_Ptr
 129+ A2FC             >
 129+ A2FC C8 23       >                dw      mirror_Ptr - $E000 + Heap_offset
 129+ A2FE             >
 129+ A2FE             >LSCR:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 129+ A2FE CD 93 A2    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 129+ A301             >
 129+ A301             >
 129+ A301             >                endif           ; ok        // for other definitions it "points" the correct handler
 129+ A301             >                // Use of "; ok" to suppress "warning[fwdref]"
 129+ A301             >
 129+ A301             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 129+ A301 10 00       >                dw      16
 130+ A303
 131+ A303              //  ______________________________________________________________________
 132+ A303              //
 133+ A303              // +origin         --
 134+ A303              //              Colon_Def PLUS_ORIGIN, "+ORIGIN", is_normal
 135+ A303              //              dw      LIT, Cold_origin        // [ hex 6366 ] literal
 136+ A303              //              dw      PLUS                    // +
 137+ A303              //              dw      EXIT                    // ;
 138+ A303                              New_Def  PLUS_ORIGIN, "+ORIGIN", is_code, is_normal
 138+ A303             >
 138+ A303             >Dict_Ptr        defl    $
 138+ A303             >
 138+ A303             >//              ______________________________________________________________________
 138+ A303             >//              Heap part
 138+ A303             >
 138+ A303             >
 138+ A303             >                org     (Heap_Ptr & $1FFF) + $E000
 138+ E3CA             >
 138+ E3CA             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 138+ E3CA             >Latest_Definition defl  Heap_Ptr
 138+ E3CA             >
 138+ E3CA             >                // dummy db directives used to calculate length of namec
 138+ E3CA 2B 4F 52 49 >                db      "+ORIGIN"
 138+ E3CE 47 49 4E    >
 138+ E3D1             >len_NFA         defl    $ - temp_NFA
 138+ E3D1             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 138+ E3CA             >
 138+ E3CA 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 138+ E3CB 2B 4F 52 49 >                db      "+ORIGIN"               // name string in 7-bit ascii, but
 138+ E3CF 47 49 4E    >
 138+ E3D2             >                org     $-1                 // alter last byte of Name just above to set
 138+ E3D1 CE          >                db      {b $} | END_BIT     // msb as name end
 138+ E3D2             >
 138+ E3D2 C0 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 138+ E3D4             >Prev_Ptr        defl    Heap_Ptr
 138+ E3D4             >
 138+ E3D4             >mirror_Ptr      defl    $
 138+ E3D4             >
 138+ E3D4 05 A3       >                dw      Dict_Ptr + 2        // xt
 138+ E3D6             >Heap_Ptr        defl    $ - $E000           // save current HP
 138+ E3D6             >
 138+ E3D6             >Current_HP      defl  $ - $E000             // used to set HP once!
 138+ E3D6             >
 138+ E3D6             >//              ______________________________________________________________________
 138+ E3D6             >//              Dictionary part
 138+ E3D6             >
 138+ E3D6             >                org     Dict_Ptr
 138+ A303             >
 138+ A303 D4 23       >                dw      mirror_Ptr - $E000 + Heap_offset
 138+ A305             >
 138+ A305             >PLUS_ORIGIN:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 138+ A305 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 138+ A305 ~           >
 138+ A305 ~           >
 138+ A305             >                endif           ; ok        // for other definitions it "points" the correct handler
 138+ A305             >                // Use of "; ok" to suppress "warning[fwdref]"
 138+ A305             >
 138+ A305             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 139+ A305 D9                           exx
 140+ A306 E1                           pop     hl
 141+ A307 11 A4 9B                     ld      de, Cold_origin
 142+ A30A 19                           add     hl, de
 143+ A30B E5                           push    hl
 144+ A30C D9                           exx
 145+ A30D                              next
 145+ A30D DD E9       >                jp      (ix)
 146+ A30F
 147+ A30F
 148+ A30F              //  ______________________________________________________________________
 149+ A30F              //
 150+ A30F                              Constant_Def CNEXT      ,   "(NEXT)", Next_Ptr
 150+ A30F             >                New_Def  CNEXT, "(NEXT)", Constant_Ptr, is_normal
 150+ A30F             >
 150+ A30F             >Dict_Ptr        defl    $
 150+ A30F             >
 150+ A30F             >//              ______________________________________________________________________
 150+ A30F             >//              Heap part
 150+ A30F             >
 150+ A30F             >
 150+ A30F             >                org     (Heap_Ptr & $1FFF) + $E000
 150+ E3D6             >
 150+ E3D6             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 150+ E3D6             >Latest_Definition defl  Heap_Ptr
 150+ E3D6             >
 150+ E3D6             >                // dummy db directives used to calculate length of namec
 150+ E3D6 28 4E 45 58 >                db      "(NEXT)"
 150+ E3DA 54 29       >
 150+ E3DC             >len_NFA         defl    $ - temp_NFA
 150+ E3DC             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 150+ E3D6             >
 150+ E3D6 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 150+ E3D7 28 4E 45 58 >                db      "(NEXT)"               // name string in 7-bit ascii, but
 150+ E3DB 54 29       >
 150+ E3DD             >                org     $-1                 // alter last byte of Name just above to set
 150+ E3DC A9          >                db      {b $} | END_BIT     // msb as name end
 150+ E3DD             >
 150+ E3DD CA 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 150+ E3DF             >Prev_Ptr        defl    Heap_Ptr
 150+ E3DF             >
 150+ E3DF             >mirror_Ptr      defl    $
 150+ E3DF             >
 150+ E3DF 11 A3       >                dw      Dict_Ptr + 2        // xt
 150+ E3E1             >Heap_Ptr        defl    $ - $E000           // save current HP
 150+ E3E1             >
 150+ E3E1             >Current_HP      defl  $ - $E000             // used to set HP once!
 150+ E3E1             >
 150+ E3E1             >//              ______________________________________________________________________
 150+ E3E1             >//              Dictionary part
 150+ E3E1             >
 150+ E3E1             >                org     Dict_Ptr
 150+ A30F             >
 150+ A30F DF 23       >                dw      mirror_Ptr - $E000 + Heap_offset
 150+ A311             >
 150+ A311             >CNEXT:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 150+ A311 CD 93 A2    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 150+ A314             >
 150+ A314             >
 150+ A314             >                endif           ; ok        // for other definitions it "points" the correct handler
 150+ A314             >                // Use of "; ok" to suppress "warning[fwdref]"
 150+ A314             >
 150+ A314             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 150+ A314 D8 9B       >                dw      Next_Ptr
 151+ A316
 152+ A316              //  ______________________________________________________________________
 153+ A316              //
 154+ A316
 155+ A316                              User_Def S0         , "S0"        , 06 // starting value of Stack-Pointer
 155+ A316             >                New_Def  S0, "S0", User_Ptr, is_normal
 155+ A316             >
 155+ A316             >Dict_Ptr        defl    $
 155+ A316             >
 155+ A316             >//              ______________________________________________________________________
 155+ A316             >//              Heap part
 155+ A316             >
 155+ A316             >
 155+ A316             >                org     (Heap_Ptr & $1FFF) + $E000
 155+ E3E1             >
 155+ E3E1             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 155+ E3E1             >Latest_Definition defl  Heap_Ptr
 155+ E3E1             >
 155+ E3E1             >                // dummy db directives used to calculate length of namec
 155+ E3E1 53 30       >                db      "S0"
 155+ E3E3             >len_NFA         defl    $ - temp_NFA
 155+ E3E3             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 155+ E3E1             >
 155+ E3E1 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 155+ E3E2 53 30       >                db      "S0"               // name string in 7-bit ascii, but
 155+ E3E4             >                org     $-1                 // alter last byte of Name just above to set
 155+ E3E3 B0          >                db      {b $} | END_BIT     // msb as name end
 155+ E3E4             >
 155+ E3E4 D6 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 155+ E3E6             >Prev_Ptr        defl    Heap_Ptr
 155+ E3E6             >
 155+ E3E6             >mirror_Ptr      defl    $
 155+ E3E6             >
 155+ E3E6 18 A3       >                dw      Dict_Ptr + 2        // xt
 155+ E3E8             >Heap_Ptr        defl    $ - $E000           // save current HP
 155+ E3E8             >
 155+ E3E8             >Current_HP      defl  $ - $E000             // used to set HP once!
 155+ E3E8             >
 155+ E3E8             >//              ______________________________________________________________________
 155+ E3E8             >//              Dictionary part
 155+ E3E8             >
 155+ E3E8             >                org     Dict_Ptr
 155+ A316             >
 155+ A316 E6 23       >                dw      mirror_Ptr - $E000 + Heap_offset
 155+ A318             >
 155+ A318             >S0:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 155+ A318 CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 155+ A31B             >
 155+ A31B             >
 155+ A31B             >                endif           ; ok        // for other definitions it "points" the correct handler
 155+ A31B             >                // Use of "; ok" to suppress "warning[fwdref]"
 155+ A31B             >
 155+ A31B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 155+ A31B 06          >                db      06
 156+ A31C                              User_Def R0         , "R0"        , 08 // starting value of Return-Pointer
 156+ A31C             >                New_Def  R0, "R0", User_Ptr, is_normal
 156+ A31C             >
 156+ A31C             >Dict_Ptr        defl    $
 156+ A31C             >
 156+ A31C             >//              ______________________________________________________________________
 156+ A31C             >//              Heap part
 156+ A31C             >
 156+ A31C             >
 156+ A31C             >                org     (Heap_Ptr & $1FFF) + $E000
 156+ E3E8             >
 156+ E3E8             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 156+ E3E8             >Latest_Definition defl  Heap_Ptr
 156+ E3E8             >
 156+ E3E8             >                // dummy db directives used to calculate length of namec
 156+ E3E8 52 30       >                db      "R0"
 156+ E3EA             >len_NFA         defl    $ - temp_NFA
 156+ E3EA             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 156+ E3E8             >
 156+ E3E8 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 156+ E3E9 52 30       >                db      "R0"               // name string in 7-bit ascii, but
 156+ E3EB             >                org     $-1                 // alter last byte of Name just above to set
 156+ E3EA B0          >                db      {b $} | END_BIT     // msb as name end
 156+ E3EB             >
 156+ E3EB E1 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 156+ E3ED             >Prev_Ptr        defl    Heap_Ptr
 156+ E3ED             >
 156+ E3ED             >mirror_Ptr      defl    $
 156+ E3ED             >
 156+ E3ED 1E A3       >                dw      Dict_Ptr + 2        // xt
 156+ E3EF             >Heap_Ptr        defl    $ - $E000           // save current HP
 156+ E3EF             >
 156+ E3EF             >Current_HP      defl  $ - $E000             // used to set HP once!
 156+ E3EF             >
 156+ E3EF             >//              ______________________________________________________________________
 156+ E3EF             >//              Dictionary part
 156+ E3EF             >
 156+ E3EF             >                org     Dict_Ptr
 156+ A31C             >
 156+ A31C ED 23       >                dw      mirror_Ptr - $E000 + Heap_offset
 156+ A31E             >
 156+ A31E             >R0:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 156+ A31E CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 156+ A321             >
 156+ A321             >
 156+ A321             >                endif           ; ok        // for other definitions it "points" the correct handler
 156+ A321             >                // Use of "; ok" to suppress "warning[fwdref]"
 156+ A321             >
 156+ A321             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 156+ A321 08          >                db      08
 157+ A322                              User_Def TIB        , "TIB"       , 10 // input terminal buffer address
 157+ A322             >                New_Def  TIB, "TIB", User_Ptr, is_normal
 157+ A322             >
 157+ A322             >Dict_Ptr        defl    $
 157+ A322             >
 157+ A322             >//              ______________________________________________________________________
 157+ A322             >//              Heap part
 157+ A322             >
 157+ A322             >
 157+ A322             >                org     (Heap_Ptr & $1FFF) + $E000
 157+ E3EF             >
 157+ E3EF             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 157+ E3EF             >Latest_Definition defl  Heap_Ptr
 157+ E3EF             >
 157+ E3EF             >                // dummy db directives used to calculate length of namec
 157+ E3EF 54 49 42    >                db      "TIB"
 157+ E3F2             >len_NFA         defl    $ - temp_NFA
 157+ E3F2             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 157+ E3EF             >
 157+ E3EF 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 157+ E3F0 54 49 42    >                db      "TIB"               // name string in 7-bit ascii, but
 157+ E3F3             >                org     $-1                 // alter last byte of Name just above to set
 157+ E3F2 C2          >                db      {b $} | END_BIT     // msb as name end
 157+ E3F3             >
 157+ E3F3 E8 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 157+ E3F5             >Prev_Ptr        defl    Heap_Ptr
 157+ E3F5             >
 157+ E3F5             >mirror_Ptr      defl    $
 157+ E3F5             >
 157+ E3F5 24 A3       >                dw      Dict_Ptr + 2        // xt
 157+ E3F7             >Heap_Ptr        defl    $ - $E000           // save current HP
 157+ E3F7             >
 157+ E3F7             >Current_HP      defl  $ - $E000             // used to set HP once!
 157+ E3F7             >
 157+ E3F7             >//              ______________________________________________________________________
 157+ E3F7             >//              Dictionary part
 157+ E3F7             >
 157+ E3F7             >                org     Dict_Ptr
 157+ A322             >
 157+ A322 F5 23       >                dw      mirror_Ptr - $E000 + Heap_offset
 157+ A324             >
 157+ A324             >TIB:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 157+ A324 CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 157+ A327             >
 157+ A327             >
 157+ A327             >                endif           ; ok        // for other definitions it "points" the correct handler
 157+ A327             >                // Use of "; ok" to suppress "warning[fwdref]"
 157+ A327             >
 157+ A327             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 157+ A327 0A          >                db      10
 158+ A328                              User_Def WIDTH      , "WIDTH"     , 12 // maximum number of characters for a word name
 158+ A328             >                New_Def  WIDTH, "WIDTH", User_Ptr, is_normal
 158+ A328             >
 158+ A328             >Dict_Ptr        defl    $
 158+ A328             >
 158+ A328             >//              ______________________________________________________________________
 158+ A328             >//              Heap part
 158+ A328             >
 158+ A328             >
 158+ A328             >                org     (Heap_Ptr & $1FFF) + $E000
 158+ E3F7             >
 158+ E3F7             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 158+ E3F7             >Latest_Definition defl  Heap_Ptr
 158+ E3F7             >
 158+ E3F7             >                // dummy db directives used to calculate length of namec
 158+ E3F7 57 49 44 54 >                db      "WIDTH"
 158+ E3FB 48          >
 158+ E3FC             >len_NFA         defl    $ - temp_NFA
 158+ E3FC             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 158+ E3F7             >
 158+ E3F7 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 158+ E3F8 57 49 44 54 >                db      "WIDTH"               // name string in 7-bit ascii, but
 158+ E3FC 48          >
 158+ E3FD             >                org     $-1                 // alter last byte of Name just above to set
 158+ E3FC C8          >                db      {b $} | END_BIT     // msb as name end
 158+ E3FD             >
 158+ E3FD EF 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 158+ E3FF             >Prev_Ptr        defl    Heap_Ptr
 158+ E3FF             >
 158+ E3FF             >mirror_Ptr      defl    $
 158+ E3FF             >
 158+ E3FF 2A A3       >                dw      Dict_Ptr + 2        // xt
 158+ E401             >Heap_Ptr        defl    $ - $E000           // save current HP
 158+ E401             >
 158+ E401             >Current_HP      defl  $ - $E000             // used to set HP once!
 158+ E401             >
 158+ E401             >//              ______________________________________________________________________
 158+ E401             >//              Dictionary part
 158+ E401             >
 158+ E401             >                org     Dict_Ptr
 158+ A328             >
 158+ A328 FF 23       >                dw      mirror_Ptr - $E000 + Heap_offset
 158+ A32A             >
 158+ A32A             >WIDTH:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 158+ A32A CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 158+ A32D             >
 158+ A32D             >
 158+ A32D             >                endif           ; ok        // for other definitions it "points" the correct handler
 158+ A32D             >                // Use of "; ok" to suppress "warning[fwdref]"
 158+ A32D             >
 158+ A32D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 158+ A32D 0C          >                db      12
 159+ A32E                              User_Def WARNING    , "WARNING"   , 14 // error reporting method: 0 base, 1 verbose
 159+ A32E             >                New_Def  WARNING, "WARNING", User_Ptr, is_normal
 159+ A32E             >
 159+ A32E             >Dict_Ptr        defl    $
 159+ A32E             >
 159+ A32E             >//              ______________________________________________________________________
 159+ A32E             >//              Heap part
 159+ A32E             >
 159+ A32E             >
 159+ A32E             >                org     (Heap_Ptr & $1FFF) + $E000
 159+ E401             >
 159+ E401             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 159+ E401             >Latest_Definition defl  Heap_Ptr
 159+ E401             >
 159+ E401             >                // dummy db directives used to calculate length of namec
 159+ E401 57 41 52 4E >                db      "WARNING"
 159+ E405 49 4E 47    >
 159+ E408             >len_NFA         defl    $ - temp_NFA
 159+ E408             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 159+ E401             >
 159+ E401 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 159+ E402 57 41 52 4E >                db      "WARNING"               // name string in 7-bit ascii, but
 159+ E406 49 4E 47    >
 159+ E409             >                org     $-1                 // alter last byte of Name just above to set
 159+ E408 C7          >                db      {b $} | END_BIT     // msb as name end
 159+ E409             >
 159+ E409 F7 23       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 159+ E40B             >Prev_Ptr        defl    Heap_Ptr
 159+ E40B             >
 159+ E40B             >mirror_Ptr      defl    $
 159+ E40B             >
 159+ E40B 30 A3       >                dw      Dict_Ptr + 2        // xt
 159+ E40D             >Heap_Ptr        defl    $ - $E000           // save current HP
 159+ E40D             >
 159+ E40D             >Current_HP      defl  $ - $E000             // used to set HP once!
 159+ E40D             >
 159+ E40D             >//              ______________________________________________________________________
 159+ E40D             >//              Dictionary part
 159+ E40D             >
 159+ E40D             >                org     Dict_Ptr
 159+ A32E             >
 159+ A32E 0B 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 159+ A330             >
 159+ A330             >WARNING:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 159+ A330 CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 159+ A333             >
 159+ A333             >
 159+ A333             >                endif           ; ok        // for other definitions it "points" the correct handler
 159+ A333             >                // Use of "; ok" to suppress "warning[fwdref]"
 159+ A333             >
 159+ A333             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 159+ A333 0E          >                db      14
 160+ A334                              User_Def FENCE      , "FENCE"     , 16 // minimum address where FORGET can work
 160+ A334             >                New_Def  FENCE, "FENCE", User_Ptr, is_normal
 160+ A334             >
 160+ A334             >Dict_Ptr        defl    $
 160+ A334             >
 160+ A334             >//              ______________________________________________________________________
 160+ A334             >//              Heap part
 160+ A334             >
 160+ A334             >
 160+ A334             >                org     (Heap_Ptr & $1FFF) + $E000
 160+ E40D             >
 160+ E40D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 160+ E40D             >Latest_Definition defl  Heap_Ptr
 160+ E40D             >
 160+ E40D             >                // dummy db directives used to calculate length of namec
 160+ E40D 46 45 4E 43 >                db      "FENCE"
 160+ E411 45          >
 160+ E412             >len_NFA         defl    $ - temp_NFA
 160+ E412             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 160+ E40D             >
 160+ E40D 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 160+ E40E 46 45 4E 43 >                db      "FENCE"               // name string in 7-bit ascii, but
 160+ E412 45          >
 160+ E413             >                org     $-1                 // alter last byte of Name just above to set
 160+ E412 C5          >                db      {b $} | END_BIT     // msb as name end
 160+ E413             >
 160+ E413 01 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 160+ E415             >Prev_Ptr        defl    Heap_Ptr
 160+ E415             >
 160+ E415             >mirror_Ptr      defl    $
 160+ E415             >
 160+ E415 36 A3       >                dw      Dict_Ptr + 2        // xt
 160+ E417             >Heap_Ptr        defl    $ - $E000           // save current HP
 160+ E417             >
 160+ E417             >Current_HP      defl  $ - $E000             // used to set HP once!
 160+ E417             >
 160+ E417             >//              ______________________________________________________________________
 160+ E417             >//              Dictionary part
 160+ E417             >
 160+ E417             >                org     Dict_Ptr
 160+ A334             >
 160+ A334 15 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 160+ A336             >
 160+ A336             >FENCE:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 160+ A336 CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 160+ A339             >
 160+ A339             >
 160+ A339             >                endif           ; ok        // for other definitions it "points" the correct handler
 160+ A339             >                // Use of "; ok" to suppress "warning[fwdref]"
 160+ A339             >
 160+ A339             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 160+ A339 10          >                db      16
 161+ A33A                              User_Def DP         , "DP"        , 18 // Dictionary Pointer
 161+ A33A             >                New_Def  DP, "DP", User_Ptr, is_normal
 161+ A33A             >
 161+ A33A             >Dict_Ptr        defl    $
 161+ A33A             >
 161+ A33A             >//              ______________________________________________________________________
 161+ A33A             >//              Heap part
 161+ A33A             >
 161+ A33A             >
 161+ A33A             >                org     (Heap_Ptr & $1FFF) + $E000
 161+ E417             >
 161+ E417             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 161+ E417             >Latest_Definition defl  Heap_Ptr
 161+ E417             >
 161+ E417             >                // dummy db directives used to calculate length of namec
 161+ E417 44 50       >                db      "DP"
 161+ E419             >len_NFA         defl    $ - temp_NFA
 161+ E419             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 161+ E417             >
 161+ E417 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 161+ E418 44 50       >                db      "DP"               // name string in 7-bit ascii, but
 161+ E41A             >                org     $-1                 // alter last byte of Name just above to set
 161+ E419 D0          >                db      {b $} | END_BIT     // msb as name end
 161+ E41A             >
 161+ E41A 0D 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 161+ E41C             >Prev_Ptr        defl    Heap_Ptr
 161+ E41C             >
 161+ E41C             >mirror_Ptr      defl    $
 161+ E41C             >
 161+ E41C 3C A3       >                dw      Dict_Ptr + 2        // xt
 161+ E41E             >Heap_Ptr        defl    $ - $E000           // save current HP
 161+ E41E             >
 161+ E41E             >Current_HP      defl  $ - $E000             // used to set HP once!
 161+ E41E             >
 161+ E41E             >//              ______________________________________________________________________
 161+ E41E             >//              Dictionary part
 161+ E41E             >
 161+ E41E             >                org     Dict_Ptr
 161+ A33A             >
 161+ A33A 1C 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 161+ A33C             >
 161+ A33C             >DP:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 161+ A33C CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 161+ A33F             >
 161+ A33F             >
 161+ A33F             >                endif           ; ok        // for other definitions it "points" the correct handler
 161+ A33F             >                // Use of "; ok" to suppress "warning[fwdref]"
 161+ A33F             >
 161+ A33F             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 161+ A33F 12          >                db      18
 162+ A340                              User_Def VOC_LINK   , "VOC-LINK"  , 20 // pointer to the latest vocabulary
 162+ A340             >                New_Def  VOC_LINK, "VOC-LINK", User_Ptr, is_normal
 162+ A340             >
 162+ A340             >Dict_Ptr        defl    $
 162+ A340             >
 162+ A340             >//              ______________________________________________________________________
 162+ A340             >//              Heap part
 162+ A340             >
 162+ A340             >
 162+ A340             >                org     (Heap_Ptr & $1FFF) + $E000
 162+ E41E             >
 162+ E41E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 162+ E41E             >Latest_Definition defl  Heap_Ptr
 162+ E41E             >
 162+ E41E             >                // dummy db directives used to calculate length of namec
 162+ E41E 56 4F 43 2D >                db      "VOC-LINK"
 162+ E422 4C 49 4E 4B >
 162+ E426             >len_NFA         defl    $ - temp_NFA
 162+ E426             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 162+ E41E             >
 162+ E41E 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 162+ E41F 56 4F 43 2D >                db      "VOC-LINK"               // name string in 7-bit ascii, but
 162+ E423 4C 49 4E 4B >
 162+ E427             >                org     $-1                 // alter last byte of Name just above to set
 162+ E426 CB          >                db      {b $} | END_BIT     // msb as name end
 162+ E427             >
 162+ E427 17 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 162+ E429             >Prev_Ptr        defl    Heap_Ptr
 162+ E429             >
 162+ E429             >mirror_Ptr      defl    $
 162+ E429             >
 162+ E429 42 A3       >                dw      Dict_Ptr + 2        // xt
 162+ E42B             >Heap_Ptr        defl    $ - $E000           // save current HP
 162+ E42B             >
 162+ E42B             >Current_HP      defl  $ - $E000             // used to set HP once!
 162+ E42B             >
 162+ E42B             >//              ______________________________________________________________________
 162+ E42B             >//              Dictionary part
 162+ E42B             >
 162+ E42B             >                org     Dict_Ptr
 162+ A340             >
 162+ A340 29 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 162+ A342             >
 162+ A342             >VOC_LINK:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 162+ A342 CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 162+ A345             >
 162+ A345             >
 162+ A345             >                endif           ; ok        // for other definitions it "points" the correct handler
 162+ A345             >                // Use of "; ok" to suppress "warning[fwdref]"
 162+ A345             >
 162+ A345             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 162+ A345 14          >                db      20
 163+ A346                              User_Def FIRST      , "FIRST"     , 22 // address of first buffer
 163+ A346             >                New_Def  FIRST, "FIRST", User_Ptr, is_normal
 163+ A346             >
 163+ A346             >Dict_Ptr        defl    $
 163+ A346             >
 163+ A346             >//              ______________________________________________________________________
 163+ A346             >//              Heap part
 163+ A346             >
 163+ A346             >
 163+ A346             >                org     (Heap_Ptr & $1FFF) + $E000
 163+ E42B             >
 163+ E42B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 163+ E42B             >Latest_Definition defl  Heap_Ptr
 163+ E42B             >
 163+ E42B             >                // dummy db directives used to calculate length of namec
 163+ E42B 46 49 52 53 >                db      "FIRST"
 163+ E42F 54          >
 163+ E430             >len_NFA         defl    $ - temp_NFA
 163+ E430             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 163+ E42B             >
 163+ E42B 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 163+ E42C 46 49 52 53 >                db      "FIRST"               // name string in 7-bit ascii, but
 163+ E430 54          >
 163+ E431             >                org     $-1                 // alter last byte of Name just above to set
 163+ E430 D4          >                db      {b $} | END_BIT     // msb as name end
 163+ E431             >
 163+ E431 1E 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 163+ E433             >Prev_Ptr        defl    Heap_Ptr
 163+ E433             >
 163+ E433             >mirror_Ptr      defl    $
 163+ E433             >
 163+ E433 48 A3       >                dw      Dict_Ptr + 2        // xt
 163+ E435             >Heap_Ptr        defl    $ - $E000           // save current HP
 163+ E435             >
 163+ E435             >Current_HP      defl  $ - $E000             // used to set HP once!
 163+ E435             >
 163+ E435             >//              ______________________________________________________________________
 163+ E435             >//              Dictionary part
 163+ E435             >
 163+ E435             >                org     Dict_Ptr
 163+ A346             >
 163+ A346 33 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 163+ A348             >
 163+ A348             >FIRST:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 163+ A348 CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 163+ A34B             >
 163+ A34B             >
 163+ A34B             >                endif           ; ok        // for other definitions it "points" the correct handler
 163+ A34B             >                // Use of "; ok" to suppress "warning[fwdref]"
 163+ A34B             >
 163+ A34B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 163+ A34B 16          >                db      22
 164+ A34C                              User_Def LIMIT      , "LIMIT"     , 24 // address of last buffer
 164+ A34C             >                New_Def  LIMIT, "LIMIT", User_Ptr, is_normal
 164+ A34C             >
 164+ A34C             >Dict_Ptr        defl    $
 164+ A34C             >
 164+ A34C             >//              ______________________________________________________________________
 164+ A34C             >//              Heap part
 164+ A34C             >
 164+ A34C             >
 164+ A34C             >                org     (Heap_Ptr & $1FFF) + $E000
 164+ E435             >
 164+ E435             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 164+ E435             >Latest_Definition defl  Heap_Ptr
 164+ E435             >
 164+ E435             >                // dummy db directives used to calculate length of namec
 164+ E435 4C 49 4D 49 >                db      "LIMIT"
 164+ E439 54          >
 164+ E43A             >len_NFA         defl    $ - temp_NFA
 164+ E43A             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 164+ E435             >
 164+ E435 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 164+ E436 4C 49 4D 49 >                db      "LIMIT"               // name string in 7-bit ascii, but
 164+ E43A 54          >
 164+ E43B             >                org     $-1                 // alter last byte of Name just above to set
 164+ E43A D4          >                db      {b $} | END_BIT     // msb as name end
 164+ E43B             >
 164+ E43B 2B 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 164+ E43D             >Prev_Ptr        defl    Heap_Ptr
 164+ E43D             >
 164+ E43D             >mirror_Ptr      defl    $
 164+ E43D             >
 164+ E43D 4E A3       >                dw      Dict_Ptr + 2        // xt
 164+ E43F             >Heap_Ptr        defl    $ - $E000           // save current HP
 164+ E43F             >
 164+ E43F             >Current_HP      defl  $ - $E000             // used to set HP once!
 164+ E43F             >
 164+ E43F             >//              ______________________________________________________________________
 164+ E43F             >//              Dictionary part
 164+ E43F             >
 164+ E43F             >                org     Dict_Ptr
 164+ A34C             >
 164+ A34C 3D 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 164+ A34E             >
 164+ A34E             >LIMIT:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 164+ A34E CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 164+ A351             >
 164+ A351             >
 164+ A351             >                endif           ; ok        // for other definitions it "points" the correct handler
 164+ A351             >                // Use of "; ok" to suppress "warning[fwdref]"
 164+ A351             >
 164+ A351             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 164+ A351 18          >                db      24
 165+ A352                              User_Def HP         , "HP"        , 26 // heap-pointer address
 165+ A352             >                New_Def  HP, "HP", User_Ptr, is_normal
 165+ A352             >
 165+ A352             >Dict_Ptr        defl    $
 165+ A352             >
 165+ A352             >//              ______________________________________________________________________
 165+ A352             >//              Heap part
 165+ A352             >
 165+ A352             >
 165+ A352             >                org     (Heap_Ptr & $1FFF) + $E000
 165+ E43F             >
 165+ E43F             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 165+ E43F             >Latest_Definition defl  Heap_Ptr
 165+ E43F             >
 165+ E43F             >                // dummy db directives used to calculate length of namec
 165+ E43F 48 50       >                db      "HP"
 165+ E441             >len_NFA         defl    $ - temp_NFA
 165+ E441             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 165+ E43F             >
 165+ E43F 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 165+ E440 48 50       >                db      "HP"               // name string in 7-bit ascii, but
 165+ E442             >                org     $-1                 // alter last byte of Name just above to set
 165+ E441 D0          >                db      {b $} | END_BIT     // msb as name end
 165+ E442             >
 165+ E442 35 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 165+ E444             >Prev_Ptr        defl    Heap_Ptr
 165+ E444             >
 165+ E444             >mirror_Ptr      defl    $
 165+ E444             >
 165+ E444 54 A3       >                dw      Dict_Ptr + 2        // xt
 165+ E446             >Heap_Ptr        defl    $ - $E000           // save current HP
 165+ E446             >
 165+ E446             >Current_HP      defl  $ - $E000             // used to set HP once!
 165+ E446             >
 165+ E446             >//              ______________________________________________________________________
 165+ E446             >//              Dictionary part
 165+ E446             >
 165+ E446             >                org     Dict_Ptr
 165+ A352             >
 165+ A352 44 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 165+ A354             >
 165+ A354             >HP:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 165+ A354 CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 165+ A357             >
 165+ A357             >
 165+ A357             >                endif           ; ok        // for other definitions it "points" the correct handler
 165+ A357             >                // Use of "; ok" to suppress "warning[fwdref]"
 165+ A357             >
 165+ A357             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 165+ A357 1A          >                db      26
 166+ A358                              User_Def NMODE      , "NMODE"     , 28 // number mode: 0 integer, 1 floating point
 166+ A358             >                New_Def  NMODE, "NMODE", User_Ptr, is_normal
 166+ A358             >
 166+ A358             >Dict_Ptr        defl    $
 166+ A358             >
 166+ A358             >//              ______________________________________________________________________
 166+ A358             >//              Heap part
 166+ A358             >
 166+ A358             >
 166+ A358             >                org     (Heap_Ptr & $1FFF) + $E000
 166+ E446             >
 166+ E446             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 166+ E446             >Latest_Definition defl  Heap_Ptr
 166+ E446             >
 166+ E446             >                // dummy db directives used to calculate length of namec
 166+ E446 4E 4D 4F 44 >                db      "NMODE"
 166+ E44A 45          >
 166+ E44B             >len_NFA         defl    $ - temp_NFA
 166+ E44B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 166+ E446             >
 166+ E446 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 166+ E447 4E 4D 4F 44 >                db      "NMODE"               // name string in 7-bit ascii, but
 166+ E44B 45          >
 166+ E44C             >                org     $-1                 // alter last byte of Name just above to set
 166+ E44B C5          >                db      {b $} | END_BIT     // msb as name end
 166+ E44C             >
 166+ E44C 3F 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 166+ E44E             >Prev_Ptr        defl    Heap_Ptr
 166+ E44E             >
 166+ E44E             >mirror_Ptr      defl    $
 166+ E44E             >
 166+ E44E 5A A3       >                dw      Dict_Ptr + 2        // xt
 166+ E450             >Heap_Ptr        defl    $ - $E000           // save current HP
 166+ E450             >
 166+ E450             >Current_HP      defl  $ - $E000             // used to set HP once!
 166+ E450             >
 166+ E450             >//              ______________________________________________________________________
 166+ E450             >//              Dictionary part
 166+ E450             >
 166+ E450             >                org     Dict_Ptr
 166+ A358             >
 166+ A358 4E 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 166+ A35A             >
 166+ A35A             >NMODE:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 166+ A35A CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 166+ A35D             >
 166+ A35D             >
 166+ A35D             >                endif           ; ok        // for other definitions it "points" the correct handler
 166+ A35D             >                // Use of "; ok" to suppress "warning[fwdref]"
 166+ A35D             >
 166+ A35D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 166+ A35D 1C          >                db      28
 167+ A35E                              User_Def BLK        , "BLK"       , 30 // block number to be interpreted. 0 for terminal
 167+ A35E             >                New_Def  BLK, "BLK", User_Ptr, is_normal
 167+ A35E             >
 167+ A35E             >Dict_Ptr        defl    $
 167+ A35E             >
 167+ A35E             >//              ______________________________________________________________________
 167+ A35E             >//              Heap part
 167+ A35E             >
 167+ A35E             >
 167+ A35E             >                org     (Heap_Ptr & $1FFF) + $E000
 167+ E450             >
 167+ E450             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 167+ E450             >Latest_Definition defl  Heap_Ptr
 167+ E450             >
 167+ E450             >                // dummy db directives used to calculate length of namec
 167+ E450 42 4C 4B    >                db      "BLK"
 167+ E453             >len_NFA         defl    $ - temp_NFA
 167+ E453             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 167+ E450             >
 167+ E450 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 167+ E451 42 4C 4B    >                db      "BLK"               // name string in 7-bit ascii, but
 167+ E454             >                org     $-1                 // alter last byte of Name just above to set
 167+ E453 CB          >                db      {b $} | END_BIT     // msb as name end
 167+ E454             >
 167+ E454 46 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 167+ E456             >Prev_Ptr        defl    Heap_Ptr
 167+ E456             >
 167+ E456             >mirror_Ptr      defl    $
 167+ E456             >
 167+ E456 60 A3       >                dw      Dict_Ptr + 2        // xt
 167+ E458             >Heap_Ptr        defl    $ - $E000           // save current HP
 167+ E458             >
 167+ E458             >Current_HP      defl  $ - $E000             // used to set HP once!
 167+ E458             >
 167+ E458             >//              ______________________________________________________________________
 167+ E458             >//              Dictionary part
 167+ E458             >
 167+ E458             >                org     Dict_Ptr
 167+ A35E             >
 167+ A35E 56 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 167+ A360             >
 167+ A360             >BLK:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 167+ A360 CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 167+ A363             >
 167+ A363             >
 167+ A363             >                endif           ; ok        // for other definitions it "points" the correct handler
 167+ A363             >                // Use of "; ok" to suppress "warning[fwdref]"
 167+ A363             >
 167+ A363             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 167+ A363 1E          >                db      30
 168+ A364                              User_Def TO_IN      , ">IN"       , 32 // incremented when consuming input buffer
 168+ A364             >                New_Def  TO_IN, ">IN", User_Ptr, is_normal
 168+ A364             >
 168+ A364             >Dict_Ptr        defl    $
 168+ A364             >
 168+ A364             >//              ______________________________________________________________________
 168+ A364             >//              Heap part
 168+ A364             >
 168+ A364             >
 168+ A364             >                org     (Heap_Ptr & $1FFF) + $E000
 168+ E458             >
 168+ E458             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 168+ E458             >Latest_Definition defl  Heap_Ptr
 168+ E458             >
 168+ E458             >                // dummy db directives used to calculate length of namec
 168+ E458 3E 49 4E    >                db      ">IN"
 168+ E45B             >len_NFA         defl    $ - temp_NFA
 168+ E45B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 168+ E458             >
 168+ E458 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 168+ E459 3E 49 4E    >                db      ">IN"               // name string in 7-bit ascii, but
 168+ E45C             >                org     $-1                 // alter last byte of Name just above to set
 168+ E45B CE          >                db      {b $} | END_BIT     // msb as name end
 168+ E45C             >
 168+ E45C 50 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 168+ E45E             >Prev_Ptr        defl    Heap_Ptr
 168+ E45E             >
 168+ E45E             >mirror_Ptr      defl    $
 168+ E45E             >
 168+ E45E 66 A3       >                dw      Dict_Ptr + 2        // xt
 168+ E460             >Heap_Ptr        defl    $ - $E000           // save current HP
 168+ E460             >
 168+ E460             >Current_HP      defl  $ - $E000             // used to set HP once!
 168+ E460             >
 168+ E460             >//              ______________________________________________________________________
 168+ E460             >//              Dictionary part
 168+ E460             >
 168+ E460             >                org     Dict_Ptr
 168+ A364             >
 168+ A364 5E 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 168+ A366             >
 168+ A366             >TO_IN:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 168+ A366 CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 168+ A369             >
 168+ A369             >
 168+ A369             >                endif           ; ok        // for other definitions it "points" the correct handler
 168+ A369             >                // Use of "; ok" to suppress "warning[fwdref]"
 168+ A369             >
 168+ A369             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 168+ A369 20          >                db      32
 169+ A36A                              User_Def OUT        , "OUT"       , 34 // incremented when sending to output
 169+ A36A             >                New_Def  OUT, "OUT", User_Ptr, is_normal
 169+ A36A             >
 169+ A36A             >Dict_Ptr        defl    $
 169+ A36A             >
 169+ A36A             >//              ______________________________________________________________________
 169+ A36A             >//              Heap part
 169+ A36A             >
 169+ A36A             >
 169+ A36A             >                org     (Heap_Ptr & $1FFF) + $E000
 169+ E460             >
 169+ E460             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 169+ E460             >Latest_Definition defl  Heap_Ptr
 169+ E460             >
 169+ E460             >                // dummy db directives used to calculate length of namec
 169+ E460 4F 55 54    >                db      "OUT"
 169+ E463             >len_NFA         defl    $ - temp_NFA
 169+ E463             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 169+ E460             >
 169+ E460 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 169+ E461 4F 55 54    >                db      "OUT"               // name string in 7-bit ascii, but
 169+ E464             >                org     $-1                 // alter last byte of Name just above to set
 169+ E463 D4          >                db      {b $} | END_BIT     // msb as name end
 169+ E464             >
 169+ E464 58 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 169+ E466             >Prev_Ptr        defl    Heap_Ptr
 169+ E466             >
 169+ E466             >mirror_Ptr      defl    $
 169+ E466             >
 169+ E466 6C A3       >                dw      Dict_Ptr + 2        // xt
 169+ E468             >Heap_Ptr        defl    $ - $E000           // save current HP
 169+ E468             >
 169+ E468             >Current_HP      defl  $ - $E000             // used to set HP once!
 169+ E468             >
 169+ E468             >//              ______________________________________________________________________
 169+ E468             >//              Dictionary part
 169+ E468             >
 169+ E468             >                org     Dict_Ptr
 169+ A36A             >
 169+ A36A 66 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 169+ A36C             >
 169+ A36C             >OUT:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 169+ A36C CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 169+ A36F             >
 169+ A36F             >
 169+ A36F             >                endif           ; ok        // for other definitions it "points" the correct handler
 169+ A36F             >                // Use of "; ok" to suppress "warning[fwdref]"
 169+ A36F             >
 169+ A36F             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 169+ A36F 22          >                db      34
 170+ A370                              User_Def SCR        , "SCR"       , 36 // latest screen retreieved by LIST
 170+ A370             >                New_Def  SCR, "SCR", User_Ptr, is_normal
 170+ A370             >
 170+ A370             >Dict_Ptr        defl    $
 170+ A370             >
 170+ A370             >//              ______________________________________________________________________
 170+ A370             >//              Heap part
 170+ A370             >
 170+ A370             >
 170+ A370             >                org     (Heap_Ptr & $1FFF) + $E000
 170+ E468             >
 170+ E468             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 170+ E468             >Latest_Definition defl  Heap_Ptr
 170+ E468             >
 170+ E468             >                // dummy db directives used to calculate length of namec
 170+ E468 53 43 52    >                db      "SCR"
 170+ E46B             >len_NFA         defl    $ - temp_NFA
 170+ E46B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 170+ E468             >
 170+ E468 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 170+ E469 53 43 52    >                db      "SCR"               // name string in 7-bit ascii, but
 170+ E46C             >                org     $-1                 // alter last byte of Name just above to set
 170+ E46B D2          >                db      {b $} | END_BIT     // msb as name end
 170+ E46C             >
 170+ E46C 60 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 170+ E46E             >Prev_Ptr        defl    Heap_Ptr
 170+ E46E             >
 170+ E46E             >mirror_Ptr      defl    $
 170+ E46E             >
 170+ E46E 72 A3       >                dw      Dict_Ptr + 2        // xt
 170+ E470             >Heap_Ptr        defl    $ - $E000           // save current HP
 170+ E470             >
 170+ E470             >Current_HP      defl  $ - $E000             // used to set HP once!
 170+ E470             >
 170+ E470             >//              ______________________________________________________________________
 170+ E470             >//              Dictionary part
 170+ E470             >
 170+ E470             >                org     Dict_Ptr
 170+ A370             >
 170+ A370 6E 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 170+ A372             >
 170+ A372             >SCR:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 170+ A372 CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 170+ A375             >
 170+ A375             >
 170+ A375             >                endif           ; ok        // for other definitions it "points" the correct handler
 170+ A375             >                // Use of "; ok" to suppress "warning[fwdref]"
 170+ A375             >
 170+ A375             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 170+ A375 24          >                db      36
 171+ A376                              User_Def OFFSET     , "OFFSET"    , 38 //
 171+ A376             >                New_Def  OFFSET, "OFFSET", User_Ptr, is_normal
 171+ A376             >
 171+ A376             >Dict_Ptr        defl    $
 171+ A376             >
 171+ A376             >//              ______________________________________________________________________
 171+ A376             >//              Heap part
 171+ A376             >
 171+ A376             >
 171+ A376             >                org     (Heap_Ptr & $1FFF) + $E000
 171+ E470             >
 171+ E470             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 171+ E470             >Latest_Definition defl  Heap_Ptr
 171+ E470             >
 171+ E470             >                // dummy db directives used to calculate length of namec
 171+ E470 4F 46 46 53 >                db      "OFFSET"
 171+ E474 45 54       >
 171+ E476             >len_NFA         defl    $ - temp_NFA
 171+ E476             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 171+ E470             >
 171+ E470 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 171+ E471 4F 46 46 53 >                db      "OFFSET"               // name string in 7-bit ascii, but
 171+ E475 45 54       >
 171+ E477             >                org     $-1                 // alter last byte of Name just above to set
 171+ E476 D4          >                db      {b $} | END_BIT     // msb as name end
 171+ E477             >
 171+ E477 68 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 171+ E479             >Prev_Ptr        defl    Heap_Ptr
 171+ E479             >
 171+ E479             >mirror_Ptr      defl    $
 171+ E479             >
 171+ E479 78 A3       >                dw      Dict_Ptr + 2        // xt
 171+ E47B             >Heap_Ptr        defl    $ - $E000           // save current HP
 171+ E47B             >
 171+ E47B             >Current_HP      defl  $ - $E000             // used to set HP once!
 171+ E47B             >
 171+ E47B             >//              ______________________________________________________________________
 171+ E47B             >//              Dictionary part
 171+ E47B             >
 171+ E47B             >                org     Dict_Ptr
 171+ A376             >
 171+ A376 79 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 171+ A378             >
 171+ A378             >OFFSET:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 171+ A378 CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 171+ A37B             >
 171+ A37B             >
 171+ A37B             >                endif           ; ok        // for other definitions it "points" the correct handler
 171+ A37B             >                // Use of "; ok" to suppress "warning[fwdref]"
 171+ A37B             >
 171+ A37B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 171+ A37B 26          >                db      38
 172+ A37C                              User_Def CONTEXT    , "CONTEXT"   , 40 // pointer to the vocabulary where search begins
 172+ A37C             >                New_Def  CONTEXT, "CONTEXT", User_Ptr, is_normal
 172+ A37C             >
 172+ A37C             >Dict_Ptr        defl    $
 172+ A37C             >
 172+ A37C             >//              ______________________________________________________________________
 172+ A37C             >//              Heap part
 172+ A37C             >
 172+ A37C             >
 172+ A37C             >                org     (Heap_Ptr & $1FFF) + $E000
 172+ E47B             >
 172+ E47B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 172+ E47B             >Latest_Definition defl  Heap_Ptr
 172+ E47B             >
 172+ E47B             >                // dummy db directives used to calculate length of namec
 172+ E47B 43 4F 4E 54 >                db      "CONTEXT"
 172+ E47F 45 58 54    >
 172+ E482             >len_NFA         defl    $ - temp_NFA
 172+ E482             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 172+ E47B             >
 172+ E47B 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 172+ E47C 43 4F 4E 54 >                db      "CONTEXT"               // name string in 7-bit ascii, but
 172+ E480 45 58 54    >
 172+ E483             >                org     $-1                 // alter last byte of Name just above to set
 172+ E482 D4          >                db      {b $} | END_BIT     // msb as name end
 172+ E483             >
 172+ E483 70 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 172+ E485             >Prev_Ptr        defl    Heap_Ptr
 172+ E485             >
 172+ E485             >mirror_Ptr      defl    $
 172+ E485             >
 172+ E485 7E A3       >                dw      Dict_Ptr + 2        // xt
 172+ E487             >Heap_Ptr        defl    $ - $E000           // save current HP
 172+ E487             >
 172+ E487             >Current_HP      defl  $ - $E000             // used to set HP once!
 172+ E487             >
 172+ E487             >//              ______________________________________________________________________
 172+ E487             >//              Dictionary part
 172+ E487             >
 172+ E487             >                org     Dict_Ptr
 172+ A37C             >
 172+ A37C 85 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 172+ A37E             >
 172+ A37E             >CONTEXT:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 172+ A37E CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 172+ A381             >
 172+ A381             >
 172+ A381             >                endif           ; ok        // for other definitions it "points" the correct handler
 172+ A381             >                // Use of "; ok" to suppress "warning[fwdref]"
 172+ A381             >
 172+ A381             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 172+ A381 28          >                db      40
 173+ A382                              User_Def CURRENT    , "CURRENT"   , 42 // pointer to the vocabulary where search continues
 173+ A382             >                New_Def  CURRENT, "CURRENT", User_Ptr, is_normal
 173+ A382             >
 173+ A382             >Dict_Ptr        defl    $
 173+ A382             >
 173+ A382             >//              ______________________________________________________________________
 173+ A382             >//              Heap part
 173+ A382             >
 173+ A382             >
 173+ A382             >                org     (Heap_Ptr & $1FFF) + $E000
 173+ E487             >
 173+ E487             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 173+ E487             >Latest_Definition defl  Heap_Ptr
 173+ E487             >
 173+ E487             >                // dummy db directives used to calculate length of namec
 173+ E487 43 55 52 52 >                db      "CURRENT"
 173+ E48B 45 4E 54    >
 173+ E48E             >len_NFA         defl    $ - temp_NFA
 173+ E48E             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 173+ E487             >
 173+ E487 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 173+ E488 43 55 52 52 >                db      "CURRENT"               // name string in 7-bit ascii, but
 173+ E48C 45 4E 54    >
 173+ E48F             >                org     $-1                 // alter last byte of Name just above to set
 173+ E48E D4          >                db      {b $} | END_BIT     // msb as name end
 173+ E48F             >
 173+ E48F 7B 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 173+ E491             >Prev_Ptr        defl    Heap_Ptr
 173+ E491             >
 173+ E491             >mirror_Ptr      defl    $
 173+ E491             >
 173+ E491 84 A3       >                dw      Dict_Ptr + 2        // xt
 173+ E493             >Heap_Ptr        defl    $ - $E000           // save current HP
 173+ E493             >
 173+ E493             >Current_HP      defl  $ - $E000             // used to set HP once!
 173+ E493             >
 173+ E493             >//              ______________________________________________________________________
 173+ E493             >//              Dictionary part
 173+ E493             >
 173+ E493             >                org     Dict_Ptr
 173+ A382             >
 173+ A382 91 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 173+ A384             >
 173+ A384             >CURRENT:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 173+ A384 CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 173+ A387             >
 173+ A387             >
 173+ A387             >                endif           ; ok        // for other definitions it "points" the correct handler
 173+ A387             >                // Use of "; ok" to suppress "warning[fwdref]"
 173+ A387             >
 173+ A387             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 173+ A387 2A          >                db      42
 174+ A388                              User_Def STATE      , "STATE"     , 44 // compilation status. 0 interpreting.
 174+ A388             >                New_Def  STATE, "STATE", User_Ptr, is_normal
 174+ A388             >
 174+ A388             >Dict_Ptr        defl    $
 174+ A388             >
 174+ A388             >//              ______________________________________________________________________
 174+ A388             >//              Heap part
 174+ A388             >
 174+ A388             >
 174+ A388             >                org     (Heap_Ptr & $1FFF) + $E000
 174+ E493             >
 174+ E493             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 174+ E493             >Latest_Definition defl  Heap_Ptr
 174+ E493             >
 174+ E493             >                // dummy db directives used to calculate length of namec
 174+ E493 53 54 41 54 >                db      "STATE"
 174+ E497 45          >
 174+ E498             >len_NFA         defl    $ - temp_NFA
 174+ E498             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 174+ E493             >
 174+ E493 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 174+ E494 53 54 41 54 >                db      "STATE"               // name string in 7-bit ascii, but
 174+ E498 45          >
 174+ E499             >                org     $-1                 // alter last byte of Name just above to set
 174+ E498 C5          >                db      {b $} | END_BIT     // msb as name end
 174+ E499             >
 174+ E499 87 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 174+ E49B             >Prev_Ptr        defl    Heap_Ptr
 174+ E49B             >
 174+ E49B             >mirror_Ptr      defl    $
 174+ E49B             >
 174+ E49B 8A A3       >                dw      Dict_Ptr + 2        // xt
 174+ E49D             >Heap_Ptr        defl    $ - $E000           // save current HP
 174+ E49D             >
 174+ E49D             >Current_HP      defl  $ - $E000             // used to set HP once!
 174+ E49D             >
 174+ E49D             >//              ______________________________________________________________________
 174+ E49D             >//              Dictionary part
 174+ E49D             >
 174+ E49D             >                org     Dict_Ptr
 174+ A388             >
 174+ A388 9B 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 174+ A38A             >
 174+ A38A             >STATE:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 174+ A38A CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 174+ A38D             >
 174+ A38D             >
 174+ A38D             >                endif           ; ok        // for other definitions it "points" the correct handler
 174+ A38D             >                // Use of "; ok" to suppress "warning[fwdref]"
 174+ A38D             >
 174+ A38D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 174+ A38D 2C          >                db      44
 175+ A38E                              User_Def BASE       , "BASE"      , 46 //
 175+ A38E             >                New_Def  BASE, "BASE", User_Ptr, is_normal
 175+ A38E             >
 175+ A38E             >Dict_Ptr        defl    $
 175+ A38E             >
 175+ A38E             >//              ______________________________________________________________________
 175+ A38E             >//              Heap part
 175+ A38E             >
 175+ A38E             >
 175+ A38E             >                org     (Heap_Ptr & $1FFF) + $E000
 175+ E49D             >
 175+ E49D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 175+ E49D             >Latest_Definition defl  Heap_Ptr
 175+ E49D             >
 175+ E49D             >                // dummy db directives used to calculate length of namec
 175+ E49D 42 41 53 45 >                db      "BASE"
 175+ E4A1             >len_NFA         defl    $ - temp_NFA
 175+ E4A1             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 175+ E49D             >
 175+ E49D 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 175+ E49E 42 41 53 45 >                db      "BASE"               // name string in 7-bit ascii, but
 175+ E4A2             >                org     $-1                 // alter last byte of Name just above to set
 175+ E4A1 C5          >                db      {b $} | END_BIT     // msb as name end
 175+ E4A2             >
 175+ E4A2 93 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 175+ E4A4             >Prev_Ptr        defl    Heap_Ptr
 175+ E4A4             >
 175+ E4A4             >mirror_Ptr      defl    $
 175+ E4A4             >
 175+ E4A4 90 A3       >                dw      Dict_Ptr + 2        // xt
 175+ E4A6             >Heap_Ptr        defl    $ - $E000           // save current HP
 175+ E4A6             >
 175+ E4A6             >Current_HP      defl  $ - $E000             // used to set HP once!
 175+ E4A6             >
 175+ E4A6             >//              ______________________________________________________________________
 175+ E4A6             >//              Dictionary part
 175+ E4A6             >
 175+ E4A6             >                org     Dict_Ptr
 175+ A38E             >
 175+ A38E A4 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 175+ A390             >
 175+ A390             >BASE:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 175+ A390 CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 175+ A393             >
 175+ A393             >
 175+ A393             >                endif           ; ok        // for other definitions it "points" the correct handler
 175+ A393             >                // Use of "; ok" to suppress "warning[fwdref]"
 175+ A393             >
 175+ A393             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 175+ A393 2E          >                db      46
 176+ A394                              User_Def DPL        , "DPL"       , 48 // number of digits after decimal point in conversion
 176+ A394             >                New_Def  DPL, "DPL", User_Ptr, is_normal
 176+ A394             >
 176+ A394             >Dict_Ptr        defl    $
 176+ A394             >
 176+ A394             >//              ______________________________________________________________________
 176+ A394             >//              Heap part
 176+ A394             >
 176+ A394             >
 176+ A394             >                org     (Heap_Ptr & $1FFF) + $E000
 176+ E4A6             >
 176+ E4A6             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 176+ E4A6             >Latest_Definition defl  Heap_Ptr
 176+ E4A6             >
 176+ E4A6             >                // dummy db directives used to calculate length of namec
 176+ E4A6 44 50 4C    >                db      "DPL"
 176+ E4A9             >len_NFA         defl    $ - temp_NFA
 176+ E4A9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 176+ E4A6             >
 176+ E4A6 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 176+ E4A7 44 50 4C    >                db      "DPL"               // name string in 7-bit ascii, but
 176+ E4AA             >                org     $-1                 // alter last byte of Name just above to set
 176+ E4A9 CC          >                db      {b $} | END_BIT     // msb as name end
 176+ E4AA             >
 176+ E4AA 9D 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 176+ E4AC             >Prev_Ptr        defl    Heap_Ptr
 176+ E4AC             >
 176+ E4AC             >mirror_Ptr      defl    $
 176+ E4AC             >
 176+ E4AC 96 A3       >                dw      Dict_Ptr + 2        // xt
 176+ E4AE             >Heap_Ptr        defl    $ - $E000           // save current HP
 176+ E4AE             >
 176+ E4AE             >Current_HP      defl  $ - $E000             // used to set HP once!
 176+ E4AE             >
 176+ E4AE             >//              ______________________________________________________________________
 176+ E4AE             >//              Dictionary part
 176+ E4AE             >
 176+ E4AE             >                org     Dict_Ptr
 176+ A394             >
 176+ A394 AC 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 176+ A396             >
 176+ A396             >DPL:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 176+ A396 CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 176+ A399             >
 176+ A399             >
 176+ A399             >                endif           ; ok        // for other definitions it "points" the correct handler
 176+ A399             >                // Use of "; ok" to suppress "warning[fwdref]"
 176+ A399             >
 176+ A399             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 176+ A399 30          >                db      48
 177+ A39A                              User_Def FLD        , "FLD"       , 50 // output field width
 177+ A39A             >                New_Def  FLD, "FLD", User_Ptr, is_normal
 177+ A39A             >
 177+ A39A             >Dict_Ptr        defl    $
 177+ A39A             >
 177+ A39A             >//              ______________________________________________________________________
 177+ A39A             >//              Heap part
 177+ A39A             >
 177+ A39A             >
 177+ A39A             >                org     (Heap_Ptr & $1FFF) + $E000
 177+ E4AE             >
 177+ E4AE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 177+ E4AE             >Latest_Definition defl  Heap_Ptr
 177+ E4AE             >
 177+ E4AE             >                // dummy db directives used to calculate length of namec
 177+ E4AE 46 4C 44    >                db      "FLD"
 177+ E4B1             >len_NFA         defl    $ - temp_NFA
 177+ E4B1             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 177+ E4AE             >
 177+ E4AE 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 177+ E4AF 46 4C 44    >                db      "FLD"               // name string in 7-bit ascii, but
 177+ E4B2             >                org     $-1                 // alter last byte of Name just above to set
 177+ E4B1 C4          >                db      {b $} | END_BIT     // msb as name end
 177+ E4B2             >
 177+ E4B2 A6 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 177+ E4B4             >Prev_Ptr        defl    Heap_Ptr
 177+ E4B4             >
 177+ E4B4             >mirror_Ptr      defl    $
 177+ E4B4             >
 177+ E4B4 9C A3       >                dw      Dict_Ptr + 2        // xt
 177+ E4B6             >Heap_Ptr        defl    $ - $E000           // save current HP
 177+ E4B6             >
 177+ E4B6             >Current_HP      defl  $ - $E000             // used to set HP once!
 177+ E4B6             >
 177+ E4B6             >//              ______________________________________________________________________
 177+ E4B6             >//              Dictionary part
 177+ E4B6             >
 177+ E4B6             >                org     Dict_Ptr
 177+ A39A             >
 177+ A39A B4 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 177+ A39C             >
 177+ A39C             >FLD:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 177+ A39C CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 177+ A39F             >
 177+ A39F             >
 177+ A39F             >                endif           ; ok        // for other definitions it "points" the correct handler
 177+ A39F             >                // Use of "; ok" to suppress "warning[fwdref]"
 177+ A39F             >
 177+ A39F             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 177+ A39F 32          >                db      50
 178+ A3A0                              User_Def CSP        , "CSP"       , 52 // used to temporary store Stack-Pointer value
 178+ A3A0             >                New_Def  CSP, "CSP", User_Ptr, is_normal
 178+ A3A0             >
 178+ A3A0             >Dict_Ptr        defl    $
 178+ A3A0             >
 178+ A3A0             >//              ______________________________________________________________________
 178+ A3A0             >//              Heap part
 178+ A3A0             >
 178+ A3A0             >
 178+ A3A0             >                org     (Heap_Ptr & $1FFF) + $E000
 178+ E4B6             >
 178+ E4B6             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 178+ E4B6             >Latest_Definition defl  Heap_Ptr
 178+ E4B6             >
 178+ E4B6             >                // dummy db directives used to calculate length of namec
 178+ E4B6 43 53 50    >                db      "CSP"
 178+ E4B9             >len_NFA         defl    $ - temp_NFA
 178+ E4B9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 178+ E4B6             >
 178+ E4B6 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 178+ E4B7 43 53 50    >                db      "CSP"               // name string in 7-bit ascii, but
 178+ E4BA             >                org     $-1                 // alter last byte of Name just above to set
 178+ E4B9 D0          >                db      {b $} | END_BIT     // msb as name end
 178+ E4BA             >
 178+ E4BA AE 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 178+ E4BC             >Prev_Ptr        defl    Heap_Ptr
 178+ E4BC             >
 178+ E4BC             >mirror_Ptr      defl    $
 178+ E4BC             >
 178+ E4BC A2 A3       >                dw      Dict_Ptr + 2        // xt
 178+ E4BE             >Heap_Ptr        defl    $ - $E000           // save current HP
 178+ E4BE             >
 178+ E4BE             >Current_HP      defl  $ - $E000             // used to set HP once!
 178+ E4BE             >
 178+ E4BE             >//              ______________________________________________________________________
 178+ E4BE             >//              Dictionary part
 178+ E4BE             >
 178+ E4BE             >                org     Dict_Ptr
 178+ A3A0             >
 178+ A3A0 BC 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 178+ A3A2             >
 178+ A3A2             >CSP:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 178+ A3A2 CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 178+ A3A5             >
 178+ A3A5             >
 178+ A3A5             >                endif           ; ok        // for other definitions it "points" the correct handler
 178+ A3A5             >                // Use of "; ok" to suppress "warning[fwdref]"
 178+ A3A5             >
 178+ A3A5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 178+ A3A5 34          >                db      52
 179+ A3A6                              User_Def RSHARP     , "R#"        , 54 // location of editing cursor
 179+ A3A6             >                New_Def  RSHARP, "R#", User_Ptr, is_normal
 179+ A3A6             >
 179+ A3A6             >Dict_Ptr        defl    $
 179+ A3A6             >
 179+ A3A6             >//              ______________________________________________________________________
 179+ A3A6             >//              Heap part
 179+ A3A6             >
 179+ A3A6             >
 179+ A3A6             >                org     (Heap_Ptr & $1FFF) + $E000
 179+ E4BE             >
 179+ E4BE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 179+ E4BE             >Latest_Definition defl  Heap_Ptr
 179+ E4BE             >
 179+ E4BE             >                // dummy db directives used to calculate length of namec
 179+ E4BE 52 23       >                db      "R#"
 179+ E4C0             >len_NFA         defl    $ - temp_NFA
 179+ E4C0             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 179+ E4BE             >
 179+ E4BE 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 179+ E4BF 52 23       >                db      "R#"               // name string in 7-bit ascii, but
 179+ E4C1             >                org     $-1                 // alter last byte of Name just above to set
 179+ E4C0 A3          >                db      {b $} | END_BIT     // msb as name end
 179+ E4C1             >
 179+ E4C1 B6 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 179+ E4C3             >Prev_Ptr        defl    Heap_Ptr
 179+ E4C3             >
 179+ E4C3             >mirror_Ptr      defl    $
 179+ E4C3             >
 179+ E4C3 A8 A3       >                dw      Dict_Ptr + 2        // xt
 179+ E4C5             >Heap_Ptr        defl    $ - $E000           // save current HP
 179+ E4C5             >
 179+ E4C5             >Current_HP      defl  $ - $E000             // used to set HP once!
 179+ E4C5             >
 179+ E4C5             >//              ______________________________________________________________________
 179+ E4C5             >//              Dictionary part
 179+ E4C5             >
 179+ E4C5             >                org     Dict_Ptr
 179+ A3A6             >
 179+ A3A6 C3 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 179+ A3A8             >
 179+ A3A8             >RSHARP:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 179+ A3A8 CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 179+ A3AB             >
 179+ A3AB             >
 179+ A3AB             >                endif           ; ok        // for other definitions it "points" the correct handler
 179+ A3AB             >                // Use of "; ok" to suppress "warning[fwdref]"
 179+ A3AB             >
 179+ A3AB             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 179+ A3AB 36          >                db      54
 180+ A3AC                              User_Def HLD        , "HLD"       , 56 // last character during a number conversion output
 180+ A3AC             >                New_Def  HLD, "HLD", User_Ptr, is_normal
 180+ A3AC             >
 180+ A3AC             >Dict_Ptr        defl    $
 180+ A3AC             >
 180+ A3AC             >//              ______________________________________________________________________
 180+ A3AC             >//              Heap part
 180+ A3AC             >
 180+ A3AC             >
 180+ A3AC             >                org     (Heap_Ptr & $1FFF) + $E000
 180+ E4C5             >
 180+ E4C5             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 180+ E4C5             >Latest_Definition defl  Heap_Ptr
 180+ E4C5             >
 180+ E4C5             >                // dummy db directives used to calculate length of namec
 180+ E4C5 48 4C 44    >                db      "HLD"
 180+ E4C8             >len_NFA         defl    $ - temp_NFA
 180+ E4C8             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 180+ E4C5             >
 180+ E4C5 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 180+ E4C6 48 4C 44    >                db      "HLD"               // name string in 7-bit ascii, but
 180+ E4C9             >                org     $-1                 // alter last byte of Name just above to set
 180+ E4C8 C4          >                db      {b $} | END_BIT     // msb as name end
 180+ E4C9             >
 180+ E4C9 BE 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 180+ E4CB             >Prev_Ptr        defl    Heap_Ptr
 180+ E4CB             >
 180+ E4CB             >mirror_Ptr      defl    $
 180+ E4CB             >
 180+ E4CB AE A3       >                dw      Dict_Ptr + 2        // xt
 180+ E4CD             >Heap_Ptr        defl    $ - $E000           // save current HP
 180+ E4CD             >
 180+ E4CD             >Current_HP      defl  $ - $E000             // used to set HP once!
 180+ E4CD             >
 180+ E4CD             >//              ______________________________________________________________________
 180+ E4CD             >//              Dictionary part
 180+ E4CD             >
 180+ E4CD             >                org     Dict_Ptr
 180+ A3AC             >
 180+ A3AC CB 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 180+ A3AE             >
 180+ A3AE             >HLD:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 180+ A3AE CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 180+ A3B1             >
 180+ A3B1             >
 180+ A3B1             >                endif           ; ok        // for other definitions it "points" the correct handler
 180+ A3B1             >                // Use of "; ok" to suppress "warning[fwdref]"
 180+ A3B1             >
 180+ A3B1             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 180+ A3B1 38          >                db      56
 181+ A3B2                              User_Def USE        , "USE"       , 58 // address of last used block
 181+ A3B2             >                New_Def  USE, "USE", User_Ptr, is_normal
 181+ A3B2             >
 181+ A3B2             >Dict_Ptr        defl    $
 181+ A3B2             >
 181+ A3B2             >//              ______________________________________________________________________
 181+ A3B2             >//              Heap part
 181+ A3B2             >
 181+ A3B2             >
 181+ A3B2             >                org     (Heap_Ptr & $1FFF) + $E000
 181+ E4CD             >
 181+ E4CD             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 181+ E4CD             >Latest_Definition defl  Heap_Ptr
 181+ E4CD             >
 181+ E4CD             >                // dummy db directives used to calculate length of namec
 181+ E4CD 55 53 45    >                db      "USE"
 181+ E4D0             >len_NFA         defl    $ - temp_NFA
 181+ E4D0             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 181+ E4CD             >
 181+ E4CD 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 181+ E4CE 55 53 45    >                db      "USE"               // name string in 7-bit ascii, but
 181+ E4D1             >                org     $-1                 // alter last byte of Name just above to set
 181+ E4D0 C5          >                db      {b $} | END_BIT     // msb as name end
 181+ E4D1             >
 181+ E4D1 C5 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 181+ E4D3             >Prev_Ptr        defl    Heap_Ptr
 181+ E4D3             >
 181+ E4D3             >mirror_Ptr      defl    $
 181+ E4D3             >
 181+ E4D3 B4 A3       >                dw      Dict_Ptr + 2        // xt
 181+ E4D5             >Heap_Ptr        defl    $ - $E000           // save current HP
 181+ E4D5             >
 181+ E4D5             >Current_HP      defl  $ - $E000             // used to set HP once!
 181+ E4D5             >
 181+ E4D5             >//              ______________________________________________________________________
 181+ E4D5             >//              Dictionary part
 181+ E4D5             >
 181+ E4D5             >                org     Dict_Ptr
 181+ A3B2             >
 181+ A3B2 D3 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 181+ A3B4             >
 181+ A3B4             >USE:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 181+ A3B4 CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 181+ A3B7             >
 181+ A3B7             >
 181+ A3B7             >                endif           ; ok        // for other definitions it "points" the correct handler
 181+ A3B7             >                // Use of "; ok" to suppress "warning[fwdref]"
 181+ A3B7             >
 181+ A3B7             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 181+ A3B7 3A          >                db      58
 182+ A3B8                              User_Def PREV       , "PREV"      , 60 // address of previous used block
 182+ A3B8             >                New_Def  PREV, "PREV", User_Ptr, is_normal
 182+ A3B8             >
 182+ A3B8             >Dict_Ptr        defl    $
 182+ A3B8             >
 182+ A3B8             >//              ______________________________________________________________________
 182+ A3B8             >//              Heap part
 182+ A3B8             >
 182+ A3B8             >
 182+ A3B8             >                org     (Heap_Ptr & $1FFF) + $E000
 182+ E4D5             >
 182+ E4D5             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 182+ E4D5             >Latest_Definition defl  Heap_Ptr
 182+ E4D5             >
 182+ E4D5             >                // dummy db directives used to calculate length of namec
 182+ E4D5 50 52 45 56 >                db      "PREV"
 182+ E4D9             >len_NFA         defl    $ - temp_NFA
 182+ E4D9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 182+ E4D5             >
 182+ E4D5 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 182+ E4D6 50 52 45 56 >                db      "PREV"               // name string in 7-bit ascii, but
 182+ E4DA             >                org     $-1                 // alter last byte of Name just above to set
 182+ E4D9 D6          >                db      {b $} | END_BIT     // msb as name end
 182+ E4DA             >
 182+ E4DA CD 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 182+ E4DC             >Prev_Ptr        defl    Heap_Ptr
 182+ E4DC             >
 182+ E4DC             >mirror_Ptr      defl    $
 182+ E4DC             >
 182+ E4DC BA A3       >                dw      Dict_Ptr + 2        // xt
 182+ E4DE             >Heap_Ptr        defl    $ - $E000           // save current HP
 182+ E4DE             >
 182+ E4DE             >Current_HP      defl  $ - $E000             // used to set HP once!
 182+ E4DE             >
 182+ E4DE             >//              ______________________________________________________________________
 182+ E4DE             >//              Dictionary part
 182+ E4DE             >
 182+ E4DE             >                org     Dict_Ptr
 182+ A3B8             >
 182+ A3B8 DC 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 182+ A3BA             >
 182+ A3BA             >PREV:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 182+ A3BA CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 182+ A3BD             >
 182+ A3BD             >
 182+ A3BD             >                endif           ; ok        // for other definitions it "points" the correct handler
 182+ A3BD             >                // Use of "; ok" to suppress "warning[fwdref]"
 182+ A3BD             >
 182+ A3BD             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 182+ A3BD 3C          >                db      60
 183+ A3BE                              User_Def LP         , "LP"        , 62 // line printer (not used)
 183+ A3BE             >                New_Def  LP, "LP", User_Ptr, is_normal
 183+ A3BE             >
 183+ A3BE             >Dict_Ptr        defl    $
 183+ A3BE             >
 183+ A3BE             >//              ______________________________________________________________________
 183+ A3BE             >//              Heap part
 183+ A3BE             >
 183+ A3BE             >
 183+ A3BE             >                org     (Heap_Ptr & $1FFF) + $E000
 183+ E4DE             >
 183+ E4DE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 183+ E4DE             >Latest_Definition defl  Heap_Ptr
 183+ E4DE             >
 183+ E4DE             >                // dummy db directives used to calculate length of namec
 183+ E4DE 4C 50       >                db      "LP"
 183+ E4E0             >len_NFA         defl    $ - temp_NFA
 183+ E4E0             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 183+ E4DE             >
 183+ E4DE 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 183+ E4DF 4C 50       >                db      "LP"               // name string in 7-bit ascii, but
 183+ E4E1             >                org     $-1                 // alter last byte of Name just above to set
 183+ E4E0 D0          >                db      {b $} | END_BIT     // msb as name end
 183+ E4E1             >
 183+ E4E1 D5 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 183+ E4E3             >Prev_Ptr        defl    Heap_Ptr
 183+ E4E3             >
 183+ E4E3             >mirror_Ptr      defl    $
 183+ E4E3             >
 183+ E4E3 C0 A3       >                dw      Dict_Ptr + 2        // xt
 183+ E4E5             >Heap_Ptr        defl    $ - $E000           // save current HP
 183+ E4E5             >
 183+ E4E5             >Current_HP      defl  $ - $E000             // used to set HP once!
 183+ E4E5             >
 183+ E4E5             >//              ______________________________________________________________________
 183+ E4E5             >//              Dictionary part
 183+ E4E5             >
 183+ E4E5             >                org     Dict_Ptr
 183+ A3BE             >
 183+ A3BE E3 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 183+ A3C0             >
 183+ A3C0             >LP:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 183+ A3C0 CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 183+ A3C3             >
 183+ A3C3             >
 183+ A3C3             >                endif           ; ok        // for other definitions it "points" the correct handler
 183+ A3C3             >                // Use of "; ok" to suppress "warning[fwdref]"
 183+ A3C3             >
 183+ A3C3             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 183+ A3C3 3E          >                db      62
 184+ A3C4                              User_Def PLACE      , "PLACE"     , 64 // number of digits after decimal point in output
 184+ A3C4             >                New_Def  PLACE, "PLACE", User_Ptr, is_normal
 184+ A3C4             >
 184+ A3C4             >Dict_Ptr        defl    $
 184+ A3C4             >
 184+ A3C4             >//              ______________________________________________________________________
 184+ A3C4             >//              Heap part
 184+ A3C4             >
 184+ A3C4             >
 184+ A3C4             >                org     (Heap_Ptr & $1FFF) + $E000
 184+ E4E5             >
 184+ E4E5             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 184+ E4E5             >Latest_Definition defl  Heap_Ptr
 184+ E4E5             >
 184+ E4E5             >                // dummy db directives used to calculate length of namec
 184+ E4E5 50 4C 41 43 >                db      "PLACE"
 184+ E4E9 45          >
 184+ E4EA             >len_NFA         defl    $ - temp_NFA
 184+ E4EA             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 184+ E4E5             >
 184+ E4E5 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 184+ E4E6 50 4C 41 43 >                db      "PLACE"               // name string in 7-bit ascii, but
 184+ E4EA 45          >
 184+ E4EB             >                org     $-1                 // alter last byte of Name just above to set
 184+ E4EA C5          >                db      {b $} | END_BIT     // msb as name end
 184+ E4EB             >
 184+ E4EB DE 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 184+ E4ED             >Prev_Ptr        defl    Heap_Ptr
 184+ E4ED             >
 184+ E4ED             >mirror_Ptr      defl    $
 184+ E4ED             >
 184+ E4ED C6 A3       >                dw      Dict_Ptr + 2        // xt
 184+ E4EF             >Heap_Ptr        defl    $ - $E000           // save current HP
 184+ E4EF             >
 184+ E4EF             >Current_HP      defl  $ - $E000             // used to set HP once!
 184+ E4EF             >
 184+ E4EF             >//              ______________________________________________________________________
 184+ E4EF             >//              Dictionary part
 184+ E4EF             >
 184+ E4EF             >                org     Dict_Ptr
 184+ A3C4             >
 184+ A3C4 ED 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 184+ A3C6             >
 184+ A3C6             >PLACE:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 184+ A3C6 CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 184+ A3C9             >
 184+ A3C9             >
 184+ A3C9             >                endif           ; ok        // for other definitions it "points" the correct handler
 184+ A3C9             >                // Use of "; ok" to suppress "warning[fwdref]"
 184+ A3C9             >
 184+ A3C9             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 184+ A3C9 40          >                db      64
 185+ A3CA                              User_Def SOURCE_ID  , "SOURCE-ID" , 66 // data-stream number in INCLUDE and LOAD-
 185+ A3CA             >                New_Def  SOURCE_ID, "SOURCE-ID", User_Ptr, is_normal
 185+ A3CA             >
 185+ A3CA             >Dict_Ptr        defl    $
 185+ A3CA             >
 185+ A3CA             >//              ______________________________________________________________________
 185+ A3CA             >//              Heap part
 185+ A3CA             >
 185+ A3CA             >
 185+ A3CA             >                org     (Heap_Ptr & $1FFF) + $E000
 185+ E4EF             >
 185+ E4EF             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 185+ E4EF             >Latest_Definition defl  Heap_Ptr
 185+ E4EF             >
 185+ E4EF             >                // dummy db directives used to calculate length of namec
 185+ E4EF 53 4F 55 52 >                db      "SOURCE-ID"
 185+ E4F3 43 45 2D 49 >
 185+ E4F7 44          >
 185+ E4F8             >len_NFA         defl    $ - temp_NFA
 185+ E4F8             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 185+ E4EF             >
 185+ E4EF 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 185+ E4F0 53 4F 55 52 >                db      "SOURCE-ID"               // name string in 7-bit ascii, but
 185+ E4F4 43 45 2D 49 >
 185+ E4F8 44          >
 185+ E4F9             >                org     $-1                 // alter last byte of Name just above to set
 185+ E4F8 C4          >                db      {b $} | END_BIT     // msb as name end
 185+ E4F9             >
 185+ E4F9 E5 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 185+ E4FB             >Prev_Ptr        defl    Heap_Ptr
 185+ E4FB             >
 185+ E4FB             >mirror_Ptr      defl    $
 185+ E4FB             >
 185+ E4FB CC A3       >                dw      Dict_Ptr + 2        // xt
 185+ E4FD             >Heap_Ptr        defl    $ - $E000           // save current HP
 185+ E4FD             >
 185+ E4FD             >Current_HP      defl  $ - $E000             // used to set HP once!
 185+ E4FD             >
 185+ E4FD             >//              ______________________________________________________________________
 185+ E4FD             >//              Dictionary part
 185+ E4FD             >
 185+ E4FD             >                org     Dict_Ptr
 185+ A3CA             >
 185+ A3CA FB 24       >                dw      mirror_Ptr - $E000 + Heap_offset
 185+ A3CC             >
 185+ A3CC             >SOURCE_ID:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 185+ A3CC CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 185+ A3CF             >
 185+ A3CF             >
 185+ A3CF             >                endif           ; ok        // for other definitions it "points" the correct handler
 185+ A3CF             >                // Use of "; ok" to suppress "warning[fwdref]"
 185+ A3CF             >
 185+ A3CF             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 185+ A3CF 42          >                db      66
 186+ A3D0                              User_Def SPAN       , "SPAN"      , 68 // number of character of last EXPECT
 186+ A3D0             >                New_Def  SPAN, "SPAN", User_Ptr, is_normal
 186+ A3D0             >
 186+ A3D0             >Dict_Ptr        defl    $
 186+ A3D0             >
 186+ A3D0             >//              ______________________________________________________________________
 186+ A3D0             >//              Heap part
 186+ A3D0             >
 186+ A3D0             >
 186+ A3D0             >                org     (Heap_Ptr & $1FFF) + $E000
 186+ E4FD             >
 186+ E4FD             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 186+ E4FD             >Latest_Definition defl  Heap_Ptr
 186+ E4FD             >
 186+ E4FD             >                // dummy db directives used to calculate length of namec
 186+ E4FD 53 50 41 4E >                db      "SPAN"
 186+ E501             >len_NFA         defl    $ - temp_NFA
 186+ E501             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 186+ E4FD             >
 186+ E4FD 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 186+ E4FE 53 50 41 4E >                db      "SPAN"               // name string in 7-bit ascii, but
 186+ E502             >                org     $-1                 // alter last byte of Name just above to set
 186+ E501 CE          >                db      {b $} | END_BIT     // msb as name end
 186+ E502             >
 186+ E502 EF 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 186+ E504             >Prev_Ptr        defl    Heap_Ptr
 186+ E504             >
 186+ E504             >mirror_Ptr      defl    $
 186+ E504             >
 186+ E504 D2 A3       >                dw      Dict_Ptr + 2        // xt
 186+ E506             >Heap_Ptr        defl    $ - $E000           // save current HP
 186+ E506             >
 186+ E506             >Current_HP      defl  $ - $E000             // used to set HP once!
 186+ E506             >
 186+ E506             >//              ______________________________________________________________________
 186+ E506             >//              Dictionary part
 186+ E506             >
 186+ E506             >                org     Dict_Ptr
 186+ A3D0             >
 186+ A3D0 04 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 186+ A3D2             >
 186+ A3D2             >SPAN:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 186+ A3D2 CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 186+ A3D5             >
 186+ A3D5             >
 186+ A3D5             >                endif           ; ok        // for other definitions it "points" the correct handler
 186+ A3D5             >                // Use of "; ok" to suppress "warning[fwdref]"
 186+ A3D5             >
 186+ A3D5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 186+ A3D5 44          >                db      68
 187+ A3D6                              User_Def HANDLER    , "HANDLER"   , 70 // Used by THROW-CATCH
 187+ A3D6             >                New_Def  HANDLER, "HANDLER", User_Ptr, is_normal
 187+ A3D6             >
 187+ A3D6             >Dict_Ptr        defl    $
 187+ A3D6             >
 187+ A3D6             >//              ______________________________________________________________________
 187+ A3D6             >//              Heap part
 187+ A3D6             >
 187+ A3D6             >
 187+ A3D6             >                org     (Heap_Ptr & $1FFF) + $E000
 187+ E506             >
 187+ E506             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 187+ E506             >Latest_Definition defl  Heap_Ptr
 187+ E506             >
 187+ E506             >                // dummy db directives used to calculate length of namec
 187+ E506 48 41 4E 44 >                db      "HANDLER"
 187+ E50A 4C 45 52    >
 187+ E50D             >len_NFA         defl    $ - temp_NFA
 187+ E50D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 187+ E506             >
 187+ E506 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 187+ E507 48 41 4E 44 >                db      "HANDLER"               // name string in 7-bit ascii, but
 187+ E50B 4C 45 52    >
 187+ E50E             >                org     $-1                 // alter last byte of Name just above to set
 187+ E50D D2          >                db      {b $} | END_BIT     // msb as name end
 187+ E50E             >
 187+ E50E FD 24       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 187+ E510             >Prev_Ptr        defl    Heap_Ptr
 187+ E510             >
 187+ E510             >mirror_Ptr      defl    $
 187+ E510             >
 187+ E510 D8 A3       >                dw      Dict_Ptr + 2        // xt
 187+ E512             >Heap_Ptr        defl    $ - $E000           // save current HP
 187+ E512             >
 187+ E512             >Current_HP      defl  $ - $E000             // used to set HP once!
 187+ E512             >
 187+ E512             >//              ______________________________________________________________________
 187+ E512             >//              Dictionary part
 187+ E512             >
 187+ E512             >                org     Dict_Ptr
 187+ A3D6             >
 187+ A3D6 10 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 187+ A3D8             >
 187+ A3D8             >HANDLER:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 187+ A3D8 CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 187+ A3DB             >
 187+ A3DB             >
 187+ A3DB             >                endif           ; ok        // for other definitions it "points" the correct handler
 187+ A3DB             >                // Use of "; ok" to suppress "warning[fwdref]"
 187+ A3DB             >
 187+ A3DB             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 187+ A3DB 46          >                db      70
 188+ A3DC                              User_Def EXP        , "EXP"       , 72 // keeps the exponent in number conversion
 188+ A3DC             >                New_Def  EXP, "EXP", User_Ptr, is_normal
 188+ A3DC             >
 188+ A3DC             >Dict_Ptr        defl    $
 188+ A3DC             >
 188+ A3DC             >//              ______________________________________________________________________
 188+ A3DC             >//              Heap part
 188+ A3DC             >
 188+ A3DC             >
 188+ A3DC             >                org     (Heap_Ptr & $1FFF) + $E000
 188+ E512             >
 188+ E512             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 188+ E512             >Latest_Definition defl  Heap_Ptr
 188+ E512             >
 188+ E512             >                // dummy db directives used to calculate length of namec
 188+ E512 45 58 50    >                db      "EXP"
 188+ E515             >len_NFA         defl    $ - temp_NFA
 188+ E515             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 188+ E512             >
 188+ E512 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 188+ E513 45 58 50    >                db      "EXP"               // name string in 7-bit ascii, but
 188+ E516             >                org     $-1                 // alter last byte of Name just above to set
 188+ E515 D0          >                db      {b $} | END_BIT     // msb as name end
 188+ E516             >
 188+ E516 06 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 188+ E518             >Prev_Ptr        defl    Heap_Ptr
 188+ E518             >
 188+ E518             >mirror_Ptr      defl    $
 188+ E518             >
 188+ E518 DE A3       >                dw      Dict_Ptr + 2        // xt
 188+ E51A             >Heap_Ptr        defl    $ - $E000           // save current HP
 188+ E51A             >
 188+ E51A             >Current_HP      defl  $ - $E000             // used to set HP once!
 188+ E51A             >
 188+ E51A             >//              ______________________________________________________________________
 188+ E51A             >//              Dictionary part
 188+ E51A             >
 188+ E51A             >                org     Dict_Ptr
 188+ A3DC             >
 188+ A3DC 18 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 188+ A3DE             >
 188+ A3DE             >EXP:          if User_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 188+ A3DE CD B3 A2    >                call    User_Ptr ; ok        // for primitive definitions  actual code
 188+ A3E1             >
 188+ A3E1             >
 188+ A3E1             >                endif           ; ok        // for other definitions it "points" the correct handler
 188+ A3E1             >                // Use of "; ok" to suppress "warning[fwdref]"
 188+ A3E1             >
 188+ A3E1             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 188+ A3E1 48          >                db      72
 189+ A3E2
 190+ A3E2              //  ______________________________________________________________________
 191+ A3E2              //
 192+ A3E2              // here         -- a
 193+ A3E2                              Colon_Def HERE, "HERE", is_normal
 193+ A3E2             >                New_Def  HERE, "HERE", Enter_Ptr, is_normal ; ok
 193+ A3E2             >
 193+ A3E2             >Dict_Ptr        defl    $
 193+ A3E2             >
 193+ A3E2             >//              ______________________________________________________________________
 193+ A3E2             >//              Heap part
 193+ A3E2             >
 193+ A3E2             >
 193+ A3E2             >                org     (Heap_Ptr & $1FFF) + $E000
 193+ E51A             >
 193+ E51A             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 193+ E51A             >Latest_Definition defl  Heap_Ptr
 193+ E51A             >
 193+ E51A             >                // dummy db directives used to calculate length of namec
 193+ E51A 48 45 52 45 >                db      "HERE"
 193+ E51E             >len_NFA         defl    $ - temp_NFA
 193+ E51E             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 193+ E51A             >
 193+ E51A 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 193+ E51B 48 45 52 45 >                db      "HERE"               // name string in 7-bit ascii, but
 193+ E51F             >                org     $-1                 // alter last byte of Name just above to set
 193+ E51E C5          >                db      {b $} | END_BIT     // msb as name end
 193+ E51F             >
 193+ E51F 12 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 193+ E521             >Prev_Ptr        defl    Heap_Ptr
 193+ E521             >
 193+ E521             >mirror_Ptr      defl    $
 193+ E521             >
 193+ E521 E4 A3       >                dw      Dict_Ptr + 2        // xt
 193+ E523             >Heap_Ptr        defl    $ - $E000           // save current HP
 193+ E523             >
 193+ E523             >Current_HP      defl  $ - $E000             // used to set HP once!
 193+ E523             >
 193+ E523             >//              ______________________________________________________________________
 193+ E523             >//              Dictionary part
 193+ E523             >
 193+ E523             >                org     Dict_Ptr
 193+ A3E2             >
 193+ A3E2 21 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 193+ A3E4             >
 193+ A3E4             >HERE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 193+ A3E4 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 193+ A3E7             >
 193+ A3E7             >
 193+ A3E7             >                endif           ; ok        // for other definitions it "points" the correct handler
 193+ A3E7             >                // Use of "; ok" to suppress "warning[fwdref]"
 193+ A3E7             >
 193+ A3E7             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 194+ A3E7 3C A3 C7 A1                  dw      DP, FETCH               // dp @
 195+ A3EB 90 A0                        dw      EXIT                    // ;
 196+ A3ED
 197+ A3ED              //  ______________________________________________________________________
 198+ A3ED              //
 199+ A3ED              // allot        n --
 200+ A3ED                              Colon_Def ALLOT, "ALLOT", is_normal
 200+ A3ED             >                New_Def  ALLOT, "ALLOT", Enter_Ptr, is_normal ; ok
 200+ A3ED             >
 200+ A3ED             >Dict_Ptr        defl    $
 200+ A3ED             >
 200+ A3ED             >//              ______________________________________________________________________
 200+ A3ED             >//              Heap part
 200+ A3ED             >
 200+ A3ED             >
 200+ A3ED             >                org     (Heap_Ptr & $1FFF) + $E000
 200+ E523             >
 200+ E523             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 200+ E523             >Latest_Definition defl  Heap_Ptr
 200+ E523             >
 200+ E523             >                // dummy db directives used to calculate length of namec
 200+ E523 41 4C 4C 4F >                db      "ALLOT"
 200+ E527 54          >
 200+ E528             >len_NFA         defl    $ - temp_NFA
 200+ E528             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 200+ E523             >
 200+ E523 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 200+ E524 41 4C 4C 4F >                db      "ALLOT"               // name string in 7-bit ascii, but
 200+ E528 54          >
 200+ E529             >                org     $-1                 // alter last byte of Name just above to set
 200+ E528 D4          >                db      {b $} | END_BIT     // msb as name end
 200+ E529             >
 200+ E529 1A 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 200+ E52B             >Prev_Ptr        defl    Heap_Ptr
 200+ E52B             >
 200+ E52B             >mirror_Ptr      defl    $
 200+ E52B             >
 200+ E52B EF A3       >                dw      Dict_Ptr + 2        // xt
 200+ E52D             >Heap_Ptr        defl    $ - $E000           // save current HP
 200+ E52D             >
 200+ E52D             >Current_HP      defl  $ - $E000             // used to set HP once!
 200+ E52D             >
 200+ E52D             >//              ______________________________________________________________________
 200+ E52D             >//              Dictionary part
 200+ E52D             >
 200+ E52D             >                org     Dict_Ptr
 200+ A3ED             >
 200+ A3ED 2B 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 200+ A3EF             >
 200+ A3EF             >ALLOT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 200+ A3EF CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 200+ A3F2             >
 200+ A3F2             >
 200+ A3F2             >                endif           ; ok        // for other definitions it "points" the correct handler
 200+ A3F2             >                // Use of "; ok" to suppress "warning[fwdref]"
 200+ A3F2             >
 200+ A3F2             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 201+ A3F2 3C A3 AF A1                  dw      DP,  PLUSSTORE          // dp +!
 202+ A3F6 90 A0                        dw      EXIT                    // ;
 203+ A3F8
 204+ A3F8              //  ______________________________________________________________________
 205+ A3F8              //
 206+ A3F8              // comma        n --
 207+ A3F8                              Colon_Def COMMA, ",", is_normal
 207+ A3F8             >                New_Def  COMMA, ",", Enter_Ptr, is_normal ; ok
 207+ A3F8             >
 207+ A3F8             >Dict_Ptr        defl    $
 207+ A3F8             >
 207+ A3F8             >//              ______________________________________________________________________
 207+ A3F8             >//              Heap part
 207+ A3F8             >
 207+ A3F8             >
 207+ A3F8             >                org     (Heap_Ptr & $1FFF) + $E000
 207+ E52D             >
 207+ E52D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 207+ E52D             >Latest_Definition defl  Heap_Ptr
 207+ E52D             >
 207+ E52D             >                // dummy db directives used to calculate length of namec
 207+ E52D 2C          >                db      ","
 207+ E52E             >len_NFA         defl    $ - temp_NFA
 207+ E52E             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 207+ E52D             >
 207+ E52D 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 207+ E52E 2C          >                db      ","               // name string in 7-bit ascii, but
 207+ E52F             >                org     $-1                 // alter last byte of Name just above to set
 207+ E52E AC          >                db      {b $} | END_BIT     // msb as name end
 207+ E52F             >
 207+ E52F 23 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 207+ E531             >Prev_Ptr        defl    Heap_Ptr
 207+ E531             >
 207+ E531             >mirror_Ptr      defl    $
 207+ E531             >
 207+ E531 FA A3       >                dw      Dict_Ptr + 2        // xt
 207+ E533             >Heap_Ptr        defl    $ - $E000           // save current HP
 207+ E533             >
 207+ E533             >Current_HP      defl  $ - $E000             // used to set HP once!
 207+ E533             >
 207+ E533             >//              ______________________________________________________________________
 207+ E533             >//              Dictionary part
 207+ E533             >
 207+ E533             >                org     Dict_Ptr
 207+ A3F8             >
 207+ A3F8 31 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 207+ A3FA             >
 207+ A3FA             >COMMA:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 207+ A3FA CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 207+ A3FD             >
 207+ A3FD             >
 207+ A3FD             >                endif           ; ok        // for other definitions it "points" the correct handler
 207+ A3FD             >                // Use of "; ok" to suppress "warning[fwdref]"
 207+ A3FD             >
 207+ A3FD             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 208+ A3FD E4 A3 D1 A1                  dw      HERE, STORE             // here !
 209+ A401 CD A2 EF A3                  dw      TWO, ALLOT              // 2 allot
 210+ A405 90 A0                        dw      EXIT                    // ;
 211+ A407
 212+ A407              //  ______________________________________________________________________
 213+ A407              //
 214+ A407              // ccomma       c --
 215+ A407                              Colon_Def CCOMMA, "C,", is_normal
 215+ A407             >                New_Def  CCOMMA, "C,", Enter_Ptr, is_normal ; ok
 215+ A407             >
 215+ A407             >Dict_Ptr        defl    $
 215+ A407             >
 215+ A407             >//              ______________________________________________________________________
 215+ A407             >//              Heap part
 215+ A407             >
 215+ A407             >
 215+ A407             >                org     (Heap_Ptr & $1FFF) + $E000
 215+ E533             >
 215+ E533             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 215+ E533             >Latest_Definition defl  Heap_Ptr
 215+ E533             >
 215+ E533             >                // dummy db directives used to calculate length of namec
 215+ E533 43 2C       >                db      "C,"
 215+ E535             >len_NFA         defl    $ - temp_NFA
 215+ E535             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 215+ E533             >
 215+ E533 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 215+ E534 43 2C       >                db      "C,"               // name string in 7-bit ascii, but
 215+ E536             >                org     $-1                 // alter last byte of Name just above to set
 215+ E535 AC          >                db      {b $} | END_BIT     // msb as name end
 215+ E536             >
 215+ E536 2D 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 215+ E538             >Prev_Ptr        defl    Heap_Ptr
 215+ E538             >
 215+ E538             >mirror_Ptr      defl    $
 215+ E538             >
 215+ E538 09 A4       >                dw      Dict_Ptr + 2        // xt
 215+ E53A             >Heap_Ptr        defl    $ - $E000           // save current HP
 215+ E53A             >
 215+ E53A             >Current_HP      defl  $ - $E000             // used to set HP once!
 215+ E53A             >
 215+ E53A             >//              ______________________________________________________________________
 215+ E53A             >//              Dictionary part
 215+ E53A             >
 215+ E53A             >                org     Dict_Ptr
 215+ A407             >
 215+ A407 38 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 215+ A409             >
 215+ A409             >CCOMMA:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 215+ A409 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 215+ A40C             >
 215+ A40C             >
 215+ A40C             >                endif           ; ok        // for other definitions it "points" the correct handler
 215+ A40C             >                // Use of "; ok" to suppress "warning[fwdref]"
 215+ A40C             >
 215+ A40C             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 216+ A40C E4 A3 E5 A1                  dw      HERE, CSTORE            // here c!
 217+ A410 C6 A2 EF A3                  dw      ONE, ALLOT              // 1 allot
 218+ A414 90 A0                        dw      EXIT                    // ;
 219+ A416
 220+ A416              //  ______________________________________________________________________
 221+ A416              //
 222+ A416              // s>d          n -- d
 223+ A416              // converts a single precision integer in a double precision
 224+ A416                              New_Def S_TO_D, "S>D", is_code, is_normal
 224+ A416             >
 224+ A416             >Dict_Ptr        defl    $
 224+ A416             >
 224+ A416             >//              ______________________________________________________________________
 224+ A416             >//              Heap part
 224+ A416             >
 224+ A416             >
 224+ A416             >                org     (Heap_Ptr & $1FFF) + $E000
 224+ E53A             >
 224+ E53A             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 224+ E53A             >Latest_Definition defl  Heap_Ptr
 224+ E53A             >
 224+ E53A             >                // dummy db directives used to calculate length of namec
 224+ E53A 53 3E 44    >                db      "S>D"
 224+ E53D             >len_NFA         defl    $ - temp_NFA
 224+ E53D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 224+ E53A             >
 224+ E53A 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 224+ E53B 53 3E 44    >                db      "S>D"               // name string in 7-bit ascii, but
 224+ E53E             >                org     $-1                 // alter last byte of Name just above to set
 224+ E53D C4          >                db      {b $} | END_BIT     // msb as name end
 224+ E53E             >
 224+ E53E 33 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 224+ E540             >Prev_Ptr        defl    Heap_Ptr
 224+ E540             >
 224+ E540             >mirror_Ptr      defl    $
 224+ E540             >
 224+ E540 18 A4       >                dw      Dict_Ptr + 2        // xt
 224+ E542             >Heap_Ptr        defl    $ - $E000           // save current HP
 224+ E542             >
 224+ E542             >Current_HP      defl  $ - $E000             // used to set HP once!
 224+ E542             >
 224+ E542             >//              ______________________________________________________________________
 224+ E542             >//              Dictionary part
 224+ E542             >
 224+ E542             >                org     Dict_Ptr
 224+ A416             >
 224+ A416 40 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 224+ A418             >
 224+ A418             >S_TO_D:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 224+ A418 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 224+ A418 ~           >
 224+ A418 ~           >
 224+ A418             >                endif           ; ok        // for other definitions it "points" the correct handler
 224+ A418             >                // Use of "; ok" to suppress "warning[fwdref]"
 224+ A418             >
 224+ A418             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 225+ A418 E1                           pop     hl
 226+ A419 7C                           ld      a, h
 227+ A41A E5                           push    hl
 228+ A41B 17                           rla
 229+ A41C ED 62                        sbc     hl, hl
 230+ A41E E5                           push    hl
 231+ A41F                              next
 231+ A41F DD E9       >                jp      (ix)
 232+ A421
 233+ A421              //  ______________________________________________________________________
 234+ A421              //
 235+ A421              // -            n1 n2 -- n3
 236+ A421              // subtraction
 237+ A421                              New_Def SUBTRACT, "-", is_code, is_normal
 237+ A421             >
 237+ A421             >Dict_Ptr        defl    $
 237+ A421             >
 237+ A421             >//              ______________________________________________________________________
 237+ A421             >//              Heap part
 237+ A421             >
 237+ A421             >
 237+ A421             >                org     (Heap_Ptr & $1FFF) + $E000
 237+ E542             >
 237+ E542             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 237+ E542             >Latest_Definition defl  Heap_Ptr
 237+ E542             >
 237+ E542             >                // dummy db directives used to calculate length of namec
 237+ E542 2D          >                db      "-"
 237+ E543             >len_NFA         defl    $ - temp_NFA
 237+ E543             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 237+ E542             >
 237+ E542 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 237+ E543 2D          >                db      "-"               // name string in 7-bit ascii, but
 237+ E544             >                org     $-1                 // alter last byte of Name just above to set
 237+ E543 AD          >                db      {b $} | END_BIT     // msb as name end
 237+ E544             >
 237+ E544 3A 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 237+ E546             >Prev_Ptr        defl    Heap_Ptr
 237+ E546             >
 237+ E546             >mirror_Ptr      defl    $
 237+ E546             >
 237+ E546 23 A4       >                dw      Dict_Ptr + 2        // xt
 237+ E548             >Heap_Ptr        defl    $ - $E000           // save current HP
 237+ E548             >
 237+ E548             >Current_HP      defl  $ - $E000             // used to set HP once!
 237+ E548             >
 237+ E548             >//              ______________________________________________________________________
 237+ E548             >//              Dictionary part
 237+ E548             >
 237+ E548             >                org     Dict_Ptr
 237+ A421             >
 237+ A421 46 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 237+ A423             >
 237+ A423             >SUBTRACT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 237+ A423 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 237+ A423 ~           >
 237+ A423 ~           >
 237+ A423             >                endif           ; ok        // for other definitions it "points" the correct handler
 237+ A423             >                // Use of "; ok" to suppress "warning[fwdref]"
 237+ A423             >
 237+ A423             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 238+ A423 D9                           exx
 239+ A424 D1                           pop     de
 240+ A425 E1                           pop     hl
 241+ A426 A7                           and     a
 242+ A427 ED 52                        sbc     hl, de
 243+ A429 E5                           push    hl
 244+ A42A D9                           exx
 245+ A42B                              next
 245+ A42B DD E9       >                jp      (ix)
 246+ A42D
 247+ A42D
 248+ A42D              //  ______________________________________________________________________
 249+ A42D              //
 250+ A42D              // =            n1 n2 -- n3
 251+ A42D              // equals
 252+ A42D                              Colon_Def EQUALS, "=", is_normal
 252+ A42D             >                New_Def  EQUALS, "=", Enter_Ptr, is_normal ; ok
 252+ A42D             >
 252+ A42D             >Dict_Ptr        defl    $
 252+ A42D             >
 252+ A42D             >//              ______________________________________________________________________
 252+ A42D             >//              Heap part
 252+ A42D             >
 252+ A42D             >
 252+ A42D             >                org     (Heap_Ptr & $1FFF) + $E000
 252+ E548             >
 252+ E548             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 252+ E548             >Latest_Definition defl  Heap_Ptr
 252+ E548             >
 252+ E548             >                // dummy db directives used to calculate length of namec
 252+ E548 3D          >                db      "="
 252+ E549             >len_NFA         defl    $ - temp_NFA
 252+ E549             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 252+ E548             >
 252+ E548 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 252+ E549 3D          >                db      "="               // name string in 7-bit ascii, but
 252+ E54A             >                org     $-1                 // alter last byte of Name just above to set
 252+ E549 BD          >                db      {b $} | END_BIT     // msb as name end
 252+ E54A             >
 252+ E54A 42 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 252+ E54C             >Prev_Ptr        defl    Heap_Ptr
 252+ E54C             >
 252+ E54C             >mirror_Ptr      defl    $
 252+ E54C             >
 252+ E54C 2F A4       >                dw      Dict_Ptr + 2        // xt
 252+ E54E             >Heap_Ptr        defl    $ - $E000           // save current HP
 252+ E54E             >
 252+ E54E             >Current_HP      defl  $ - $E000             // used to set HP once!
 252+ E54E             >
 252+ E54E             >//              ______________________________________________________________________
 252+ E54E             >//              Dictionary part
 252+ E54E             >
 252+ E54E             >                org     Dict_Ptr
 252+ A42D             >
 252+ A42D 4C 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 252+ A42F             >
 252+ A42F             >EQUALS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 252+ A42F CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 252+ A432             >
 252+ A432             >
 252+ A432             >                endif           ; ok        // for other definitions it "points" the correct handler
 252+ A432             >                // Use of "; ok" to suppress "warning[fwdref]"
 252+ A432             >
 252+ A432             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 253+ A432 23 A4 B5 A0                  dw      SUBTRACT, ZEQUAL        // - 0=
 254+ A436 90 A0                        dw      EXIT                    // ;
 255+ A438
 256+ A438              //  ______________________________________________________________________
 257+ A438              //
 258+ A438              // u<           u1 u2 -- u3
 259+ A438              // unsigned less-than
 260+ A438                              New_Def ULESS, "U<", is_code, is_normal
 260+ A438             >
 260+ A438             >Dict_Ptr        defl    $
 260+ A438             >
 260+ A438             >//              ______________________________________________________________________
 260+ A438             >//              Heap part
 260+ A438             >
 260+ A438             >
 260+ A438             >                org     (Heap_Ptr & $1FFF) + $E000
 260+ E54E             >
 260+ E54E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 260+ E54E             >Latest_Definition defl  Heap_Ptr
 260+ E54E             >
 260+ E54E             >                // dummy db directives used to calculate length of namec
 260+ E54E 55 3C       >                db      "U<"
 260+ E550             >len_NFA         defl    $ - temp_NFA
 260+ E550             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 260+ E54E             >
 260+ E54E 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 260+ E54F 55 3C       >                db      "U<"               // name string in 7-bit ascii, but
 260+ E551             >                org     $-1                 // alter last byte of Name just above to set
 260+ E550 BC          >                db      {b $} | END_BIT     // msb as name end
 260+ E551             >
 260+ E551 48 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 260+ E553             >Prev_Ptr        defl    Heap_Ptr
 260+ E553             >
 260+ E553             >mirror_Ptr      defl    $
 260+ E553             >
 260+ E553 3A A4       >                dw      Dict_Ptr + 2        // xt
 260+ E555             >Heap_Ptr        defl    $ - $E000           // save current HP
 260+ E555             >
 260+ E555             >Current_HP      defl  $ - $E000             // used to set HP once!
 260+ E555             >
 260+ E555             >//              ______________________________________________________________________
 260+ E555             >//              Dictionary part
 260+ E555             >
 260+ E555             >                org     Dict_Ptr
 260+ A438             >
 260+ A438 53 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 260+ A43A             >
 260+ A43A             >ULESS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 260+ A43A ~           >                call    runcode ; ok        // for primitive definitions  actual code
 260+ A43A ~           >
 260+ A43A ~           >
 260+ A43A             >                endif           ; ok        // for other definitions it "points" the correct handler
 260+ A43A             >                // Use of "; ok" to suppress "warning[fwdref]"
 260+ A43A             >
 260+ A43A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 261+ A43A D9                           exx
 262+ A43B D1                           pop     de
 263+ A43C E1                           pop     hl
 264+ A43D A7                           and     a
 265+ A43E ED 52                        sbc     hl, de
 266+ A440 ED 62                        sbc     hl, hl
 267+ A442 E5                           push    hl
 268+ A443 D9                           exx
 269+ A444                              next
 269+ A444 DD E9       >                jp      (ix)
 270+ A446
 271+ A446              //  ______________________________________________________________________
 272+ A446              //
 273+ A446              // <           n1 n2 -- n3
 274+ A446              // less-than
 275+ A446                              New_Def LESS, "<", is_code, is_normal
 275+ A446             >
 275+ A446             >Dict_Ptr        defl    $
 275+ A446             >
 275+ A446             >//              ______________________________________________________________________
 275+ A446             >//              Heap part
 275+ A446             >
 275+ A446             >
 275+ A446             >                org     (Heap_Ptr & $1FFF) + $E000
 275+ E555             >
 275+ E555             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 275+ E555             >Latest_Definition defl  Heap_Ptr
 275+ E555             >
 275+ E555             >                // dummy db directives used to calculate length of namec
 275+ E555 3C          >                db      "<"
 275+ E556             >len_NFA         defl    $ - temp_NFA
 275+ E556             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 275+ E555             >
 275+ E555 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 275+ E556 3C          >                db      "<"               // name string in 7-bit ascii, but
 275+ E557             >                org     $-1                 // alter last byte of Name just above to set
 275+ E556 BC          >                db      {b $} | END_BIT     // msb as name end
 275+ E557             >
 275+ E557 4E 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 275+ E559             >Prev_Ptr        defl    Heap_Ptr
 275+ E559             >
 275+ E559             >mirror_Ptr      defl    $
 275+ E559             >
 275+ E559 48 A4       >                dw      Dict_Ptr + 2        // xt
 275+ E55B             >Heap_Ptr        defl    $ - $E000           // save current HP
 275+ E55B             >
 275+ E55B             >Current_HP      defl  $ - $E000             // used to set HP once!
 275+ E55B             >
 275+ E55B             >//              ______________________________________________________________________
 275+ E55B             >//              Dictionary part
 275+ E55B             >
 275+ E55B             >                org     Dict_Ptr
 275+ A446             >
 275+ A446 59 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 275+ A448             >
 275+ A448             >LESS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 275+ A448 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 275+ A448 ~           >
 275+ A448 ~           >
 275+ A448             >                endif           ; ok        // for other definitions it "points" the correct handler
 275+ A448             >                // Use of "; ok" to suppress "warning[fwdref]"
 275+ A448             >
 275+ A448             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 276+ A448 D9                           exx
 277+ A449 D1                           pop     de
 278+ A44A E1                           pop     hl
 279+ A44B 7C                           ld      a, h
 280+ A44C EE 80                        xor     $80
 281+ A44E 67                           ld      h, a
 282+ A44F 7A                           ld      a, d
 283+ A450 EE 80                        xor     $80
 284+ A452 57                           ld      d, a
 285+ A453              //              and     a
 286+ A453 ED 52                        sbc     hl, de
 287+ A455 ED 62                        sbc     hl, hl
 288+ A457 E5                           push    hl
 289+ A458 D9                           exx
 290+ A459                              next
 290+ A459 DD E9       >                jp      (ix)
 291+ A45B
 292+ A45B              //  ______________________________________________________________________
 293+ A45B              //
 294+ A45B              // >            n1 n2 -- n3
 295+ A45B              // greater than
 296+ A45B                              Colon_Def GREATER, ">", is_normal
 296+ A45B             >                New_Def  GREATER, ">", Enter_Ptr, is_normal ; ok
 296+ A45B             >
 296+ A45B             >Dict_Ptr        defl    $
 296+ A45B             >
 296+ A45B             >//              ______________________________________________________________________
 296+ A45B             >//              Heap part
 296+ A45B             >
 296+ A45B             >
 296+ A45B             >                org     (Heap_Ptr & $1FFF) + $E000
 296+ E55B             >
 296+ E55B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 296+ E55B             >Latest_Definition defl  Heap_Ptr
 296+ E55B             >
 296+ E55B             >                // dummy db directives used to calculate length of namec
 296+ E55B 3E          >                db      ">"
 296+ E55C             >len_NFA         defl    $ - temp_NFA
 296+ E55C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 296+ E55B             >
 296+ E55B 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 296+ E55C 3E          >                db      ">"               // name string in 7-bit ascii, but
 296+ E55D             >                org     $-1                 // alter last byte of Name just above to set
 296+ E55C BE          >                db      {b $} | END_BIT     // msb as name end
 296+ E55D             >
 296+ E55D 55 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 296+ E55F             >Prev_Ptr        defl    Heap_Ptr
 296+ E55F             >
 296+ E55F             >mirror_Ptr      defl    $
 296+ E55F             >
 296+ E55F 5D A4       >                dw      Dict_Ptr + 2        // xt
 296+ E561             >Heap_Ptr        defl    $ - $E000           // save current HP
 296+ E561             >
 296+ E561             >Current_HP      defl  $ - $E000             // used to set HP once!
 296+ E561             >
 296+ E561             >//              ______________________________________________________________________
 296+ E561             >//              Dictionary part
 296+ E561             >
 296+ E561             >                org     Dict_Ptr
 296+ A45B             >
 296+ A45B 5F 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 296+ A45D             >
 296+ A45D             >GREATER:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 296+ A45D CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 296+ A460             >
 296+ A460             >
 296+ A460             >                endif           ; ok        // for other definitions it "points" the correct handler
 296+ A460             >                // Use of "; ok" to suppress "warning[fwdref]"
 296+ A460             >
 296+ A460             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 297+ A460 62 A1 48 A4                  dw      SWAP, LESS              // swap <
 298+ A464 90 A0                        dw      EXIT                    // ;
 299+ A466              //  ______________________________________________________________________
 300+ A466              //
 301+ A466              // min          n1 n2 -- n3
 302+ A466              // minimum between n1 and n2
 303+ A466                              Colon_Def MIN, "MIN" , is_normal
 303+ A466             >                New_Def  MIN, "MIN", Enter_Ptr, is_normal ; ok
 303+ A466             >
 303+ A466             >Dict_Ptr        defl    $
 303+ A466             >
 303+ A466             >//              ______________________________________________________________________
 303+ A466             >//              Heap part
 303+ A466             >
 303+ A466             >
 303+ A466             >                org     (Heap_Ptr & $1FFF) + $E000
 303+ E561             >
 303+ E561             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 303+ E561             >Latest_Definition defl  Heap_Ptr
 303+ E561             >
 303+ E561             >                // dummy db directives used to calculate length of namec
 303+ E561 4D 49 4E    >                db      "MIN"
 303+ E564             >len_NFA         defl    $ - temp_NFA
 303+ E564             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 303+ E561             >
 303+ E561 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 303+ E562 4D 49 4E    >                db      "MIN"               // name string in 7-bit ascii, but
 303+ E565             >                org     $-1                 // alter last byte of Name just above to set
 303+ E564 CE          >                db      {b $} | END_BIT     // msb as name end
 303+ E565             >
 303+ E565 5B 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 303+ E567             >Prev_Ptr        defl    Heap_Ptr
 303+ E567             >
 303+ E567             >mirror_Ptr      defl    $
 303+ E567             >
 303+ E567 68 A4       >                dw      Dict_Ptr + 2        // xt
 303+ E569             >Heap_Ptr        defl    $ - $E000           // save current HP
 303+ E569             >
 303+ E569             >Current_HP      defl  $ - $E000             // used to set HP once!
 303+ E569             >
 303+ E569             >//              ______________________________________________________________________
 303+ E569             >//              Dictionary part
 303+ E569             >
 303+ E569             >                org     Dict_Ptr
 303+ A466             >
 303+ A466 67 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 303+ A468             >
 303+ A468             >MIN:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 303+ A468 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 303+ A46B             >
 303+ A46B             >
 303+ A46B             >                endif           ; ok        // for other definitions it "points" the correct handler
 303+ A46B             >                // Use of "; ok" to suppress "warning[fwdref]"
 303+ A46B             >
 303+ A46B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 304+ A46B A5 A1                        dw      TWO_DUP                 // 2dup
 305+ A46D 5D A4                        dw      GREATER                 // >
 306+ A46F 33 9C                        dw      ZBRANCH
 307+ A471 04 00                        dw      Min_Skip - $   // if
 308+ A473 62 A1                        dw          SWAP                //      swap
 309+ A475              Min_Skip:                                       // endif
 310+ A475 4E A1                        dw      DROP                    // drop
 311+ A477 90 A0                        dw      EXIT                    // ;
 312+ A479
 313+ A479              //  ______________________________________________________________________
 314+ A479              //
 315+ A479              // max          n1 n2 -- n3
 316+ A479              // maximum between n1 and n2
 317+ A479                              Colon_Def MAX, "MAX", is_normal
 317+ A479             >                New_Def  MAX, "MAX", Enter_Ptr, is_normal ; ok
 317+ A479             >
 317+ A479             >Dict_Ptr        defl    $
 317+ A479             >
 317+ A479             >//              ______________________________________________________________________
 317+ A479             >//              Heap part
 317+ A479             >
 317+ A479             >
 317+ A479             >                org     (Heap_Ptr & $1FFF) + $E000
 317+ E569             >
 317+ E569             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 317+ E569             >Latest_Definition defl  Heap_Ptr
 317+ E569             >
 317+ E569             >                // dummy db directives used to calculate length of namec
 317+ E569 4D 41 58    >                db      "MAX"
 317+ E56C             >len_NFA         defl    $ - temp_NFA
 317+ E56C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 317+ E569             >
 317+ E569 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 317+ E56A 4D 41 58    >                db      "MAX"               // name string in 7-bit ascii, but
 317+ E56D             >                org     $-1                 // alter last byte of Name just above to set
 317+ E56C D8          >                db      {b $} | END_BIT     // msb as name end
 317+ E56D             >
 317+ E56D 61 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 317+ E56F             >Prev_Ptr        defl    Heap_Ptr
 317+ E56F             >
 317+ E56F             >mirror_Ptr      defl    $
 317+ E56F             >
 317+ E56F 7B A4       >                dw      Dict_Ptr + 2        // xt
 317+ E571             >Heap_Ptr        defl    $ - $E000           // save current HP
 317+ E571             >
 317+ E571             >Current_HP      defl  $ - $E000             // used to set HP once!
 317+ E571             >
 317+ E571             >//              ______________________________________________________________________
 317+ E571             >//              Dictionary part
 317+ E571             >
 317+ E571             >                org     Dict_Ptr
 317+ A479             >
 317+ A479 6F 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 317+ A47B             >
 317+ A47B             >MAX:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 317+ A47B CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 317+ A47E             >
 317+ A47E             >
 317+ A47E             >                endif           ; ok        // for other definitions it "points" the correct handler
 317+ A47E             >                // Use of "; ok" to suppress "warning[fwdref]"
 317+ A47E             >
 317+ A47E             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 318+ A47E A5 A1                        dw      TWO_DUP                 // 2dup
 319+ A480 48 A4                        dw      LESS                    // <
 320+ A482 33 9C                        dw      ZBRANCH
 321+ A484 04 00                        dw      Max_Skip - $   // if
 322+ A486 62 A1                        dw          SWAP                //      swap
 323+ A488              Max_Skip:                                       // endif
 324+ A488 4E A1                        dw      DROP                    // drop
 325+ A48A 90 A0                        dw      EXIT                    // ;
 326+ A48C
 327+ A48C              //  ______________________________________________________________________
 328+ A48C              //
 329+ A48C              // ?dup         n -- 0 | n n
 330+ A48C              // duplicate if not zero
 331+ A48C                              New_Def QDUP, "?DUP", is_code, is_normal
 331+ A48C             >
 331+ A48C             >Dict_Ptr        defl    $
 331+ A48C             >
 331+ A48C             >//              ______________________________________________________________________
 331+ A48C             >//              Heap part
 331+ A48C             >
 331+ A48C             >
 331+ A48C             >                org     (Heap_Ptr & $1FFF) + $E000
 331+ E571             >
 331+ E571             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 331+ E571             >Latest_Definition defl  Heap_Ptr
 331+ E571             >
 331+ E571             >                // dummy db directives used to calculate length of namec
 331+ E571 3F 44 55 50 >                db      "?DUP"
 331+ E575             >len_NFA         defl    $ - temp_NFA
 331+ E575             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 331+ E571             >
 331+ E571 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 331+ E572 3F 44 55 50 >                db      "?DUP"               // name string in 7-bit ascii, but
 331+ E576             >                org     $-1                 // alter last byte of Name just above to set
 331+ E575 D0          >                db      {b $} | END_BIT     // msb as name end
 331+ E576             >
 331+ E576 69 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 331+ E578             >Prev_Ptr        defl    Heap_Ptr
 331+ E578             >
 331+ E578             >mirror_Ptr      defl    $
 331+ E578             >
 331+ E578 8E A4       >                dw      Dict_Ptr + 2        // xt
 331+ E57A             >Heap_Ptr        defl    $ - $E000           // save current HP
 331+ E57A             >
 331+ E57A             >Current_HP      defl  $ - $E000             // used to set HP once!
 331+ E57A             >
 331+ E57A             >//              ______________________________________________________________________
 331+ E57A             >//              Dictionary part
 331+ E57A             >
 331+ E57A             >                org     Dict_Ptr
 331+ A48C             >
 331+ A48C 78 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 331+ A48E             >
 331+ A48E             >QDUP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 331+ A48E ~           >                call    runcode ; ok        // for primitive definitions  actual code
 331+ A48E ~           >
 331+ A48E ~           >
 331+ A48E             >                endif           ; ok        // for other definitions it "points" the correct handler
 331+ A48E             >                // Use of "; ok" to suppress "warning[fwdref]"
 331+ A48E             >
 331+ A48E             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 332+ A48E              QDup_Ptr:
 333+ A48E E1                           pop     hl
 334+ A48F 7C                           ld      a, h
 335+ A490 B5                           or      l
 336+ A491 28 01                        jr      z, QDup_Skip
 337+ A493 E5                               push    hl
 338+ A494              QDup_Skip:
 339+ A494                              psh1
 339+ A494 E5          >                push    hl
 339+ A495 DD E9       >                jp      (ix)
 340+ A497
 341+ A497              //  ______________________________________________________________________
 342+ A497              //
 343+ A497              // -dup         n -- 0 | n n
 344+ A497              // duplicate if not zero
 345+ A497                              New_Def LDUP, "-DUP", is_code, is_normal
 345+ A497             >
 345+ A497             >Dict_Ptr        defl    $
 345+ A497             >
 345+ A497             >//              ______________________________________________________________________
 345+ A497             >//              Heap part
 345+ A497             >
 345+ A497             >
 345+ A497             >                org     (Heap_Ptr & $1FFF) + $E000
 345+ E57A             >
 345+ E57A             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 345+ E57A             >Latest_Definition defl  Heap_Ptr
 345+ E57A             >
 345+ E57A             >                // dummy db directives used to calculate length of namec
 345+ E57A 2D 44 55 50 >                db      "-DUP"
 345+ E57E             >len_NFA         defl    $ - temp_NFA
 345+ E57E             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 345+ E57A             >
 345+ E57A 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 345+ E57B 2D 44 55 50 >                db      "-DUP"               // name string in 7-bit ascii, but
 345+ E57F             >                org     $-1                 // alter last byte of Name just above to set
 345+ E57E D0          >                db      {b $} | END_BIT     // msb as name end
 345+ E57F             >
 345+ E57F 71 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 345+ E581             >Prev_Ptr        defl    Heap_Ptr
 345+ E581             >
 345+ E581             >mirror_Ptr      defl    $
 345+ E581             >
 345+ E581 99 A4       >                dw      Dict_Ptr + 2        // xt
 345+ E583             >Heap_Ptr        defl    $ - $E000           // save current HP
 345+ E583             >
 345+ E583             >Current_HP      defl  $ - $E000             // used to set HP once!
 345+ E583             >
 345+ E583             >//              ______________________________________________________________________
 345+ E583             >//              Dictionary part
 345+ E583             >
 345+ E583             >                org     Dict_Ptr
 345+ A497             >
 345+ A497 81 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 345+ A499             >
 345+ A499             >LDUP:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 345+ A499 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 345+ A499 ~           >
 345+ A499 ~           >
 345+ A499             >                endif           ; ok        // for other definitions it "points" the correct handler
 345+ A499             >                // Use of "; ok" to suppress "warning[fwdref]"
 345+ A499             >
 345+ A499             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 346+ A499 C3 8E A4                     jp      QDup_Ptr
 347+ A49C
 348+ A49C              //  ______________________________________________________________________
 349+ A49C              //
 350+ A49C              // emit         c --
 351+ A49C                              Colon_Def EMIT, "EMIT", is_normal
 351+ A49C             >                New_Def  EMIT, "EMIT", Enter_Ptr, is_normal ; ok
 351+ A49C             >
 351+ A49C             >Dict_Ptr        defl    $
 351+ A49C             >
 351+ A49C             >//              ______________________________________________________________________
 351+ A49C             >//              Heap part
 351+ A49C             >
 351+ A49C             >
 351+ A49C             >                org     (Heap_Ptr & $1FFF) + $E000
 351+ E583             >
 351+ E583             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 351+ E583             >Latest_Definition defl  Heap_Ptr
 351+ E583             >
 351+ E583             >                // dummy db directives used to calculate length of namec
 351+ E583 45 4D 49 54 >                db      "EMIT"
 351+ E587             >len_NFA         defl    $ - temp_NFA
 351+ E587             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 351+ E583             >
 351+ E583 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 351+ E584 45 4D 49 54 >                db      "EMIT"               // name string in 7-bit ascii, but
 351+ E588             >                org     $-1                 // alter last byte of Name just above to set
 351+ E587 D4          >                db      {b $} | END_BIT     // msb as name end
 351+ E588             >
 351+ E588 7A 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 351+ E58A             >Prev_Ptr        defl    Heap_Ptr
 351+ E58A             >
 351+ E58A             >mirror_Ptr      defl    $
 351+ E58A             >
 351+ E58A 9E A4       >                dw      Dict_Ptr + 2        // xt
 351+ E58C             >Heap_Ptr        defl    $ - $E000           // save current HP
 351+ E58C             >
 351+ E58C             >Current_HP      defl  $ - $E000             // used to set HP once!
 351+ E58C             >
 351+ E58C             >//              ______________________________________________________________________
 351+ E58C             >//              Dictionary part
 351+ E58C             >
 351+ E58C             >                org     Dict_Ptr
 351+ A49C             >
 351+ A49C 8A 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 351+ A49E             >
 351+ A49E             >EMIT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 351+ A49E CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 351+ A4A1             >
 351+ A4A1             >
 351+ A4A1             >                endif           ; ok        // for other definitions it "points" the correct handler
 351+ A4A1             >                // Use of "; ok" to suppress "warning[fwdref]"
 351+ A4A1             >
 351+ A4A1             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 352+ A4A1 12 9E                        dw      C_EMIT                      // (?emit)
 353+ A4A3 8E A4                        dw      QDUP                        // ?dup
 354+ A4A5                                                                  // if
 355+ A4A5 33 9C                        dw      ZBRANCH
 356+ A4A7 0A 00                        dw      Emit_Skip - $
 357+ A4A9 E0 9D                        dw          EMITC                   //      emitc
 358+ A4AB C6 A2                        dw          ONE                     //      1
 359+ A4AD 6C A3 AF A1                  dw          OUT, PLUSSTORE        //      out +!
 360+ A4B1              Emit_Skip:                                          // endif
 361+ A4B1 90 A0                        dw      EXIT                        // ;
 362+ A4B3
 363+ A4B3              //  ______________________________________________________________________
 364+ A4B3              //
 365+ A4B3              // space        --
 366+ A4B3                              Colon_Def SPACE, "SPACE", is_normal
 366+ A4B3             >                New_Def  SPACE, "SPACE", Enter_Ptr, is_normal ; ok
 366+ A4B3             >
 366+ A4B3             >Dict_Ptr        defl    $
 366+ A4B3             >
 366+ A4B3             >//              ______________________________________________________________________
 366+ A4B3             >//              Heap part
 366+ A4B3             >
 366+ A4B3             >
 366+ A4B3             >                org     (Heap_Ptr & $1FFF) + $E000
 366+ E58C             >
 366+ E58C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 366+ E58C             >Latest_Definition defl  Heap_Ptr
 366+ E58C             >
 366+ E58C             >                // dummy db directives used to calculate length of namec
 366+ E58C 53 50 41 43 >                db      "SPACE"
 366+ E590 45          >
 366+ E591             >len_NFA         defl    $ - temp_NFA
 366+ E591             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 366+ E58C             >
 366+ E58C 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 366+ E58D 53 50 41 43 >                db      "SPACE"               // name string in 7-bit ascii, but
 366+ E591 45          >
 366+ E592             >                org     $-1                 // alter last byte of Name just above to set
 366+ E591 C5          >                db      {b $} | END_BIT     // msb as name end
 366+ E592             >
 366+ E592 83 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 366+ E594             >Prev_Ptr        defl    Heap_Ptr
 366+ E594             >
 366+ E594             >mirror_Ptr      defl    $
 366+ E594             >
 366+ E594 B5 A4       >                dw      Dict_Ptr + 2        // xt
 366+ E596             >Heap_Ptr        defl    $ - $E000           // save current HP
 366+ E596             >
 366+ E596             >Current_HP      defl  $ - $E000             // used to set HP once!
 366+ E596             >
 366+ E596             >//              ______________________________________________________________________
 366+ E596             >//              Dictionary part
 366+ E596             >
 366+ E596             >                org     Dict_Ptr
 366+ A4B3             >
 366+ A4B3 94 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 366+ A4B5             >
 366+ A4B5             >SPACE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 366+ A4B5 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 366+ A4B8             >
 366+ A4B8             >
 366+ A4B8             >                endif           ; ok        // for other definitions it "points" the correct handler
 366+ A4B8             >                // Use of "; ok" to suppress "warning[fwdref]"
 366+ A4B8             >
 366+ A4B8             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 367+ A4B8 E2 A2 9E A4                  dw      BL, EMIT                // bl emit
 368+ A4BC 90 A0                        dw      EXIT                    // ;
 369+ A4BE
 370+ A4BE              //  ______________________________________________________________________
 371+ A4BE              //
 372+ A4BE              // traverse     a n -- a
 373+ A4BE              // A dictionary entry is structured as follows
 374+ A4BE              // NFA: +0   one byte of word-length (n<32) | some flags (immediate, smudge) | $80
 375+ A4BE              //      +1   word name, last character is toggled with $80
 376+ A4BE              // LFA: +1+n link to NFA ofprevious  dictionary entry.
 377+ A4BE              // CFA: +3+n routine address. Colon definitions here have a CALL aa
 378+ A4BE              // PFA: +6+n "is_code", definitions have no PFA. // +5
 379+ A4BE              //
 380+ A4BE                              Colon_Def TRAVERSE, "TRAVERSE", is_normal
 380+ A4BE             >                New_Def  TRAVERSE, "TRAVERSE", Enter_Ptr, is_normal ; ok
 380+ A4BE             >
 380+ A4BE             >Dict_Ptr        defl    $
 380+ A4BE             >
 380+ A4BE             >//              ______________________________________________________________________
 380+ A4BE             >//              Heap part
 380+ A4BE             >
 380+ A4BE             >
 380+ A4BE             >                org     (Heap_Ptr & $1FFF) + $E000
 380+ E596             >
 380+ E596             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 380+ E596             >Latest_Definition defl  Heap_Ptr
 380+ E596             >
 380+ E596             >                // dummy db directives used to calculate length of namec
 380+ E596 54 52 41 56 >                db      "TRAVERSE"
 380+ E59A 45 52 53 45 >
 380+ E59E             >len_NFA         defl    $ - temp_NFA
 380+ E59E             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 380+ E596             >
 380+ E596 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 380+ E597 54 52 41 56 >                db      "TRAVERSE"               // name string in 7-bit ascii, but
 380+ E59B 45 52 53 45 >
 380+ E59F             >                org     $-1                 // alter last byte of Name just above to set
 380+ E59E C5          >                db      {b $} | END_BIT     // msb as name end
 380+ E59F             >
 380+ E59F 8C 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 380+ E5A1             >Prev_Ptr        defl    Heap_Ptr
 380+ E5A1             >
 380+ E5A1             >mirror_Ptr      defl    $
 380+ E5A1             >
 380+ E5A1 C0 A4       >                dw      Dict_Ptr + 2        // xt
 380+ E5A3             >Heap_Ptr        defl    $ - $E000           // save current HP
 380+ E5A3             >
 380+ E5A3             >Current_HP      defl  $ - $E000             // used to set HP once!
 380+ E5A3             >
 380+ E5A3             >//              ______________________________________________________________________
 380+ E5A3             >//              Dictionary part
 380+ E5A3             >
 380+ E5A3             >                org     Dict_Ptr
 380+ A4BE             >
 380+ A4BE A1 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 380+ A4C0             >
 380+ A4C0             >TRAVERSE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 380+ A4C0 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 380+ A4C3             >
 380+ A4C3             >
 380+ A4C3             >                endif           ; ok        // for other definitions it "points" the correct handler
 380+ A4C3             >                // Use of "; ok" to suppress "warning[fwdref]"
 380+ A4C3             >
 380+ A4C3             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 381+ A4C3 62 A1                        dw      SWAP                    // swap
 382+ A4C5              Traverse_Begin:                                 // begin
 383+ A4C5 45 A1 E3 A0                  dw          OVER, PLUS          //      over +
 384+ A4C9 E1 9B 7F 00                  dw          LIT, 127            //      127
 385+ A4CD 45 A1 DC A1                  dw          OVER, CFETCH        //      over @
 386+ A4D1 48 A4                        dw          LESS                //      <
 387+ A4D3                                                              // until
 388+ A4D3 33 9C                        dw      ZBRANCH
 389+ A4D5 F0 FF                        dw      Traverse_Begin - $
 390+ A4D7 53 A1                        dw      NIP                     //  nip
 391+ A4D9 90 A0                        dw      EXIT                    //  ;
 392+ A4DB
 393+ A4DB              //  ______________________________________________________________________
 394+ A4DB              //
 395+ A4DB              // mmu7@        -- n
 396+ A4DB              // query current page in MMU7 8K-RAM : 0 and 223
 397+ A4DB
 398+ A4DB                              New_Def MMU7_FETCH, "MMU7@", is_code, is_normal
 398+ A4DB             >
 398+ A4DB             >Dict_Ptr        defl    $
 398+ A4DB             >
 398+ A4DB             >//              ______________________________________________________________________
 398+ A4DB             >//              Heap part
 398+ A4DB             >
 398+ A4DB             >
 398+ A4DB             >                org     (Heap_Ptr & $1FFF) + $E000
 398+ E5A3             >
 398+ E5A3             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 398+ E5A3             >Latest_Definition defl  Heap_Ptr
 398+ E5A3             >
 398+ E5A3             >                // dummy db directives used to calculate length of namec
 398+ E5A3 4D 4D 55 37 >                db      "MMU7@"
 398+ E5A7 40          >
 398+ E5A8             >len_NFA         defl    $ - temp_NFA
 398+ E5A8             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 398+ E5A3             >
 398+ E5A3 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 398+ E5A4 4D 4D 55 37 >                db      "MMU7@"               // name string in 7-bit ascii, but
 398+ E5A8 40          >
 398+ E5A9             >                org     $-1                 // alter last byte of Name just above to set
 398+ E5A8 C0          >                db      {b $} | END_BIT     // msb as name end
 398+ E5A9             >
 398+ E5A9 96 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 398+ E5AB             >Prev_Ptr        defl    Heap_Ptr
 398+ E5AB             >
 398+ E5AB             >mirror_Ptr      defl    $
 398+ E5AB             >
 398+ E5AB DD A4       >                dw      Dict_Ptr + 2        // xt
 398+ E5AD             >Heap_Ptr        defl    $ - $E000           // save current HP
 398+ E5AD             >
 398+ E5AD             >Current_HP      defl  $ - $E000             // used to set HP once!
 398+ E5AD             >
 398+ E5AD             >//              ______________________________________________________________________
 398+ E5AD             >//              Dictionary part
 398+ E5AD             >
 398+ E5AD             >                org     Dict_Ptr
 398+ A4DB             >
 398+ A4DB AB 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 398+ A4DD             >
 398+ A4DD             >MMU7_FETCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 398+ A4DD ~           >                call    runcode ; ok        // for primitive definitions  actual code
 398+ A4DD ~           >
 398+ A4DD ~           >
 398+ A4DD             >                endif           ; ok        // for other definitions it "points" the correct handler
 398+ A4DD             >                // Use of "; ok" to suppress "warning[fwdref]"
 398+ A4DD             >
 398+ A4DD             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 399+ A4DD D9                           exx
 400+ A4DE CD DD 9C                     call    MMU7_read
 401+ A4E1 D9                           exx
 402+ A4E2 6F                           ld      l, a
 403+ A4E3 26 00                        ld      h, 0
 404+ A4E5 E5                           push    hl
 405+ A4E6                              next
 405+ A4E6 DD E9       >                jp      (ix)
 406+ A4E8
 407+ A4E8              //  ______________________________________________________________________
 408+ A4E8              //
 409+ A4E8              // mmu7!        n --
 410+ A4E8              // set MMU7 8K-RAM page to n given between 0 and 223
 411+ A4E8              // optimized version that uses NEXTREG n,A Z80n op-code.
 412+ A4E8
 413+ A4E8                              New_Def MMU7_STORE, "MMU7!", is_code, is_normal
 413+ A4E8             >
 413+ A4E8             >Dict_Ptr        defl    $
 413+ A4E8             >
 413+ A4E8             >//              ______________________________________________________________________
 413+ A4E8             >//              Heap part
 413+ A4E8             >
 413+ A4E8             >
 413+ A4E8             >                org     (Heap_Ptr & $1FFF) + $E000
 413+ E5AD             >
 413+ E5AD             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 413+ E5AD             >Latest_Definition defl  Heap_Ptr
 413+ E5AD             >
 413+ E5AD             >                // dummy db directives used to calculate length of namec
 413+ E5AD 4D 4D 55 37 >                db      "MMU7!"
 413+ E5B1 21          >
 413+ E5B2             >len_NFA         defl    $ - temp_NFA
 413+ E5B2             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 413+ E5AD             >
 413+ E5AD 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 413+ E5AE 4D 4D 55 37 >                db      "MMU7!"               // name string in 7-bit ascii, but
 413+ E5B2 21          >
 413+ E5B3             >                org     $-1                 // alter last byte of Name just above to set
 413+ E5B2 A1          >                db      {b $} | END_BIT     // msb as name end
 413+ E5B3             >
 413+ E5B3 A3 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 413+ E5B5             >Prev_Ptr        defl    Heap_Ptr
 413+ E5B5             >
 413+ E5B5             >mirror_Ptr      defl    $
 413+ E5B5             >
 413+ E5B5 EA A4       >                dw      Dict_Ptr + 2        // xt
 413+ E5B7             >Heap_Ptr        defl    $ - $E000           // save current HP
 413+ E5B7             >
 413+ E5B7             >Current_HP      defl  $ - $E000             // used to set HP once!
 413+ E5B7             >
 413+ E5B7             >//              ______________________________________________________________________
 413+ E5B7             >//              Dictionary part
 413+ E5B7             >
 413+ E5B7             >                org     Dict_Ptr
 413+ A4E8             >
 413+ A4E8 B5 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 413+ A4EA             >
 413+ A4EA             >MMU7_STORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 413+ A4EA ~           >                call    runcode ; ok        // for primitive definitions  actual code
 413+ A4EA ~           >
 413+ A4EA ~           >
 413+ A4EA             >                endif           ; ok        // for other definitions it "points" the correct handler
 413+ A4EA             >                // Use of "; ok" to suppress "warning[fwdref]"
 413+ A4EA             >
 413+ A4EA             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 414+ A4EA E1                           pop     hl
 415+ A4EB 7D                           ld      a, l
 416+ A4EC ED 92 57                     nextreg 87, a
 417+ A4EF
 418+ A4EF                              next
 418+ A4EF DD E9       >                jp      (ix)
 419+ A4F1
 420+ A4F1              //  ______________________________________________________________________
 421+ A4F1              //
 422+ A4F1              // >far         ha -- a n
 423+ A4F1              // decode bits 765 of H as one of the 8K-page between 64 and 71 (40h-47h)
 424+ A4F1              // take lower bits of H and L as an offset from E000h
 425+ A4F1              // then return address  a  between E000h-FFFFh
 426+ A4F1              // and page number n  between 64-71 (40h-47h)
 427+ A4F1              // For example, in hex:
 428+ A4F1              //   0000 >FAR  gives  40.E000
 429+ A4F1              //   1FFF >FAR  gives  40.FFFF
 430+ A4F1              //   2000 >FAR  gives  41.E000
 431+ A4F1              //   3FFF >FAR  gives  41.FFFF
 432+ A4F1              //   EFFF >FAR  gives  47.EFFF
 433+ A4F1              //   FFFF >FAR  gives  47.FFFF
 434+ A4F1                              New_Def TO_FAR, ">FAR", is_code, is_normal
 434+ A4F1             >
 434+ A4F1             >Dict_Ptr        defl    $
 434+ A4F1             >
 434+ A4F1             >//              ______________________________________________________________________
 434+ A4F1             >//              Heap part
 434+ A4F1             >
 434+ A4F1             >
 434+ A4F1             >                org     (Heap_Ptr & $1FFF) + $E000
 434+ E5B7             >
 434+ E5B7             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 434+ E5B7             >Latest_Definition defl  Heap_Ptr
 434+ E5B7             >
 434+ E5B7             >                // dummy db directives used to calculate length of namec
 434+ E5B7 3E 46 41 52 >                db      ">FAR"
 434+ E5BB             >len_NFA         defl    $ - temp_NFA
 434+ E5BB             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 434+ E5B7             >
 434+ E5B7 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 434+ E5B8 3E 46 41 52 >                db      ">FAR"               // name string in 7-bit ascii, but
 434+ E5BC             >                org     $-1                 // alter last byte of Name just above to set
 434+ E5BB D2          >                db      {b $} | END_BIT     // msb as name end
 434+ E5BC             >
 434+ E5BC AD 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 434+ E5BE             >Prev_Ptr        defl    Heap_Ptr
 434+ E5BE             >
 434+ E5BE             >mirror_Ptr      defl    $
 434+ E5BE             >
 434+ E5BE F3 A4       >                dw      Dict_Ptr + 2        // xt
 434+ E5C0             >Heap_Ptr        defl    $ - $E000           // save current HP
 434+ E5C0             >
 434+ E5C0             >Current_HP      defl  $ - $E000             // used to set HP once!
 434+ E5C0             >
 434+ E5C0             >//              ______________________________________________________________________
 434+ E5C0             >//              Dictionary part
 434+ E5C0             >
 434+ E5C0             >                org     Dict_Ptr
 434+ A4F1             >
 434+ A4F1 BE 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 434+ A4F3             >
 434+ A4F3             >TO_FAR:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 434+ A4F3 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 434+ A4F3 ~           >
 434+ A4F3 ~           >
 434+ A4F3             >                endif           ; ok        // for other definitions it "points" the correct handler
 434+ A4F3             >                // Use of "; ok" to suppress "warning[fwdref]"
 434+ A4F3             >
 434+ A4F3             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 435+ A4F3 E1                           pop     hl
 436+ A4F4 CD E8 9C                     call    TO_FAR_rout
 437+ A4F7 E5                           push    hl
 438+ A4F8 6F                           ld      l, a
 439+ A4F9 26 00                        ld      h, 0
 440+ A4FB E5                           push    hl
 441+ A4FC                              next
 441+ A4FC DD E9       >                jp      (ix)
 442+ A4FE
 443+ A4FE              //  ______________________________________________________________________
 444+ A4FE              //
 445+ A4FE              // <far         a n  -- ha
 446+ A4FE              // given an address E000-FFFF and a page number n (64-71 or 40h-47h)
 447+ A4FE              // reverse of >FAR: encodes a FAR address compressing
 448+ A4FE              // to bits 765 of H, lower bits of HL address offset from E000h
 449+ A4FE                              New_Def FROM_FAR, "<FAR", is_code, is_normal
 449+ A4FE             >
 449+ A4FE             >Dict_Ptr        defl    $
 449+ A4FE             >
 449+ A4FE             >//              ______________________________________________________________________
 449+ A4FE             >//              Heap part
 449+ A4FE             >
 449+ A4FE             >
 449+ A4FE             >                org     (Heap_Ptr & $1FFF) + $E000
 449+ E5C0             >
 449+ E5C0             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 449+ E5C0             >Latest_Definition defl  Heap_Ptr
 449+ E5C0             >
 449+ E5C0             >                // dummy db directives used to calculate length of namec
 449+ E5C0 3C 46 41 52 >                db      "<FAR"
 449+ E5C4             >len_NFA         defl    $ - temp_NFA
 449+ E5C4             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 449+ E5C0             >
 449+ E5C0 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 449+ E5C1 3C 46 41 52 >                db      "<FAR"               // name string in 7-bit ascii, but
 449+ E5C5             >                org     $-1                 // alter last byte of Name just above to set
 449+ E5C4 D2          >                db      {b $} | END_BIT     // msb as name end
 449+ E5C5             >
 449+ E5C5 B7 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 449+ E5C7             >Prev_Ptr        defl    Heap_Ptr
 449+ E5C7             >
 449+ E5C7             >mirror_Ptr      defl    $
 449+ E5C7             >
 449+ E5C7 00 A5       >                dw      Dict_Ptr + 2        // xt
 449+ E5C9             >Heap_Ptr        defl    $ - $E000           // save current HP
 449+ E5C9             >
 449+ E5C9             >Current_HP      defl  $ - $E000             // used to set HP once!
 449+ E5C9             >
 449+ E5C9             >//              ______________________________________________________________________
 449+ E5C9             >//              Dictionary part
 449+ E5C9             >
 449+ E5C9             >                org     Dict_Ptr
 449+ A4FE             >
 449+ A4FE C7 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 449+ A500             >
 449+ A500             >FROM_FAR:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 449+ A500 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 449+ A500 ~           >
 449+ A500 ~           >
 449+ A500             >                endif           ; ok        // for other definitions it "points" the correct handler
 449+ A500             >                // Use of "; ok" to suppress "warning[fwdref]"
 449+ A500             >
 449+ A500             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 450+ A500 E1                           pop     hl                  // page number in e
 451+ A501 7D                           ld      a, l
 452+ A502 E6 07                        and     07
 453+ A504 0F                           rrca
 454+ A505 0F                           rrca
 455+ A506 0F                           rrca
 456+ A507 08                           ex      af, af
 457+ A508 E1                           pop     hl                  // address in hl
 458+ A509 7C                           ld      a, h
 459+ A50A E6 1F                        and     $1F
 460+ A50C 67                           ld      h, a
 461+ A50D 08                           ex      af, af
 462+ A50E B4                           or      h
 463+ A50F 67                           ld      h, a
 464+ A510                              psh1
 464+ A510 E5          >                push    hl
 464+ A511 DD E9       >                jp      (ix)
 465+ A513
 466+ A513              //  ______________________________________________________________________
 467+ A513              //
 468+ A513              // ?mmu7        a -- f
 469+ A513              // query current page in MMU7 8K-RAM : 0 and 223
 470+ A513                              Colon_Def QMMU7, "?MMU7", is_normal
 470+ A513             >                New_Def  QMMU7, "?MMU7", Enter_Ptr, is_normal ; ok
 470+ A513             >
 470+ A513             >Dict_Ptr        defl    $
 470+ A513             >
 470+ A513             >//              ______________________________________________________________________
 470+ A513             >//              Heap part
 470+ A513             >
 470+ A513             >
 470+ A513             >                org     (Heap_Ptr & $1FFF) + $E000
 470+ E5C9             >
 470+ E5C9             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 470+ E5C9             >Latest_Definition defl  Heap_Ptr
 470+ E5C9             >
 470+ E5C9             >                // dummy db directives used to calculate length of namec
 470+ E5C9 3F 4D 4D 55 >                db      "?MMU7"
 470+ E5CD 37          >
 470+ E5CE             >len_NFA         defl    $ - temp_NFA
 470+ E5CE             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 470+ E5C9             >
 470+ E5C9 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 470+ E5CA 3F 4D 4D 55 >                db      "?MMU7"               // name string in 7-bit ascii, but
 470+ E5CE 37          >
 470+ E5CF             >                org     $-1                 // alter last byte of Name just above to set
 470+ E5CE B7          >                db      {b $} | END_BIT     // msb as name end
 470+ E5CF             >
 470+ E5CF C0 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 470+ E5D1             >Prev_Ptr        defl    Heap_Ptr
 470+ E5D1             >
 470+ E5D1             >mirror_Ptr      defl    $
 470+ E5D1             >
 470+ E5D1 15 A5       >                dw      Dict_Ptr + 2        // xt
 470+ E5D3             >Heap_Ptr        defl    $ - $E000           // save current HP
 470+ E5D3             >
 470+ E5D3             >Current_HP      defl  $ - $E000             // used to set HP once!
 470+ E5D3             >
 470+ E5D3             >//              ______________________________________________________________________
 470+ E5D3             >//              Dictionary part
 470+ E5D3             >
 470+ E5D3             >                org     Dict_Ptr
 470+ A513             >
 470+ A513 D1 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 470+ A515             >
 470+ A515             >QMMU7:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 470+ A515 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 470+ A518             >
 470+ A518             >
 470+ A518             >                endif           ; ok        // for other definitions it "points" the correct handler
 470+ A518             >                // Use of "; ok" to suppress "warning[fwdref]"
 470+ A518             >
 470+ A518             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 471+ A518 69 A1                        dw      DUP
 472+ A51A E1 9B 00 E0                  dw      LIT, $E000
 473+ A51E 3A A4                        dw      ULESS
 474+ A520 C3 A0                        dw      NOT_OP
 475+ A522 90 A0                        dw      EXIT
 476+ A524
 477+ A524              //  ______________________________________________________________________
 478+ A524              //
 479+ A524              // far          hp -- ha
 480+ A524              // query current page in MMU7 8K-RAM : 0 and 223
 481+ A524                              Colon_Def FAR, "FAR", is_normal
 481+ A524             >                New_Def  FAR, "FAR", Enter_Ptr, is_normal ; ok
 481+ A524             >
 481+ A524             >Dict_Ptr        defl    $
 481+ A524             >
 481+ A524             >//              ______________________________________________________________________
 481+ A524             >//              Heap part
 481+ A524             >
 481+ A524             >
 481+ A524             >                org     (Heap_Ptr & $1FFF) + $E000
 481+ E5D3             >
 481+ E5D3             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 481+ E5D3             >Latest_Definition defl  Heap_Ptr
 481+ E5D3             >
 481+ E5D3             >                // dummy db directives used to calculate length of namec
 481+ E5D3 46 41 52    >                db      "FAR"
 481+ E5D6             >len_NFA         defl    $ - temp_NFA
 481+ E5D6             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 481+ E5D3             >
 481+ E5D3 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 481+ E5D4 46 41 52    >                db      "FAR"               // name string in 7-bit ascii, but
 481+ E5D7             >                org     $-1                 // alter last byte of Name just above to set
 481+ E5D6 D2          >                db      {b $} | END_BIT     // msb as name end
 481+ E5D7             >
 481+ E5D7 C9 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 481+ E5D9             >Prev_Ptr        defl    Heap_Ptr
 481+ E5D9             >
 481+ E5D9             >mirror_Ptr      defl    $
 481+ E5D9             >
 481+ E5D9 26 A5       >                dw      Dict_Ptr + 2        // xt
 481+ E5DB             >Heap_Ptr        defl    $ - $E000           // save current HP
 481+ E5DB             >
 481+ E5DB             >Current_HP      defl  $ - $E000             // used to set HP once!
 481+ E5DB             >
 481+ E5DB             >//              ______________________________________________________________________
 481+ E5DB             >//              Dictionary part
 481+ E5DB             >
 481+ E5DB             >                org     Dict_Ptr
 481+ A524             >
 481+ A524 D9 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 481+ A526             >
 481+ A526             >FAR:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 481+ A526 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 481+ A529             >
 481+ A529             >
 481+ A529             >                endif           ; ok        // for other definitions it "points" the correct handler
 481+ A529             >                // Use of "; ok" to suppress "warning[fwdref]"
 481+ A529             >
 481+ A529             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 482+ A529 F3 A4                        dw      TO_FAR
 483+ A52B EA A4                        dw      MMU7_STORE
 484+ A52D 90 A0                        dw      EXIT
 485+ A52F
 486+ A52F              //  ______________________________________________________________________
 487+ A52F              //
 488+ A52F              // ?heapp       n -- n f
 489+ A52F              // query current page in MMU7 8K-RAM : 0 and 223
 490+ A52F                              Colon_Def QHEAPP, "?HEAPP", is_normal
 490+ A52F             >                New_Def  QHEAPP, "?HEAPP", Enter_Ptr, is_normal ; ok
 490+ A52F             >
 490+ A52F             >Dict_Ptr        defl    $
 490+ A52F             >
 490+ A52F             >//              ______________________________________________________________________
 490+ A52F             >//              Heap part
 490+ A52F             >
 490+ A52F             >
 490+ A52F             >                org     (Heap_Ptr & $1FFF) + $E000
 490+ E5DB             >
 490+ E5DB             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 490+ E5DB             >Latest_Definition defl  Heap_Ptr
 490+ E5DB             >
 490+ E5DB             >                // dummy db directives used to calculate length of namec
 490+ E5DB 3F 48 45 41 >                db      "?HEAPP"
 490+ E5DF 50 50       >
 490+ E5E1             >len_NFA         defl    $ - temp_NFA
 490+ E5E1             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 490+ E5DB             >
 490+ E5DB 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 490+ E5DC 3F 48 45 41 >                db      "?HEAPP"               // name string in 7-bit ascii, but
 490+ E5E0 50 50       >
 490+ E5E2             >                org     $-1                 // alter last byte of Name just above to set
 490+ E5E1 D0          >                db      {b $} | END_BIT     // msb as name end
 490+ E5E2             >
 490+ E5E2 D3 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 490+ E5E4             >Prev_Ptr        defl    Heap_Ptr
 490+ E5E4             >
 490+ E5E4             >mirror_Ptr      defl    $
 490+ E5E4             >
 490+ E5E4 31 A5       >                dw      Dict_Ptr + 2        // xt
 490+ E5E6             >Heap_Ptr        defl    $ - $E000           // save current HP
 490+ E5E6             >
 490+ E5E6             >Current_HP      defl  $ - $E000             // used to set HP once!
 490+ E5E6             >
 490+ E5E6             >//              ______________________________________________________________________
 490+ E5E6             >//              Dictionary part
 490+ E5E6             >
 490+ E5E6             >                org     Dict_Ptr
 490+ A52F             >
 490+ A52F E4 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 490+ A531             >
 490+ A531             >QHEAPP:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 490+ A531 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 490+ A534             >
 490+ A534             >
 490+ A534             >                endif           ; ok        // for other definitions it "points" the correct handler
 490+ A534             >                // Use of "; ok" to suppress "warning[fwdref]"
 490+ A534             >
 490+ A534             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 491+ A534 69 A1                        dw      DUP
 492+ A536 33 9C                        dw      ZBRANCH
 493+ A538 08 00                        dw      QHeap_Skip - $
 494+ A53A E1 9B 00 60                  dw          LIT, $6000
 495+ A53E 3A A4                        dw          ULESS
 496+ A540              QHeap_Skip:                                          // endif
 497+ A540 90 A0                        dw      EXIT                        // ;
 498+ A542
 499+ A542              //  ______________________________________________________________________
 500+ A542              //
 501+ A542              // ?>heap       n1 -- n2
 502+ A542              // query current page in MMU7 8K-RAM : 0 and 223
 503+ A542                              Colon_Def QTOHEAP, "?>HEAP", is_normal
 503+ A542             >                New_Def  QTOHEAP, "?>HEAP", Enter_Ptr, is_normal ; ok
 503+ A542             >
 503+ A542             >Dict_Ptr        defl    $
 503+ A542             >
 503+ A542             >//              ______________________________________________________________________
 503+ A542             >//              Heap part
 503+ A542             >
 503+ A542             >
 503+ A542             >                org     (Heap_Ptr & $1FFF) + $E000
 503+ E5E6             >
 503+ E5E6             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 503+ E5E6             >Latest_Definition defl  Heap_Ptr
 503+ E5E6             >
 503+ E5E6             >                // dummy db directives used to calculate length of namec
 503+ E5E6 3F 3E 48 45 >                db      "?>HEAP"
 503+ E5EA 41 50       >
 503+ E5EC             >len_NFA         defl    $ - temp_NFA
 503+ E5EC             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 503+ E5E6             >
 503+ E5E6 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 503+ E5E7 3F 3E 48 45 >                db      "?>HEAP"               // name string in 7-bit ascii, but
 503+ E5EB 41 50       >
 503+ E5ED             >                org     $-1                 // alter last byte of Name just above to set
 503+ E5EC D0          >                db      {b $} | END_BIT     // msb as name end
 503+ E5ED             >
 503+ E5ED DB 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 503+ E5EF             >Prev_Ptr        defl    Heap_Ptr
 503+ E5EF             >
 503+ E5EF             >mirror_Ptr      defl    $
 503+ E5EF             >
 503+ E5EF 44 A5       >                dw      Dict_Ptr + 2        // xt
 503+ E5F1             >Heap_Ptr        defl    $ - $E000           // save current HP
 503+ E5F1             >
 503+ E5F1             >Current_HP      defl  $ - $E000             // used to set HP once!
 503+ E5F1             >
 503+ E5F1             >//              ______________________________________________________________________
 503+ E5F1             >//              Dictionary part
 503+ E5F1             >
 503+ E5F1             >                org     Dict_Ptr
 503+ A542             >
 503+ A542 EF 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 503+ A544             >
 503+ A544             >QTOHEAP:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 503+ A544 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 503+ A547             >
 503+ A547             >
 503+ A547             >                endif           ; ok        // for other definitions it "points" the correct handler
 503+ A547             >                // Use of "; ok" to suppress "warning[fwdref]"
 503+ A547             >
 503+ A547             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 504+ A547 69 A1                        dw      DUP
 505+ A549 31 A5                        dw      QHEAPP
 506+ A54B 33 9C                        dw      ZBRANCH
 507+ A54D 04 00                        dw      Q2Heap_Skip - $
 508+ A54F 26 A5                        dw          FAR
 509+ A551              Q2Heap_Skip:                                          // endif
 510+ A551 90 A0                        dw      EXIT                        // ;
 511+ A553
 512+ A553              //  ______________________________________________________________________
 513+ A553              //
 514+ A553              // hp_fetch     -- a
 515+ A553                              Colon_Def HP_FETCH, "HP@", is_normal
 515+ A553             >                New_Def  HP_FETCH, "HP@", Enter_Ptr, is_normal ; ok
 515+ A553             >
 515+ A553             >Dict_Ptr        defl    $
 515+ A553             >
 515+ A553             >//              ______________________________________________________________________
 515+ A553             >//              Heap part
 515+ A553             >
 515+ A553             >
 515+ A553             >                org     (Heap_Ptr & $1FFF) + $E000
 515+ E5F1             >
 515+ E5F1             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 515+ E5F1             >Latest_Definition defl  Heap_Ptr
 515+ E5F1             >
 515+ E5F1             >                // dummy db directives used to calculate length of namec
 515+ E5F1 48 50 40    >                db      "HP@"
 515+ E5F4             >len_NFA         defl    $ - temp_NFA
 515+ E5F4             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 515+ E5F1             >
 515+ E5F1 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 515+ E5F2 48 50 40    >                db      "HP@"               // name string in 7-bit ascii, but
 515+ E5F5             >                org     $-1                 // alter last byte of Name just above to set
 515+ E5F4 C0          >                db      {b $} | END_BIT     // msb as name end
 515+ E5F5             >
 515+ E5F5 E6 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 515+ E5F7             >Prev_Ptr        defl    Heap_Ptr
 515+ E5F7             >
 515+ E5F7             >mirror_Ptr      defl    $
 515+ E5F7             >
 515+ E5F7 55 A5       >                dw      Dict_Ptr + 2        // xt
 515+ E5F9             >Heap_Ptr        defl    $ - $E000           // save current HP
 515+ E5F9             >
 515+ E5F9             >Current_HP      defl  $ - $E000             // used to set HP once!
 515+ E5F9             >
 515+ E5F9             >//              ______________________________________________________________________
 515+ E5F9             >//              Dictionary part
 515+ E5F9             >
 515+ E5F9             >                org     Dict_Ptr
 515+ A553             >
 515+ A553 F7 25       >                dw      mirror_Ptr - $E000 + Heap_offset
 515+ A555             >
 515+ A555             >HP_FETCH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 515+ A555 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 515+ A558             >
 515+ A558             >
 515+ A558             >                endif           ; ok        // for other definitions it "points" the correct handler
 515+ A558             >                // Use of "; ok" to suppress "warning[fwdref]"
 515+ A558             >
 515+ A558             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 516+ A558 54 A3 C7 A1                  dw      HP, FETCH               // hp @
 517+ A55C 90 A0                        dw      EXIT                    // ;
 518+ A55E
 519+ A55E              //  ______________________________________________________________________
 520+ A55E              //
 521+ A55E              // page-watermark   -- n
 522+ A55E              // number of buffers available. must be the difference between LIMIT and FIRST divided by 516
 523+ A55E                              Constant_Def PAGE_WATERMARK,   "PAGE-WATERMARK", $1F80
 523+ A55E             >                New_Def  PAGE_WATERMARK, "PAGE-WATERMARK", Constant_Ptr, is_normal
 523+ A55E             >
 523+ A55E             >Dict_Ptr        defl    $
 523+ A55E             >
 523+ A55E             >//              ______________________________________________________________________
 523+ A55E             >//              Heap part
 523+ A55E             >
 523+ A55E             >
 523+ A55E             >                org     (Heap_Ptr & $1FFF) + $E000
 523+ E5F9             >
 523+ E5F9             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 523+ E5F9             >Latest_Definition defl  Heap_Ptr
 523+ E5F9             >
 523+ E5F9             >                // dummy db directives used to calculate length of namec
 523+ E5F9 50 41 47 45 >                db      "PAGE-WATERMARK"
 523+ E5FD 2D 57 41 54 >
 523+ E601 45 52 4D 41 >
 523+ E605 52 4B       >
 523+ E607             >len_NFA         defl    $ - temp_NFA
 523+ E607             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 523+ E5F9             >
 523+ E5F9 8E          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 523+ E5FA 50 41 47 45 >                db      "PAGE-WATERMARK"               // name string in 7-bit ascii, but
 523+ E5FE 2D 57 41 54 >
 523+ E602 45 52 4D 41 >
 523+ E606 52 4B       >
 523+ E608             >                org     $-1                 // alter last byte of Name just above to set
 523+ E607 CB          >                db      {b $} | END_BIT     // msb as name end
 523+ E608             >
 523+ E608 F1 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 523+ E60A             >Prev_Ptr        defl    Heap_Ptr
 523+ E60A             >
 523+ E60A             >mirror_Ptr      defl    $
 523+ E60A             >
 523+ E60A 60 A5       >                dw      Dict_Ptr + 2        // xt
 523+ E60C             >Heap_Ptr        defl    $ - $E000           // save current HP
 523+ E60C             >
 523+ E60C             >Current_HP      defl  $ - $E000             // used to set HP once!
 523+ E60C             >
 523+ E60C             >//              ______________________________________________________________________
 523+ E60C             >//              Dictionary part
 523+ E60C             >
 523+ E60C             >                org     Dict_Ptr
 523+ A55E             >
 523+ A55E 0A 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 523+ A560             >
 523+ A560             >PAGE_WATERMARK:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 523+ A560 CD 93 A2    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 523+ A563             >
 523+ A563             >
 523+ A563             >                endif           ; ok        // for other definitions it "points" the correct handler
 523+ A563             >                // Use of "; ok" to suppress "warning[fwdref]"
 523+ A563             >
 523+ A563             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 523+ A563 80 1F       >                dw      $1F80
 524+ A565
 525+ A565              //  ______________________________________________________________________
 526+ A565              //
 527+ A565              // skip-hp-page ha -- a
 528+ A565                              Colon_Def SKIP_HP_PAGE, "SKIP-HP-PAGE", is_normal
 528+ A565             >                New_Def  SKIP_HP_PAGE, "SKIP-HP-PAGE", Enter_Ptr, is_normal ; ok
 528+ A565             >
 528+ A565             >Dict_Ptr        defl    $
 528+ A565             >
 528+ A565             >//              ______________________________________________________________________
 528+ A565             >//              Heap part
 528+ A565             >
 528+ A565             >
 528+ A565             >                org     (Heap_Ptr & $1FFF) + $E000
 528+ E60C             >
 528+ E60C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 528+ E60C             >Latest_Definition defl  Heap_Ptr
 528+ E60C             >
 528+ E60C             >                // dummy db directives used to calculate length of namec
 528+ E60C 53 4B 49 50 >                db      "SKIP-HP-PAGE"
 528+ E610 2D 48 50 2D >
 528+ E614 50 41 47 45 >
 528+ E618             >len_NFA         defl    $ - temp_NFA
 528+ E618             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 528+ E60C             >
 528+ E60C 8C          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 528+ E60D 53 4B 49 50 >                db      "SKIP-HP-PAGE"               // name string in 7-bit ascii, but
 528+ E611 2D 48 50 2D >
 528+ E615 50 41 47 45 >
 528+ E619             >                org     $-1                 // alter last byte of Name just above to set
 528+ E618 C5          >                db      {b $} | END_BIT     // msb as name end
 528+ E619             >
 528+ E619 F9 25       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 528+ E61B             >Prev_Ptr        defl    Heap_Ptr
 528+ E61B             >
 528+ E61B             >mirror_Ptr      defl    $
 528+ E61B             >
 528+ E61B 67 A5       >                dw      Dict_Ptr + 2        // xt
 528+ E61D             >Heap_Ptr        defl    $ - $E000           // save current HP
 528+ E61D             >
 528+ E61D             >Current_HP      defl  $ - $E000             // used to set HP once!
 528+ E61D             >
 528+ E61D             >//              ______________________________________________________________________
 528+ E61D             >//              Dictionary part
 528+ E61D             >
 528+ E61D             >                org     Dict_Ptr
 528+ A565             >
 528+ A565 1B 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 528+ A567             >
 528+ A567             >SKIP_HP_PAGE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 528+ A567 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 528+ A56A             >
 528+ A56A             >
 528+ A56A             >                endif           ; ok        // for other definitions it "points" the correct handler
 528+ A56A             >                // Use of "; ok" to suppress "warning[fwdref]"
 528+ A56A             >
 528+ A56A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 529+ A56A 55 A5                        dw      HP_FETCH                // hp@
 530+ A56C E1 9B FF 1F                  dw      LIT, $1FFF, AND_OP      // 1FFF and
 530+ A570 4A A0
 531+ A572 E3 A0                        dw      PLUS
 532+ A574 60 A5                        dw      PAGE_WATERMARK
 533+ A576 5D A4                        dw      GREATER
 534+ A578 33 9C                        dw      ZBRANCH
 535+ A57A 12 00                        dw      Skip_Skip - $   // if
 536+ A57C 55 A5                        dw      HP_FETCH
 537+ A57E E1 9B FF 1F                  dw      LIT, $1FFF, OR_OP
 537+ A582 59 A0
 538+ A584 FC A0 0A A1                  dw      ONE_PLUS, TWO_PLUS
 539+ A588 54 A3 D1 A1                  dw      HP, STORE
 540+ A58C              Skip_Skip:
 541+ A58C 90 A0                        dw      EXIT                    // ;
 542+ A58E              //  ______________________________________________________________________
 543+ A58E              //
 544+ A58E              // latest       -- nfa
 545+ A58E                              Colon_Def LATEST, "LATEST", is_normal
 545+ A58E             >                New_Def  LATEST, "LATEST", Enter_Ptr, is_normal ; ok
 545+ A58E             >
 545+ A58E             >Dict_Ptr        defl    $
 545+ A58E             >
 545+ A58E             >//              ______________________________________________________________________
 545+ A58E             >//              Heap part
 545+ A58E             >
 545+ A58E             >
 545+ A58E             >                org     (Heap_Ptr & $1FFF) + $E000
 545+ E61D             >
 545+ E61D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 545+ E61D             >Latest_Definition defl  Heap_Ptr
 545+ E61D             >
 545+ E61D             >                // dummy db directives used to calculate length of namec
 545+ E61D 4C 41 54 45 >                db      "LATEST"
 545+ E621 53 54       >
 545+ E623             >len_NFA         defl    $ - temp_NFA
 545+ E623             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 545+ E61D             >
 545+ E61D 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 545+ E61E 4C 41 54 45 >                db      "LATEST"               // name string in 7-bit ascii, but
 545+ E622 53 54       >
 545+ E624             >                org     $-1                 // alter last byte of Name just above to set
 545+ E623 D4          >                db      {b $} | END_BIT     // msb as name end
 545+ E624             >
 545+ E624 0C 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 545+ E626             >Prev_Ptr        defl    Heap_Ptr
 545+ E626             >
 545+ E626             >mirror_Ptr      defl    $
 545+ E626             >
 545+ E626 90 A5       >                dw      Dict_Ptr + 2        // xt
 545+ E628             >Heap_Ptr        defl    $ - $E000           // save current HP
 545+ E628             >
 545+ E628             >Current_HP      defl  $ - $E000             // used to set HP once!
 545+ E628             >
 545+ E628             >//              ______________________________________________________________________
 545+ E628             >//              Dictionary part
 545+ E628             >
 545+ E628             >                org     Dict_Ptr
 545+ A58E             >
 545+ A58E 26 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 545+ A590             >
 545+ A590             >LATEST:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 545+ A590 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 545+ A593             >
 545+ A593             >
 545+ A593             >                endif           ; ok        // for other definitions it "points" the correct handler
 545+ A593             >                // Use of "; ok" to suppress "warning[fwdref]"
 545+ A593             >
 545+ A593             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 546+ A593 84 A3                        dw      CURRENT                 // current
 547+ A595 C7 A1 C7 A1                  dw      FETCH, FETCH            // @ @
 548+ A599 26 A5                        dw      FAR // Q TO HEAP
 549+ A59B 90 A0                        dw      EXIT                    // ;
 550+ A59D
 551+ A59D              //  ______________________________________________________________________
 552+ A59D              //
 553+ A59D              // >body        cfa -- pfa
 554+ A59D                              Colon_Def TO_BODY, ">BODY", is_normal
 554+ A59D             >                New_Def  TO_BODY, ">BODY", Enter_Ptr, is_normal ; ok
 554+ A59D             >
 554+ A59D             >Dict_Ptr        defl    $
 554+ A59D             >
 554+ A59D             >//              ______________________________________________________________________
 554+ A59D             >//              Heap part
 554+ A59D             >
 554+ A59D             >
 554+ A59D             >                org     (Heap_Ptr & $1FFF) + $E000
 554+ E628             >
 554+ E628             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 554+ E628             >Latest_Definition defl  Heap_Ptr
 554+ E628             >
 554+ E628             >                // dummy db directives used to calculate length of namec
 554+ E628 3E 42 4F 44 >                db      ">BODY"
 554+ E62C 59          >
 554+ E62D             >len_NFA         defl    $ - temp_NFA
 554+ E62D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 554+ E628             >
 554+ E628 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 554+ E629 3E 42 4F 44 >                db      ">BODY"               // name string in 7-bit ascii, but
 554+ E62D 59          >
 554+ E62E             >                org     $-1                 // alter last byte of Name just above to set
 554+ E62D D9          >                db      {b $} | END_BIT     // msb as name end
 554+ E62E             >
 554+ E62E 1D 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 554+ E630             >Prev_Ptr        defl    Heap_Ptr
 554+ E630             >
 554+ E630             >mirror_Ptr      defl    $
 554+ E630             >
 554+ E630 9F A5       >                dw      Dict_Ptr + 2        // xt
 554+ E632             >Heap_Ptr        defl    $ - $E000           // save current HP
 554+ E632             >
 554+ E632             >Current_HP      defl  $ - $E000             // used to set HP once!
 554+ E632             >
 554+ E632             >//              ______________________________________________________________________
 554+ E632             >//              Dictionary part
 554+ E632             >
 554+ E632             >                org     Dict_Ptr
 554+ A59D             >
 554+ A59D 30 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 554+ A59F             >
 554+ A59F             >TO_BODY:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 554+ A59F CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 554+ A5A2             >
 554+ A5A2             >
 554+ A5A2             >                endif           ; ok        // for other definitions it "points" the correct handler
 554+ A5A2             >                // Use of "; ok" to suppress "warning[fwdref]"
 554+ A5A2             >
 554+ A5A2             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 555+ A5A2 D4 A2 E3 A0                  dw      THREE, PLUS             // cell+ --> 3 +
 556+ A5A6 90 A0                        dw      EXIT                    // ;
 557+ A5A8
 558+ A5A8              //  ______________________________________________________________________
 559+ A5A8              //
 560+ A5A8              // <name        cfa -- nfa
 561+ A5A8                              Colon_Def TO_NAME, "<NAME", is_normal
 561+ A5A8             >                New_Def  TO_NAME, "<NAME", Enter_Ptr, is_normal ; ok
 561+ A5A8             >
 561+ A5A8             >Dict_Ptr        defl    $
 561+ A5A8             >
 561+ A5A8             >//              ______________________________________________________________________
 561+ A5A8             >//              Heap part
 561+ A5A8             >
 561+ A5A8             >
 561+ A5A8             >                org     (Heap_Ptr & $1FFF) + $E000
 561+ E632             >
 561+ E632             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 561+ E632             >Latest_Definition defl  Heap_Ptr
 561+ E632             >
 561+ E632             >                // dummy db directives used to calculate length of namec
 561+ E632 3C 4E 41 4D >                db      "<NAME"
 561+ E636 45          >
 561+ E637             >len_NFA         defl    $ - temp_NFA
 561+ E637             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 561+ E632             >
 561+ E632 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 561+ E633 3C 4E 41 4D >                db      "<NAME"               // name string in 7-bit ascii, but
 561+ E637 45          >
 561+ E638             >                org     $-1                 // alter last byte of Name just above to set
 561+ E637 C5          >                db      {b $} | END_BIT     // msb as name end
 561+ E638             >
 561+ E638 28 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 561+ E63A             >Prev_Ptr        defl    Heap_Ptr
 561+ E63A             >
 561+ E63A             >mirror_Ptr      defl    $
 561+ E63A             >
 561+ E63A AA A5       >                dw      Dict_Ptr + 2        // xt
 561+ E63C             >Heap_Ptr        defl    $ - $E000           // save current HP
 561+ E63C             >
 561+ E63C             >Current_HP      defl  $ - $E000             // used to set HP once!
 561+ E63C             >
 561+ E63C             >//              ______________________________________________________________________
 561+ E63C             >//              Dictionary part
 561+ E63C             >
 561+ E63C             >                org     Dict_Ptr
 561+ A5A8             >
 561+ A5A8 3A 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 561+ A5AA             >
 561+ A5AA             >TO_NAME:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 561+ A5AA CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 561+ A5AD             >
 561+ A5AD             >
 561+ A5AD             >                endif           ; ok        // for other definitions it "points" the correct handler
 561+ A5AD             >                // Use of "; ok" to suppress "warning[fwdref]"
 561+ A5AD             >
 561+ A5AD             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 562+ A5AD 17 A1                        dw      CELL_MINUS              // cell-
 563+ A5AF 69 A1 C7 A1                  dw      DUP, FETCH
 564+ A5B3 31 A5                        dw      QHEAPP
 565+ A5B5 33 9C                        dw      ZBRANCH
 566+ A5B7 08 00                        dw      ToName_Skip - $
 567+ A5B9 C7 A1 26 A5                  dw          FETCH, FAR
 568+ A5BD 17 A1                        dw          CELL_MINUS
 569+ A5BF              ToName_Skip:                                    // endif
 570+ A5BF
 571+ A5BF 03 A1                        dw      ONE_SUBTRACT            // 1-
 572+ A5C1 DB A2                        dw      NEG_ONE                 // -1
 573+ A5C3 C0 A4                        dw      TRAVERSE                // traverse
 574+ A5C5 90 A0                        dw      EXIT                    // ;
 575+ A5C7
 576+ A5C7              //  ______________________________________________________________________
 577+ A5C7              //
 578+ A5C7              // cfa          pfa -- cfa
 579+ A5C7                              Colon_Def CFA, "CFA", is_normal
 579+ A5C7             >                New_Def  CFA, "CFA", Enter_Ptr, is_normal ; ok
 579+ A5C7             >
 579+ A5C7             >Dict_Ptr        defl    $
 579+ A5C7             >
 579+ A5C7             >//              ______________________________________________________________________
 579+ A5C7             >//              Heap part
 579+ A5C7             >
 579+ A5C7             >
 579+ A5C7             >                org     (Heap_Ptr & $1FFF) + $E000
 579+ E63C             >
 579+ E63C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 579+ E63C             >Latest_Definition defl  Heap_Ptr
 579+ E63C             >
 579+ E63C             >                // dummy db directives used to calculate length of namec
 579+ E63C 43 46 41    >                db      "CFA"
 579+ E63F             >len_NFA         defl    $ - temp_NFA
 579+ E63F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 579+ E63C             >
 579+ E63C 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 579+ E63D 43 46 41    >                db      "CFA"               // name string in 7-bit ascii, but
 579+ E640             >                org     $-1                 // alter last byte of Name just above to set
 579+ E63F C1          >                db      {b $} | END_BIT     // msb as name end
 579+ E640             >
 579+ E640 32 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 579+ E642             >Prev_Ptr        defl    Heap_Ptr
 579+ E642             >
 579+ E642             >mirror_Ptr      defl    $
 579+ E642             >
 579+ E642 C9 A5       >                dw      Dict_Ptr + 2        // xt
 579+ E644             >Heap_Ptr        defl    $ - $E000           // save current HP
 579+ E644             >
 579+ E644             >Current_HP      defl  $ - $E000             // used to set HP once!
 579+ E644             >
 579+ E644             >//              ______________________________________________________________________
 579+ E644             >//              Dictionary part
 579+ E644             >
 579+ E644             >                org     Dict_Ptr
 579+ A5C7             >
 579+ A5C7 42 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 579+ A5C9             >
 579+ A5C9             >CFA:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 579+ A5C9 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 579+ A5CC             >
 579+ A5CC             >
 579+ A5CC             >                endif           ; ok        // for other definitions it "points" the correct handler
 579+ A5CC             >                // Use of "; ok" to suppress "warning[fwdref]"
 579+ A5CC             >
 579+ A5CC             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 580+ A5CC D4 A2 23 A4                  dw      THREE, SUBTRACT         // 3 -
 581+ A5D0 90 A0                        dw      EXIT                    // ;
 582+ A5D2
 583+ A5D2              //  ______________________________________________________________________
 584+ A5D2              //
 585+ A5D2              // nfa          pfa -- nfa
 586+ A5D2                              Colon_Def NFA, "NFA", is_normal
 586+ A5D2             >                New_Def  NFA, "NFA", Enter_Ptr, is_normal ; ok
 586+ A5D2             >
 586+ A5D2             >Dict_Ptr        defl    $
 586+ A5D2             >
 586+ A5D2             >//              ______________________________________________________________________
 586+ A5D2             >//              Heap part
 586+ A5D2             >
 586+ A5D2             >
 586+ A5D2             >                org     (Heap_Ptr & $1FFF) + $E000
 586+ E644             >
 586+ E644             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 586+ E644             >Latest_Definition defl  Heap_Ptr
 586+ E644             >
 586+ E644             >                // dummy db directives used to calculate length of namec
 586+ E644 4E 46 41    >                db      "NFA"
 586+ E647             >len_NFA         defl    $ - temp_NFA
 586+ E647             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 586+ E644             >
 586+ E644 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 586+ E645 4E 46 41    >                db      "NFA"               // name string in 7-bit ascii, but
 586+ E648             >                org     $-1                 // alter last byte of Name just above to set
 586+ E647 C1          >                db      {b $} | END_BIT     // msb as name end
 586+ E648             >
 586+ E648 3C 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 586+ E64A             >Prev_Ptr        defl    Heap_Ptr
 586+ E64A             >
 586+ E64A             >mirror_Ptr      defl    $
 586+ E64A             >
 586+ E64A D4 A5       >                dw      Dict_Ptr + 2        // xt
 586+ E64C             >Heap_Ptr        defl    $ - $E000           // save current HP
 586+ E64C             >
 586+ E64C             >Current_HP      defl  $ - $E000             // used to set HP once!
 586+ E64C             >
 586+ E64C             >//              ______________________________________________________________________
 586+ E64C             >//              Dictionary part
 586+ E64C             >
 586+ E64C             >                org     Dict_Ptr
 586+ A5D2             >
 586+ A5D2 4A 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 586+ A5D4             >
 586+ A5D4             >NFA:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 586+ A5D4 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 586+ A5D7             >
 586+ A5D7             >
 586+ A5D7             >                endif           ; ok        // for other definitions it "points" the correct handler
 586+ A5D7             >                // Use of "; ok" to suppress "warning[fwdref]"
 586+ A5D7             >
 586+ A5D7             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 587+ A5D7 C9 A5                        dw      CFA                     // cfa
 588+ A5D9 AA A5                        dw      TO_NAME                 // traverse
 589+ A5DB 90 A0                        dw      EXIT                    // ;
 590+ A5DD
 591+ A5DD              //  ______________________________________________________________________
 592+ A5DD              //
 593+ A5DD              // lfa          pfa -- lfa
 594+ A5DD                              Colon_Def LFA, "LFA", is_normal
 594+ A5DD             >                New_Def  LFA, "LFA", Enter_Ptr, is_normal ; ok
 594+ A5DD             >
 594+ A5DD             >Dict_Ptr        defl    $
 594+ A5DD             >
 594+ A5DD             >//              ______________________________________________________________________
 594+ A5DD             >//              Heap part
 594+ A5DD             >
 594+ A5DD             >
 594+ A5DD             >                org     (Heap_Ptr & $1FFF) + $E000
 594+ E64C             >
 594+ E64C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 594+ E64C             >Latest_Definition defl  Heap_Ptr
 594+ E64C             >
 594+ E64C             >                // dummy db directives used to calculate length of namec
 594+ E64C 4C 46 41    >                db      "LFA"
 594+ E64F             >len_NFA         defl    $ - temp_NFA
 594+ E64F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 594+ E64C             >
 594+ E64C 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 594+ E64D 4C 46 41    >                db      "LFA"               // name string in 7-bit ascii, but
 594+ E650             >                org     $-1                 // alter last byte of Name just above to set
 594+ E64F C1          >                db      {b $} | END_BIT     // msb as name end
 594+ E650             >
 594+ E650 44 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 594+ E652             >Prev_Ptr        defl    Heap_Ptr
 594+ E652             >
 594+ E652             >mirror_Ptr      defl    $
 594+ E652             >
 594+ E652 DF A5       >                dw      Dict_Ptr + 2        // xt
 594+ E654             >Heap_Ptr        defl    $ - $E000           // save current HP
 594+ E654             >
 594+ E654             >Current_HP      defl  $ - $E000             // used to set HP once!
 594+ E654             >
 594+ E654             >//              ______________________________________________________________________
 594+ E654             >//              Dictionary part
 594+ E654             >
 594+ E654             >                org     Dict_Ptr
 594+ A5DD             >
 594+ A5DD 52 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 594+ A5DF             >
 594+ A5DF             >LFA:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 594+ A5DF CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 594+ A5E2             >
 594+ A5E2             >
 594+ A5E2             >                endif           ; ok        // for other definitions it "points" the correct handler
 594+ A5E2             >                // Use of "; ok" to suppress "warning[fwdref]"
 594+ A5E2             >
 594+ A5E2             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 595+ A5E2 D4 A5                        dw      NFA                     // nfa
 596+ A5E4 C6 A2                        dw      ONE                     // 1
 597+ A5E6 C0 A4                        dw      TRAVERSE                // traverse
 598+ A5E8 FC A0                        dw      ONE_PLUS                // 1+
 599+ A5EA 90 A0                        dw      EXIT                    // ;
 600+ A5EC
 601+ A5EC              //  ______________________________________________________________________
 602+ A5EC              //
 603+ A5EC              // pfa          nfa -- pfa
 604+ A5EC                              Colon_Def PFA, "PFA", is_normal
 604+ A5EC             >                New_Def  PFA, "PFA", Enter_Ptr, is_normal ; ok
 604+ A5EC             >
 604+ A5EC             >Dict_Ptr        defl    $
 604+ A5EC             >
 604+ A5EC             >//              ______________________________________________________________________
 604+ A5EC             >//              Heap part
 604+ A5EC             >
 604+ A5EC             >
 604+ A5EC             >                org     (Heap_Ptr & $1FFF) + $E000
 604+ E654             >
 604+ E654             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 604+ E654             >Latest_Definition defl  Heap_Ptr
 604+ E654             >
 604+ E654             >                // dummy db directives used to calculate length of namec
 604+ E654 50 46 41    >                db      "PFA"
 604+ E657             >len_NFA         defl    $ - temp_NFA
 604+ E657             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 604+ E654             >
 604+ E654 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 604+ E655 50 46 41    >                db      "PFA"               // name string in 7-bit ascii, but
 604+ E658             >                org     $-1                 // alter last byte of Name just above to set
 604+ E657 C1          >                db      {b $} | END_BIT     // msb as name end
 604+ E658             >
 604+ E658 4C 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 604+ E65A             >Prev_Ptr        defl    Heap_Ptr
 604+ E65A             >
 604+ E65A             >mirror_Ptr      defl    $
 604+ E65A             >
 604+ E65A EE A5       >                dw      Dict_Ptr + 2        // xt
 604+ E65C             >Heap_Ptr        defl    $ - $E000           // save current HP
 604+ E65C             >
 604+ E65C             >Current_HP      defl  $ - $E000             // used to set HP once!
 604+ E65C             >
 604+ E65C             >//              ______________________________________________________________________
 604+ E65C             >//              Dictionary part
 604+ E65C             >
 604+ E65C             >                org     Dict_Ptr
 604+ A5EC             >
 604+ A5EC 5A 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 604+ A5EE             >
 604+ A5EE             >PFA:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 604+ A5EE CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 604+ A5F1             >
 604+ A5F1             >
 604+ A5F1             >                endif           ; ok        // for other definitions it "points" the correct handler
 604+ A5F1             >                // Use of "; ok" to suppress "warning[fwdref]"
 604+ A5F1             >
 604+ A5F1             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 605+ A5F1 44 A5                        dw      QTOHEAP
 606+ A5F3 C6 A2                        dw      ONE                     // 1
 607+ A5F5 C0 A4                        dw      TRAVERSE                // traverse
 608+ A5F7 FC A0                        dw      ONE_PLUS                // 1+
 609+ A5F9 12 A1                        dw      CELL_PLUS               // cell+
 610+ A5FB 15 A5                        dw      QMMU7
 611+ A5FD 33 9C                        dw      ZBRANCH
 612+ A5FF 0E 00                        dw      PFA_Skip - $
 613+ A601 DD A4                        dw          MMU7_FETCH
 614+ A603 C6 A2 23 A4                  dw          ONE, SUBTRACT
 615+ A607 33 9C                        dw          ZBRANCH
 616+ A609 04 00                        dw          PFA_Skip - $
 617+ A60B C7 A1                        dw              FETCH
 618+ A60D              PFA_Skip:                                    // endif
 619+ A60D 9F A5                        dw      TO_BODY                 // >body
 620+ A60F 90 A0                        dw      EXIT                    // ;
 621+ A611
 622+ A611              //  ______________________________________________________________________
 623+ A611              //
 624+ A611              // !csp         --
 625+ A611              // store in user variable CSP current value of SP. Used at compile-time for syntax checkng
 626+ A611                              Colon_Def STORE_CSP, "!CSP", is_normal
 626+ A611             >                New_Def  STORE_CSP, "!CSP", Enter_Ptr, is_normal ; ok
 626+ A611             >
 626+ A611             >Dict_Ptr        defl    $
 626+ A611             >
 626+ A611             >//              ______________________________________________________________________
 626+ A611             >//              Heap part
 626+ A611             >
 626+ A611             >
 626+ A611             >                org     (Heap_Ptr & $1FFF) + $E000
 626+ E65C             >
 626+ E65C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 626+ E65C             >Latest_Definition defl  Heap_Ptr
 626+ E65C             >
 626+ E65C             >                // dummy db directives used to calculate length of namec
 626+ E65C 21 43 53 50 >                db      "!CSP"
 626+ E660             >len_NFA         defl    $ - temp_NFA
 626+ E660             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 626+ E65C             >
 626+ E65C 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 626+ E65D 21 43 53 50 >                db      "!CSP"               // name string in 7-bit ascii, but
 626+ E661             >                org     $-1                 // alter last byte of Name just above to set
 626+ E660 D0          >                db      {b $} | END_BIT     // msb as name end
 626+ E661             >
 626+ E661 54 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 626+ E663             >Prev_Ptr        defl    Heap_Ptr
 626+ E663             >
 626+ E663             >mirror_Ptr      defl    $
 626+ E663             >
 626+ E663 13 A6       >                dw      Dict_Ptr + 2        // xt
 626+ E665             >Heap_Ptr        defl    $ - $E000           // save current HP
 626+ E665             >
 626+ E665             >Current_HP      defl  $ - $E000             // used to set HP once!
 626+ E665             >
 626+ E665             >//              ______________________________________________________________________
 626+ E665             >//              Dictionary part
 626+ E665             >
 626+ E665             >                org     Dict_Ptr
 626+ A611             >
 626+ A611 63 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 626+ A613             >
 626+ A613             >STORE_CSP:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 626+ A613 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 626+ A616             >
 626+ A616             >
 626+ A616             >                endif           ; ok        // for other definitions it "points" the correct handler
 626+ A616             >                // Use of "; ok" to suppress "warning[fwdref]"
 626+ A616             >
 626+ A616             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 627+ A616 77 A0                        dw      SPFETCH                 // sp@
 628+ A618 A2 A3 D1 A1                  dw      CSP, STORE              // csp !
 629+ A61C 90 A0                        dw      EXIT                    // ;
 630+ A61E
 631+ A61E              //  ______________________________________________________________________
 632+ A61E              //
 633+ A61E              // ?error       f n --
 634+ A61E              // rase error n if flag f it true
 635+ A61E                              Colon_Def QERROR, "?ERROR", is_normal
 635+ A61E             >                New_Def  QERROR, "?ERROR", Enter_Ptr, is_normal ; ok
 635+ A61E             >
 635+ A61E             >Dict_Ptr        defl    $
 635+ A61E             >
 635+ A61E             >//              ______________________________________________________________________
 635+ A61E             >//              Heap part
 635+ A61E             >
 635+ A61E             >
 635+ A61E             >                org     (Heap_Ptr & $1FFF) + $E000
 635+ E665             >
 635+ E665             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 635+ E665             >Latest_Definition defl  Heap_Ptr
 635+ E665             >
 635+ E665             >                // dummy db directives used to calculate length of namec
 635+ E665 3F 45 52 52 >                db      "?ERROR"
 635+ E669 4F 52       >
 635+ E66B             >len_NFA         defl    $ - temp_NFA
 635+ E66B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 635+ E665             >
 635+ E665 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 635+ E666 3F 45 52 52 >                db      "?ERROR"               // name string in 7-bit ascii, but
 635+ E66A 4F 52       >
 635+ E66C             >                org     $-1                 // alter last byte of Name just above to set
 635+ E66B D2          >                db      {b $} | END_BIT     // msb as name end
 635+ E66C             >
 635+ E66C 5C 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 635+ E66E             >Prev_Ptr        defl    Heap_Ptr
 635+ E66E             >
 635+ E66E             >mirror_Ptr      defl    $
 635+ E66E             >
 635+ E66E 20 A6       >                dw      Dict_Ptr + 2        // xt
 635+ E670             >Heap_Ptr        defl    $ - $E000           // save current HP
 635+ E670             >
 635+ E670             >Current_HP      defl  $ - $E000             // used to set HP once!
 635+ E670             >
 635+ E670             >//              ______________________________________________________________________
 635+ E670             >//              Dictionary part
 635+ E670             >
 635+ E670             >                org     Dict_Ptr
 635+ A61E             >
 635+ A61E 6E 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 635+ A620             >
 635+ A620             >QERROR:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 635+ A620 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 635+ A623             >
 635+ A623             >
 635+ A623             >                endif           ; ok        // for other definitions it "points" the correct handler
 635+ A623             >                // Use of "; ok" to suppress "warning[fwdref]"
 635+ A623             >
 635+ A623             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 636+ A623 62 A1                        dw      SWAP                    // swap
 637+ A625                                                              // if
 638+ A625 33 9C                        dw      ZBRANCH
 639+ A627 08 00                        dw      QError_Else - $
 640+ A629 12 AB                        dw          ERROR               //      error  ( is a forward-ref )
 641+ A62B                                                              // else
 642+ A62B 26 9C                        dw      BRANCH
 643+ A62D 04 00                        dw      QError_Endif - $
 644+ A62F              QError_Else:
 645+ A62F 4E A1                        dw          DROP                //      drop
 646+ A631              QError_Endif:                                   // endif
 647+ A631 90 A0                        dw      EXIT                    // ;
 648+ A633
 649+ A633              //  ______________________________________________________________________
 650+ A633              //
 651+ A633              // ?comp       --
 652+ A633              // raise msg #17 if not compiling
 653+ A633                              Colon_Def QCOMP, "?COMP", is_normal
 653+ A633             >                New_Def  QCOMP, "?COMP", Enter_Ptr, is_normal ; ok
 653+ A633             >
 653+ A633             >Dict_Ptr        defl    $
 653+ A633             >
 653+ A633             >//              ______________________________________________________________________
 653+ A633             >//              Heap part
 653+ A633             >
 653+ A633             >
 653+ A633             >                org     (Heap_Ptr & $1FFF) + $E000
 653+ E670             >
 653+ E670             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 653+ E670             >Latest_Definition defl  Heap_Ptr
 653+ E670             >
 653+ E670             >                // dummy db directives used to calculate length of namec
 653+ E670 3F 43 4F 4D >                db      "?COMP"
 653+ E674 50          >
 653+ E675             >len_NFA         defl    $ - temp_NFA
 653+ E675             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 653+ E670             >
 653+ E670 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 653+ E671 3F 43 4F 4D >                db      "?COMP"               // name string in 7-bit ascii, but
 653+ E675 50          >
 653+ E676             >                org     $-1                 // alter last byte of Name just above to set
 653+ E675 D0          >                db      {b $} | END_BIT     // msb as name end
 653+ E676             >
 653+ E676 65 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 653+ E678             >Prev_Ptr        defl    Heap_Ptr
 653+ E678             >
 653+ E678             >mirror_Ptr      defl    $
 653+ E678             >
 653+ E678 35 A6       >                dw      Dict_Ptr + 2        // xt
 653+ E67A             >Heap_Ptr        defl    $ - $E000           // save current HP
 653+ E67A             >
 653+ E67A             >Current_HP      defl  $ - $E000             // used to set HP once!
 653+ E67A             >
 653+ E67A             >//              ______________________________________________________________________
 653+ E67A             >//              Dictionary part
 653+ E67A             >
 653+ E67A             >                org     Dict_Ptr
 653+ A633             >
 653+ A633 78 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 653+ A635             >
 653+ A635             >QCOMP:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 653+ A635 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 653+ A638             >
 653+ A638             >
 653+ A638             >                endif           ; ok        // for other definitions it "points" the correct handler
 653+ A638             >                // Use of "; ok" to suppress "warning[fwdref]"
 653+ A638             >
 653+ A638             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 654+ A638 8A A3 C7 A1                  dw      STATE, FETCH            // state @
 655+ A63C B5 A0                        dw      ZEQUAL                  // 0=
 656+ A63E E1 9B 11 00                  dw      LIT, 17                 // 17  ( can't be executed )
 657+ A642 20 A6                        dw      QERROR                  // ?error
 658+ A644 90 A0                        dw      EXIT                    // ;
 659+ A646
 660+ A646              //  ______________________________________________________________________
 661+ A646              //
 662+ A646              // ?exec       --
 663+ A646              // raise msg #18 if compiling
 664+ A646                              Colon_Def QEXEC, "?EXEC", is_normal
 664+ A646             >                New_Def  QEXEC, "?EXEC", Enter_Ptr, is_normal ; ok
 664+ A646             >
 664+ A646             >Dict_Ptr        defl    $
 664+ A646             >
 664+ A646             >//              ______________________________________________________________________
 664+ A646             >//              Heap part
 664+ A646             >
 664+ A646             >
 664+ A646             >                org     (Heap_Ptr & $1FFF) + $E000
 664+ E67A             >
 664+ E67A             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 664+ E67A             >Latest_Definition defl  Heap_Ptr
 664+ E67A             >
 664+ E67A             >                // dummy db directives used to calculate length of namec
 664+ E67A 3F 45 58 45 >                db      "?EXEC"
 664+ E67E 43          >
 664+ E67F             >len_NFA         defl    $ - temp_NFA
 664+ E67F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 664+ E67A             >
 664+ E67A 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 664+ E67B 3F 45 58 45 >                db      "?EXEC"               // name string in 7-bit ascii, but
 664+ E67F 43          >
 664+ E680             >                org     $-1                 // alter last byte of Name just above to set
 664+ E67F C3          >                db      {b $} | END_BIT     // msb as name end
 664+ E680             >
 664+ E680 70 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 664+ E682             >Prev_Ptr        defl    Heap_Ptr
 664+ E682             >
 664+ E682             >mirror_Ptr      defl    $
 664+ E682             >
 664+ E682 48 A6       >                dw      Dict_Ptr + 2        // xt
 664+ E684             >Heap_Ptr        defl    $ - $E000           // save current HP
 664+ E684             >
 664+ E684             >Current_HP      defl  $ - $E000             // used to set HP once!
 664+ E684             >
 664+ E684             >//              ______________________________________________________________________
 664+ E684             >//              Dictionary part
 664+ E684             >
 664+ E684             >                org     Dict_Ptr
 664+ A646             >
 664+ A646 82 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 664+ A648             >
 664+ A648             >QEXEC:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 664+ A648 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 664+ A64B             >
 664+ A64B             >
 664+ A64B             >                endif           ; ok        // for other definitions it "points" the correct handler
 664+ A64B             >                // Use of "; ok" to suppress "warning[fwdref]"
 664+ A64B             >
 664+ A64B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 665+ A64B 8A A3 C7 A1                  dw      STATE, FETCH            // state @
 666+ A64F E1 9B 12 00                  dw      LIT, 18                 // 18  ( can't be compiled )
 667+ A653 20 A6                        dw      QERROR                  // ?error
 668+ A655 90 A0                        dw      EXIT                    // ;
 669+ A657
 670+ A657              //  ______________________________________________________________________
 671+ A657              //
 672+ A657              // ?pairs       n1 n2 --
 673+ A657              // raise msg #19 if n1 != n2. Compiler pushes some placeholder to stack for syntax checking
 674+ A657                              Colon_Def QPAIRS, "?PAIRS", is_normal
 674+ A657             >                New_Def  QPAIRS, "?PAIRS", Enter_Ptr, is_normal ; ok
 674+ A657             >
 674+ A657             >Dict_Ptr        defl    $
 674+ A657             >
 674+ A657             >//              ______________________________________________________________________
 674+ A657             >//              Heap part
 674+ A657             >
 674+ A657             >
 674+ A657             >                org     (Heap_Ptr & $1FFF) + $E000
 674+ E684             >
 674+ E684             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 674+ E684             >Latest_Definition defl  Heap_Ptr
 674+ E684             >
 674+ E684             >                // dummy db directives used to calculate length of namec
 674+ E684 3F 50 41 49 >                db      "?PAIRS"
 674+ E688 52 53       >
 674+ E68A             >len_NFA         defl    $ - temp_NFA
 674+ E68A             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 674+ E684             >
 674+ E684 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 674+ E685 3F 50 41 49 >                db      "?PAIRS"               // name string in 7-bit ascii, but
 674+ E689 52 53       >
 674+ E68B             >                org     $-1                 // alter last byte of Name just above to set
 674+ E68A D3          >                db      {b $} | END_BIT     // msb as name end
 674+ E68B             >
 674+ E68B 7A 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 674+ E68D             >Prev_Ptr        defl    Heap_Ptr
 674+ E68D             >
 674+ E68D             >mirror_Ptr      defl    $
 674+ E68D             >
 674+ E68D 59 A6       >                dw      Dict_Ptr + 2        // xt
 674+ E68F             >Heap_Ptr        defl    $ - $E000           // save current HP
 674+ E68F             >
 674+ E68F             >Current_HP      defl  $ - $E000             // used to set HP once!
 674+ E68F             >
 674+ E68F             >//              ______________________________________________________________________
 674+ E68F             >//              Dictionary part
 674+ E68F             >
 674+ E68F             >                org     Dict_Ptr
 674+ A657             >
 674+ A657 8D 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 674+ A659             >
 674+ A659             >QPAIRS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 674+ A659 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 674+ A65C             >
 674+ A65C             >
 674+ A65C             >                endif           ; ok        // for other definitions it "points" the correct handler
 674+ A65C             >                // Use of "; ok" to suppress "warning[fwdref]"
 674+ A65C             >
 674+ A65C             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 675+ A65C 23 A4                        dw      SUBTRACT                // -
 676+ A65E E1 9B 13 00                  dw      LIT, 19                 // 18  ( syntax error )
 677+ A662 20 A6                        dw      QERROR                  // ?error
 678+ A664 90 A0                        dw      EXIT                    // ;
 679+ A666
 680+ A666              //  ______________________________________________________________________
 681+ A666              //
 682+ A666              // ?csp       --
 683+ A666              // raise msg #20 if surrent SP in not what previously saved in CSP.
 684+ A666              // Compiler relies on that for  syntax checking of structures
 685+ A666                              Colon_Def QCSP, "?CSP", is_normal
 685+ A666             >                New_Def  QCSP, "?CSP", Enter_Ptr, is_normal ; ok
 685+ A666             >
 685+ A666             >Dict_Ptr        defl    $
 685+ A666             >
 685+ A666             >//              ______________________________________________________________________
 685+ A666             >//              Heap part
 685+ A666             >
 685+ A666             >
 685+ A666             >                org     (Heap_Ptr & $1FFF) + $E000
 685+ E68F             >
 685+ E68F             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 685+ E68F             >Latest_Definition defl  Heap_Ptr
 685+ E68F             >
 685+ E68F             >                // dummy db directives used to calculate length of namec
 685+ E68F 3F 43 53 50 >                db      "?CSP"
 685+ E693             >len_NFA         defl    $ - temp_NFA
 685+ E693             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 685+ E68F             >
 685+ E68F 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 685+ E690 3F 43 53 50 >                db      "?CSP"               // name string in 7-bit ascii, but
 685+ E694             >                org     $-1                 // alter last byte of Name just above to set
 685+ E693 D0          >                db      {b $} | END_BIT     // msb as name end
 685+ E694             >
 685+ E694 84 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 685+ E696             >Prev_Ptr        defl    Heap_Ptr
 685+ E696             >
 685+ E696             >mirror_Ptr      defl    $
 685+ E696             >
 685+ E696 68 A6       >                dw      Dict_Ptr + 2        // xt
 685+ E698             >Heap_Ptr        defl    $ - $E000           // save current HP
 685+ E698             >
 685+ E698             >Current_HP      defl  $ - $E000             // used to set HP once!
 685+ E698             >
 685+ E698             >//              ______________________________________________________________________
 685+ E698             >//              Dictionary part
 685+ E698             >
 685+ E698             >                org     Dict_Ptr
 685+ A666             >
 685+ A666 96 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 685+ A668             >
 685+ A668             >QCSP:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 685+ A668 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 685+ A66B             >
 685+ A66B             >
 685+ A66B             >                endif           ; ok        // for other definitions it "points" the correct handler
 685+ A66B             >                // Use of "; ok" to suppress "warning[fwdref]"
 685+ A66B             >
 685+ A66B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 686+ A66B 77 A0                        dw      SPFETCH                 // sp@
 687+ A66D A2 A3 C7 A1                  dw      CSP, FETCH              // csp @
 688+ A671 23 A4                        dw      SUBTRACT                // -
 689+ A673 E1 9B 14 00                  dw      LIT, 20                 // 20  ( bad definition end )
 690+ A677 20 A6                        dw      QERROR                  // ?error
 691+ A679 90 A0                        dw      EXIT                    // ;
 692+ A67B
 693+ A67B              //  ______________________________________________________________________
 694+ A67B              //
 695+ A67B              // ?loading      --
 696+ A67B              // raise msg #22 if not loading
 697+ A67B                              Colon_Def QLOADING, "?LOADING", is_normal
 697+ A67B             >                New_Def  QLOADING, "?LOADING", Enter_Ptr, is_normal ; ok
 697+ A67B             >
 697+ A67B             >Dict_Ptr        defl    $
 697+ A67B             >
 697+ A67B             >//              ______________________________________________________________________
 697+ A67B             >//              Heap part
 697+ A67B             >
 697+ A67B             >
 697+ A67B             >                org     (Heap_Ptr & $1FFF) + $E000
 697+ E698             >
 697+ E698             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 697+ E698             >Latest_Definition defl  Heap_Ptr
 697+ E698             >
 697+ E698             >                // dummy db directives used to calculate length of namec
 697+ E698 3F 4C 4F 41 >                db      "?LOADING"
 697+ E69C 44 49 4E 47 >
 697+ E6A0             >len_NFA         defl    $ - temp_NFA
 697+ E6A0             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 697+ E698             >
 697+ E698 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 697+ E699 3F 4C 4F 41 >                db      "?LOADING"               // name string in 7-bit ascii, but
 697+ E69D 44 49 4E 47 >
 697+ E6A1             >                org     $-1                 // alter last byte of Name just above to set
 697+ E6A0 C7          >                db      {b $} | END_BIT     // msb as name end
 697+ E6A1             >
 697+ E6A1 8F 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 697+ E6A3             >Prev_Ptr        defl    Heap_Ptr
 697+ E6A3             >
 697+ E6A3             >mirror_Ptr      defl    $
 697+ E6A3             >
 697+ E6A3 7D A6       >                dw      Dict_Ptr + 2        // xt
 697+ E6A5             >Heap_Ptr        defl    $ - $E000           // save current HP
 697+ E6A5             >
 697+ E6A5             >Current_HP      defl  $ - $E000             // used to set HP once!
 697+ E6A5             >
 697+ E6A5             >//              ______________________________________________________________________
 697+ E6A5             >//              Dictionary part
 697+ E6A5             >
 697+ E6A5             >                org     Dict_Ptr
 697+ A67B             >
 697+ A67B A3 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 697+ A67D             >
 697+ A67D             >QLOADING:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 697+ A67D CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 697+ A680             >
 697+ A680             >
 697+ A680             >                endif           ; ok        // for other definitions it "points" the correct handler
 697+ A680             >                // Use of "; ok" to suppress "warning[fwdref]"
 697+ A680             >
 697+ A680             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 698+ A680 60 A3 C7 A1                  dw      BLK, FETCH              // blk @
 699+ A684 B5 A0                        dw      ZEQUAL                  // 0=
 700+ A686 E1 9B 16 00                  dw      LIT, 22                 // 22  ( aren't loading now )
 701+ A68A 20 A6                        dw      QERROR                  // ?error
 702+ A68C 90 A0                        dw      EXIT                    // ;
 703+ A68E
 704+ A68E              //  ______________________________________________________________________
 705+ A68E              //
 706+ A68E              // compile      --
 707+ A68E              // compiles the following word
 708+ A68E                              Colon_Def COMPILE, "COMPILE", is_normal
 708+ A68E             >                New_Def  COMPILE, "COMPILE", Enter_Ptr, is_normal ; ok
 708+ A68E             >
 708+ A68E             >Dict_Ptr        defl    $
 708+ A68E             >
 708+ A68E             >//              ______________________________________________________________________
 708+ A68E             >//              Heap part
 708+ A68E             >
 708+ A68E             >
 708+ A68E             >                org     (Heap_Ptr & $1FFF) + $E000
 708+ E6A5             >
 708+ E6A5             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 708+ E6A5             >Latest_Definition defl  Heap_Ptr
 708+ E6A5             >
 708+ E6A5             >                // dummy db directives used to calculate length of namec
 708+ E6A5 43 4F 4D 50 >                db      "COMPILE"
 708+ E6A9 49 4C 45    >
 708+ E6AC             >len_NFA         defl    $ - temp_NFA
 708+ E6AC             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 708+ E6A5             >
 708+ E6A5 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 708+ E6A6 43 4F 4D 50 >                db      "COMPILE"               // name string in 7-bit ascii, but
 708+ E6AA 49 4C 45    >
 708+ E6AD             >                org     $-1                 // alter last byte of Name just above to set
 708+ E6AC C5          >                db      {b $} | END_BIT     // msb as name end
 708+ E6AD             >
 708+ E6AD 98 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 708+ E6AF             >Prev_Ptr        defl    Heap_Ptr
 708+ E6AF             >
 708+ E6AF             >mirror_Ptr      defl    $
 708+ E6AF             >
 708+ E6AF 90 A6       >                dw      Dict_Ptr + 2        // xt
 708+ E6B1             >Heap_Ptr        defl    $ - $E000           // save current HP
 708+ E6B1             >
 708+ E6B1             >Current_HP      defl  $ - $E000             // used to set HP once!
 708+ E6B1             >
 708+ E6B1             >//              ______________________________________________________________________
 708+ E6B1             >//              Dictionary part
 708+ E6B1             >
 708+ E6B1             >                org     Dict_Ptr
 708+ A68E             >
 708+ A68E AF 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 708+ A690             >
 708+ A690             >COMPILE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 708+ A690 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 708+ A693             >
 708+ A693             >
 708+ A693             >                endif           ; ok        // for other definitions it "points" the correct handler
 708+ A693             >                // Use of "; ok" to suppress "warning[fwdref]"
 708+ A693             >
 708+ A693             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 709+ A693 35 A6                        dw      QCOMP                   // ?comp
 710+ A695 A5 A0                        dw      R_TO                    // r>
 711+ A697 69 A1 12 A1                  dw      DUP, CELL_PLUS          // dup, cell+
 712+ A69B 9A A0                        dw      TO_R                    // >r
 713+ A69D C7 A1 FA A3                  dw      FETCH, COMMA            // @ ,
 714+ A6A1 90 A0                        dw      EXIT                    // ;
 715+ A6A3
 716+ A6A3              //  ______________________________________________________________________
 717+ A6A3              //
 718+ A6A3              // compile,     --
 719+ A6A3              // compiles the following word
 720+ A6A3                              Colon_Def COMPILE_XT, "COMPILE,", is_normal
 720+ A6A3             >                New_Def  COMPILE_XT, "COMPILE,", Enter_Ptr, is_normal ; ok
 720+ A6A3             >
 720+ A6A3             >Dict_Ptr        defl    $
 720+ A6A3             >
 720+ A6A3             >//              ______________________________________________________________________
 720+ A6A3             >//              Heap part
 720+ A6A3             >
 720+ A6A3             >
 720+ A6A3             >                org     (Heap_Ptr & $1FFF) + $E000
 720+ E6B1             >
 720+ E6B1             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 720+ E6B1             >Latest_Definition defl  Heap_Ptr
 720+ E6B1             >
 720+ E6B1             >                // dummy db directives used to calculate length of namec
 720+ E6B1 43 4F 4D 50 >                db      "COMPILE,"
 720+ E6B5 49 4C 45 2C >
 720+ E6B9             >len_NFA         defl    $ - temp_NFA
 720+ E6B9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 720+ E6B1             >
 720+ E6B1 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 720+ E6B2 43 4F 4D 50 >                db      "COMPILE,"               // name string in 7-bit ascii, but
 720+ E6B6 49 4C 45 2C >
 720+ E6BA             >                org     $-1                 // alter last byte of Name just above to set
 720+ E6B9 AC          >                db      {b $} | END_BIT     // msb as name end
 720+ E6BA             >
 720+ E6BA A5 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 720+ E6BC             >Prev_Ptr        defl    Heap_Ptr
 720+ E6BC             >
 720+ E6BC             >mirror_Ptr      defl    $
 720+ E6BC             >
 720+ E6BC A5 A6       >                dw      Dict_Ptr + 2        // xt
 720+ E6BE             >Heap_Ptr        defl    $ - $E000           // save current HP
 720+ E6BE             >
 720+ E6BE             >Current_HP      defl  $ - $E000             // used to set HP once!
 720+ E6BE             >
 720+ E6BE             >//              ______________________________________________________________________
 720+ E6BE             >//              Dictionary part
 720+ E6BE             >
 720+ E6BE             >                org     Dict_Ptr
 720+ A6A3             >
 720+ A6A3 BC 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 720+ A6A5             >
 720+ A6A5             >COMPILE_XT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 720+ A6A5 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 720+ A6A8             >
 720+ A6A8             >
 720+ A6A8             >                endif           ; ok        // for other definitions it "points" the correct handler
 720+ A6A8             >                // Use of "; ok" to suppress "warning[fwdref]"
 720+ A6A8             >
 720+ A6A8             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 721+ A6A8 35 A6                        dw      QCOMP                   // ?comp
 722+ A6AA FA A3                        dw      COMMA                   // ,
 723+ A6AC 90 A0                        dw      EXIT                    // ;
 724+ A6AE
 725+ A6AE              //  ______________________________________________________________________
 726+ A6AE              //
 727+ A6AE              // [            --
 728+ A6AE              // stop compilation
 729+ A6AE                              Colon_Def SQUARED_OPEN, "[", is_immediate
 729+ A6AE             >                New_Def  SQUARED_OPEN, "[", Enter_Ptr, is_immediate ; ok
 729+ A6AE             >
 729+ A6AE             >Dict_Ptr        defl    $
 729+ A6AE             >
 729+ A6AE             >//              ______________________________________________________________________
 729+ A6AE             >//              Heap part
 729+ A6AE             >
 729+ A6AE             >
 729+ A6AE             >                org     (Heap_Ptr & $1FFF) + $E000
 729+ E6BE             >
 729+ E6BE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 729+ E6BE             >Latest_Definition defl  Heap_Ptr
 729+ E6BE             >
 729+ E6BE             >                // dummy db directives used to calculate length of namec
 729+ E6BE 5B          >                db      "["
 729+ E6BF             >len_NFA         defl    $ - temp_NFA
 729+ E6BF             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 729+ E6BE             >
 729+ E6BE C1          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 729+ E6BF 5B          >                db      "["               // name string in 7-bit ascii, but
 729+ E6C0             >                org     $-1                 // alter last byte of Name just above to set
 729+ E6BF DB          >                db      {b $} | END_BIT     // msb as name end
 729+ E6C0             >
 729+ E6C0 B1 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 729+ E6C2             >Prev_Ptr        defl    Heap_Ptr
 729+ E6C2             >
 729+ E6C2             >mirror_Ptr      defl    $
 729+ E6C2             >
 729+ E6C2 B0 A6       >                dw      Dict_Ptr + 2        // xt
 729+ E6C4             >Heap_Ptr        defl    $ - $E000           // save current HP
 729+ E6C4             >
 729+ E6C4             >Current_HP      defl  $ - $E000             // used to set HP once!
 729+ E6C4             >
 729+ E6C4             >//              ______________________________________________________________________
 729+ E6C4             >//              Dictionary part
 729+ E6C4             >
 729+ E6C4             >                org     Dict_Ptr
 729+ A6AE             >
 729+ A6AE C2 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 729+ A6B0             >
 729+ A6B0             >SQUARED_OPEN:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 729+ A6B0 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 729+ A6B3             >
 729+ A6B3             >
 729+ A6B3             >                endif           ; ok        // for other definitions it "points" the correct handler
 729+ A6B3             >                // Use of "; ok" to suppress "warning[fwdref]"
 729+ A6B3             >
 729+ A6B3             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 730+ A6B3 BF A2                        dw      ZERO                    // 0
 731+ A6B5 8A A3 D1 A1                  dw      STATE, STORE            // state !
 732+ A6B9 90 A0                        dw      EXIT                    // ; immediate
 733+ A6BB
 734+ A6BB              //  ______________________________________________________________________
 735+ A6BB              //
 736+ A6BB              // ]            --
 737+ A6BB              // start compilation
 738+ A6BB                              Colon_Def SQUARED_CLOSE, "]", is_normal
 738+ A6BB             >                New_Def  SQUARED_CLOSE, "]", Enter_Ptr, is_normal ; ok
 738+ A6BB             >
 738+ A6BB             >Dict_Ptr        defl    $
 738+ A6BB             >
 738+ A6BB             >//              ______________________________________________________________________
 738+ A6BB             >//              Heap part
 738+ A6BB             >
 738+ A6BB             >
 738+ A6BB             >                org     (Heap_Ptr & $1FFF) + $E000
 738+ E6C4             >
 738+ E6C4             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 738+ E6C4             >Latest_Definition defl  Heap_Ptr
 738+ E6C4             >
 738+ E6C4             >                // dummy db directives used to calculate length of namec
 738+ E6C4 5D          >                db      "]"
 738+ E6C5             >len_NFA         defl    $ - temp_NFA
 738+ E6C5             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 738+ E6C4             >
 738+ E6C4 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 738+ E6C5 5D          >                db      "]"               // name string in 7-bit ascii, but
 738+ E6C6             >                org     $-1                 // alter last byte of Name just above to set
 738+ E6C5 DD          >                db      {b $} | END_BIT     // msb as name end
 738+ E6C6             >
 738+ E6C6 BE 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 738+ E6C8             >Prev_Ptr        defl    Heap_Ptr
 738+ E6C8             >
 738+ E6C8             >mirror_Ptr      defl    $
 738+ E6C8             >
 738+ E6C8 BD A6       >                dw      Dict_Ptr + 2        // xt
 738+ E6CA             >Heap_Ptr        defl    $ - $E000           // save current HP
 738+ E6CA             >
 738+ E6CA             >Current_HP      defl  $ - $E000             // used to set HP once!
 738+ E6CA             >
 738+ E6CA             >//              ______________________________________________________________________
 738+ E6CA             >//              Dictionary part
 738+ E6CA             >
 738+ E6CA             >                org     Dict_Ptr
 738+ A6BB             >
 738+ A6BB C8 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 738+ A6BD             >
 738+ A6BD             >SQUARED_CLOSE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 738+ A6BD CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 738+ A6C0             >
 738+ A6C0             >
 738+ A6C0             >                endif           ; ok        // for other definitions it "points" the correct handler
 738+ A6C0             >                // Use of "; ok" to suppress "warning[fwdref]"
 738+ A6C0             >
 738+ A6C0             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 739+ A6C0 E1 9B C0 00                  dw      LIT, $C0                // 192
 740+ A6C4 8A A3 D1 A1                  dw      STATE, STORE            // state !
 741+ A6C8 90 A0                        dw      EXIT                    // ;
 742+ A6CA
 743+ A6CA              //  ______________________________________________________________________
 744+ A6CA              //
 745+ A6CA              // smudge       --
 746+ A6CA              // toggle smudge bit of latest definition
 747+ A6CA                              Colon_Def SMUDGE, "SMUDGE", is_normal
 747+ A6CA             >                New_Def  SMUDGE, "SMUDGE", Enter_Ptr, is_normal ; ok
 747+ A6CA             >
 747+ A6CA             >Dict_Ptr        defl    $
 747+ A6CA             >
 747+ A6CA             >//              ______________________________________________________________________
 747+ A6CA             >//              Heap part
 747+ A6CA             >
 747+ A6CA             >
 747+ A6CA             >                org     (Heap_Ptr & $1FFF) + $E000
 747+ E6CA             >
 747+ E6CA             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 747+ E6CA             >Latest_Definition defl  Heap_Ptr
 747+ E6CA             >
 747+ E6CA             >                // dummy db directives used to calculate length of namec
 747+ E6CA 53 4D 55 44 >                db      "SMUDGE"
 747+ E6CE 47 45       >
 747+ E6D0             >len_NFA         defl    $ - temp_NFA
 747+ E6D0             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 747+ E6CA             >
 747+ E6CA 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 747+ E6CB 53 4D 55 44 >                db      "SMUDGE"               // name string in 7-bit ascii, but
 747+ E6CF 47 45       >
 747+ E6D1             >                org     $-1                 // alter last byte of Name just above to set
 747+ E6D0 C5          >                db      {b $} | END_BIT     // msb as name end
 747+ E6D1             >
 747+ E6D1 C4 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 747+ E6D3             >Prev_Ptr        defl    Heap_Ptr
 747+ E6D3             >
 747+ E6D3             >mirror_Ptr      defl    $
 747+ E6D3             >
 747+ E6D3 CC A6       >                dw      Dict_Ptr + 2        // xt
 747+ E6D5             >Heap_Ptr        defl    $ - $E000           // save current HP
 747+ E6D5             >
 747+ E6D5             >Current_HP      defl  $ - $E000             // used to set HP once!
 747+ E6D5             >
 747+ E6D5             >//              ______________________________________________________________________
 747+ E6D5             >//              Dictionary part
 747+ E6D5             >
 747+ E6D5             >                org     Dict_Ptr
 747+ A6CA             >
 747+ A6CA D3 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 747+ A6CC             >
 747+ A6CC             >SMUDGE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 747+ A6CC CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 747+ A6CF             >
 747+ A6CF             >
 747+ A6CF             >                endif           ; ok        // for other definitions it "points" the correct handler
 747+ A6CF             >                // Use of "; ok" to suppress "warning[fwdref]"
 747+ A6CF             >
 747+ A6CF             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 748+ A6CF 90 A5                        dw      LATEST                  // latest
 749+ A6D1 E1 9B 20 00                  dw      LIT, SMUDGE_BIT         // 32
 750+ A6D5 BE A1                        dw      TOGGLE                  // toggle
 751+ A6D7 90 A0                        dw      EXIT                    // ;
 752+ A6D9
 753+ A6D9              //  ______________________________________________________________________
 754+ A6D9              //
 755+ A6D9              // immediate    --
 756+ A6D9              // make immediate the latest definition
 757+ A6D9                              Colon_Def IMMEDIATE, "IMMEDIATE", is_normal
 757+ A6D9             >                New_Def  IMMEDIATE, "IMMEDIATE", Enter_Ptr, is_normal ; ok
 757+ A6D9             >
 757+ A6D9             >Dict_Ptr        defl    $
 757+ A6D9             >
 757+ A6D9             >//              ______________________________________________________________________
 757+ A6D9             >//              Heap part
 757+ A6D9             >
 757+ A6D9             >
 757+ A6D9             >                org     (Heap_Ptr & $1FFF) + $E000
 757+ E6D5             >
 757+ E6D5             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 757+ E6D5             >Latest_Definition defl  Heap_Ptr
 757+ E6D5             >
 757+ E6D5             >                // dummy db directives used to calculate length of namec
 757+ E6D5 49 4D 4D 45 >                db      "IMMEDIATE"
 757+ E6D9 44 49 41 54 >
 757+ E6DD 45          >
 757+ E6DE             >len_NFA         defl    $ - temp_NFA
 757+ E6DE             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 757+ E6D5             >
 757+ E6D5 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 757+ E6D6 49 4D 4D 45 >                db      "IMMEDIATE"               // name string in 7-bit ascii, but
 757+ E6DA 44 49 41 54 >
 757+ E6DE 45          >
 757+ E6DF             >                org     $-1                 // alter last byte of Name just above to set
 757+ E6DE C5          >                db      {b $} | END_BIT     // msb as name end
 757+ E6DF             >
 757+ E6DF CA 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 757+ E6E1             >Prev_Ptr        defl    Heap_Ptr
 757+ E6E1             >
 757+ E6E1             >mirror_Ptr      defl    $
 757+ E6E1             >
 757+ E6E1 DB A6       >                dw      Dict_Ptr + 2        // xt
 757+ E6E3             >Heap_Ptr        defl    $ - $E000           // save current HP
 757+ E6E3             >
 757+ E6E3             >Current_HP      defl  $ - $E000             // used to set HP once!
 757+ E6E3             >
 757+ E6E3             >//              ______________________________________________________________________
 757+ E6E3             >//              Dictionary part
 757+ E6E3             >
 757+ E6E3             >                org     Dict_Ptr
 757+ A6D9             >
 757+ A6D9 E1 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 757+ A6DB             >
 757+ A6DB             >IMMEDIATE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 757+ A6DB CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 757+ A6DE             >
 757+ A6DE             >
 757+ A6DE             >                endif           ; ok        // for other definitions it "points" the correct handler
 757+ A6DE             >                // Use of "; ok" to suppress "warning[fwdref]"
 757+ A6DE             >
 757+ A6DE             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 758+ A6DE 90 A5                        dw      LATEST                  // latest
 759+ A6E0 E1 9B 40 00                  dw      LIT, $40                // 64
 760+ A6E4 BE A1                        dw      TOGGLE                  // toggle
 761+ A6E6 90 A0                        dw      EXIT                    // ;
 762+ A6E8
 763+ A6E8              //  ______________________________________________________________________
 764+ A6E8              //
 765+ A6E8              // hex          --
 766+ A6E8              // change numeration base
 767+ A6E8                              Colon_Def HEX, "HEX", is_normal
 767+ A6E8             >                New_Def  HEX, "HEX", Enter_Ptr, is_normal ; ok
 767+ A6E8             >
 767+ A6E8             >Dict_Ptr        defl    $
 767+ A6E8             >
 767+ A6E8             >//              ______________________________________________________________________
 767+ A6E8             >//              Heap part
 767+ A6E8             >
 767+ A6E8             >
 767+ A6E8             >                org     (Heap_Ptr & $1FFF) + $E000
 767+ E6E3             >
 767+ E6E3             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 767+ E6E3             >Latest_Definition defl  Heap_Ptr
 767+ E6E3             >
 767+ E6E3             >                // dummy db directives used to calculate length of namec
 767+ E6E3 48 45 58    >                db      "HEX"
 767+ E6E6             >len_NFA         defl    $ - temp_NFA
 767+ E6E6             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 767+ E6E3             >
 767+ E6E3 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 767+ E6E4 48 45 58    >                db      "HEX"               // name string in 7-bit ascii, but
 767+ E6E7             >                org     $-1                 // alter last byte of Name just above to set
 767+ E6E6 D8          >                db      {b $} | END_BIT     // msb as name end
 767+ E6E7             >
 767+ E6E7 D5 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 767+ E6E9             >Prev_Ptr        defl    Heap_Ptr
 767+ E6E9             >
 767+ E6E9             >mirror_Ptr      defl    $
 767+ E6E9             >
 767+ E6E9 EA A6       >                dw      Dict_Ptr + 2        // xt
 767+ E6EB             >Heap_Ptr        defl    $ - $E000           // save current HP
 767+ E6EB             >
 767+ E6EB             >Current_HP      defl  $ - $E000             // used to set HP once!
 767+ E6EB             >
 767+ E6EB             >//              ______________________________________________________________________
 767+ E6EB             >//              Dictionary part
 767+ E6EB             >
 767+ E6EB             >                org     Dict_Ptr
 767+ A6E8             >
 767+ A6E8 E9 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 767+ A6EA             >
 767+ A6EA             >HEX:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 767+ A6EA CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 767+ A6ED             >
 767+ A6ED             >
 767+ A6ED             >                endif           ; ok        // for other definitions it "points" the correct handler
 767+ A6ED             >                // Use of "; ok" to suppress "warning[fwdref]"
 767+ A6ED             >
 767+ A6ED             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 768+ A6ED E1 9B 10 00                  dw      LIT, 16                 // 16
 769+ A6F1 90 A3 D1 A1                  dw      BASE, STORE             // base !
 770+ A6F5 90 A0                        dw      EXIT                    // ;
 771+ A6F7
 772+ A6F7              //  ______________________________________________________________________
 773+ A6F7              //
 774+ A6F7              // decimal      --
 775+ A6F7              // change numeration base
 776+ A6F7                              Colon_Def DECIMAL, "DECIMAL", is_normal
 776+ A6F7             >                New_Def  DECIMAL, "DECIMAL", Enter_Ptr, is_normal ; ok
 776+ A6F7             >
 776+ A6F7             >Dict_Ptr        defl    $
 776+ A6F7             >
 776+ A6F7             >//              ______________________________________________________________________
 776+ A6F7             >//              Heap part
 776+ A6F7             >
 776+ A6F7             >
 776+ A6F7             >                org     (Heap_Ptr & $1FFF) + $E000
 776+ E6EB             >
 776+ E6EB             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 776+ E6EB             >Latest_Definition defl  Heap_Ptr
 776+ E6EB             >
 776+ E6EB             >                // dummy db directives used to calculate length of namec
 776+ E6EB 44 45 43 49 >                db      "DECIMAL"
 776+ E6EF 4D 41 4C    >
 776+ E6F2             >len_NFA         defl    $ - temp_NFA
 776+ E6F2             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 776+ E6EB             >
 776+ E6EB 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 776+ E6EC 44 45 43 49 >                db      "DECIMAL"               // name string in 7-bit ascii, but
 776+ E6F0 4D 41 4C    >
 776+ E6F3             >                org     $-1                 // alter last byte of Name just above to set
 776+ E6F2 CC          >                db      {b $} | END_BIT     // msb as name end
 776+ E6F3             >
 776+ E6F3 E3 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 776+ E6F5             >Prev_Ptr        defl    Heap_Ptr
 776+ E6F5             >
 776+ E6F5             >mirror_Ptr      defl    $
 776+ E6F5             >
 776+ E6F5 F9 A6       >                dw      Dict_Ptr + 2        // xt
 776+ E6F7             >Heap_Ptr        defl    $ - $E000           // save current HP
 776+ E6F7             >
 776+ E6F7             >Current_HP      defl  $ - $E000             // used to set HP once!
 776+ E6F7             >
 776+ E6F7             >//              ______________________________________________________________________
 776+ E6F7             >//              Dictionary part
 776+ E6F7             >
 776+ E6F7             >                org     Dict_Ptr
 776+ A6F7             >
 776+ A6F7 F5 26       >                dw      mirror_Ptr - $E000 + Heap_offset
 776+ A6F9             >
 776+ A6F9             >DECIMAL:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 776+ A6F9 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 776+ A6FC             >
 776+ A6FC             >
 776+ A6FC             >                endif           ; ok        // for other definitions it "points" the correct handler
 776+ A6FC             >                // Use of "; ok" to suppress "warning[fwdref]"
 776+ A6FC             >
 776+ A6FC             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 777+ A6FC E1 9B 0A 00                  dw      LIT, 10                 // 10
 778+ A700 90 A3 D1 A1                  dw      BASE, STORE             // base !
 779+ A704 90 A0                        dw      EXIT                    // ;
 780+ A706
 781+ A706              //  ______________________________________________________________________
 782+ A706              //
 783+ A706              // (;code)       --
 784+ A706              // patch to CFA to call/jump to the "following code"
 785+ A706                              Colon_Def C_SEMICOLON_CODE, "(;CODE)", is_normal
 785+ A706             >                New_Def  C_SEMICOLON_CODE, "(;CODE)", Enter_Ptr, is_normal ; ok
 785+ A706             >
 785+ A706             >Dict_Ptr        defl    $
 785+ A706             >
 785+ A706             >//              ______________________________________________________________________
 785+ A706             >//              Heap part
 785+ A706             >
 785+ A706             >
 785+ A706             >                org     (Heap_Ptr & $1FFF) + $E000
 785+ E6F7             >
 785+ E6F7             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 785+ E6F7             >Latest_Definition defl  Heap_Ptr
 785+ E6F7             >
 785+ E6F7             >                // dummy db directives used to calculate length of namec
 785+ E6F7 28 3B 43 4F >                db      "(;CODE)"
 785+ E6FB 44 45 29    >
 785+ E6FE             >len_NFA         defl    $ - temp_NFA
 785+ E6FE             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 785+ E6F7             >
 785+ E6F7 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 785+ E6F8 28 3B 43 4F >                db      "(;CODE)"               // name string in 7-bit ascii, but
 785+ E6FC 44 45 29    >
 785+ E6FF             >                org     $-1                 // alter last byte of Name just above to set
 785+ E6FE A9          >                db      {b $} | END_BIT     // msb as name end
 785+ E6FF             >
 785+ E6FF EB 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 785+ E701             >Prev_Ptr        defl    Heap_Ptr
 785+ E701             >
 785+ E701             >mirror_Ptr      defl    $
 785+ E701             >
 785+ E701 08 A7       >                dw      Dict_Ptr + 2        // xt
 785+ E703             >Heap_Ptr        defl    $ - $E000           // save current HP
 785+ E703             >
 785+ E703             >Current_HP      defl  $ - $E000             // used to set HP once!
 785+ E703             >
 785+ E703             >//              ______________________________________________________________________
 785+ E703             >//              Dictionary part
 785+ E703             >
 785+ E703             >                org     Dict_Ptr
 785+ A706             >
 785+ A706 01 27       >                dw      mirror_Ptr - $E000 + Heap_offset
 785+ A708             >
 785+ A708             >C_SEMICOLON_CODE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 785+ A708 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 785+ A70B             >
 785+ A70B             >
 785+ A70B             >                endif           ; ok        // for other definitions it "points" the correct handler
 785+ A70B             >                // Use of "; ok" to suppress "warning[fwdref]"
 785+ A70B             >
 785+ A70B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 786+ A70B A5 A0                        dw      R_TO                    // r>       ( Return Stack has IP to caller's next cell )
 787+ A70D 90 A5                        dw      LATEST                  // latest   ( Word being defined in this moment )
 788+ A70F EE A5 C9 A5                  dw      PFA, CFA                // pfa cfa  ( cfa of latest word )
 789+ A713
 790+ A713 E1 9B CD 00                  dw      LIT, $CD                // $CD      ( At Latest CFA put "call" op-code )
 791+ A717 45 A1 E5 A1                  dw      OVER, CSTORE            // over c!  ( why can't use comma? because CFA was already ALLOTted by create? )
 792+ A71B FC A0                        dw      ONE_PLUS                // 1+       ( At Latest CFA+1 put address for call. )
 793+ A71D
 794+ A71D D1 A1                        dw      STORE                   // !
 795+ A71F 90 A0                        dw      EXIT                    // ;
 796+ A721
 797+ A721              //  ______________________________________________________________________
 798+ A721              //
 799+ A721              // ;code        --
 800+ A721                              Colon_Def SEMICOLON_CODE, ";CODE", is_immediate
 800+ A721             >                New_Def  SEMICOLON_CODE, ";CODE", Enter_Ptr, is_immediate ; ok
 800+ A721             >
 800+ A721             >Dict_Ptr        defl    $
 800+ A721             >
 800+ A721             >//              ______________________________________________________________________
 800+ A721             >//              Heap part
 800+ A721             >
 800+ A721             >
 800+ A721             >                org     (Heap_Ptr & $1FFF) + $E000
 800+ E703             >
 800+ E703             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 800+ E703             >Latest_Definition defl  Heap_Ptr
 800+ E703             >
 800+ E703             >                // dummy db directives used to calculate length of namec
 800+ E703 3B 43 4F 44 >                db      ";CODE"
 800+ E707 45          >
 800+ E708             >len_NFA         defl    $ - temp_NFA
 800+ E708             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 800+ E703             >
 800+ E703 C5          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 800+ E704 3B 43 4F 44 >                db      ";CODE"               // name string in 7-bit ascii, but
 800+ E708 45          >
 800+ E709             >                org     $-1                 // alter last byte of Name just above to set
 800+ E708 C5          >                db      {b $} | END_BIT     // msb as name end
 800+ E709             >
 800+ E709 F7 26       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 800+ E70B             >Prev_Ptr        defl    Heap_Ptr
 800+ E70B             >
 800+ E70B             >mirror_Ptr      defl    $
 800+ E70B             >
 800+ E70B 23 A7       >                dw      Dict_Ptr + 2        // xt
 800+ E70D             >Heap_Ptr        defl    $ - $E000           // save current HP
 800+ E70D             >
 800+ E70D             >Current_HP      defl  $ - $E000             // used to set HP once!
 800+ E70D             >
 800+ E70D             >//              ______________________________________________________________________
 800+ E70D             >//              Dictionary part
 800+ E70D             >
 800+ E70D             >                org     Dict_Ptr
 800+ A721             >
 800+ A721 0B 27       >                dw      mirror_Ptr - $E000 + Heap_offset
 800+ A723             >
 800+ A723             >SEMICOLON_CODE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 800+ A723 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 800+ A726             >
 800+ A726             >
 800+ A726             >                endif           ; ok        // for other definitions it "points" the correct handler
 800+ A726             >                // Use of "; ok" to suppress "warning[fwdref]"
 800+ A726             >
 800+ A726             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 801+ A726 68 A6                        dw      QCSP                    // ?csp
 802+ A728 90 A6                        dw      COMPILE                 // compile
 803+ A72A 08 A7                        dw      C_SEMICOLON_CODE        // (;code)
 804+ A72C B0 A6                        dw      SQUARED_OPEN            // [
 805+ A72E 86 A2                        dw      NOOP                    // noop () can be patched later to ASSEMBLER... )
 806+ A730 90 A0                        dw      EXIT                    // ; immediate
 807+ A732
 808+ A732              //  ______________________________________________________________________
 809+ A732              //
 810+ A732              // <builds      --
 811+ A732                              Colon_Def CBUILDS, "<BUILDS", is_normal
 811+ A732             >                New_Def  CBUILDS, "<BUILDS", Enter_Ptr, is_normal ; ok
 811+ A732             >
 811+ A732             >Dict_Ptr        defl    $
 811+ A732             >
 811+ A732             >//              ______________________________________________________________________
 811+ A732             >//              Heap part
 811+ A732             >
 811+ A732             >
 811+ A732             >                org     (Heap_Ptr & $1FFF) + $E000
 811+ E70D             >
 811+ E70D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 811+ E70D             >Latest_Definition defl  Heap_Ptr
 811+ E70D             >
 811+ E70D             >                // dummy db directives used to calculate length of namec
 811+ E70D 3C 42 55 49 >                db      "<BUILDS"
 811+ E711 4C 44 53    >
 811+ E714             >len_NFA         defl    $ - temp_NFA
 811+ E714             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 811+ E70D             >
 811+ E70D 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 811+ E70E 3C 42 55 49 >                db      "<BUILDS"               // name string in 7-bit ascii, but
 811+ E712 4C 44 53    >
 811+ E715             >                org     $-1                 // alter last byte of Name just above to set
 811+ E714 D3          >                db      {b $} | END_BIT     // msb as name end
 811+ E715             >
 811+ E715 03 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 811+ E717             >Prev_Ptr        defl    Heap_Ptr
 811+ E717             >
 811+ E717             >mirror_Ptr      defl    $
 811+ E717             >
 811+ E717 34 A7       >                dw      Dict_Ptr + 2        // xt
 811+ E719             >Heap_Ptr        defl    $ - $E000           // save current HP
 811+ E719             >
 811+ E719             >Current_HP      defl  $ - $E000             // used to set HP once!
 811+ E719             >
 811+ E719             >//              ______________________________________________________________________
 811+ E719             >//              Dictionary part
 811+ E719             >
 811+ E719             >                org     Dict_Ptr
 811+ A732             >
 811+ A732 17 27       >                dw      mirror_Ptr - $E000 + Heap_offset
 811+ A734             >
 811+ A734             >CBUILDS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 811+ A734 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 811+ A737             >
 811+ A737             >
 811+ A737             >                endif           ; ok        // for other definitions it "points" the correct handler
 811+ A737             >                // Use of "; ok" to suppress "warning[fwdref]"
 811+ A737             >
 811+ A737             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 812+ A737 BF A2                        dw      ZERO                    // 0
 813+ A739 8A A2                        dw      CONSTANT                // constant
 814+ A73B 90 A0                        dw      EXIT                    // ;
 815+ A73D
 816+ A73D              //  ______________________________________________________________________
 817+ A73D              //
 818+ A73D              // recurse      --
 819+ A73D              //              Colon_Def RECURSE, "RECURSE", is_immediate
 820+ A73D              //              dw      QCOMP                   // ?comp
 821+ A73D              //              dw      LATEST                  // latest
 822+ A73D              //              dw      PFA, CFA                // pfa cfa
 823+ A73D              //              dw      COMMA                   // ,
 824+ A73D              //              dw      EXIT                    // ; immediate
 825+ A73D
 826+ A73D              //  ______________________________________________________________________
 827+ A73D              //
 828+ A73D              // does>     --
 829+ A73D                              Colon_Def DOES_TO, "DOES>", is_normal
 829+ A73D             >                New_Def  DOES_TO, "DOES>", Enter_Ptr, is_normal ; ok
 829+ A73D             >
 829+ A73D             >Dict_Ptr        defl    $
 829+ A73D             >
 829+ A73D             >//              ______________________________________________________________________
 829+ A73D             >//              Heap part
 829+ A73D             >
 829+ A73D             >
 829+ A73D             >                org     (Heap_Ptr & $1FFF) + $E000
 829+ E719             >
 829+ E719             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 829+ E719             >Latest_Definition defl  Heap_Ptr
 829+ E719             >
 829+ E719             >                // dummy db directives used to calculate length of namec
 829+ E719 44 4F 45 53 >                db      "DOES>"
 829+ E71D 3E          >
 829+ E71E             >len_NFA         defl    $ - temp_NFA
 829+ E71E             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 829+ E719             >
 829+ E719 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 829+ E71A 44 4F 45 53 >                db      "DOES>"               // name string in 7-bit ascii, but
 829+ E71E 3E          >
 829+ E71F             >                org     $-1                 // alter last byte of Name just above to set
 829+ E71E BE          >                db      {b $} | END_BIT     // msb as name end
 829+ E71F             >
 829+ E71F 0D 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 829+ E721             >Prev_Ptr        defl    Heap_Ptr
 829+ E721             >
 829+ E721             >mirror_Ptr      defl    $
 829+ E721             >
 829+ E721 3F A7       >                dw      Dict_Ptr + 2        // xt
 829+ E723             >Heap_Ptr        defl    $ - $E000           // save current HP
 829+ E723             >
 829+ E723             >Current_HP      defl  $ - $E000             // used to set HP once!
 829+ E723             >
 829+ E723             >//              ______________________________________________________________________
 829+ E723             >//              Dictionary part
 829+ E723             >
 829+ E723             >                org     Dict_Ptr
 829+ A73D             >
 829+ A73D 21 27       >                dw      mirror_Ptr - $E000 + Heap_offset
 829+ A73F             >
 829+ A73F             >DOES_TO:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 829+ A73F CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 829+ A742             >
 829+ A742             >
 829+ A742             >                endif           ; ok        // for other definitions it "points" the correct handler
 829+ A742             >                // Use of "; ok" to suppress "warning[fwdref]"
 829+ A742             >
 829+ A742             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 830+ A742 A5 A0                        dw      R_TO                    // r>
 831+ A744 90 A5                        dw      LATEST                  // latest
 832+ A746 EE A5                        dw      PFA                     // pfa
 833+ A748 D1 A1                        dw      STORE                   // !
 834+ A74A 08 A7                        dw      C_SEMICOLON_CODE        // ;code
 835+ A74C              Does_Ptr:
 836+ A74C                              // via call coded in CFA
 837+ A74C EB                           ex      de, hl //**
 838+ A74D                              // *** ldhlrp
 839+ A74D 2B                           dec     hl                  // push on Return-Stack current Instruction-Pointer
 840+ A74E 70                           ld      (hl), b
 841+ A74F 2B                           dec     hl
 842+ A750 71                           ld      (hl), c
 843+ A751                              // *** ldrphl
 844+ A751 EB                           ex      de, hl //**
 845+ A752 E1                           pop     hl                  // CFA has a call to this, so PFA -> IP
 846+ A753
 847+ A753 4E                           ld      c, (hl)
 848+ A754 23                           inc     hl
 849+ A755 46                           ld      b, (hl)
 850+ A756 23                           inc     hl
 851+ A757
 852+ A757                              psh1
 852+ A757 E5          >                push    hl
 852+ A758 DD E9       >                jp      (ix)
 853+ A75A                              // SMUDGE !
 854+ A75A
 855+ A75A              //  ______________________________________________________________________
 856+ A75A              //
 857+ A75A              // count        a -- a2 n
 858+ A75A              // expects a counted string at address a, returns string address and counter
 859+ A75A                              New_Def COUNT, "COUNT", is_code, is_normal
 859+ A75A             >
 859+ A75A             >Dict_Ptr        defl    $
 859+ A75A             >
 859+ A75A             >//              ______________________________________________________________________
 859+ A75A             >//              Heap part
 859+ A75A             >
 859+ A75A             >
 859+ A75A             >                org     (Heap_Ptr & $1FFF) + $E000
 859+ E723             >
 859+ E723             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 859+ E723             >Latest_Definition defl  Heap_Ptr
 859+ E723             >
 859+ E723             >                // dummy db directives used to calculate length of namec
 859+ E723 43 4F 55 4E >                db      "COUNT"
 859+ E727 54          >
 859+ E728             >len_NFA         defl    $ - temp_NFA
 859+ E728             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 859+ E723             >
 859+ E723 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 859+ E724 43 4F 55 4E >                db      "COUNT"               // name string in 7-bit ascii, but
 859+ E728 54          >
 859+ E729             >                org     $-1                 // alter last byte of Name just above to set
 859+ E728 D4          >                db      {b $} | END_BIT     // msb as name end
 859+ E729             >
 859+ E729 19 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 859+ E72B             >Prev_Ptr        defl    Heap_Ptr
 859+ E72B             >
 859+ E72B             >mirror_Ptr      defl    $
 859+ E72B             >
 859+ E72B 5C A7       >                dw      Dict_Ptr + 2        // xt
 859+ E72D             >Heap_Ptr        defl    $ - $E000           // save current HP
 859+ E72D             >
 859+ E72D             >Current_HP      defl  $ - $E000             // used to set HP once!
 859+ E72D             >
 859+ E72D             >//              ______________________________________________________________________
 859+ E72D             >//              Dictionary part
 859+ E72D             >
 859+ E72D             >                org     Dict_Ptr
 859+ A75A             >
 859+ A75A 2B 27       >                dw      mirror_Ptr - $E000 + Heap_offset
 859+ A75C             >
 859+ A75C             >COUNT:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 859+ A75C ~           >                call    runcode ; ok        // for primitive definitions  actual code
 859+ A75C ~           >
 859+ A75C ~           >
 859+ A75C             >                endif           ; ok        // for other definitions it "points" the correct handler
 859+ A75C             >                // Use of "; ok" to suppress "warning[fwdref]"
 859+ A75C             >
 859+ A75C             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 860+ A75C D9                           exx
 861+ A75D E1                           pop     hl
 862+ A75E 5E                           ld      e, (hl)
 863+ A75F 16 00                        ld      d, 0
 864+ A761 23                           inc     hl
 865+ A762              Count_Here:
 866+ A762 E5                           push    hl
 867+ A763 D5                           push    de
 868+ A764 D9                           exx
 869+ A765                              next
 869+ A765 DD E9       >                jp      (ix)
 870+ A767              //                pop     hl
 871+ A767              //                ld      a, (hl)
 872+ A767              //                inc     hl
 873+ A767              //                push    hl
 874+ A767              //                ld      h, 0
 875+ A767              //                ld      l, a
 876+ A767              //                push    hl
 877+ A767              //                next
 878+ A767
 879+ A767              //  ______________________________________________________________________
 880+ A767              //
 881+ A767              // bounds       a n -- a+n n
 882+ A767              // given an address and a length ( a n ) calculate the bound addresses
 883+ A767              // suitable for DO-LOOP
 884+ A767                              New_Def BOUNDS, "BOUNDS", is_code, is_normal
 884+ A767             >
 884+ A767             >Dict_Ptr        defl    $
 884+ A767             >
 884+ A767             >//              ______________________________________________________________________
 884+ A767             >//              Heap part
 884+ A767             >
 884+ A767             >
 884+ A767             >                org     (Heap_Ptr & $1FFF) + $E000
 884+ E72D             >
 884+ E72D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 884+ E72D             >Latest_Definition defl  Heap_Ptr
 884+ E72D             >
 884+ E72D             >                // dummy db directives used to calculate length of namec
 884+ E72D 42 4F 55 4E >                db      "BOUNDS"
 884+ E731 44 53       >
 884+ E733             >len_NFA         defl    $ - temp_NFA
 884+ E733             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 884+ E72D             >
 884+ E72D 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 884+ E72E 42 4F 55 4E >                db      "BOUNDS"               // name string in 7-bit ascii, but
 884+ E732 44 53       >
 884+ E734             >                org     $-1                 // alter last byte of Name just above to set
 884+ E733 D3          >                db      {b $} | END_BIT     // msb as name end
 884+ E734             >
 884+ E734 23 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 884+ E736             >Prev_Ptr        defl    Heap_Ptr
 884+ E736             >
 884+ E736             >mirror_Ptr      defl    $
 884+ E736             >
 884+ E736 69 A7       >                dw      Dict_Ptr + 2        // xt
 884+ E738             >Heap_Ptr        defl    $ - $E000           // save current HP
 884+ E738             >
 884+ E738             >Current_HP      defl  $ - $E000             // used to set HP once!
 884+ E738             >
 884+ E738             >//              ______________________________________________________________________
 884+ E738             >//              Dictionary part
 884+ E738             >
 884+ E738             >                org     Dict_Ptr
 884+ A767             >
 884+ A767 36 27       >                dw      mirror_Ptr - $E000 + Heap_offset
 884+ A769             >
 884+ A769             >BOUNDS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 884+ A769 ~           >                call    runcode ; ok        // for primitive definitions  actual code
 884+ A769 ~           >
 884+ A769 ~           >
 884+ A769             >                endif           ; ok        // for other definitions it "points" the correct handler
 884+ A769             >                // Use of "; ok" to suppress "warning[fwdref]"
 884+ A769             >
 884+ A769             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 885+ A769 D9                           exx
 886+ A76A E1                           pop     hl
 887+ A76B D1                           pop     de
 888+ A76C 19                           add     hl, de
 889+ A76D 18 F3                        jr      Count_Here
 890+ A76F                              // push    hl
 891+ A76F                              // push    de
 892+ A76F                              // exx
 893+ A76F                              // next
 894+ A76F
 895+ A76F              //  ______________________________________________________________________
 896+ A76F              //
 897+ A76F              // leave        --
 898+ A76F              // Compile (leave) to leave current LOOP and jump just after it
 899+ A76F                              Colon_Def LEAVE, "LEAVE", is_immediate
 899+ A76F             >                New_Def  LEAVE, "LEAVE", Enter_Ptr, is_immediate ; ok
 899+ A76F             >
 899+ A76F             >Dict_Ptr        defl    $
 899+ A76F             >
 899+ A76F             >//              ______________________________________________________________________
 899+ A76F             >//              Heap part
 899+ A76F             >
 899+ A76F             >
 899+ A76F             >                org     (Heap_Ptr & $1FFF) + $E000
 899+ E738             >
 899+ E738             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 899+ E738             >Latest_Definition defl  Heap_Ptr
 899+ E738             >
 899+ E738             >                // dummy db directives used to calculate length of namec
 899+ E738 4C 45 41 56 >                db      "LEAVE"
 899+ E73C 45          >
 899+ E73D             >len_NFA         defl    $ - temp_NFA
 899+ E73D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 899+ E738             >
 899+ E738 C5          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 899+ E739 4C 45 41 56 >                db      "LEAVE"               // name string in 7-bit ascii, but
 899+ E73D 45          >
 899+ E73E             >                org     $-1                 // alter last byte of Name just above to set
 899+ E73D C5          >                db      {b $} | END_BIT     // msb as name end
 899+ E73E             >
 899+ E73E 2D 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 899+ E740             >Prev_Ptr        defl    Heap_Ptr
 899+ E740             >
 899+ E740             >mirror_Ptr      defl    $
 899+ E740             >
 899+ E740 71 A7       >                dw      Dict_Ptr + 2        // xt
 899+ E742             >Heap_Ptr        defl    $ - $E000           // save current HP
 899+ E742             >
 899+ E742             >Current_HP      defl  $ - $E000             // used to set HP once!
 899+ E742             >
 899+ E742             >//              ______________________________________________________________________
 899+ E742             >//              Dictionary part
 899+ E742             >
 899+ E742             >                org     Dict_Ptr
 899+ A76F             >
 899+ A76F 40 27       >                dw      mirror_Ptr - $E000 + Heap_offset
 899+ A771             >
 899+ A771             >LEAVE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 899+ A771 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 899+ A774             >
 899+ A774             >
 899+ A774             >                endif           ; ok        // for other definitions it "points" the correct handler
 899+ A774             >                // Use of "; ok" to suppress "warning[fwdref]"
 899+ A774             >
 899+ A774             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 900+ A774 90 A6 3E 9C                  dw      COMPILE, C_LEAVE       // compile (leave)     \ unloop and branch
 901+ A778 E4 A3 9A A0                  dw      HERE, TO_R, ZERO, COMMA // here >r 0 ,
 901+ A77C BF A2 FA A3
 902+ A780 BF A2 BF A2                  dw      ZERO, ZERO
 903+ A784 77 A0 69 A1                  dw      SPFETCH, DUP
 904+ A788 12 A1 12 A1                  dw      CELL_PLUS, CELL_PLUS
 905+ A78C 59 A1                        dw      TUCK
 906+ A78E A2 A3 C7 A1                  dw      CSP, FETCH
 907+ A792 62 A1 23 A4                  dw      SWAP, SUBTRACT
 908+ A796 CB 9F                        dw      CMOVE
 909+ A798 A2 A3 C7 A1                  dw      CSP, FETCH, CELL_MINUS
 909+ A79C 17 A1
 910+ A79E A5 A0 45 A1                  dw      R_TO, OVER, STORE
 910+ A7A2 D1 A1
 911+ A7A4 17 A1 BF A2                  dw      CELL_MINUS, ZERO
 912+ A7A8 62 A1 D1 A1                  dw      SWAP, STORE
 913+ A7AC 90 A0                        dw      EXIT                    // ;
 914+ A7AE
 915+ A7AE              //  ______________________________________________________________________
 916+ A7AE              //
 917+ A7AE              // type         a n --
 918+ A7AE              // Sends to current output channel n characters starting at address a.
 919+ A7AE                              Colon_Def TYPE, "TYPE", is_normal
 919+ A7AE             >                New_Def  TYPE, "TYPE", Enter_Ptr, is_normal ; ok
 919+ A7AE             >
 919+ A7AE             >Dict_Ptr        defl    $
 919+ A7AE             >
 919+ A7AE             >//              ______________________________________________________________________
 919+ A7AE             >//              Heap part
 919+ A7AE             >
 919+ A7AE             >
 919+ A7AE             >                org     (Heap_Ptr & $1FFF) + $E000
 919+ E742             >
 919+ E742             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 919+ E742             >Latest_Definition defl  Heap_Ptr
 919+ E742             >
 919+ E742             >                // dummy db directives used to calculate length of namec
 919+ E742 54 59 50 45 >                db      "TYPE"
 919+ E746             >len_NFA         defl    $ - temp_NFA
 919+ E746             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 919+ E742             >
 919+ E742 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 919+ E743 54 59 50 45 >                db      "TYPE"               // name string in 7-bit ascii, but
 919+ E747             >                org     $-1                 // alter last byte of Name just above to set
 919+ E746 C5          >                db      {b $} | END_BIT     // msb as name end
 919+ E747             >
 919+ E747 38 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 919+ E749             >Prev_Ptr        defl    Heap_Ptr
 919+ E749             >
 919+ E749             >mirror_Ptr      defl    $
 919+ E749             >
 919+ E749 B0 A7       >                dw      Dict_Ptr + 2        // xt
 919+ E74B             >Heap_Ptr        defl    $ - $E000           // save current HP
 919+ E74B             >
 919+ E74B             >Current_HP      defl  $ - $E000             // used to set HP once!
 919+ E74B             >
 919+ E74B             >//              ______________________________________________________________________
 919+ E74B             >//              Dictionary part
 919+ E74B             >
 919+ E74B             >                org     Dict_Ptr
 919+ A7AE             >
 919+ A7AE 49 27       >                dw      mirror_Ptr - $E000 + Heap_offset
 919+ A7B0             >
 919+ A7B0             >TYPE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 919+ A7B0 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 919+ A7B3             >
 919+ A7B3             >
 919+ A7B3             >                endif           ; ok        // for other definitions it "points" the correct handler
 919+ A7B3             >                // Use of "; ok" to suppress "warning[fwdref]"
 919+ A7B3             >
 919+ A7B3             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 920+ A7B3 69 A7                        dw      BOUNDS                  // bounds
 921+ A7B5 4A 9C                        dw      C_Q_DO                  // ?do
 922+ A7B7 0C 00                        dw      Type_Skip - $
 923+ A7B9              Type_Loop:
 924+ A7B9 78 9C DC A1                  dw          I, CFETCH           //      i c@
 925+ A7BD 9E A4                        dw          EMIT                //      emit
 926+ A7BF 1E 9C                        dw      C_LOOP                  // loop
 927+ A7C1 F8 FF                        dw      Type_Loop - $
 928+ A7C3              Type_Skip:
 929+ A7C3 90 A0                        dw      EXIT                    // ;
 930+ A7C5
 931+ A7C5              //  ______________________________________________________________________
 932+ A7C5              //
 933+ A7C5              // -trailing    a n1 -- a n2
 934+ A7C5              // Assumes that an n1 bytes-long string is stored at address a
 935+ A7C5              // and the string contains a space delimited word,
 936+ A7C5              // Finds n2 as the position of the first character after the word.
 937+ A7C5                              Colon_Def LTRAILING, "-TRAILING", is_normal
 937+ A7C5             >                New_Def  LTRAILING, "-TRAILING", Enter_Ptr, is_normal ; ok
 937+ A7C5             >
 937+ A7C5             >Dict_Ptr        defl    $
 937+ A7C5             >
 937+ A7C5             >//              ______________________________________________________________________
 937+ A7C5             >//              Heap part
 937+ A7C5             >
 937+ A7C5             >
 937+ A7C5             >                org     (Heap_Ptr & $1FFF) + $E000
 937+ E74B             >
 937+ E74B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 937+ E74B             >Latest_Definition defl  Heap_Ptr
 937+ E74B             >
 937+ E74B             >                // dummy db directives used to calculate length of namec
 937+ E74B 2D 54 52 41 >                db      "-TRAILING"
 937+ E74F 49 4C 49 4E >
 937+ E753 47          >
 937+ E754             >len_NFA         defl    $ - temp_NFA
 937+ E754             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 937+ E74B             >
 937+ E74B 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 937+ E74C 2D 54 52 41 >                db      "-TRAILING"               // name string in 7-bit ascii, but
 937+ E750 49 4C 49 4E >
 937+ E754 47          >
 937+ E755             >                org     $-1                 // alter last byte of Name just above to set
 937+ E754 C7          >                db      {b $} | END_BIT     // msb as name end
 937+ E755             >
 937+ E755 42 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 937+ E757             >Prev_Ptr        defl    Heap_Ptr
 937+ E757             >
 937+ E757             >mirror_Ptr      defl    $
 937+ E757             >
 937+ E757 C7 A7       >                dw      Dict_Ptr + 2        // xt
 937+ E759             >Heap_Ptr        defl    $ - $E000           // save current HP
 937+ E759             >
 937+ E759             >Current_HP      defl  $ - $E000             // used to set HP once!
 937+ E759             >
 937+ E759             >//              ______________________________________________________________________
 937+ E759             >//              Dictionary part
 937+ E759             >
 937+ E759             >                org     Dict_Ptr
 937+ A7C5             >
 937+ A7C5 57 27       >                dw      mirror_Ptr - $E000 + Heap_offset
 937+ A7C7             >
 937+ A7C7             >LTRAILING:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 937+ A7C7 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 937+ A7CA             >
 937+ A7CA             >
 937+ A7CA             >                endif           ; ok        // for other definitions it "points" the correct handler
 937+ A7CA             >                // Use of "; ok" to suppress "warning[fwdref]"
 937+ A7CA             >
 937+ A7CA             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 938+ A7CA 69 A1 BF A2                  dw      DUP, ZERO               // dup 0
 939+ A7CE                                                              // do
 940+ A7CE 4A 9C                        dw      C_Q_DO
 941+ A7D0 20 00                        dw      LTrailing_Leave - $
 942+ A7D2              LTrailing_Loop:
 943+ A7D2 A5 A1 E3 A0                  dw          TWO_DUP, PLUS       //      2dup +
 944+ A7D6 03 A1                        dw          ONE_SUBTRACT        //      1-
 945+ A7D8 DC A1                        dw          CFETCH              //      c@
 946+ A7DA E2 A2 23 A4                  dw          BL, SUBTRACT        //      bl -
 947+ A7DE                                                              //      if
 948+ A7DE 33 9C                        dw          ZBRANCH
 949+ A7E0 0A 00                        dw          LTrailing_Else - $
 950+ A7E2 3E 9C                        dw              C_LEAVE         //          leave
 951+ A7E4 0C 00                        dw              LTrailing_Leave - $
 952+ A7E6 26 9C                        dw          BRANCH              //      else
 953+ A7E8 04 00                        dw          LTrailing_Endif - $
 954+ A7EA              LTrailing_Else:
 955+ A7EA 03 A1                        dw              ONE_SUBTRACT    //          1-
 956+ A7EC              LTrailing_Endif:                                //      endif
 957+ A7EC                                                              // loop
 958+ A7EC 1E 9C                        dw      C_LOOP
 959+ A7EE E4 FF                        dw      LTrailing_Loop - $
 960+ A7F0              LTrailing_Leave:
 961+ A7F0 90 A0                        dw      EXIT                    // ;
 962+ A7F2
 963+ A7F2              //  ______________________________________________________________________
 964+ A7F2              //
 965+ A7F2              // accept       a n1 -- n2
 966+ A7F2              // Accepts at most n1 characters from terminal and stores them at address a
 967+ A7F2              // CR stops input. A 'nul' is added as trailer.
 968+ A7F2              // n2 is the string length. n2 is kept in span user variable also.
 969+ A7F2                              Colon_Def ACCEPT, "ACCEPT", is_normal
 969+ A7F2             >                New_Def  ACCEPT, "ACCEPT", Enter_Ptr, is_normal ; ok
 969+ A7F2             >
 969+ A7F2             >Dict_Ptr        defl    $
 969+ A7F2             >
 969+ A7F2             >//              ______________________________________________________________________
 969+ A7F2             >//              Heap part
 969+ A7F2             >
 969+ A7F2             >
 969+ A7F2             >                org     (Heap_Ptr & $1FFF) + $E000
 969+ E759             >
 969+ E759             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 969+ E759             >Latest_Definition defl  Heap_Ptr
 969+ E759             >
 969+ E759             >                // dummy db directives used to calculate length of namec
 969+ E759 41 43 43 45 >                db      "ACCEPT"
 969+ E75D 50 54       >
 969+ E75F             >len_NFA         defl    $ - temp_NFA
 969+ E75F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 969+ E759             >
 969+ E759 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 969+ E75A 41 43 43 45 >                db      "ACCEPT"               // name string in 7-bit ascii, but
 969+ E75E 50 54       >
 969+ E760             >                org     $-1                 // alter last byte of Name just above to set
 969+ E75F D4          >                db      {b $} | END_BIT     // msb as name end
 969+ E760             >
 969+ E760 4B 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 969+ E762             >Prev_Ptr        defl    Heap_Ptr
 969+ E762             >
 969+ E762             >mirror_Ptr      defl    $
 969+ E762             >
 969+ E762 F4 A7       >                dw      Dict_Ptr + 2        // xt
 969+ E764             >Heap_Ptr        defl    $ - $E000           // save current HP
 969+ E764             >
 969+ E764             >Current_HP      defl  $ - $E000             // used to set HP once!
 969+ E764             >
 969+ E764             >//              ______________________________________________________________________
 969+ E764             >//              Dictionary part
 969+ E764             >
 969+ E764             >                org     Dict_Ptr
 969+ A7F2             >
 969+ A7F2 62 27       >                dw      mirror_Ptr - $E000 + Heap_offset
 969+ A7F4             >
 969+ A7F4             >ACCEPT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 969+ A7F4 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 969+ A7F7             >
 969+ A7F7             >
 969+ A7F7             >                endif           ; ok        // for other definitions it "points" the correct handler
 969+ A7F7             >                // Use of "; ok" to suppress "warning[fwdref]"
 969+ A7F7             >
 969+ A7F7             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 970+ A7F7 45 A1 E3 A0                  dw      OVER, PLUS, OVER        //                      ( a  n1+a  a )
 970+ A7FB 45 A1
 971+ A7FD BF A2 7B A1                  dw      ZERO, DASH_ROT          //                      ( a  0     a+n1  a )
 972+ A801                                                              // do
 973+ A801 4A 9C                        dw      C_Q_DO
 974+ A803 8C 00                        dw      Accept_Leave - $
 975+ A805              Accept_Loop:
 976+ A805 76 9E                        dw          CUR
 977+ A807 4E A1 BE 9E                  dw          DROP, KEY           //      drop key        ( a  c )
 978+ A80B 69 A1                        dw          DUP                 //      dup             ( a  c  c )
 979+ A80D E1 9B 0E 00                  dw          LIT, $0E            //      0E
 980+ A811 05 A3                        dw          PLUS_ORIGIN         //      +origin
 981+ A813 C7 A1                        dw          FETCH               //      @               ( a  c  c  del )
 982+ A815 2F A4                        dw          EQUALS              //      =               ( a  c  c==del )
 983+ A817                                                              //      if
 984+ A817 33 9C                        dw          ZBRANCH
 985+ A819 2C 00                        dw          Accept_Else_0 - $
 986+ A81B 4E A1                        dw              DROP            //          drop        ( a  )
 987+ A81D 69 A1 78 9C                  dw              DUP, I, EQUALS  //          dup i =     ( a  a==i )
 987+ A821 2F A4
 988+ A823 C6 A2 4A A0                  dw              ONE, AND_OP     //          1 and
 989+ A827 69 A1                        dw              DUP             //          dup         ( a  a==i  a==i )
 990+ A829 A5 A0                        dw              R_TO            //          r> 2 - + r>
 991+ A82B 1F A1 E3 A0                  dw              TWO_MINUS, PLUS //      ( decrement index by 1 or 2 )
 992+ A82F 9A A0                        dw              TO_R            //
 993+ A831                                                              //          if
 994+ A831 33 9C                        dw              ZBRANCH
 995+ A833 0A 00                        dw              Accept_Else_1 - $
 996+ A835 E1 9B 07 00                  dw                  LIT, 7      //              7       ( a  7 )
 997+ A839                                                              //          else
 998+ A839 26 9C                        dw              BRANCH
 999+ A83B 06 00                        dw              Accept_Endif_1 - $
1000+ A83D              Accept_Else_1:
1001+ A83D E1 9B 08 00                  dw                  LIT, 8      //              8       ( a  8 )
1002+ A841              Accept_Endif_1:                                 //          endif
1003+ A841 26 9C                        dw          BRANCH
1004+ A843 2E 00                        dw          Accept_Endif_0 - $
1005+ A845              Accept_Else_0:                                  //      else
1006+ A845 69 A1                        dw              DUP             //          dup         ( a  c  c )
1007+ A847 E1 9B 0D 00                  dw              LIT, 13         //          13
1008+ A84B 2F A4                        dw              EQUALS          //          =           ( a  c  c==CR )
1009+ A84D                                                              //          if
1010+ A84D 33 9C                        dw              ZBRANCH
1011+ A84F 0C 00                        dw              Accept_Else_2 - $
1012+ A851 4E A1 E2 A2                  dw                  DROP, BL    //              drop bl ( a  bl )
1013+ A855 BF A2                        dw                  ZERO        //              0       ( a  c  0 )
1014+ A857                                                              //          else
1015+ A857 26 9C                        dw              BRANCH
1016+ A859 04 00                        dw              Accept_Endif_2 - $
1017+ A85B              Accept_Else_2:
1018+ A85B 69 A1                        dw                  DUP         //              dup     ( a  c  c )
1019+ A85D                                                              //          endif
1020+ A85D              Accept_Endif_2:
1021+ A85D 78 9C E5 A1                  dw              I, CSTORE       //          i           ( a  c )
1022+ A861 69 A1 E2 A2                  dw              DUP, BL, LESS   //          dup bl <    ( a  c  c<BL )
1022+ A865 48 A4
1023+ A867                                                              //          if
1024+ A867 33 9C                        dw              ZBRANCH
1025+ A869 08 00                        dw              Accept_Endif_3 - $
1026+ A86B A5 A0                        dw                  R_TO        //              r>
1027+ A86D 03 A1                        dw                  ONE_SUBTRACT//              1-
1028+ A86F 9A A0                        dw                  TO_R        //              >r
1029+ A871                                                              //          endif
1030+ A871              Accept_Endif_3:
1031+ A871              Accept_Endif_0:                                 //      endif
1032+ A871 9E A4                        dw          EMIT                //      emit
1033+ A873
1034+ A873 BF A2 78 9C                  dw          ZERO, I, ONE_PLUS   //      0 i 1+ !
1034+ A877 FC A0
1035+ A879 D1 A1                        dw          STORE               //          ( zero pad )
1036+ A87B 78 9C                        dw          I                   //      i
1037+ A87D 78 9C DC A1                  dw          I, CFETCH, ZEQUAL   //      i 0= if
1037+ A881 B5 A0
1038+ A883 33 9C                        dw          ZBRANCH             //
1039+ A885 06 00                        dw              Accept_Endif_4 - $
1040+ A887 3E 9C                        dw                  C_LEAVE     //              leave
1041+ A889 06 00                        dw                  Accept_Leave - $
1042+ A88B              Accept_Endif_4:                                 //      endif
1043+ A88B                                                              // loop
1044+ A88B 1E 9C                        dw      C_LOOP
1045+ A88D 78 FF                        dw      Accept_Loop - $
1046+ A88F              Accept_Leave:
1047+ A88F 62 A1 23 A4                  dw      SWAP, SUBTRACT          // swap -
1048+ A893 FC A0                        dw      ONE_PLUS                // 1+
1049+ A895 69 A1 D2 A3                  dw      DUP, SPAN, STORE        // dup span !
1049+ A899 D1 A1
1050+ A89B 90 A0                        dw      EXIT                    // ;
1051+ A89D
1052+ A89D              //  ______________________________________________________________________
1053+ A89D              //
1054+ A89D              // expect      a n --
1055+ A89D              // Accepts at most n1 characters from terminal and stores them at address a
1056+ A89D              // CR stops input. A 'nul' is added as trailer.
1057+ A89D              // n2 is the string length. n2 is kept in span user variable also.
1058+ A89D              //              Colon_Def EXPECT, "EXPECT", is_normal
1059+ A89D              //              dw      ACCEPT, DROP            // accept drop
1060+ A89D              //              dw      EXIT                    // ;
1061+ A89D
1062+ A89D              //  ______________________________________________________________________
1063+ A89D              //
1064+ A89D              // query        --
1065+ A89D              // Accept at most 80 character from console. CR stops.
1066+ A89D              // Text is stored in TIB. Variable IN is zeroed.
1067+ A89D                              Colon_Def QUERY, "QUERY", is_normal
1067+ A89D             >                New_Def  QUERY, "QUERY", Enter_Ptr, is_normal ; ok
1067+ A89D             >
1067+ A89D             >Dict_Ptr        defl    $
1067+ A89D             >
1067+ A89D             >//              ______________________________________________________________________
1067+ A89D             >//              Heap part
1067+ A89D             >
1067+ A89D             >
1067+ A89D             >                org     (Heap_Ptr & $1FFF) + $E000
1067+ E764             >
1067+ E764             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1067+ E764             >Latest_Definition defl  Heap_Ptr
1067+ E764             >
1067+ E764             >                // dummy db directives used to calculate length of namec
1067+ E764 51 55 45 52 >                db      "QUERY"
1067+ E768 59          >
1067+ E769             >len_NFA         defl    $ - temp_NFA
1067+ E769             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1067+ E764             >
1067+ E764 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1067+ E765 51 55 45 52 >                db      "QUERY"               // name string in 7-bit ascii, but
1067+ E769 59          >
1067+ E76A             >                org     $-1                 // alter last byte of Name just above to set
1067+ E769 D9          >                db      {b $} | END_BIT     // msb as name end
1067+ E76A             >
1067+ E76A 59 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1067+ E76C             >Prev_Ptr        defl    Heap_Ptr
1067+ E76C             >
1067+ E76C             >mirror_Ptr      defl    $
1067+ E76C             >
1067+ E76C 9F A8       >                dw      Dict_Ptr + 2        // xt
1067+ E76E             >Heap_Ptr        defl    $ - $E000           // save current HP
1067+ E76E             >
1067+ E76E             >Current_HP      defl  $ - $E000             // used to set HP once!
1067+ E76E             >
1067+ E76E             >//              ______________________________________________________________________
1067+ E76E             >//              Dictionary part
1067+ E76E             >
1067+ E76E             >                org     Dict_Ptr
1067+ A89D             >
1067+ A89D 6C 27       >                dw      mirror_Ptr - $E000 + Heap_offset
1067+ A89F             >
1067+ A89F             >QUERY:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1067+ A89F CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1067+ A8A2             >
1067+ A8A2             >
1067+ A8A2             >                endif           ; ok        // for other definitions it "points" the correct handler
1067+ A8A2             >                // Use of "; ok" to suppress "warning[fwdref]"
1067+ A8A2             >
1067+ A8A2             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1068+ A8A2 24 A3 C7 A1                  dw      TIB, FETCH              // tib @
1069+ A8A6 E1 9B 50 00                  dw      LIT, 80                 // 80
1070+ A8AA F4 A7 4E A1                  dw      ACCEPT, DROP            // accept drop
1071+ A8AE BF A2 66 A3                  dw      ZERO, TO_IN, STORE      // 0 >in !
1071+ A8B2 D1 A1
1072+ A8B4 90 A0                        dw      EXIT                    // ;
1073+ A8B6
1074+ A8B6              //  ______________________________________________________________________
1075+ A8B6              //
1076+ A8B6              // fill        a n c --
1077+ A8B6              // If n > 0, fills n locations starting from address a with the value c.
1078+ A8B6                              New_Def FILL, "FILL", is_code, is_normal
1078+ A8B6             >
1078+ A8B6             >Dict_Ptr        defl    $
1078+ A8B6             >
1078+ A8B6             >//              ______________________________________________________________________
1078+ A8B6             >//              Heap part
1078+ A8B6             >
1078+ A8B6             >
1078+ A8B6             >                org     (Heap_Ptr & $1FFF) + $E000
1078+ E76E             >
1078+ E76E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1078+ E76E             >Latest_Definition defl  Heap_Ptr
1078+ E76E             >
1078+ E76E             >                // dummy db directives used to calculate length of namec
1078+ E76E 46 49 4C 4C >                db      "FILL"
1078+ E772             >len_NFA         defl    $ - temp_NFA
1078+ E772             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1078+ E76E             >
1078+ E76E 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1078+ E76F 46 49 4C 4C >                db      "FILL"               // name string in 7-bit ascii, but
1078+ E773             >                org     $-1                 // alter last byte of Name just above to set
1078+ E772 CC          >                db      {b $} | END_BIT     // msb as name end
1078+ E773             >
1078+ E773 64 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1078+ E775             >Prev_Ptr        defl    Heap_Ptr
1078+ E775             >
1078+ E775             >mirror_Ptr      defl    $
1078+ E775             >
1078+ E775 B8 A8       >                dw      Dict_Ptr + 2        // xt
1078+ E777             >Heap_Ptr        defl    $ - $E000           // save current HP
1078+ E777             >
1078+ E777             >Current_HP      defl  $ - $E000             // used to set HP once!
1078+ E777             >
1078+ E777             >//              ______________________________________________________________________
1078+ E777             >//              Dictionary part
1078+ E777             >
1078+ E777             >                org     Dict_Ptr
1078+ A8B6             >
1078+ A8B6 75 27       >                dw      mirror_Ptr - $E000 + Heap_offset
1078+ A8B8             >
1078+ A8B8             >FILL:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
1078+ A8B8 ~           >                call    runcode ; ok        // for primitive definitions  actual code
1078+ A8B8 ~           >
1078+ A8B8 ~           >
1078+ A8B8             >                endif           ; ok        // for other definitions it "points" the correct handler
1078+ A8B8             >                // Use of "; ok" to suppress "warning[fwdref]"
1078+ A8B8             >
1078+ A8B8             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1079+ A8B8 D9                           exx
1080+ A8B9 D1                           pop     de                  // de has character
1081+ A8BA C1                           pop     bc                  // bc has counter
1082+ A8BB E1                           pop     hl                  // hl has address, save Instruction Pointer
1083+ A8BC              Fill_Loop:
1084+ A8BC 78                               ld      a, b
1085+ A8BD B1                               or      c
1086+ A8BE 28 05                        jr      z, Fill_While_End
1087+ A8C0 73                               ld      (hl), e
1088+ A8C1 0B                               dec     bc
1089+ A8C2 23                               inc     hl
1090+ A8C3 18 F7                        jr      Fill_Loop
1091+ A8C5              Fill_While_End:
1092+ A8C5 D9                           exx
1093+ A8C6                              next
1093+ A8C6 DD E9       >                jp      (ix)
1094+ A8C8
1095+ A8C8              //  ______________________________________________________________________
1096+ A8C8              //
1097+ A8C8              // erase        a n --
1098+ A8C8              // If n > 0, fills n locations starting from address a with 'nul' characters.
1099+ A8C8                              Colon_Def ERASE, "ERASE", is_normal
1099+ A8C8             >                New_Def  ERASE, "ERASE", Enter_Ptr, is_normal ; ok
1099+ A8C8             >
1099+ A8C8             >Dict_Ptr        defl    $
1099+ A8C8             >
1099+ A8C8             >//              ______________________________________________________________________
1099+ A8C8             >//              Heap part
1099+ A8C8             >
1099+ A8C8             >
1099+ A8C8             >                org     (Heap_Ptr & $1FFF) + $E000
1099+ E777             >
1099+ E777             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1099+ E777             >Latest_Definition defl  Heap_Ptr
1099+ E777             >
1099+ E777             >                // dummy db directives used to calculate length of namec
1099+ E777 45 52 41 53 >                db      "ERASE"
1099+ E77B 45          >
1099+ E77C             >len_NFA         defl    $ - temp_NFA
1099+ E77C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1099+ E777             >
1099+ E777 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1099+ E778 45 52 41 53 >                db      "ERASE"               // name string in 7-bit ascii, but
1099+ E77C 45          >
1099+ E77D             >                org     $-1                 // alter last byte of Name just above to set
1099+ E77C C5          >                db      {b $} | END_BIT     // msb as name end
1099+ E77D             >
1099+ E77D 6E 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1099+ E77F             >Prev_Ptr        defl    Heap_Ptr
1099+ E77F             >
1099+ E77F             >mirror_Ptr      defl    $
1099+ E77F             >
1099+ E77F CA A8       >                dw      Dict_Ptr + 2        // xt
1099+ E781             >Heap_Ptr        defl    $ - $E000           // save current HP
1099+ E781             >
1099+ E781             >Current_HP      defl  $ - $E000             // used to set HP once!
1099+ E781             >
1099+ E781             >//              ______________________________________________________________________
1099+ E781             >//              Dictionary part
1099+ E781             >
1099+ E781             >                org     Dict_Ptr
1099+ A8C8             >
1099+ A8C8 7F 27       >                dw      mirror_Ptr - $E000 + Heap_offset
1099+ A8CA             >
1099+ A8CA             >ERASE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1099+ A8CA CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1099+ A8CD             >
1099+ A8CD             >
1099+ A8CD             >                endif           ; ok        // for other definitions it "points" the correct handler
1099+ A8CD             >                // Use of "; ok" to suppress "warning[fwdref]"
1099+ A8CD             >
1099+ A8CD             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1100+ A8CD BF A2 B8 A8                  dw      ZERO, FILL              // 0 fill
1101+ A8D1 90 A0                        dw      EXIT                    // ;
1102+ A8D3
1103+ A8D3              //  ______________________________________________________________________
1104+ A8D3              //
1105+ A8D3              // blank        a n --
1106+ A8D3              // If n > 0, fills n locations starting from address a with 'nul' characters.
1107+ A8D3                              Colon_Def BLANK, "BLANK", is_normal
1107+ A8D3             >                New_Def  BLANK, "BLANK", Enter_Ptr, is_normal ; ok
1107+ A8D3             >
1107+ A8D3             >Dict_Ptr        defl    $
1107+ A8D3             >
1107+ A8D3             >//              ______________________________________________________________________
1107+ A8D3             >//              Heap part
1107+ A8D3             >
1107+ A8D3             >
1107+ A8D3             >                org     (Heap_Ptr & $1FFF) + $E000
1107+ E781             >
1107+ E781             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1107+ E781             >Latest_Definition defl  Heap_Ptr
1107+ E781             >
1107+ E781             >                // dummy db directives used to calculate length of namec
1107+ E781 42 4C 41 4E >                db      "BLANK"
1107+ E785 4B          >
1107+ E786             >len_NFA         defl    $ - temp_NFA
1107+ E786             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1107+ E781             >
1107+ E781 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1107+ E782 42 4C 41 4E >                db      "BLANK"               // name string in 7-bit ascii, but
1107+ E786 4B          >
1107+ E787             >                org     $-1                 // alter last byte of Name just above to set
1107+ E786 CB          >                db      {b $} | END_BIT     // msb as name end
1107+ E787             >
1107+ E787 77 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1107+ E789             >Prev_Ptr        defl    Heap_Ptr
1107+ E789             >
1107+ E789             >mirror_Ptr      defl    $
1107+ E789             >
1107+ E789 D5 A8       >                dw      Dict_Ptr + 2        // xt
1107+ E78B             >Heap_Ptr        defl    $ - $E000           // save current HP
1107+ E78B             >
1107+ E78B             >Current_HP      defl  $ - $E000             // used to set HP once!
1107+ E78B             >
1107+ E78B             >//              ______________________________________________________________________
1107+ E78B             >//              Dictionary part
1107+ E78B             >
1107+ E78B             >                org     Dict_Ptr
1107+ A8D3             >
1107+ A8D3 89 27       >                dw      mirror_Ptr - $E000 + Heap_offset
1107+ A8D5             >
1107+ A8D5             >BLANK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1107+ A8D5 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1107+ A8D8             >
1107+ A8D8             >
1107+ A8D8             >                endif           ; ok        // for other definitions it "points" the correct handler
1107+ A8D8             >                // Use of "; ok" to suppress "warning[fwdref]"
1107+ A8D8             >
1107+ A8D8             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1108+ A8D8 E2 A2 B8 A8                  dw      BL, FILL                // bl fill
1109+ A8DC 90 A0                        dw      EXIT                    // ;
1110+ A8DE
1111+ A8DE              //  ______________________________________________________________________
1112+ A8DE              //
1113+ A8DE              // hold         c --
1114+ A8DE              // Used between <# and #> to insert a character c in numeric formatting.
1115+ A8DE                              Colon_Def HOLD, "HOLD", is_normal
1115+ A8DE             >                New_Def  HOLD, "HOLD", Enter_Ptr, is_normal ; ok
1115+ A8DE             >
1115+ A8DE             >Dict_Ptr        defl    $
1115+ A8DE             >
1115+ A8DE             >//              ______________________________________________________________________
1115+ A8DE             >//              Heap part
1115+ A8DE             >
1115+ A8DE             >
1115+ A8DE             >                org     (Heap_Ptr & $1FFF) + $E000
1115+ E78B             >
1115+ E78B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1115+ E78B             >Latest_Definition defl  Heap_Ptr
1115+ E78B             >
1115+ E78B             >                // dummy db directives used to calculate length of namec
1115+ E78B 48 4F 4C 44 >                db      "HOLD"
1115+ E78F             >len_NFA         defl    $ - temp_NFA
1115+ E78F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1115+ E78B             >
1115+ E78B 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1115+ E78C 48 4F 4C 44 >                db      "HOLD"               // name string in 7-bit ascii, but
1115+ E790             >                org     $-1                 // alter last byte of Name just above to set
1115+ E78F C4          >                db      {b $} | END_BIT     // msb as name end
1115+ E790             >
1115+ E790 81 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1115+ E792             >Prev_Ptr        defl    Heap_Ptr
1115+ E792             >
1115+ E792             >mirror_Ptr      defl    $
1115+ E792             >
1115+ E792 E0 A8       >                dw      Dict_Ptr + 2        // xt
1115+ E794             >Heap_Ptr        defl    $ - $E000           // save current HP
1115+ E794             >
1115+ E794             >Current_HP      defl  $ - $E000             // used to set HP once!
1115+ E794             >
1115+ E794             >//              ______________________________________________________________________
1115+ E794             >//              Dictionary part
1115+ E794             >
1115+ E794             >                org     Dict_Ptr
1115+ A8DE             >
1115+ A8DE 92 27       >                dw      mirror_Ptr - $E000 + Heap_offset
1115+ A8E0             >
1115+ A8E0             >HOLD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1115+ A8E0 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1115+ A8E3             >
1115+ A8E3             >
1115+ A8E3             >                endif           ; ok        // for other definitions it "points" the correct handler
1115+ A8E3             >                // Use of "; ok" to suppress "warning[fwdref]"
1115+ A8E3             >
1115+ A8E3             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1116+ A8E3 DB A2                        dw      NEG_ONE                 // -1
1117+ A8E5 AE A3 AF A1                  dw      HLD, PLUSSTORE          // hld +!
1118+ A8E9 AE A3 C7 A1                  dw      HLD, FETCH, CSTORE      // hld @ c!
1118+ A8ED E5 A1
1119+ A8EF 90 A0                        dw      EXIT                    // ;
1120+ A8F1
1121+ A8F1              //  ______________________________________________________________________
1122+ A8F1              //
1123+ A8F1              // pad         -- a
1124+ A8F1              // leaves the buffer text address. This is at a fixed distance over HERE.
1125+ A8F1                              Colon_Def PAD, "PAD", is_normal
1125+ A8F1             >                New_Def  PAD, "PAD", Enter_Ptr, is_normal ; ok
1125+ A8F1             >
1125+ A8F1             >Dict_Ptr        defl    $
1125+ A8F1             >
1125+ A8F1             >//              ______________________________________________________________________
1125+ A8F1             >//              Heap part
1125+ A8F1             >
1125+ A8F1             >
1125+ A8F1             >                org     (Heap_Ptr & $1FFF) + $E000
1125+ E794             >
1125+ E794             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1125+ E794             >Latest_Definition defl  Heap_Ptr
1125+ E794             >
1125+ E794             >                // dummy db directives used to calculate length of namec
1125+ E794 50 41 44    >                db      "PAD"
1125+ E797             >len_NFA         defl    $ - temp_NFA
1125+ E797             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1125+ E794             >
1125+ E794 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1125+ E795 50 41 44    >                db      "PAD"               // name string in 7-bit ascii, but
1125+ E798             >                org     $-1                 // alter last byte of Name just above to set
1125+ E797 C4          >                db      {b $} | END_BIT     // msb as name end
1125+ E798             >
1125+ E798 8B 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1125+ E79A             >Prev_Ptr        defl    Heap_Ptr
1125+ E79A             >
1125+ E79A             >mirror_Ptr      defl    $
1125+ E79A             >
1125+ E79A F3 A8       >                dw      Dict_Ptr + 2        // xt
1125+ E79C             >Heap_Ptr        defl    $ - $E000           // save current HP
1125+ E79C             >
1125+ E79C             >Current_HP      defl  $ - $E000             // used to set HP once!
1125+ E79C             >
1125+ E79C             >//              ______________________________________________________________________
1125+ E79C             >//              Dictionary part
1125+ E79C             >
1125+ E79C             >                org     Dict_Ptr
1125+ A8F1             >
1125+ A8F1 9A 27       >                dw      mirror_Ptr - $E000 + Heap_offset
1125+ A8F3             >
1125+ A8F3             >PAD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1125+ A8F3 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1125+ A8F6             >
1125+ A8F6             >
1125+ A8F6             >                endif           ; ok        // for other definitions it "points" the correct handler
1125+ A8F6             >                // Use of "; ok" to suppress "warning[fwdref]"
1125+ A8F6             >
1125+ A8F6             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1126+ A8F6 E4 A3                        dw      HERE                    // here
1127+ A8F8 E1 9B 44 00                  dw      LIT, 68                 // 68
1128+ A8FC E3 A0                        dw      PLUS                    // +
1129+ A8FE 90 A0                        dw      EXIT                    // ;
1130+ A900
1131+ A900              //  ______________________________________________________________________
1132+ A900              //
1133+ A900              // word         c -- a
1134+ A900              // reads characters from input streams until it encouners a c delimiter.
1135+ A900              // Stores that packet so it starts from HERE
1136+ A900              // WORD leaves a counter as first byte and ends the packet with two spaces.
1137+ A900              // Other occurrences of c are ignored.
1138+ A900              // If BLK is zero, text is taken from terminal buffer TIB.
1139+ A900              // Otherwise text is taken from the disk-block given by BLK.
1140+ A900              // "in" variable is incremented of the number of character read.
1141+ A900              // The number of characters read is given by ENCLOSE.
1142+ A900                              Colon_Def WORD, "WORD", is_normal
1142+ A900             >                New_Def  WORD, "WORD", Enter_Ptr, is_normal ; ok
1142+ A900             >
1142+ A900             >Dict_Ptr        defl    $
1142+ A900             >
1142+ A900             >//              ______________________________________________________________________
1142+ A900             >//              Heap part
1142+ A900             >
1142+ A900             >
1142+ A900             >                org     (Heap_Ptr & $1FFF) + $E000
1142+ E79C             >
1142+ E79C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1142+ E79C             >Latest_Definition defl  Heap_Ptr
1142+ E79C             >
1142+ E79C             >                // dummy db directives used to calculate length of namec
1142+ E79C 57 4F 52 44 >                db      "WORD"
1142+ E7A0             >len_NFA         defl    $ - temp_NFA
1142+ E7A0             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1142+ E79C             >
1142+ E79C 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1142+ E79D 57 4F 52 44 >                db      "WORD"               // name string in 7-bit ascii, but
1142+ E7A1             >                org     $-1                 // alter last byte of Name just above to set
1142+ E7A0 C4          >                db      {b $} | END_BIT     // msb as name end
1142+ E7A1             >
1142+ E7A1 94 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1142+ E7A3             >Prev_Ptr        defl    Heap_Ptr
1142+ E7A3             >
1142+ E7A3             >mirror_Ptr      defl    $
1142+ E7A3             >
1142+ E7A3 02 A9       >                dw      Dict_Ptr + 2        // xt
1142+ E7A5             >Heap_Ptr        defl    $ - $E000           // save current HP
1142+ E7A5             >
1142+ E7A5             >Current_HP      defl  $ - $E000             // used to set HP once!
1142+ E7A5             >
1142+ E7A5             >//              ______________________________________________________________________
1142+ E7A5             >//              Dictionary part
1142+ E7A5             >
1142+ E7A5             >                org     Dict_Ptr
1142+ A900             >
1142+ A900 A3 27       >                dw      mirror_Ptr - $E000 + Heap_offset
1142+ A902             >
1142+ A902             >WORD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1142+ A902 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1142+ A905             >
1142+ A905             >
1142+ A905             >                endif           ; ok        // for other definitions it "points" the correct handler
1142+ A905             >                // Use of "; ok" to suppress "warning[fwdref]"
1142+ A905             >
1142+ A905             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1143+ A905 60 A3 C7 A1                  dw      BLK, FETCH              // blk @
1144+ A909                                                              // if
1145+ A909 33 9C                        dw      ZBRANCH
1146+ A90B 0C 00                        dw      Word_Else - $
1147+ A90D 60 A3 C7 A1                  dw          BLK, FETCH          //      blk @
1148+ A911 5E B1                        dw          BLOCK               //      block ( forward )
1149+ A913                                                              // else
1150+ A913 26 9C                        dw      BRANCH
1151+ A915 06 00                        dw      Word_Endif - $
1152+ A917              Word_Else:
1153+ A917 24 A3 C7 A1                  dw         TIB, FETCH           //      tib @
1154+ A91B              Word_Endif:                                     // endif
1155+ A91B 66 A3 C7 A1                  dw      TO_IN, FETCH, PLUS      // >in @ +
1155+ A91F E3 A0
1156+ A921 62 A1 67 9D                  dw      SWAP, ENCLOSE           // swap enclose
1157+ A925 E4 A3 E1 9B                  dw      HERE, LIT, 34, BLANK    // here 34 blank
1157+ A929 22 00 D5 A8
1158+ A92D 66 A3 AF A1                  dw      TO_IN, PLUSSTORE        // >in @ +
1159+ A931 45 A1 23 A4                  dw      OVER, SUBTRACT, TO_R    // over - >r
1159+ A935 9A A0
1160+ A937 B0 A0 E4 A3                  dw      R_OP, HERE, CSTORE      // r here c!
1160+ A93B E5 A1
1161+ A93D E3 A0                        dw      PLUS                    // +
1162+ A93F E4 A3 FC A0                  dw      HERE, ONE_PLUS, R_TO    // here 1+ r>
1162+ A943 A5 A0
1163+ A945 CB 9F                        dw      CMOVE                   // cmove
1164+ A947 E4 A3                        dw      HERE                    // here
1165+ A949 90 A0                        dw      EXIT                    // ;
1166+ A94B
1167+ A94B              //  ______________________________________________________________________
1168+ A94B              //
1169+ A94B              // (.")         --
1170+ A94B              // Direct procedure compiled by ." and  .(  It executes TYPE.
1171+ A94B                              Colon_Def C_DOT_QUOTE, '(.")', is_normal
1171+ A94B             >                New_Def  C_DOT_QUOTE, '(.")', Enter_Ptr, is_normal ; ok
1171+ A94B             >
1171+ A94B             >Dict_Ptr        defl    $
1171+ A94B             >
1171+ A94B             >//              ______________________________________________________________________
1171+ A94B             >//              Heap part
1171+ A94B             >
1171+ A94B             >
1171+ A94B             >                org     (Heap_Ptr & $1FFF) + $E000
1171+ E7A5             >
1171+ E7A5             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1171+ E7A5             >Latest_Definition defl  Heap_Ptr
1171+ E7A5             >
1171+ E7A5             >                // dummy db directives used to calculate length of namec
1171+ E7A5 28 2E 22 29 >                db      '(.")'
1171+ E7A9             >len_NFA         defl    $ - temp_NFA
1171+ E7A9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1171+ E7A5             >
1171+ E7A5 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1171+ E7A6 28 2E 22 29 >                db      '(.")'               // name string in 7-bit ascii, but
1171+ E7AA             >                org     $-1                 // alter last byte of Name just above to set
1171+ E7A9 A9          >                db      {b $} | END_BIT     // msb as name end
1171+ E7AA             >
1171+ E7AA 9C 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1171+ E7AC             >Prev_Ptr        defl    Heap_Ptr
1171+ E7AC             >
1171+ E7AC             >mirror_Ptr      defl    $
1171+ E7AC             >
1171+ E7AC 4D A9       >                dw      Dict_Ptr + 2        // xt
1171+ E7AE             >Heap_Ptr        defl    $ - $E000           // save current HP
1171+ E7AE             >
1171+ E7AE             >Current_HP      defl  $ - $E000             // used to set HP once!
1171+ E7AE             >
1171+ E7AE             >//              ______________________________________________________________________
1171+ E7AE             >//              Dictionary part
1171+ E7AE             >
1171+ E7AE             >                org     Dict_Ptr
1171+ A94B             >
1171+ A94B AC 27       >                dw      mirror_Ptr - $E000 + Heap_offset
1171+ A94D             >
1171+ A94D             >C_DOT_QUOTE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1171+ A94D CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1171+ A950             >
1171+ A950             >
1171+ A950             >                endif           ; ok        // for other definitions it "points" the correct handler
1171+ A950             >                // Use of "; ok" to suppress "warning[fwdref]"
1171+ A950             >
1171+ A950             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1172+ A950 B0 A0 5C A7                  dw      R_OP, COUNT             // r count
1173+ A954 69 A1 FC A0                  dw      DUP, ONE_PLUS           // dup 1+
1174+ A958 A5 A0 E3 A0                  dw      R_TO, PLUS, TO_R        // r> + >r  ( advance IP )
1174+ A95C 9A A0
1175+ A95E B0 A7                        dw      TYPE                    // type
1176+ A960 90 A0                        dw      EXIT                    // ;
1177+ A962
1178+ A962              //  ______________________________________________________________________
1179+ A962              //
1180+ A962              // char         -- c
1181+ A962              // get first character from next input word
1182+ A962                              Colon_Def CHAR,  "CHAR", is_normal
1182+ A962             >                New_Def  CHAR, "CHAR", Enter_Ptr, is_normal ; ok
1182+ A962             >
1182+ A962             >Dict_Ptr        defl    $
1182+ A962             >
1182+ A962             >//              ______________________________________________________________________
1182+ A962             >//              Heap part
1182+ A962             >
1182+ A962             >
1182+ A962             >                org     (Heap_Ptr & $1FFF) + $E000
1182+ E7AE             >
1182+ E7AE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1182+ E7AE             >Latest_Definition defl  Heap_Ptr
1182+ E7AE             >
1182+ E7AE             >                // dummy db directives used to calculate length of namec
1182+ E7AE 43 48 41 52 >                db      "CHAR"
1182+ E7B2             >len_NFA         defl    $ - temp_NFA
1182+ E7B2             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1182+ E7AE             >
1182+ E7AE 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1182+ E7AF 43 48 41 52 >                db      "CHAR"               // name string in 7-bit ascii, but
1182+ E7B3             >                org     $-1                 // alter last byte of Name just above to set
1182+ E7B2 D2          >                db      {b $} | END_BIT     // msb as name end
1182+ E7B3             >
1182+ E7B3 A5 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1182+ E7B5             >Prev_Ptr        defl    Heap_Ptr
1182+ E7B5             >
1182+ E7B5             >mirror_Ptr      defl    $
1182+ E7B5             >
1182+ E7B5 64 A9       >                dw      Dict_Ptr + 2        // xt
1182+ E7B7             >Heap_Ptr        defl    $ - $E000           // save current HP
1182+ E7B7             >
1182+ E7B7             >Current_HP      defl  $ - $E000             // used to set HP once!
1182+ E7B7             >
1182+ E7B7             >//              ______________________________________________________________________
1182+ E7B7             >//              Dictionary part
1182+ E7B7             >
1182+ E7B7             >                org     Dict_Ptr
1182+ A962             >
1182+ A962 B5 27       >                dw      mirror_Ptr - $E000 + Heap_offset
1182+ A964             >
1182+ A964             >CHAR:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1182+ A964 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1182+ A967             >
1182+ A967             >
1182+ A967             >                endif           ; ok        // for other definitions it "points" the correct handler
1182+ A967             >                // Use of "; ok" to suppress "warning[fwdref]"
1182+ A967             >
1182+ A967             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1183+ A967 E2 A2 02 A9                  dw      BL, WORD                // bl word
1184+ A96B FC A0 DC A1                  dw      ONE_PLUS, CFETCH        // 1+ c@
1185+ A96F 90 A0                        dw      EXIT                    // ;
1186+ A971
1187+ A971              //  ______________________________________________________________________
1188+ A971              //
1189+ A971              // ,"           --
1190+ A971              // compiles a string terminated by " as a counted string from next input stream
1191+ A971                              Colon_Def COMMA_QUOTE,  ',"', is_normal
1191+ A971             >                New_Def  COMMA_QUOTE, ',"', Enter_Ptr, is_normal ; ok
1191+ A971             >
1191+ A971             >Dict_Ptr        defl    $
1191+ A971             >
1191+ A971             >//              ______________________________________________________________________
1191+ A971             >//              Heap part
1191+ A971             >
1191+ A971             >
1191+ A971             >                org     (Heap_Ptr & $1FFF) + $E000
1191+ E7B7             >
1191+ E7B7             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1191+ E7B7             >Latest_Definition defl  Heap_Ptr
1191+ E7B7             >
1191+ E7B7             >                // dummy db directives used to calculate length of namec
1191+ E7B7 2C 22       >                db      ',"'
1191+ E7B9             >len_NFA         defl    $ - temp_NFA
1191+ E7B9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1191+ E7B7             >
1191+ E7B7 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1191+ E7B8 2C 22       >                db      ',"'               // name string in 7-bit ascii, but
1191+ E7BA             >                org     $-1                 // alter last byte of Name just above to set
1191+ E7B9 A2          >                db      {b $} | END_BIT     // msb as name end
1191+ E7BA             >
1191+ E7BA AE 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1191+ E7BC             >Prev_Ptr        defl    Heap_Ptr
1191+ E7BC             >
1191+ E7BC             >mirror_Ptr      defl    $
1191+ E7BC             >
1191+ E7BC 73 A9       >                dw      Dict_Ptr + 2        // xt
1191+ E7BE             >Heap_Ptr        defl    $ - $E000           // save current HP
1191+ E7BE             >
1191+ E7BE             >Current_HP      defl  $ - $E000             // used to set HP once!
1191+ E7BE             >
1191+ E7BE             >//              ______________________________________________________________________
1191+ E7BE             >//              Dictionary part
1191+ E7BE             >
1191+ E7BE             >                org     Dict_Ptr
1191+ A971             >
1191+ A971 BC 27       >                dw      mirror_Ptr - $E000 + Heap_offset
1191+ A973             >
1191+ A973             >COMMA_QUOTE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1191+ A973 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1191+ A976             >
1191+ A976             >
1191+ A976             >                endif           ; ok        // for other definitions it "points" the correct handler
1191+ A976             >                // Use of "; ok" to suppress "warning[fwdref]"
1191+ A976             >
1191+ A976             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1192+ A976 E1 9B 22 00                  dw      LIT, DQUOTE_CHAR        // [char] "
1193+ A97A 02 A9                        dw      WORD                    // word
1194+ A97C DC A1 FC A0                  dw      CFETCH, ONE_PLUS        // c@ 1+
1195+ A980 EF A3                        dw      ALLOT                   // allot
1196+ A982 BF A2 09 A4                  dw      ZERO, CCOMMA            // 0 c,  ( nul-terminated string - useful anyway )
1197+ A986 90 A0                        dw      EXIT
1198+ A988
1199+ A988              //  ______________________________________________________________________
1200+ A988              //
1201+ A988              // .c           c --
1202+ A988              // intermediate general purpose string builder, used by ." and .(
1203+ A988                              Colon_Def DOT_C,  ".C", is_immediate
1203+ A988             >                New_Def  DOT_C, ".C", Enter_Ptr, is_immediate ; ok
1203+ A988             >
1203+ A988             >Dict_Ptr        defl    $
1203+ A988             >
1203+ A988             >//              ______________________________________________________________________
1203+ A988             >//              Heap part
1203+ A988             >
1203+ A988             >
1203+ A988             >                org     (Heap_Ptr & $1FFF) + $E000
1203+ E7BE             >
1203+ E7BE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1203+ E7BE             >Latest_Definition defl  Heap_Ptr
1203+ E7BE             >
1203+ E7BE             >                // dummy db directives used to calculate length of namec
1203+ E7BE 2E 43       >                db      ".C"
1203+ E7C0             >len_NFA         defl    $ - temp_NFA
1203+ E7C0             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1203+ E7BE             >
1203+ E7BE C2          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
1203+ E7BF 2E 43       >                db      ".C"               // name string in 7-bit ascii, but
1203+ E7C1             >                org     $-1                 // alter last byte of Name just above to set
1203+ E7C0 C3          >                db      {b $} | END_BIT     // msb as name end
1203+ E7C1             >
1203+ E7C1 B7 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1203+ E7C3             >Prev_Ptr        defl    Heap_Ptr
1203+ E7C3             >
1203+ E7C3             >mirror_Ptr      defl    $
1203+ E7C3             >
1203+ E7C3 8A A9       >                dw      Dict_Ptr + 2        // xt
1203+ E7C5             >Heap_Ptr        defl    $ - $E000           // save current HP
1203+ E7C5             >
1203+ E7C5             >Current_HP      defl  $ - $E000             // used to set HP once!
1203+ E7C5             >
1203+ E7C5             >//              ______________________________________________________________________
1203+ E7C5             >//              Dictionary part
1203+ E7C5             >
1203+ E7C5             >                org     Dict_Ptr
1203+ A988             >
1203+ A988 C3 27       >                dw      mirror_Ptr - $E000 + Heap_offset
1203+ A98A             >
1203+ A98A             >DOT_C:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1203+ A98A CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1203+ A98D             >
1203+ A98D             >
1203+ A98D             >                endif           ; ok        // for other definitions it "points" the correct handler
1203+ A98D             >                // Use of "; ok" to suppress "warning[fwdref]"
1203+ A98D             >
1203+ A98D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1204+ A98D 8A A3 C7 A1                  dw      STATE, FETCH            // state @
1205+ A991                                                              // if
1206+ A991 33 9C                        dw      ZBRANCH
1207+ A993 12 00                        dw      Dot_C_Else - $
1208+ A995 90 A6 4D A9                  dw          COMPILE, C_DOT_QUOTE //     compile (.")
1209+ A999 02 A9 DC A1                  dw          WORD, CFETCH        //      word c@
1210+ A99D FC A0 EF A3                  dw          ONE_PLUS, ALLOT     //      1+ allot
1211+ A9A1                                                              // else
1212+ A9A1 26 9C                        dw      BRANCH
1213+ A9A3 08 00                        dw      Dot_C_Endif - $
1214+ A9A5              Dot_C_Else:
1215+ A9A5 02 A9 5C A7                  dw          WORD, COUNT, TYPE   //      word count type
1215+ A9A9 B0 A7
1216+ A9AB              Dot_C_Endif:                                    // endif
1217+ A9AB 90 A0                        dw      EXIT                    ;
1218+ A9AD
1219+ A9AD              //  ______________________________________________________________________
1220+ A9AD              //
1221+ A9AD              // ."           c --
1222+ A9AD                              Colon_Def DOT_QUOTE,  '."', is_immediate
1222+ A9AD             >                New_Def  DOT_QUOTE, '."', Enter_Ptr, is_immediate ; ok
1222+ A9AD             >
1222+ A9AD             >Dict_Ptr        defl    $
1222+ A9AD             >
1222+ A9AD             >//              ______________________________________________________________________
1222+ A9AD             >//              Heap part
1222+ A9AD             >
1222+ A9AD             >
1222+ A9AD             >                org     (Heap_Ptr & $1FFF) + $E000
1222+ E7C5             >
1222+ E7C5             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1222+ E7C5             >Latest_Definition defl  Heap_Ptr
1222+ E7C5             >
1222+ E7C5             >                // dummy db directives used to calculate length of namec
1222+ E7C5 2E 22       >                db      '."'
1222+ E7C7             >len_NFA         defl    $ - temp_NFA
1222+ E7C7             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1222+ E7C5             >
1222+ E7C5 C2          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
1222+ E7C6 2E 22       >                db      '."'               // name string in 7-bit ascii, but
1222+ E7C8             >                org     $-1                 // alter last byte of Name just above to set
1222+ E7C7 A2          >                db      {b $} | END_BIT     // msb as name end
1222+ E7C8             >
1222+ E7C8 BE 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1222+ E7CA             >Prev_Ptr        defl    Heap_Ptr
1222+ E7CA             >
1222+ E7CA             >mirror_Ptr      defl    $
1222+ E7CA             >
1222+ E7CA AF A9       >                dw      Dict_Ptr + 2        // xt
1222+ E7CC             >Heap_Ptr        defl    $ - $E000           // save current HP
1222+ E7CC             >
1222+ E7CC             >Current_HP      defl  $ - $E000             // used to set HP once!
1222+ E7CC             >
1222+ E7CC             >//              ______________________________________________________________________
1222+ E7CC             >//              Dictionary part
1222+ E7CC             >
1222+ E7CC             >                org     Dict_Ptr
1222+ A9AD             >
1222+ A9AD CA 27       >                dw      mirror_Ptr - $E000 + Heap_offset
1222+ A9AF             >
1222+ A9AF             >DOT_QUOTE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1222+ A9AF CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1222+ A9B2             >
1222+ A9B2             >
1222+ A9B2             >                endif           ; ok        // for other definitions it "points" the correct handler
1222+ A9B2             >                // Use of "; ok" to suppress "warning[fwdref]"
1222+ A9B2             >
1222+ A9B2             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1223+ A9B2 E1 9B 22 00                  dw      LIT, DQUOTE_CHAR        // [char] "
1224+ A9B6 8A A9                        dw      DOT_C                   // [compile] .c
1225+ A9B8 90 A0                        dw      EXIT                    // ; immediate
1226+ A9BA
1227+ A9BA              //  ______________________________________________________________________
1228+ A9BA              //
1229+ A9BA              // .(           c --
1230+ A9BA                              Colon_Def DOT_BRACKET,  ".(", is_immediate
1230+ A9BA             >                New_Def  DOT_BRACKET, ".(", Enter_Ptr, is_immediate ; ok
1230+ A9BA             >
1230+ A9BA             >Dict_Ptr        defl    $
1230+ A9BA             >
1230+ A9BA             >//              ______________________________________________________________________
1230+ A9BA             >//              Heap part
1230+ A9BA             >
1230+ A9BA             >
1230+ A9BA             >                org     (Heap_Ptr & $1FFF) + $E000
1230+ E7CC             >
1230+ E7CC             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1230+ E7CC             >Latest_Definition defl  Heap_Ptr
1230+ E7CC             >
1230+ E7CC             >                // dummy db directives used to calculate length of namec
1230+ E7CC 2E 28       >                db      ".("
1230+ E7CE             >len_NFA         defl    $ - temp_NFA
1230+ E7CE             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1230+ E7CC             >
1230+ E7CC C2          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
1230+ E7CD 2E 28       >                db      ".("               // name string in 7-bit ascii, but
1230+ E7CF             >                org     $-1                 // alter last byte of Name just above to set
1230+ E7CE A8          >                db      {b $} | END_BIT     // msb as name end
1230+ E7CF             >
1230+ E7CF C5 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1230+ E7D1             >Prev_Ptr        defl    Heap_Ptr
1230+ E7D1             >
1230+ E7D1             >mirror_Ptr      defl    $
1230+ E7D1             >
1230+ E7D1 BC A9       >                dw      Dict_Ptr + 2        // xt
1230+ E7D3             >Heap_Ptr        defl    $ - $E000           // save current HP
1230+ E7D3             >
1230+ E7D3             >Current_HP      defl  $ - $E000             // used to set HP once!
1230+ E7D3             >
1230+ E7D3             >//              ______________________________________________________________________
1230+ E7D3             >//              Dictionary part
1230+ E7D3             >
1230+ E7D3             >                org     Dict_Ptr
1230+ A9BA             >
1230+ A9BA D1 27       >                dw      mirror_Ptr - $E000 + Heap_offset
1230+ A9BC             >
1230+ A9BC             >DOT_BRACKET:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1230+ A9BC CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1230+ A9BF             >
1230+ A9BF             >
1230+ A9BF             >                endif           ; ok        // for other definitions it "points" the correct handler
1230+ A9BF             >                // Use of "; ok" to suppress "warning[fwdref]"
1230+ A9BF             >
1230+ A9BF             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1231+ A9BF E1 9B 29 00                  dw      LIT, ")"                // [char] )
1232+ A9C3 8A A9                        dw      DOT_C                   // [compile] .c
1233+ A9C5 90 A0                        dw      EXIT                    // ; immediate
1234+ A9C7
1235+ A9C7              //  ______________________________________________________________________
1236+ A9C7              //
1237+ A9C7              // (sgn)        a -- a f
1238+ A9C7              // determines if char in addr a is a sign (+ or -), and in that case increments
1239+ A9C7              // a flag. Returns f as the sign, true for negative, false for positive.
1240+ A9C7              // called by NUMBER and (EXP)
1241+ A9C7                              Colon_Def CSGN,  "(SGN)", is_normal
1241+ A9C7             >                New_Def  CSGN, "(SGN)", Enter_Ptr, is_normal ; ok
1241+ A9C7             >
1241+ A9C7             >Dict_Ptr        defl    $
1241+ A9C7             >
1241+ A9C7             >//              ______________________________________________________________________
1241+ A9C7             >//              Heap part
1241+ A9C7             >
1241+ A9C7             >
1241+ A9C7             >                org     (Heap_Ptr & $1FFF) + $E000
1241+ E7D3             >
1241+ E7D3             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1241+ E7D3             >Latest_Definition defl  Heap_Ptr
1241+ E7D3             >
1241+ E7D3             >                // dummy db directives used to calculate length of namec
1241+ E7D3 28 53 47 4E >                db      "(SGN)"
1241+ E7D7 29          >
1241+ E7D8             >len_NFA         defl    $ - temp_NFA
1241+ E7D8             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1241+ E7D3             >
1241+ E7D3 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1241+ E7D4 28 53 47 4E >                db      "(SGN)"               // name string in 7-bit ascii, but
1241+ E7D8 29          >
1241+ E7D9             >                org     $-1                 // alter last byte of Name just above to set
1241+ E7D8 A9          >                db      {b $} | END_BIT     // msb as name end
1241+ E7D9             >
1241+ E7D9 CC 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1241+ E7DB             >Prev_Ptr        defl    Heap_Ptr
1241+ E7DB             >
1241+ E7DB             >mirror_Ptr      defl    $
1241+ E7DB             >
1241+ E7DB C9 A9       >                dw      Dict_Ptr + 2        // xt
1241+ E7DD             >Heap_Ptr        defl    $ - $E000           // save current HP
1241+ E7DD             >
1241+ E7DD             >Current_HP      defl  $ - $E000             // used to set HP once!
1241+ E7DD             >
1241+ E7DD             >//              ______________________________________________________________________
1241+ E7DD             >//              Dictionary part
1241+ E7DD             >
1241+ E7DD             >                org     Dict_Ptr
1241+ A9C7             >
1241+ A9C7 DB 27       >                dw      mirror_Ptr - $E000 + Heap_offset
1241+ A9C9             >
1241+ A9C9             >CSGN:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1241+ A9C9 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1241+ A9CC             >
1241+ A9CC             >
1241+ A9CC             >                endif           ; ok        // for other definitions it "points" the correct handler
1241+ A9CC             >                // Use of "; ok" to suppress "warning[fwdref]"
1241+ A9CC             >
1241+ A9CC             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1242+ A9CC 69 A1 FC A0                  dw      DUP, ONE_PLUS, CFETCH   // dup 1+ c@
1242+ A9D0 DC A1
1243+ A9D2 69 A1 E1 9B                  dw      DUP, LIT, "-", EQUALS   // dup [char] - =
1243+ A9D6 2D 00 2F A4
1244+ A9DA                                                              // if
1245+ A9DA 33 9C                        dw      ZBRANCH
1246+ A9DC 12 00                        dw      CSgn_Else_0 - $
1247+ A9DE 4E A1                        dw          DROP                //      drop
1248+ A9E0 FC A0                        dw          ONE_PLUS            //      1+
1249+ A9E2 C6 A2 96 A3                  dw          ONE, DPL, PLUSSTORE //      1 dpl +!
1249+ A9E6 AF A1
1250+ A9E8 C6 A2                        dw          ONE                 //      1
1251+ A9EA                                                              // else
1252+ A9EA 26 9C                        dw      BRANCH
1253+ A9EC 16 00                        dw      CSgn_Endif_0 - $
1254+ A9EE              CSgn_Else_0:
1255+ A9EE E1 9B 2B 00                  dw          LIT, "+", EQUALS    //      [char] + =
1255+ A9F2 2F A4
1256+ A9F4                                                              //      if
1257+ A9F4 33 9C                        dw          ZBRANCH
1258+ A9F6 0A 00                        dw          CSgn_Endif_1 - $
1259+ A9F8 FC A0                        dw              ONE_PLUS        //          1+
1260+ A9FA C6 A2 96 A3                  dw              ONE, DPL        //          1 dpl
1261+ A9FE AF A1                        dw              PLUSSTORE       //          +!
1262+ AA00              CSgn_Endif_1                                    //      endif
1263+ AA00 BF A2                        dw          ZERO                //      0
1264+ AA02              CSgn_Endif_0:                                   // endif
1265+ AA02 90 A0                        dw      EXIT
1266+ AA04
1267+ AA04              //  ______________________________________________________________________
1268+ AA04              //
1269+ AA04              // (number)     d a -- d1 a1
1270+ AA04              // using the current BASE parse characters stored in address a
1271+ AA04              // accumulating a double precision integer d
1272+ AA04              // the process stops at the first not-convertible character
1273+ AA04              // A double-number is kept in CPU registers as HLDE.
1274+ AA04              // On the stack a double number is treated as two single numbers
1275+ AA04              // where HL is on the top of the stack and DE is the second from top,
1276+ AA04              // so in the stack memory it appears as LHED.
1277+ AA04              // Instead, in 2VARIABLE a double number is stored as EDLH.
1278+ AA04                              Colon_Def CNUMBER,  "(NUMBER)", is_normal
1278+ AA04             >                New_Def  CNUMBER, "(NUMBER)", Enter_Ptr, is_normal ; ok
1278+ AA04             >
1278+ AA04             >Dict_Ptr        defl    $
1278+ AA04             >
1278+ AA04             >//              ______________________________________________________________________
1278+ AA04             >//              Heap part
1278+ AA04             >
1278+ AA04             >
1278+ AA04             >                org     (Heap_Ptr & $1FFF) + $E000
1278+ E7DD             >
1278+ E7DD             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1278+ E7DD             >Latest_Definition defl  Heap_Ptr
1278+ E7DD             >
1278+ E7DD             >                // dummy db directives used to calculate length of namec
1278+ E7DD 28 4E 55 4D >                db      "(NUMBER)"
1278+ E7E1 42 45 52 29 >
1278+ E7E5             >len_NFA         defl    $ - temp_NFA
1278+ E7E5             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1278+ E7DD             >
1278+ E7DD 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1278+ E7DE 28 4E 55 4D >                db      "(NUMBER)"               // name string in 7-bit ascii, but
1278+ E7E2 42 45 52 29 >
1278+ E7E6             >                org     $-1                 // alter last byte of Name just above to set
1278+ E7E5 A9          >                db      {b $} | END_BIT     // msb as name end
1278+ E7E6             >
1278+ E7E6 D3 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1278+ E7E8             >Prev_Ptr        defl    Heap_Ptr
1278+ E7E8             >
1278+ E7E8             >mirror_Ptr      defl    $
1278+ E7E8             >
1278+ E7E8 06 AA       >                dw      Dict_Ptr + 2        // xt
1278+ E7EA             >Heap_Ptr        defl    $ - $E000           // save current HP
1278+ E7EA             >
1278+ E7EA             >Current_HP      defl  $ - $E000             // used to set HP once!
1278+ E7EA             >
1278+ E7EA             >//              ______________________________________________________________________
1278+ E7EA             >//              Dictionary part
1278+ E7EA             >
1278+ E7EA             >                org     Dict_Ptr
1278+ AA04             >
1278+ AA04 E8 27       >                dw      mirror_Ptr - $E000 + Heap_offset
1278+ AA06             >
1278+ AA06             >CNUMBER:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1278+ AA06 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1278+ AA09             >
1278+ AA09             >
1278+ AA09             >                endif           ; ok        // for other definitions it "points" the correct handler
1278+ AA09             >                // Use of "; ok" to suppress "warning[fwdref]"
1278+ AA09             >
1278+ AA09             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1279+ AA09                                                              // begin
1280+ AA09              CNumber_Begin:
1281+ AA09 FC A0                        dw          ONE_PLUS            //      1+
1282+ AA0B 69 A1 9A A0                  dw          DUP, TO_R           //      dup >r
1283+ AA0F DC A1                        dw          CFETCH              //      @
1284+ AA11 90 A3 C7 A1                  dw          BASE, FETCH         //      base @
1285+ AA15 8B 9C                        dw          DIGIT               //      digit
1286+ AA17                                                              // while
1287+ AA17 33 9C                        dw      ZBRANCH
1288+ AA19 2C 00                        dw      CNumber_While_end - $
1289+ AA1B 62 A1                        dw          SWAP                //      swap
1290+ AA1D 90 A3 C7 A1                  dw          BASE, FETCH         //      base @
1291+ AA21 EF 9F                        dw          UM_MUL              //      um*
1292+ AA23 4E A1 70 A1                  dw          DROP, ROT           //      drop rot
1293+ AA27 90 A3 C7 A1                  dw          BASE, FETCH         //      base @
1294+ AA2B EF 9F                        dw          UM_MUL              //      um*
1295+ AA2D ED A0                        dw          DPLUS               //      d+
1296+ AA2F 96 A3 C7 A1                  dw          DPL, FETCH          //      dpl @
1297+ AA33 FC A0                        dw          ONE_PLUS            //      1+
1298+ AA35                                                              //      if
1299+ AA35 33 9C                        dw          ZBRANCH
1300+ AA37 08 00                        dw          CNumber_Endif - $
1301+ AA39 C6 A2 96 A3                  dw              ONE, DPL        //          1 dpl
1302+ AA3D AF A1                        dw              PLUSSTORE       //          +!
1303+ AA3F              CNumber_Endif:                                  //      endif
1304+ AA3F A5 A0                        dw             R_TO             //      r>  ( balance rp )
1305+ AA41 26 9C                        dw      BRANCH
1306+ AA43 C6 FF                        dw      CNumber_Begin - $
1307+ AA45              CNumber_While_end:                              // repeat
1308+ AA45 A5 A0                        dw      R_TO                    // r>  ( balance rp on exit while-repeat )
1309+ AA47 90 A0                        dw      EXIT                    // ;
1310+ AA49
1311+ AA49              //  ______________________________________________________________________
1312+ AA49              //
1313+ AA49              // (prefix)
1314+ AA49                              Colon_Def CPREFIX,  "(PREFIX)", is_normal
1314+ AA49             >                New_Def  CPREFIX, "(PREFIX)", Enter_Ptr, is_normal ; ok
1314+ AA49             >
1314+ AA49             >Dict_Ptr        defl    $
1314+ AA49             >
1314+ AA49             >//              ______________________________________________________________________
1314+ AA49             >//              Heap part
1314+ AA49             >
1314+ AA49             >
1314+ AA49             >                org     (Heap_Ptr & $1FFF) + $E000
1314+ E7EA             >
1314+ E7EA             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1314+ E7EA             >Latest_Definition defl  Heap_Ptr
1314+ E7EA             >
1314+ E7EA             >                // dummy db directives used to calculate length of namec
1314+ E7EA 28 50 52 45 >                db      "(PREFIX)"
1314+ E7EE 46 49 58 29 >
1314+ E7F2             >len_NFA         defl    $ - temp_NFA
1314+ E7F2             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1314+ E7EA             >
1314+ E7EA 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1314+ E7EB 28 50 52 45 >                db      "(PREFIX)"               // name string in 7-bit ascii, but
1314+ E7EF 46 49 58 29 >
1314+ E7F3             >                org     $-1                 // alter last byte of Name just above to set
1314+ E7F2 A9          >                db      {b $} | END_BIT     // msb as name end
1314+ E7F3             >
1314+ E7F3 DD 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1314+ E7F5             >Prev_Ptr        defl    Heap_Ptr
1314+ E7F5             >
1314+ E7F5             >mirror_Ptr      defl    $
1314+ E7F5             >
1314+ E7F5 4B AA       >                dw      Dict_Ptr + 2        // xt
1314+ E7F7             >Heap_Ptr        defl    $ - $E000           // save current HP
1314+ E7F7             >
1314+ E7F7             >Current_HP      defl  $ - $E000             // used to set HP once!
1314+ E7F7             >
1314+ E7F7             >//              ______________________________________________________________________
1314+ E7F7             >//              Dictionary part
1314+ E7F7             >
1314+ E7F7             >                org     Dict_Ptr
1314+ AA49             >
1314+ AA49 F5 27       >                dw      mirror_Ptr - $E000 + Heap_offset
1314+ AA4B             >
1314+ AA4B             >CPREFIX:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1314+ AA4B CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1314+ AA4E             >
1314+ AA4E             >
1314+ AA4E             >                endif           ; ok        // for other definitions it "points" the correct handler
1314+ AA4E             >                // Use of "; ok" to suppress "warning[fwdref]"
1314+ AA4E             >
1314+ AA4E             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1315+ AA4E 69 A1 FC A0                  dw      DUP, ONE_PLUS, CFETCH   // dup 1+ c@
1315+ AA52 DC A1
1316+ AA54 69 A1 9A A0                  dw      DUP, TO_R               // dup >r
1317+ AA58 E1 9B 24 00                  dw      LIT, "$", EQUALS        // [char] $ =
1317+ AA5C 2F A4
1318+ AA5E                                                              // if
1319+ AA5E 33 9C                        dw      ZBRANCH
1320+ AA60 0C 00                        dw      CPrefix_Endif_0 - $
1321+ AA62 FC A0                        dw          ONE_PLUS            //      1+
1322+ AA64 E1 9B 10 00                  dw          LIT, 16
1323+ AA68 90 A3 D1 A1                  dw          BASE, STORE         //      16 base !
1324+ AA6C              CPrefix_Endif_0:                                // endif
1325+ AA6C A5 A0                        dw      R_TO                    // r>
1326+ AA6E E1 9B 25 00                  dw      LIT, "%", EQUALS        // [char] $ =
1326+ AA72 2F A4
1327+ AA74                                                              // if
1328+ AA74 33 9C                        dw      ZBRANCH
1329+ AA76 0A 00                        dw      CPrefix_Endif_1 - $
1330+ AA78 FC A0                        dw          ONE_PLUS            //      1+
1331+ AA7A CD A2                        dw          TWO
1332+ AA7C 90 A3 D1 A1                  dw          BASE, STORE         //      2 base !
1333+ AA80              CPrefix_Endif_1:                                // endif
1334+ AA80 90 A0                        dw      EXIT
1335+ AA82
1336+ AA82              //  ______________________________________________________________________
1337+ AA82              //
1338+ AA82              // number       a -- d
1339+ AA82                              Colon_Def NUMBER,  "NUMBER", is_normal
1339+ AA82             >                New_Def  NUMBER, "NUMBER", Enter_Ptr, is_normal ; ok
1339+ AA82             >
1339+ AA82             >Dict_Ptr        defl    $
1339+ AA82             >
1339+ AA82             >//              ______________________________________________________________________
1339+ AA82             >//              Heap part
1339+ AA82             >
1339+ AA82             >
1339+ AA82             >                org     (Heap_Ptr & $1FFF) + $E000
1339+ E7F7             >
1339+ E7F7             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1339+ E7F7             >Latest_Definition defl  Heap_Ptr
1339+ E7F7             >
1339+ E7F7             >                // dummy db directives used to calculate length of namec
1339+ E7F7 4E 55 4D 42 >                db      "NUMBER"
1339+ E7FB 45 52       >
1339+ E7FD             >len_NFA         defl    $ - temp_NFA
1339+ E7FD             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1339+ E7F7             >
1339+ E7F7 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1339+ E7F8 4E 55 4D 42 >                db      "NUMBER"               // name string in 7-bit ascii, but
1339+ E7FC 45 52       >
1339+ E7FE             >                org     $-1                 // alter last byte of Name just above to set
1339+ E7FD D2          >                db      {b $} | END_BIT     // msb as name end
1339+ E7FE             >
1339+ E7FE EA 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1339+ E800             >Prev_Ptr        defl    Heap_Ptr
1339+ E800             >
1339+ E800             >mirror_Ptr      defl    $
1339+ E800             >
1339+ E800 84 AA       >                dw      Dict_Ptr + 2        // xt
1339+ E802             >Heap_Ptr        defl    $ - $E000           // save current HP
1339+ E802             >
1339+ E802             >Current_HP      defl  $ - $E000             // used to set HP once!
1339+ E802             >
1339+ E802             >//              ______________________________________________________________________
1339+ E802             >//              Dictionary part
1339+ E802             >
1339+ E802             >                org     Dict_Ptr
1339+ AA82             >
1339+ AA82 00 28       >                dw      mirror_Ptr - $E000 + Heap_offset
1339+ AA84             >
1339+ AA84             >NUMBER:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1339+ AA84 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1339+ AA87             >
1339+ AA87             >
1339+ AA87             >                endif           ; ok        // for other definitions it "points" the correct handler
1339+ AA87             >                // Use of "; ok" to suppress "warning[fwdref]"
1339+ AA87             >
1339+ AA87             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1340+ AA87 BF A2 BF A2                  dw      ZERO, ZERO              // 0 0
1341+ AA8B 70 A1                        dw      ROT                     // rot
1342+ AA8D C9 A9 9A A0                  dw      CSGN, TO_R              // (sgn) >r
1343+ AA91 DB A2 96 A3                  dw      NEG_ONE, DPL, STORE     // -1 dpl !
1343+ AA95 D1 A1
1344+ AA97 90 A3 C7 A1                  dw      BASE, FETCH, TO_R       // base @ >r  // ***
1344+ AA9B 9A A0
1345+ AA9D 4B AA                        dw      CPREFIX                 // (prefix)   // ***
1346+ AA9F 06 AA                        dw      CNUMBER                 // (number)
1347+ AAA1 69 A1 DC A1                  dw      DUP, CFETCH             // dup c@
1348+ AAA5 E1 9B 2E 00                  dw      LIT, ".", EQUALS        // [char] . =  ( decimal point )
1348+ AAA9 2F A4
1349+ AAAB                                                              // if
1350+ AAAB 33 9C                        dw      ZBRANCH
1351+ AAAD 0A 00                        dw      Number_Endif_1 - $
1352+ AAAF BF A2 96 A3                  dw          ZERO, DPL, STORE    //      0 dpl !
1352+ AAB3 D1 A1
1353+ AAB5 06 AA                        dw          CNUMBER             //      (number)
1354+ AAB7              Number_Endif_1:                                 // endif
1355+ AAB7 DC A1 E2 A2                  dw      CFETCH, BL              // c@ bl
1356+ AABB 23 A4 BF A2                  dw      SUBTRACT, ZERO, QERROR  // - 0 ?error
1356+ AABF 20 A6
1357+ AAC1 A5 A0 90 A3                  dw      R_TO, BASE, STORE       // r> base !  // ***
1357+ AAC5 D1 A1
1358+ AAC7 A5 A0                        dw      R_TO                    // r>
1359+ AAC9                                                              // if
1360+ AAC9 33 9C                        dw      ZBRANCH
1361+ AACB 04 00                        dw      Number_Endif_2 - $
1362+ AACD 32 A1                        dw          DMINUS              //      dminus
1363+ AACF              Number_Endif_2:                                 // endif
1364+ AACF 90 A0                        dw      EXIT                    // ;
1365+ AAD1
1366+ AAD1              //  ______________________________________________________________________
1367+ AAD1              //
1368+ AAD1              // twofind      a -- d
1369+ AAD1                              Colon_Def TWOFIND,  "2FIND", is_normal
1369+ AAD1             >                New_Def  TWOFIND, "2FIND", Enter_Ptr, is_normal ; ok
1369+ AAD1             >
1369+ AAD1             >Dict_Ptr        defl    $
1369+ AAD1             >
1369+ AAD1             >//              ______________________________________________________________________
1369+ AAD1             >//              Heap part
1369+ AAD1             >
1369+ AAD1             >
1369+ AAD1             >                org     (Heap_Ptr & $1FFF) + $E000
1369+ E802             >
1369+ E802             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1369+ E802             >Latest_Definition defl  Heap_Ptr
1369+ E802             >
1369+ E802             >                // dummy db directives used to calculate length of namec
1369+ E802 32 46 49 4E >                db      "2FIND"
1369+ E806 44          >
1369+ E807             >len_NFA         defl    $ - temp_NFA
1369+ E807             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1369+ E802             >
1369+ E802 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1369+ E803 32 46 49 4E >                db      "2FIND"               // name string in 7-bit ascii, but
1369+ E807 44          >
1369+ E808             >                org     $-1                 // alter last byte of Name just above to set
1369+ E807 C4          >                db      {b $} | END_BIT     // msb as name end
1369+ E808             >
1369+ E808 F7 27       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1369+ E80A             >Prev_Ptr        defl    Heap_Ptr
1369+ E80A             >
1369+ E80A             >mirror_Ptr      defl    $
1369+ E80A             >
1369+ E80A D3 AA       >                dw      Dict_Ptr + 2        // xt
1369+ E80C             >Heap_Ptr        defl    $ - $E000           // save current HP
1369+ E80C             >
1369+ E80C             >Current_HP      defl  $ - $E000             // used to set HP once!
1369+ E80C             >
1369+ E80C             >//              ______________________________________________________________________
1369+ E80C             >//              Dictionary part
1369+ E80C             >
1369+ E80C             >                org     Dict_Ptr
1369+ AAD1             >
1369+ AAD1 0A 28       >                dw      mirror_Ptr - $E000 + Heap_offset
1369+ AAD3             >
1369+ AAD3             >TWOFIND:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1369+ AAD3 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1369+ AAD6             >
1369+ AAD6             >
1369+ AAD6             >                endif           ; ok        // for other definitions it "points" the correct handler
1369+ AAD6             >                // Use of "; ok" to suppress "warning[fwdref]"
1369+ AAD6             >
1369+ AAD6             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1370+ AAD6 9A A0 B0 A0                  dw      TO_R, R_OP              // >r r@
1371+ AADA 7E A3 C7 A1                  dw      CONTEXT, FETCH, FETCH   // context @ @
1371+ AADE C7 A1
1372+ AAE0 F9 9C                        dw      C_FIND                  // (find)
1373+ AAE2 8E A4                        dw      QDUP                    // ?dup
1374+ AAE4 B5 A0                        dw      ZEQUAL                  // 0=
1375+ AAE6                                                              // if
1376+ AAE6 33 9C                        dw      ZBRANCH
1377+ AAE8 0C 00                        dw      LFind_Endif - $
1378+ AAEA B0 A0                        dw          R_OP                //      r@
1379+ AAEC                              // dw          LATEST               //      latest
1380+ AAEC 84 A3 C7 A1                  dw          CURRENT, FETCH, FETCH   // context @ @
1380+ AAF0 C7 A1
1381+ AAF2 F9 9C                        dw          C_FIND              //      (find)
1382+ AAF4              LFind_Endif:                                    // endif
1383+ AAF4 A5 A0 4E A1                  dw      R_TO, DROP              // r> drop
1384+ AAF8 90 A0                        dw      EXIT                    // ;
1385+ AAFA
1386+ AAFA              //  ______________________________________________________________________
1387+ AAFA              //
1388+ AAFA              // -find        a -- d
1389+ AAFA                              Colon_Def LFIND,  "-FIND", is_normal
1389+ AAFA             >                New_Def  LFIND, "-FIND", Enter_Ptr, is_normal ; ok
1389+ AAFA             >
1389+ AAFA             >Dict_Ptr        defl    $
1389+ AAFA             >
1389+ AAFA             >//              ______________________________________________________________________
1389+ AAFA             >//              Heap part
1389+ AAFA             >
1389+ AAFA             >
1389+ AAFA             >                org     (Heap_Ptr & $1FFF) + $E000
1389+ E80C             >
1389+ E80C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1389+ E80C             >Latest_Definition defl  Heap_Ptr
1389+ E80C             >
1389+ E80C             >                // dummy db directives used to calculate length of namec
1389+ E80C 2D 46 49 4E >                db      "-FIND"
1389+ E810 44          >
1389+ E811             >len_NFA         defl    $ - temp_NFA
1389+ E811             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1389+ E80C             >
1389+ E80C 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1389+ E80D 2D 46 49 4E >                db      "-FIND"               // name string in 7-bit ascii, but
1389+ E811 44          >
1389+ E812             >                org     $-1                 // alter last byte of Name just above to set
1389+ E811 C4          >                db      {b $} | END_BIT     // msb as name end
1389+ E812             >
1389+ E812 02 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1389+ E814             >Prev_Ptr        defl    Heap_Ptr
1389+ E814             >
1389+ E814             >mirror_Ptr      defl    $
1389+ E814             >
1389+ E814 FC AA       >                dw      Dict_Ptr + 2        // xt
1389+ E816             >Heap_Ptr        defl    $ - $E000           // save current HP
1389+ E816             >
1389+ E816             >Current_HP      defl  $ - $E000             // used to set HP once!
1389+ E816             >
1389+ E816             >//              ______________________________________________________________________
1389+ E816             >//              Dictionary part
1389+ E816             >
1389+ E816             >                org     Dict_Ptr
1389+ AAFA             >
1389+ AAFA 14 28       >                dw      mirror_Ptr - $E000 + Heap_offset
1389+ AAFC             >
1389+ AAFC             >LFIND:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1389+ AAFC CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1389+ AAFF             >
1389+ AAFF             >
1389+ AAFF             >                endif           ; ok        // for other definitions it "points" the correct handler
1389+ AAFF             >                // Use of "; ok" to suppress "warning[fwdref]"
1389+ AAFF             >
1389+ AAFF             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1390+ AAFF E2 A2 02 A9                  dw      BL, WORD                // bl word
1391+ AB03 D3 AA                        dw      TWOFIND                 // 2find
1392+ AB05 90 A0                        dw      EXIT                    // ;
1393+ AB07
1394+ AB07              //  ______________________________________________________________________
1395+ AB07              //
1396+ AB07              // (abort)      --
1397+ AB07                              Colon_Def CABORT,  "(ABORT)", is_normal
1397+ AB07             >                New_Def  CABORT, "(ABORT)", Enter_Ptr, is_normal ; ok
1397+ AB07             >
1397+ AB07             >Dict_Ptr        defl    $
1397+ AB07             >
1397+ AB07             >//              ______________________________________________________________________
1397+ AB07             >//              Heap part
1397+ AB07             >
1397+ AB07             >
1397+ AB07             >                org     (Heap_Ptr & $1FFF) + $E000
1397+ E816             >
1397+ E816             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1397+ E816             >Latest_Definition defl  Heap_Ptr
1397+ E816             >
1397+ E816             >                // dummy db directives used to calculate length of namec
1397+ E816 28 41 42 4F >                db      "(ABORT)"
1397+ E81A 52 54 29    >
1397+ E81D             >len_NFA         defl    $ - temp_NFA
1397+ E81D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1397+ E816             >
1397+ E816 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1397+ E817 28 41 42 4F >                db      "(ABORT)"               // name string in 7-bit ascii, but
1397+ E81B 52 54 29    >
1397+ E81E             >                org     $-1                 // alter last byte of Name just above to set
1397+ E81D A9          >                db      {b $} | END_BIT     // msb as name end
1397+ E81E             >
1397+ E81E 0C 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1397+ E820             >Prev_Ptr        defl    Heap_Ptr
1397+ E820             >
1397+ E820             >mirror_Ptr      defl    $
1397+ E820             >
1397+ E820 09 AB       >                dw      Dict_Ptr + 2        // xt
1397+ E822             >Heap_Ptr        defl    $ - $E000           // save current HP
1397+ E822             >
1397+ E822             >Current_HP      defl  $ - $E000             // used to set HP once!
1397+ E822             >
1397+ E822             >//              ______________________________________________________________________
1397+ E822             >//              Dictionary part
1397+ E822             >
1397+ E822             >                org     Dict_Ptr
1397+ AB07             >
1397+ AB07 20 28       >                dw      mirror_Ptr - $E000 + Heap_offset
1397+ AB09             >
1397+ AB09             >CABORT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1397+ AB09 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1397+ AB0C             >
1397+ AB0C             >
1397+ AB0C             >                endif           ; ok        // for other definitions it "points" the correct handler
1397+ AB0C             >                // Use of "; ok" to suppress "warning[fwdref]"
1397+ AB0C             >
1397+ AB0C             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1398+ AB0C 9C AD                        dw      ABORT                   // abort
1399+ AB0E 90 A0                        dw      EXIT                    // ;
1400+ AB10
1401+ AB10              //  ______________________________________________________________________
1402+ AB10              //
1403+ AB10              // error        n --
1404+ AB10              // raise an error
1405+ AB10              // if WARNING is 0, prints "MSG#n".
1406+ AB10              // if WARNING is 1, prints line n of screen 4.
1407+ AB10              // if WARNING is -1 does (ABORT) that normally does ABORT
1408+ AB10              // value can be negative or beyond block 4.
1409+ AB10                              Colon_Def ERROR,  "ERROR", is_normal
1409+ AB10             >                New_Def  ERROR, "ERROR", Enter_Ptr, is_normal ; ok
1409+ AB10             >
1409+ AB10             >Dict_Ptr        defl    $
1409+ AB10             >
1409+ AB10             >//              ______________________________________________________________________
1409+ AB10             >//              Heap part
1409+ AB10             >
1409+ AB10             >
1409+ AB10             >                org     (Heap_Ptr & $1FFF) + $E000
1409+ E822             >
1409+ E822             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1409+ E822             >Latest_Definition defl  Heap_Ptr
1409+ E822             >
1409+ E822             >                // dummy db directives used to calculate length of namec
1409+ E822 45 52 52 4F >                db      "ERROR"
1409+ E826 52          >
1409+ E827             >len_NFA         defl    $ - temp_NFA
1409+ E827             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1409+ E822             >
1409+ E822 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1409+ E823 45 52 52 4F >                db      "ERROR"               // name string in 7-bit ascii, but
1409+ E827 52          >
1409+ E828             >                org     $-1                 // alter last byte of Name just above to set
1409+ E827 D2          >                db      {b $} | END_BIT     // msb as name end
1409+ E828             >
1409+ E828 16 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1409+ E82A             >Prev_Ptr        defl    Heap_Ptr
1409+ E82A             >
1409+ E82A             >mirror_Ptr      defl    $
1409+ E82A             >
1409+ E82A 12 AB       >                dw      Dict_Ptr + 2        // xt
1409+ E82C             >Heap_Ptr        defl    $ - $E000           // save current HP
1409+ E82C             >
1409+ E82C             >Current_HP      defl  $ - $E000             // used to set HP once!
1409+ E82C             >
1409+ E82C             >//              ______________________________________________________________________
1409+ E82C             >//              Dictionary part
1409+ E82C             >
1409+ E82C             >                org     Dict_Ptr
1409+ AB10             >
1409+ AB10 2A 28       >                dw      mirror_Ptr - $E000 + Heap_offset
1409+ AB12             >
1409+ AB12             >ERROR:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1409+ AB12 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1409+ AB15             >
1409+ AB15             >
1409+ AB15             >                endif           ; ok        // for other definitions it "points" the correct handler
1409+ AB15             >                // Use of "; ok" to suppress "warning[fwdref]"
1409+ AB15             >
1409+ AB15             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1410+ AB15 30 A3 C7 A1                  dw      WARNING, FETCH, ZLESS   // warning @ 0<
1410+ AB19 C8 A0
1411+ AB1B                                                              // if
1412+ AB1B 33 9C                        dw      ZBRANCH
1413+ AB1D 04 00                        dw      Error_Endif_1 - $
1414+ AB1F 09 AB                        dw          CABORT              //      (abort)
1415+ AB21              Error_Endif_1:                                  // endif
1416+ AB21 E4 A3 5C A7                  dw      HERE, COUNT, TYPE       // here count type
1416+ AB25 B0 A7
1417+ AB27 4D A9                        dw      C_DOT_QUOTE             // .( ? )
1418+ AB29 02 3F 20                     db      2, "? "
1419+ AB2C 71 AF                        dw      MESSAGE                 // message  ( forward )
1420+ AB2E 18 A3 C7 A1                  dw      S0, FETCH, SPSTORE      // s0 @ sp!
1420+ AB32 80 A0
1421+ AB34 60 A3 C7 A1                  dw      BLK, FETCH, QDUP        // blk @ ?dup
1421+ AB38 8E A4
1422+ AB3A                                                              // if
1423+ AB3A 33 9C                        dw      ZBRANCH
1424+ AB3C 08 00                        dw      Error_Endif_2 - $
1425+ AB3E 66 A3 C7 A1                  dw          TO_IN, FETCH, SWAP  //      >in @ swap
1425+ AB42 62 A1
1426+ AB44              Error_Endif_2:                                  // endif
1427+ AB44 60 AD                        dw      QUIT                    // quit ( forward )
1428+ AB46 90 A0                        dw      EXIT                    // ;
1429+ AB48              //  ______________________________________________________________________
1430+ AB48              //
1431+ AB48              // id.          nfa --
1432+ AB48                              Colon_Def ID_DOT,  "ID.", is_normal
1432+ AB48             >                New_Def  ID_DOT, "ID.", Enter_Ptr, is_normal ; ok
1432+ AB48             >
1432+ AB48             >Dict_Ptr        defl    $
1432+ AB48             >
1432+ AB48             >//              ______________________________________________________________________
1432+ AB48             >//              Heap part
1432+ AB48             >
1432+ AB48             >
1432+ AB48             >                org     (Heap_Ptr & $1FFF) + $E000
1432+ E82C             >
1432+ E82C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1432+ E82C             >Latest_Definition defl  Heap_Ptr
1432+ E82C             >
1432+ E82C             >                // dummy db directives used to calculate length of namec
1432+ E82C 49 44 2E    >                db      "ID."
1432+ E82F             >len_NFA         defl    $ - temp_NFA
1432+ E82F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1432+ E82C             >
1432+ E82C 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1432+ E82D 49 44 2E    >                db      "ID."               // name string in 7-bit ascii, but
1432+ E830             >                org     $-1                 // alter last byte of Name just above to set
1432+ E82F AE          >                db      {b $} | END_BIT     // msb as name end
1432+ E830             >
1432+ E830 22 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1432+ E832             >Prev_Ptr        defl    Heap_Ptr
1432+ E832             >
1432+ E832             >mirror_Ptr      defl    $
1432+ E832             >
1432+ E832 4A AB       >                dw      Dict_Ptr + 2        // xt
1432+ E834             >Heap_Ptr        defl    $ - $E000           // save current HP
1432+ E834             >
1432+ E834             >Current_HP      defl  $ - $E000             // used to set HP once!
1432+ E834             >
1432+ E834             >//              ______________________________________________________________________
1432+ E834             >//              Dictionary part
1432+ E834             >
1432+ E834             >                org     Dict_Ptr
1432+ AB48             >
1432+ AB48 32 28       >                dw      mirror_Ptr - $E000 + Heap_offset
1432+ AB4A             >
1432+ AB4A             >ID_DOT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1432+ AB4A CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1432+ AB4D             >
1432+ AB4D             >
1432+ AB4D             >                endif           ; ok        // for other definitions it "points" the correct handler
1432+ AB4D             >                // Use of "; ok" to suppress "warning[fwdref]"
1432+ AB4D             >
1432+ AB4D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1433+ AB4D 44 A5                        dw      QTOHEAP
1434+ AB4F 69 A1 C6 A2                  dw      DUP, ONE, TRAVERSE      // dup 1 traverse
1434+ AB53 C0 A4
1435+ AB55 FC A0                        dw      ONE_PLUS                // 1+
1436+ AB57 45 A1 23 A4                  dw      OVER, SUBTRACT          // over -
1437+ AB5B 69 A1 9A A0                  dw      DUP, TO_R               // >r
1438+ AB5F F3 A8 62 A1                  dw      PAD, SWAP               // pad swap
1439+ AB63 CB 9F                        dw      CMOVE                   // cmove
1440+ AB65 F3 A8 FC A0                  dw      PAD, ONE_PLUS           // pad 1+
1441+ AB69 A5 A0 03 A1                  dw      R_TO, ONE_SUBTRACT      // R> 1-
1442+ AB6D B0 A7 B5 A4                  dw      TYPE, SPACE             // type
1443+ AB71 90 A0                        dw      EXIT                    // ;
1444+ AB73
1445+ AB73              //  ______________________________________________________________________
1446+ AB73              //
1447+ AB73              // code         -- cccc
1448+ AB73                              Colon_Def CODE,  "CODE", is_normal
1448+ AB73             >                New_Def  CODE, "CODE", Enter_Ptr, is_normal ; ok
1448+ AB73             >
1448+ AB73             >Dict_Ptr        defl    $
1448+ AB73             >
1448+ AB73             >//              ______________________________________________________________________
1448+ AB73             >//              Heap part
1448+ AB73             >
1448+ AB73             >
1448+ AB73             >                org     (Heap_Ptr & $1FFF) + $E000
1448+ E834             >
1448+ E834             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1448+ E834             >Latest_Definition defl  Heap_Ptr
1448+ E834             >
1448+ E834             >                // dummy db directives used to calculate length of namec
1448+ E834 43 4F 44 45 >                db      "CODE"
1448+ E838             >len_NFA         defl    $ - temp_NFA
1448+ E838             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1448+ E834             >
1448+ E834 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1448+ E835 43 4F 44 45 >                db      "CODE"               // name string in 7-bit ascii, but
1448+ E839             >                org     $-1                 // alter last byte of Name just above to set
1448+ E838 C5          >                db      {b $} | END_BIT     // msb as name end
1448+ E839             >
1448+ E839 2C 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1448+ E83B             >Prev_Ptr        defl    Heap_Ptr
1448+ E83B             >
1448+ E83B             >mirror_Ptr      defl    $
1448+ E83B             >
1448+ E83B 75 AB       >                dw      Dict_Ptr + 2        // xt
1448+ E83D             >Heap_Ptr        defl    $ - $E000           // save current HP
1448+ E83D             >
1448+ E83D             >Current_HP      defl  $ - $E000             // used to set HP once!
1448+ E83D             >
1448+ E83D             >//              ______________________________________________________________________
1448+ E83D             >//              Dictionary part
1448+ E83D             >
1448+ E83D             >                org     Dict_Ptr
1448+ AB73             >
1448+ AB73 3B 28       >                dw      mirror_Ptr - $E000 + Heap_offset
1448+ AB75             >
1448+ AB75             >CODE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1448+ AB75 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1448+ AB78             >
1448+ AB78             >
1448+ AB78             >                endif           ; ok        // for other definitions it "points" the correct handler
1448+ AB78             >                // Use of "; ok" to suppress "warning[fwdref]"
1448+ AB78             >
1448+ AB78             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1449+ AB78 FC AA                        dw      LFIND                   // -find
1450+ AB7A                                                              // if
1451+ AB7A 33 9C                        dw      ZBRANCH
1452+ AB7C 10 00                        dw      Code_Endif - $
1453+ AB7E 4E A1                        dw          DROP                //      drop
1454+ AB80 AA A5 4A AB                  dw          TO_NAME, ID_DOT     //      >name id.
1455+ AB84 E1 9B 04 00                  dw          LIT, 4, MESSAGE     //      4 message
1455+ AB88 71 AF
1456+ AB8A B5 A4                        dw          SPACE               //      space
1457+ AB8C              Code_Endif:                                     // endif
1458+ AB8C E4 A3                        dw      HERE                    // here
1459+ AB8E                                                              // ( ---- here begins NFA ---- )
1460+ AB8E 69 A1 DC A1                  dw      DUP, CFETCH             // dup c@
1461+ AB92 2A A3 C7 A1                  dw      WIDTH, FETCH, MIN       // width @ min  ( max 31 character length )
1461+ AB96 68 A4
1462+ AB98 FC A0                        dw      ONE_PLUS                // 1+
1463+ AB9A 69 A1 EF A3                  dw      DUP, ALLOT              // dup allot
1464+ AB9E 12 A1 12 A1                  dw      CELL_PLUS, CELL_PLUS    // cell+ cell+
1465+ ABA2 9A A0                        dw      TO_R                    // >r
1466+ ABA4 69 A1                        dw      DUP                     // dup
1467+ ABA6 E1 9B                        dw      LIT
1468+ ABA8 A0 00                        dw      SMUDGE_BIT | END_BIT    // 160
1469+ ABAA BE A1                        dw      TOGGLE                  // toggle
1470+ ABAC E4 A3 03 A1                  dw      HERE, ONE_SUBTRACT      // here 1- ( last character )
1471+ ABB0 E1 9B 80 00                  dw      LIT, END_BIT, TOGGLE    // 128 toggle
1471+ ABB4 BE A1
1472+ ABB6                                                              // ( ---- here is LFA ---- )
1473+ ABB6 84 A3 C7 A1                  dw      CURRENT, FETCH, FETCH   // current @ @ , \ latest ,
1473+ ABBA C7 A1
1474+ ABBC FA A3                        dw      COMMA
1475+ ABBE 69 A1 12 A1                  dw      DUP, CELL_PLUS, COMMA   // dup cell+ ,
1475+ ABC2 FA A3
1476+ ABC4 55 A5                        dw      HP_FETCH                // hp@
1477+ ABC6 84 A3 C7 A1                  dw      CURRENT, FETCH, STORE   // current @ ! ( save this word as the latest )
1477+ ABCA D1 A1
1478+ ABCC 55 A5 26 A5                  dw      HP_FETCH, FAR           // hp@ far R@ cmove
1479+ ABD0 B0 A0 CB 9F                  dw      R_OP, CMOVE
1480+ ABD4 B0 A0 24 A1                  dw      R_OP, MINUS, ALLOT      // r@ negate allot
1480+ ABD8 EF A3
1481+ ABDA A5 A0 54 A3                  dw      R_TO, HP, PLUSSTORE     // r> hp +!
1481+ ABDE AF A1
1482+ ABE0 55 A5 17 A1                  dw      HP_FETCH, CELL_MINUS    // hp@ cell- ,
1483+ ABE4 FA A3                        dw      COMMA
1484+ ABE6 BF A2 67 A5                  dw      ZERO, SKIP_HP_PAGE
1485+ ABEA                                                              // ( ---- here is LFA ---- )
1486+ ABEA 90 A0                        dw      EXIT                    // ;
1487+ ABEC
1488+ ABEC              //  ______________________________________________________________________
1489+ ABEC              //
1490+ ABEC              // create       -- cccc     ( compile time )
1491+ ABEC              //              -- a        ( run time )
1492+ ABEC                              Colon_Def CREATE,  "CREATE", is_normal
1492+ ABEC             >                New_Def  CREATE, "CREATE", Enter_Ptr, is_normal ; ok
1492+ ABEC             >
1492+ ABEC             >Dict_Ptr        defl    $
1492+ ABEC             >
1492+ ABEC             >//              ______________________________________________________________________
1492+ ABEC             >//              Heap part
1492+ ABEC             >
1492+ ABEC             >
1492+ ABEC             >                org     (Heap_Ptr & $1FFF) + $E000
1492+ E83D             >
1492+ E83D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1492+ E83D             >Latest_Definition defl  Heap_Ptr
1492+ E83D             >
1492+ E83D             >                // dummy db directives used to calculate length of namec
1492+ E83D 43 52 45 41 >                db      "CREATE"
1492+ E841 54 45       >
1492+ E843             >len_NFA         defl    $ - temp_NFA
1492+ E843             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1492+ E83D             >
1492+ E83D 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1492+ E83E 43 52 45 41 >                db      "CREATE"               // name string in 7-bit ascii, but
1492+ E842 54 45       >
1492+ E844             >                org     $-1                 // alter last byte of Name just above to set
1492+ E843 C5          >                db      {b $} | END_BIT     // msb as name end
1492+ E844             >
1492+ E844 34 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1492+ E846             >Prev_Ptr        defl    Heap_Ptr
1492+ E846             >
1492+ E846             >mirror_Ptr      defl    $
1492+ E846             >
1492+ E846 EE AB       >                dw      Dict_Ptr + 2        // xt
1492+ E848             >Heap_Ptr        defl    $ - $E000           // save current HP
1492+ E848             >
1492+ E848             >Current_HP      defl  $ - $E000             // used to set HP once!
1492+ E848             >
1492+ E848             >//              ______________________________________________________________________
1492+ E848             >//              Dictionary part
1492+ E848             >
1492+ E848             >                org     Dict_Ptr
1492+ ABEC             >
1492+ ABEC 46 28       >                dw      mirror_Ptr - $E000 + Heap_offset
1492+ ABEE             >
1492+ ABEE             >CREATE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1492+ ABEE CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1492+ ABF1             >
1492+ ABF1             >
1492+ ABF1             >                endif           ; ok        // for other definitions it "points" the correct handler
1492+ ABF1             >                // Use of "; ok" to suppress "warning[fwdref]"
1492+ ABF1             >
1492+ ABF1             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1493+ ABF1 75 AB CC A6                  dw      CODE, SMUDGE            // code smudge
1494+ ABF5 E1 9B CD 00                  dw      LIT, $CD, CCOMMA        // 00CD c,
1494+ ABF9 09 A4
1495+ ABFB E1 9B A6 A2                  dw      LIT, Variable_Ptr, COMMA// Variable_Ptr ,
1495+ ABFF FA A3
1496+ AC01 08 A7                        dw      C_SEMICOLON_CODE
1497+ AC03                              // this routine is called from the call coded in CFA
1498+ AC03              Create_Ptr:
1499+ AC03
1500+ AC03
1501+ AC03
1502+ AC03                              next
1502+ AC03 DD E9       >                jp      (ix)
1503+ AC05
1504+ AC05              //  ______________________________________________________________________
1505+ AC05              //
1506+ AC05              // [compile]    -- cccc     ( compile time )
1507+ AC05                              Colon_Def COMPILE_IMMEDIATE,  "[COMPILE]", is_immediate
1507+ AC05             >                New_Def  COMPILE_IMMEDIATE, "[COMPILE]", Enter_Ptr, is_immediate ; ok
1507+ AC05             >
1507+ AC05             >Dict_Ptr        defl    $
1507+ AC05             >
1507+ AC05             >//              ______________________________________________________________________
1507+ AC05             >//              Heap part
1507+ AC05             >
1507+ AC05             >
1507+ AC05             >                org     (Heap_Ptr & $1FFF) + $E000
1507+ E848             >
1507+ E848             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1507+ E848             >Latest_Definition defl  Heap_Ptr
1507+ E848             >
1507+ E848             >                // dummy db directives used to calculate length of namec
1507+ E848 5B 43 4F 4D >                db      "[COMPILE]"
1507+ E84C 50 49 4C 45 >
1507+ E850 5D          >
1507+ E851             >len_NFA         defl    $ - temp_NFA
1507+ E851             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1507+ E848             >
1507+ E848 C9          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
1507+ E849 5B 43 4F 4D >                db      "[COMPILE]"               // name string in 7-bit ascii, but
1507+ E84D 50 49 4C 45 >
1507+ E851 5D          >
1507+ E852             >                org     $-1                 // alter last byte of Name just above to set
1507+ E851 DD          >                db      {b $} | END_BIT     // msb as name end
1507+ E852             >
1507+ E852 3D 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1507+ E854             >Prev_Ptr        defl    Heap_Ptr
1507+ E854             >
1507+ E854             >mirror_Ptr      defl    $
1507+ E854             >
1507+ E854 07 AC       >                dw      Dict_Ptr + 2        // xt
1507+ E856             >Heap_Ptr        defl    $ - $E000           // save current HP
1507+ E856             >
1507+ E856             >Current_HP      defl  $ - $E000             // used to set HP once!
1507+ E856             >
1507+ E856             >//              ______________________________________________________________________
1507+ E856             >//              Dictionary part
1507+ E856             >
1507+ E856             >                org     Dict_Ptr
1507+ AC05             >
1507+ AC05 54 28       >                dw      mirror_Ptr - $E000 + Heap_offset
1507+ AC07             >
1507+ AC07             >COMPILE_IMMEDIATE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1507+ AC07 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1507+ AC0A             >
1507+ AC0A             >
1507+ AC0A             >                endif           ; ok        // for other definitions it "points" the correct handler
1507+ AC0A             >                // Use of "; ok" to suppress "warning[fwdref]"
1507+ AC0A             >
1507+ AC0A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1508+ AC0A FC AA                        dw      LFIND                   // -find      (  cfa  b  f  )
1509+ AC0C B5 A0                        dw      ZEQUAL                  // 0=         (  cfa  b  )
1510+ AC0E BF A2 20 A6                  dw      ZERO, QERROR            // 0 ?error
1511+ AC12 4E A1                        dw      DROP                    // drop       (  cfa  )
1512+ AC14 FA A3                        dw      COMMA                   // ,
1513+ AC16 90 A0                        dw      EXIT                    // ; immediate
1514+ AC18
1515+ AC18              //  ______________________________________________________________________
1516+ AC18              //
1517+ AC18              // literal      n --      ( compile time )
1518+ AC18                              Colon_Def LITERAL,  "LITERAL", is_immediate
1518+ AC18             >                New_Def  LITERAL, "LITERAL", Enter_Ptr, is_immediate ; ok
1518+ AC18             >
1518+ AC18             >Dict_Ptr        defl    $
1518+ AC18             >
1518+ AC18             >//              ______________________________________________________________________
1518+ AC18             >//              Heap part
1518+ AC18             >
1518+ AC18             >
1518+ AC18             >                org     (Heap_Ptr & $1FFF) + $E000
1518+ E856             >
1518+ E856             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1518+ E856             >Latest_Definition defl  Heap_Ptr
1518+ E856             >
1518+ E856             >                // dummy db directives used to calculate length of namec
1518+ E856 4C 49 54 45 >                db      "LITERAL"
1518+ E85A 52 41 4C    >
1518+ E85D             >len_NFA         defl    $ - temp_NFA
1518+ E85D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1518+ E856             >
1518+ E856 C7          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
1518+ E857 4C 49 54 45 >                db      "LITERAL"               // name string in 7-bit ascii, but
1518+ E85B 52 41 4C    >
1518+ E85E             >                org     $-1                 // alter last byte of Name just above to set
1518+ E85D CC          >                db      {b $} | END_BIT     // msb as name end
1518+ E85E             >
1518+ E85E 48 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1518+ E860             >Prev_Ptr        defl    Heap_Ptr
1518+ E860             >
1518+ E860             >mirror_Ptr      defl    $
1518+ E860             >
1518+ E860 1A AC       >                dw      Dict_Ptr + 2        // xt
1518+ E862             >Heap_Ptr        defl    $ - $E000           // save current HP
1518+ E862             >
1518+ E862             >Current_HP      defl  $ - $E000             // used to set HP once!
1518+ E862             >
1518+ E862             >//              ______________________________________________________________________
1518+ E862             >//              Dictionary part
1518+ E862             >
1518+ E862             >                org     Dict_Ptr
1518+ AC18             >
1518+ AC18 60 28       >                dw      mirror_Ptr - $E000 + Heap_offset
1518+ AC1A             >
1518+ AC1A             >LITERAL:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1518+ AC1A CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1518+ AC1D             >
1518+ AC1D             >
1518+ AC1D             >                endif           ; ok        // for other definitions it "points" the correct handler
1518+ AC1D             >                // Use of "; ok" to suppress "warning[fwdref]"
1518+ AC1D             >
1518+ AC1D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1519+ AC1D 8A A3 C7 A1                  dw      STATE, FETCH            // state @
1520+ AC21                                                              // if
1521+ AC21 33 9C                        dw      ZBRANCH
1522+ AC23 08 00                        dw      Literal_Endif - $
1523+ AC25 90 A6 E1 9B                  dw          COMPILE, LIT        //      compile lit
1524+ AC29 FA A3                        dw          COMMA               //      ,
1525+ AC2B              Literal_Endif:                                  // endif
1526+ AC2B 90 A0                        dw      EXIT                    // ; immediate
1527+ AC2D
1528+ AC2D              //  ______________________________________________________________________
1529+ AC2D              //
1530+ AC2D              // dliteral     n --      ( compile time )
1531+ AC2D                              Colon_Def DLITERAL,  "DLITERAL", is_immediate
1531+ AC2D             >                New_Def  DLITERAL, "DLITERAL", Enter_Ptr, is_immediate ; ok
1531+ AC2D             >
1531+ AC2D             >Dict_Ptr        defl    $
1531+ AC2D             >
1531+ AC2D             >//              ______________________________________________________________________
1531+ AC2D             >//              Heap part
1531+ AC2D             >
1531+ AC2D             >
1531+ AC2D             >                org     (Heap_Ptr & $1FFF) + $E000
1531+ E862             >
1531+ E862             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1531+ E862             >Latest_Definition defl  Heap_Ptr
1531+ E862             >
1531+ E862             >                // dummy db directives used to calculate length of namec
1531+ E862 44 4C 49 54 >                db      "DLITERAL"
1531+ E866 45 52 41 4C >
1531+ E86A             >len_NFA         defl    $ - temp_NFA
1531+ E86A             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1531+ E862             >
1531+ E862 C8          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
1531+ E863 44 4C 49 54 >                db      "DLITERAL"               // name string in 7-bit ascii, but
1531+ E867 45 52 41 4C >
1531+ E86B             >                org     $-1                 // alter last byte of Name just above to set
1531+ E86A CC          >                db      {b $} | END_BIT     // msb as name end
1531+ E86B             >
1531+ E86B 56 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1531+ E86D             >Prev_Ptr        defl    Heap_Ptr
1531+ E86D             >
1531+ E86D             >mirror_Ptr      defl    $
1531+ E86D             >
1531+ E86D 2F AC       >                dw      Dict_Ptr + 2        // xt
1531+ E86F             >Heap_Ptr        defl    $ - $E000           // save current HP
1531+ E86F             >
1531+ E86F             >Current_HP      defl  $ - $E000             // used to set HP once!
1531+ E86F             >
1531+ E86F             >//              ______________________________________________________________________
1531+ E86F             >//              Dictionary part
1531+ E86F             >
1531+ E86F             >                org     Dict_Ptr
1531+ AC2D             >
1531+ AC2D 6D 28       >                dw      mirror_Ptr - $E000 + Heap_offset
1531+ AC2F             >
1531+ AC2F             >DLITERAL:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1531+ AC2F CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1531+ AC32             >
1531+ AC32             >
1531+ AC32             >                endif           ; ok        // for other definitions it "points" the correct handler
1531+ AC32             >                // Use of "; ok" to suppress "warning[fwdref]"
1531+ AC32             >
1531+ AC32             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1532+ AC32 8A A3 C7 A1                  dw      STATE, FETCH            // state @
1533+ AC36                                                              // if
1534+ AC36 33 9C                        dw      ZBRANCH
1535+ AC38 08 00                        dw      DLiteral_Endif - $
1536+ AC3A 62 A1                        dw          SWAP                //      swap
1537+ AC3C 1A AC 1A AC                  dw          LITERAL,  LITERAL   //      [compile] literal [compile] literal
1538+ AC40              DLiteral_Endif:                                 // endif
1539+ AC40 90 A0                        dw      EXIT                    // ; immediate
1540+ AC42
1541+ AC42              //  ______________________________________________________________________
1542+ AC42              //
1543+ AC42              // [char]       n --      ( compile time )
1544+ AC42              // inside colon definition, gets first character from next input word
1545+ AC42              // and compiles it as literal.
1546+ AC42                              Colon_Def COMPILE_CHAR,  "[CHAR]", is_immediate
1546+ AC42             >                New_Def  COMPILE_CHAR, "[CHAR]", Enter_Ptr, is_immediate ; ok
1546+ AC42             >
1546+ AC42             >Dict_Ptr        defl    $
1546+ AC42             >
1546+ AC42             >//              ______________________________________________________________________
1546+ AC42             >//              Heap part
1546+ AC42             >
1546+ AC42             >
1546+ AC42             >                org     (Heap_Ptr & $1FFF) + $E000
1546+ E86F             >
1546+ E86F             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1546+ E86F             >Latest_Definition defl  Heap_Ptr
1546+ E86F             >
1546+ E86F             >                // dummy db directives used to calculate length of namec
1546+ E86F 5B 43 48 41 >                db      "[CHAR]"
1546+ E873 52 5D       >
1546+ E875             >len_NFA         defl    $ - temp_NFA
1546+ E875             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1546+ E86F             >
1546+ E86F C6          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
1546+ E870 5B 43 48 41 >                db      "[CHAR]"               // name string in 7-bit ascii, but
1546+ E874 52 5D       >
1546+ E876             >                org     $-1                 // alter last byte of Name just above to set
1546+ E875 DD          >                db      {b $} | END_BIT     // msb as name end
1546+ E876             >
1546+ E876 62 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1546+ E878             >Prev_Ptr        defl    Heap_Ptr
1546+ E878             >
1546+ E878             >mirror_Ptr      defl    $
1546+ E878             >
1546+ E878 44 AC       >                dw      Dict_Ptr + 2        // xt
1546+ E87A             >Heap_Ptr        defl    $ - $E000           // save current HP
1546+ E87A             >
1546+ E87A             >Current_HP      defl  $ - $E000             // used to set HP once!
1546+ E87A             >
1546+ E87A             >//              ______________________________________________________________________
1546+ E87A             >//              Dictionary part
1546+ E87A             >
1546+ E87A             >                org     Dict_Ptr
1546+ AC42             >
1546+ AC42 78 28       >                dw      mirror_Ptr - $E000 + Heap_offset
1546+ AC44             >
1546+ AC44             >COMPILE_CHAR:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1546+ AC44 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1546+ AC47             >
1546+ AC47             >
1546+ AC47             >                endif           ; ok        // for other definitions it "points" the correct handler
1546+ AC47             >                // Use of "; ok" to suppress "warning[fwdref]"
1546+ AC47             >
1546+ AC47             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1547+ AC47 64 A9 1A AC                  dw      CHAR, LITERAL           // char [compile] literal
1548+ AC4B 90 A0                        dw      EXIT                    // ; immediate
1549+ AC4D
1550+ AC4D              //  ______________________________________________________________________
1551+ AC4D              //
1552+ AC4D              // 0x00         n --      ( compile time )
1553+ AC4D                              Colon_Def NUL_WORD,  $00, is_immediate
1553+ AC4D             >                New_Def  NUL_WORD, $00, Enter_Ptr, is_immediate ; ok
1553+ AC4D             >
1553+ AC4D             >Dict_Ptr        defl    $
1553+ AC4D             >
1553+ AC4D             >//              ______________________________________________________________________
1553+ AC4D             >//              Heap part
1553+ AC4D             >
1553+ AC4D             >
1553+ AC4D             >                org     (Heap_Ptr & $1FFF) + $E000
1553+ E87A             >
1553+ E87A             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1553+ E87A             >Latest_Definition defl  Heap_Ptr
1553+ E87A             >
1553+ E87A             >                // dummy db directives used to calculate length of namec
1553+ E87A 00          >                db      $00
1553+ E87B             >len_NFA         defl    $ - temp_NFA
1553+ E87B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1553+ E87A             >
1553+ E87A C1          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
1553+ E87B 00          >                db      $00               // name string in 7-bit ascii, but
1553+ E87C             >                org     $-1                 // alter last byte of Name just above to set
1553+ E87B 80          >                db      {b $} | END_BIT     // msb as name end
1553+ E87C             >
1553+ E87C 6F 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1553+ E87E             >Prev_Ptr        defl    Heap_Ptr
1553+ E87E             >
1553+ E87E             >mirror_Ptr      defl    $
1553+ E87E             >
1553+ E87E 4F AC       >                dw      Dict_Ptr + 2        // xt
1553+ E880             >Heap_Ptr        defl    $ - $E000           // save current HP
1553+ E880             >
1553+ E880             >Current_HP      defl  $ - $E000             // used to set HP once!
1553+ E880             >
1553+ E880             >//              ______________________________________________________________________
1553+ E880             >//              Dictionary part
1553+ E880             >
1553+ E880             >                org     Dict_Ptr
1553+ AC4D             >
1553+ AC4D 7E 28       >                dw      mirror_Ptr - $E000 + Heap_offset
1553+ AC4F             >
1553+ AC4F             >NUL_WORD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1553+ AC4F CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1553+ AC52             >
1553+ AC52             >
1553+ AC52             >                endif           ; ok        // for other definitions it "points" the correct handler
1553+ AC52             >                // Use of "; ok" to suppress "warning[fwdref]"
1553+ AC52             >
1553+ AC52             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1554+ AC52 60 A3 C7 A1                  dw      BLK, FETCH, ONE         // blk @ 1
1554+ AC56 C6 A2
1555+ AC58 5D A4                        dw      GREATER                 // > if
1556+ AC5A                                                              // if
1557+ AC5A 33 9C                        dw      ZBRANCH
1558+ AC5C 28 00                        dw      Nul_Else_1 - $
1559+ AC5E C6 A2 60 A3                  dw          ONE, BLK, PLUSSTORE //      1 blk +!
1559+ AC62 AF A1
1560+ AC64 BF A2 66 A3                  dw          ZERO, TO_IN, STORE  //      0 >in !
1560+ AC68 D1 A1
1561+ AC6A 60 A3 C7 A1                  dw          BLK, FETCH          //      blk @
1562+ AC6E F7 A2                        dw          BSCR                //      b/scr
1563+ AC70 03 A1                        dw          ONE_SUBTRACT        //      1 -
1564+ AC72 4A A0                        dw          AND_OP              //      and  ( this is tricky )
1565+ AC74 B5 A0                        dw          ZEQUAL              //      0=
1566+ AC76                                                              //      if
1567+ AC76 33 9C                        dw          ZBRANCH
1568+ AC78 08 00                        dw          Nul_Endif_2 - $
1569+ AC7A 48 A6                        dw              QEXEC           //          ?exec
1570+ AC7C A5 A0 4E A1                  dw              R_TO, DROP      //          r> drop
1571+ AC80              Nul_Endif_2:                                    //      endif
1572+ AC80 26 9C                        dw      BRANCH
1573+ AC82 06 00                        dw      Nul_Endif_1 - $
1574+ AC84              Nul_Else_1:                                     // else
1575+ AC84 A5 A0 4E A1                  dw          R_TO, DROP          //      r> drop
1576+ AC88              Nul_Endif_1:                                    // endif
1577+ AC88 90 A0                        dw      EXIT                    // ;
1578+ AC8A
1579+ AC8A              //  ______________________________________________________________________
1580+ AC8A              //
1581+ AC8A              // ?stack       --
1582+ AC8A              // Raise error #1 if stack is empty and you pop it
1583+ AC8A              // Raise error #7 if stack is full.
1584+ AC8A              // This means SP must always stay between HERE and FFFF
1585+ AC8A              // For 128K BANK paging purpose SP must be <= BFE0 and 50 words room
1586+ AC8A              // for Next 8K MMU paging this is $DOE8
1587+ AC8A                              Colon_Def QSTACK, "?STACK", is_normal
1587+ AC8A             >                New_Def  QSTACK, "?STACK", Enter_Ptr, is_normal ; ok
1587+ AC8A             >
1587+ AC8A             >Dict_Ptr        defl    $
1587+ AC8A             >
1587+ AC8A             >//              ______________________________________________________________________
1587+ AC8A             >//              Heap part
1587+ AC8A             >
1587+ AC8A             >
1587+ AC8A             >                org     (Heap_Ptr & $1FFF) + $E000
1587+ E880             >
1587+ E880             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
1587+ E880             >Latest_Definition defl  Heap_Ptr
1587+ E880             >
1587+ E880             >                // dummy db directives used to calculate length of namec
1587+ E880 3F 53 54 41 >                db      "?STACK"
1587+ E884 43 4B       >
1587+ E886             >len_NFA         defl    $ - temp_NFA
1587+ E886             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
1587+ E880             >
1587+ E880 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
1587+ E881 3F 53 54 41 >                db      "?STACK"               // name string in 7-bit ascii, but
1587+ E885 43 4B       >
1587+ E887             >                org     $-1                 // alter last byte of Name just above to set
1587+ E886 CB          >                db      {b $} | END_BIT     // msb as name end
1587+ E887             >
1587+ E887 7A 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
1587+ E889             >Prev_Ptr        defl    Heap_Ptr
1587+ E889             >
1587+ E889             >mirror_Ptr      defl    $
1587+ E889             >
1587+ E889 8C AC       >                dw      Dict_Ptr + 2        // xt
1587+ E88B             >Heap_Ptr        defl    $ - $E000           // save current HP
1587+ E88B             >
1587+ E88B             >Current_HP      defl  $ - $E000             // used to set HP once!
1587+ E88B             >
1587+ E88B             >//              ______________________________________________________________________
1587+ E88B             >//              Dictionary part
1587+ E88B             >
1587+ E88B             >                org     Dict_Ptr
1587+ AC8A             >
1587+ AC8A 89 28       >                dw      mirror_Ptr - $E000 + Heap_offset
1587+ AC8C             >
1587+ AC8C             >QSTACK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
1587+ AC8C CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
1587+ AC8F             >
1587+ AC8F             >
1587+ AC8F             >                endif           ; ok        // for other definitions it "points" the correct handler
1587+ AC8F             >                // Use of "; ok" to suppress "warning[fwdref]"
1587+ AC8F             >
1587+ AC8F             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
1588+ AC8F 77 A0                        dw      SPFETCH                 // sp@
1589+ AC91 18 A3 C7 A1                  dw      S0, FETCH               // s0 @
1590+ AC95 62 A1 3A A4                  dw      SWAP, ULESS             // swap u<
1591+ AC99 C6 A2 20 A6                  dw      ONE, QERROR             // 1 ?error
1592+ AC9D E4 A3                        dw      HERE                    // here
1593+ AC9F 18 A3 C7 A1                  dw      S0, FETCH, LESS         // s0 @ <
1593+ ACA3 48 A4
1594+ ACA5                                                              // if
1595+ ACA5 33 9C                        dw      ZBRANCH
1596+ ACA7 14 00                        dw      QStack_Endif - $
1597+ ACA9 77 A0                        dw          SPFETCH             //      sp@
1598+ ACAB E4 A3 E1 9B                  dw          HERE, LIT, 128      //      here 128
1598+ ACAF 80 00
1599+ ACB1 E3 A0 3A A4                  dw          PLUS, ULESS         //      plus u<
1600+ ACB5 E1 9B 07 00                  dw          LIT, 7, QERROR      //      7 Cerror
1600+ ACB9 20 A6
1601+ ACBB              QStack_Endif:                                   // endif
1602+ ACBB 90 A0                        dw      EXIT                    // ;
1603+ ACBD
1604+ ACBD
# file closed: C:\Zx\CSpect\Projects\vForth17_MMU7/source/L1.asm
 122  ACBD                              include "L2.asm"
# file opened: C:\Zx\CSpect\Projects\vForth17_MMU7/source/L2.asm
   1+ ACBD              //  ______________________________________________________________________
   2+ ACBD              //
   3+ ACBD              //  L2.asm
   4+ ACBD              //
   5+ ACBD              //  Level-2 3dos
   6+ ACBD              //  the Forth interpreter, vocabulary, cold/warm start and quit from Forth.
   7+ ACBD              //  ______________________________________________________________________
   8+ ACBD
   9+ ACBD
  10+ ACBD              //  ______________________________________________________________________
  11+ ACBD              //
  12+ ACBD              // interpret    --
  13+ ACBD              // This is the text interpreter.
  14+ ACBD              // It executes or compiles, depending on STATE, the text coming from
  15+ ACBD              // current input stream.
  16+ ACBD              // If the word search fails after parsing CONTEXT and CURRENT vocabulary,
  17+ ACBD              // the word is interpreted as numeric and converted, using current BASE,
  18+ ACBD              // leaving on top of stack a single or double precision number, depending
  19+ ACBD              // on the presence of a decimal point.
  20+ ACBD              // If the number conversion fails, the terminal is notified with ? followed
  21+ ACBD              // by the offending word.
  22+ ACBD                              Colon_Def INTERPRET, "INTERPRET", is_normal
  22+ ACBD             >                New_Def  INTERPRET, "INTERPRET", Enter_Ptr, is_normal ; ok
  22+ ACBD             >
  22+ ACBD             >Dict_Ptr        defl    $
  22+ ACBD             >
  22+ ACBD             >//              ______________________________________________________________________
  22+ ACBD             >//              Heap part
  22+ ACBD             >
  22+ ACBD             >
  22+ ACBD             >                org     (Heap_Ptr & $1FFF) + $E000
  22+ E88B             >
  22+ E88B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  22+ E88B             >Latest_Definition defl  Heap_Ptr
  22+ E88B             >
  22+ E88B             >                // dummy db directives used to calculate length of namec
  22+ E88B 49 4E 54 45 >                db      "INTERPRET"
  22+ E88F 52 50 52 45 >
  22+ E893 54          >
  22+ E894             >len_NFA         defl    $ - temp_NFA
  22+ E894             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  22+ E88B             >
  22+ E88B 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  22+ E88C 49 4E 54 45 >                db      "INTERPRET"               // name string in 7-bit ascii, but
  22+ E890 52 50 52 45 >
  22+ E894 54          >
  22+ E895             >                org     $-1                 // alter last byte of Name just above to set
  22+ E894 D4          >                db      {b $} | END_BIT     // msb as name end
  22+ E895             >
  22+ E895 80 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
  22+ E897             >Prev_Ptr        defl    Heap_Ptr
  22+ E897             >
  22+ E897             >mirror_Ptr      defl    $
  22+ E897             >
  22+ E897 BF AC       >                dw      Dict_Ptr + 2        // xt
  22+ E899             >Heap_Ptr        defl    $ - $E000           // save current HP
  22+ E899             >
  22+ E899             >Current_HP      defl  $ - $E000             // used to set HP once!
  22+ E899             >
  22+ E899             >//              ______________________________________________________________________
  22+ E899             >//              Dictionary part
  22+ E899             >
  22+ E899             >                org     Dict_Ptr
  22+ ACBD             >
  22+ ACBD 97 28       >                dw      mirror_Ptr - $E000 + Heap_offset
  22+ ACBF             >
  22+ ACBF             >INTERPRET:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
  22+ ACBF CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
  22+ ACC2             >
  22+ ACC2             >
  22+ ACC2             >                endif           ; ok        // for other definitions it "points" the correct handler
  22+ ACC2             >                // Use of "; ok" to suppress "warning[fwdref]"
  22+ ACC2             >
  22+ ACC2             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  23+ ACC2
  24+ ACC2              Interpret_Begin:                                        // begin
  25+ ACC2 FC AA                        dw          LFIND                       //      -find
  26+ ACC4                                                                      //      if
  27+ ACC4 33 9C                        dw          ZBRANCH
  28+ ACC6 1A 00                        dw          Interpret_Else_1 - $
  29+ ACC8 8A A3 C7 A1                  dw              STATE, FETCH, LESS      //          state @ <
  29+ ACCC 48 A4
  30+ ACCE                                                                      //          if
  31+ ACCE 33 9C                        dw              ZBRANCH
  32+ ACD0 08 00                        dw              Interpret_Else_2 - $
  33+ ACD2 A5 A6                        dw                  COMPILE_XT          //              compile,
  34+ ACD4                                                                      //          else
  35+ ACD4 26 9C                        dw              BRANCH
  36+ ACD6 06 00                        dw              Interpret_Endif_2 - $
  37+ ACD8              Interpret_Else_2:
  38+ ACD8 EC 9B 86 A2                  dw                  EXECUTE, NOOP       //              execute nooop
  39+ ACDC              Interpret_Endif_2:                                      //          endif
  40+ ACDC                                                                      //      else
  41+ ACDC 26 9C                        dw          BRANCH
  42+ ACDE 1A 00                        dw          Interpret_Endif_1 - $
  43+ ACE0              Interpret_Else_1:
  44+ ACE0 E4 A3 84 AA                  dw              HERE, NUMBER            //          here number
  45+ ACE4 96 A3 C7 A1                  dw              DPL, FETCH, ONE_PLUS    //          dpl @ 1+
  45+ ACE8 FC A0
  46+ ACEA                                                                      //          if
  47+ ACEA 33 9C                        dw              ZBRANCH
  48+ ACEC 08 00                        dw              Interpret_Else_3 - $
  49+ ACEE              //              dw                  NMODE, FETCH        //              nmode @
  50+ ACEE              //                                                      //              if
  51+ ACEE              //              dw                  ZBRANCH
  52+ ACEE              //              dw                  Interpret_Endif_4 - $
  53+ ACEE              //              dw                      ONE, ZERO       //                  1 0
  54+ ACEE              //              dw                      TWO_DROP        //                  2drop
  55+ ACEE              //Interpret_Endif_4:                                      //              endif
  56+ ACEE 2F AC                        dw                  DLITERAL            //              [compile] dliteral
  57+ ACF0                                                                      //          else
  58+ ACF0 26 9C                        dw              BRANCH
  59+ ACF2 06 00                        dw              Interpret_Endif_3 - $
  60+ ACF4              Interpret_Else_3:
  61+ ACF4 4E A1                        dw                  DROP                //              drop
  62+ ACF6 1A AC                        dw                  LITERAL             //              [compile]  literal
  63+ ACF8              Interpret_Endif_3:                                      //          endif
  64+ ACF8              Interpret_Endif_1:                                      //      endif
  65+ ACF8 8C AC                        dw          QSTACK                      //      ?stack
  66+ ACFA F1 9E                        dw          QTERMINAL                   //      ?terminal
  67+ ACFC                                                                      //      if
  68+ ACFC 33 9C                        dw          ZBRANCH
  69+ ACFE 04 00                        dw          Interpret_Endif_5 - $
  70+ AD00 60 AD                        dw              QUIT                    //          quit
  71+ AD02              Interpret_Endif_5:                                      //      endif
  72+ AD02 26 9C                        dw      BRANCH
  73+ AD04 BE FF                        dw      Interpret_Begin - $
  74+ AD06 90 A0                        dw      EXIT                            // ;
  75+ AD08
  76+ AD08              //  ______________________________________________________________________
  77+ AD08              //
  78+ AD08              // vocabulary   -- cccc     ( compile time )
  79+ AD08              // Defining word used in the form   VOCABULARY cccc
  80+ AD08              // creates the word  cccc  that gives the name to the vocabulary.
  81+ AD08              // Giving  cccc  makes the vocabulary CONTEXT so its words are executed first
  82+ AD08              // Giving  cccc DEFINITIONS makes  the vocabulary  CURRENT
  83+ AD08              // so new definitions can be inserted in that vocabulary.
  84+ AD08                              Colon_Def VOCABULARY, "VOCABULARY", is_normal
  84+ AD08             >                New_Def  VOCABULARY, "VOCABULARY", Enter_Ptr, is_normal ; ok
  84+ AD08             >
  84+ AD08             >Dict_Ptr        defl    $
  84+ AD08             >
  84+ AD08             >//              ______________________________________________________________________
  84+ AD08             >//              Heap part
  84+ AD08             >
  84+ AD08             >
  84+ AD08             >                org     (Heap_Ptr & $1FFF) + $E000
  84+ E899             >
  84+ E899             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  84+ E899             >Latest_Definition defl  Heap_Ptr
  84+ E899             >
  84+ E899             >                // dummy db directives used to calculate length of namec
  84+ E899 56 4F 43 41 >                db      "VOCABULARY"
  84+ E89D 42 55 4C 41 >
  84+ E8A1 52 59       >
  84+ E8A3             >len_NFA         defl    $ - temp_NFA
  84+ E8A3             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  84+ E899             >
  84+ E899 8A          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  84+ E89A 56 4F 43 41 >                db      "VOCABULARY"               // name string in 7-bit ascii, but
  84+ E89E 42 55 4C 41 >
  84+ E8A2 52 59       >
  84+ E8A4             >                org     $-1                 // alter last byte of Name just above to set
  84+ E8A3 D9          >                db      {b $} | END_BIT     // msb as name end
  84+ E8A4             >
  84+ E8A4 8B 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
  84+ E8A6             >Prev_Ptr        defl    Heap_Ptr
  84+ E8A6             >
  84+ E8A6             >mirror_Ptr      defl    $
  84+ E8A6             >
  84+ E8A6 0A AD       >                dw      Dict_Ptr + 2        // xt
  84+ E8A8             >Heap_Ptr        defl    $ - $E000           // save current HP
  84+ E8A8             >
  84+ E8A8             >Current_HP      defl  $ - $E000             // used to set HP once!
  84+ E8A8             >
  84+ E8A8             >//              ______________________________________________________________________
  84+ E8A8             >//              Dictionary part
  84+ E8A8             >
  84+ E8A8             >                org     Dict_Ptr
  84+ AD08             >
  84+ AD08 A6 28       >                dw      mirror_Ptr - $E000 + Heap_offset
  84+ AD0A             >
  84+ AD0A             >VOCABULARY:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
  84+ AD0A CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
  84+ AD0D             >
  84+ AD0D             >
  84+ AD0D             >                endif           ; ok        // for other definitions it "points" the correct handler
  84+ AD0D             >                // Use of "; ok" to suppress "warning[fwdref]"
  84+ AD0D             >
  84+ AD0D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  85+ AD0D
  86+ AD0D 34 A7                        dw      CBUILDS
  87+ AD0F
  88+ AD0F E1 9B 81 A0                  dw      LIT, $A081, COMMA       // $81A0 ,
  88+ AD13 FA A3
  89+ AD15 84 A3 C7 A1                  dw      CURRENT, FETCH          // current @
  90+ AD19 17 A1 FA A3                  dw      CELL_MINUS, COMMA       // cell- ,
  91+ AD1D E4 A3                        dw      HERE                    // here
  92+ AD1F 42 A3 C7 A1                  dw      VOC_LINK, FETCH, COMMA  // voc-link @ ,
  92+ AD23 FA A3
  93+ AD25 42 A3 D1 A1                  dw      VOC_LINK, STORE         // voc-link !
  94+ AD29
  95+ AD29 3F A7                        dw      DOES_TO                 // does>
  96+ AD2B              Vocabulary_Does:
  97+ AD2B 12 A1                        dw      CELL_PLUS               // cell+
  98+ AD2D 7E A3 D1 A1                  dw      CONTEXT, STORE          // context !
  99+ AD31 90 A0                        dw      EXIT                    // ;
 100+ AD33
 101+ AD33              //  ______________________________________________________________________
 102+ AD33              //
 103+ AD33              // forth        --
 104+ AD33              // Name of the first vocabulary.
 105+ AD33              // It makes FORTH the CONTEXT vocabulary.
 106+ AD33              // Until new user vocabulary are defined, new colon-definitions becomes
 107+ AD33              // part of FORTH. It is immediate, so it will executed during the creation
 108+ AD33              // of a colon definition to be able to select the vocabulary.
 109+ AD33
 110+ AD33                              New_Def FORTH, "FORTH", Does_Ptr, is_immediate
 110+ AD33             >
 110+ AD33             >Dict_Ptr        defl    $
 110+ AD33             >
 110+ AD33             >//              ______________________________________________________________________
 110+ AD33             >//              Heap part
 110+ AD33             >
 110+ AD33             >
 110+ AD33             >                org     (Heap_Ptr & $1FFF) + $E000
 110+ E8A8             >
 110+ E8A8             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 110+ E8A8             >Latest_Definition defl  Heap_Ptr
 110+ E8A8             >
 110+ E8A8             >                // dummy db directives used to calculate length of namec
 110+ E8A8 46 4F 52 54 >                db      "FORTH"
 110+ E8AC 48          >
 110+ E8AD             >len_NFA         defl    $ - temp_NFA
 110+ E8AD             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 110+ E8A8             >
 110+ E8A8 C5          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 110+ E8A9 46 4F 52 54 >                db      "FORTH"               // name string in 7-bit ascii, but
 110+ E8AD 48          >
 110+ E8AE             >                org     $-1                 // alter last byte of Name just above to set
 110+ E8AD C8          >                db      {b $} | END_BIT     // msb as name end
 110+ E8AE             >
 110+ E8AE 99 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 110+ E8B0             >Prev_Ptr        defl    Heap_Ptr
 110+ E8B0             >
 110+ E8B0             >mirror_Ptr      defl    $
 110+ E8B0             >
 110+ E8B0 35 AD       >                dw      Dict_Ptr + 2        // xt
 110+ E8B2             >Heap_Ptr        defl    $ - $E000           // save current HP
 110+ E8B2             >
 110+ E8B2             >Current_HP      defl  $ - $E000             // used to set HP once!
 110+ E8B2             >
 110+ E8B2             >//              ______________________________________________________________________
 110+ E8B2             >//              Dictionary part
 110+ E8B2             >
 110+ E8B2             >                org     Dict_Ptr
 110+ AD33             >
 110+ AD33 B0 28       >                dw      mirror_Ptr - $E000 + Heap_offset
 110+ AD35             >
 110+ AD35             >FORTH:          if Does_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 110+ AD35 CD 4C A7    >                call    Does_Ptr ; ok        // for primitive definitions  actual code
 110+ AD38             >
 110+ AD38             >
 110+ AD38             >                endif           ; ok        // for other definitions it "points" the correct handler
 110+ AD38             >                // Use of "; ok" to suppress "warning[fwdref]"
 110+ AD38             >
 110+ AD38             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 111+ AD38 2B AD                        dw      Vocabulary_Does
 112+ AD3A 81 A0                        db      $81, $A0
 113+ AD3C              Forth_Latest_Ptr:
 114+ AD3C A8 08                        dw      Latest_Definition
 115+ AD3E              Voclink_Ptr:
 116+ AD3E 00 00                        dw      0
 117+ AD40              // Any new vocabulary is structured as follow:
 118+ AD40              // PFA+0 points to DOES> part of VOCABULARY to perform CELL+ CONTEXT !
 119+ AD40              // PFA+2 is 81,A0 i.e. a null-word used as LATEST in the new vocabulary
 120+ AD40              // PFA+4 always contains the LATEST word of this VOCABULARY.
 121+ AD40              //       at creations it points to the null-word of its parent vocabulary
 122+ AD40              //       that is normally FORTH, For example ASSEMBLER points FORTH's null-word
 123+ AD40              // PFA+6 is the pointer that builds up the vocabulary linked list.
 124+ AD40              //       FORTH has 0 here to signal the end of the list and user's variable
 125+ AD40              //       VOC-LINK points to PFA+6 of the newest vocabulary created.
 126+ AD40              //       While FORTH is the only vocabulary, VOC-LINK points to FORTH's PFA+6
 127+ AD40              //       When ASSEMBLER is created, its PFA+6 points to FORTH's PFA+6, and so on
 128+ AD40
 129+ AD40              //  ______________________________________________________________________
 130+ AD40              //
 131+ AD40              // definitions  --
 132+ AD40              // Used in the form  cccc DEFINITIONS
 133+ AD40              // set the CURRENT vocabulary at CONTEXT to insert new definitions in
 134+ AD40              // vocabulary cccc.
 135+ AD40                              Colon_Def DEFINITIONS, "DEFINITIONS", is_normal
 135+ AD40             >                New_Def  DEFINITIONS, "DEFINITIONS", Enter_Ptr, is_normal ; ok
 135+ AD40             >
 135+ AD40             >Dict_Ptr        defl    $
 135+ AD40             >
 135+ AD40             >//              ______________________________________________________________________
 135+ AD40             >//              Heap part
 135+ AD40             >
 135+ AD40             >
 135+ AD40             >                org     (Heap_Ptr & $1FFF) + $E000
 135+ E8B2             >
 135+ E8B2             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 135+ E8B2             >Latest_Definition defl  Heap_Ptr
 135+ E8B2             >
 135+ E8B2             >                // dummy db directives used to calculate length of namec
 135+ E8B2 44 45 46 49 >                db      "DEFINITIONS"
 135+ E8B6 4E 49 54 49 >
 135+ E8BA 4F 4E 53    >
 135+ E8BD             >len_NFA         defl    $ - temp_NFA
 135+ E8BD             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 135+ E8B2             >
 135+ E8B2 8B          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 135+ E8B3 44 45 46 49 >                db      "DEFINITIONS"               // name string in 7-bit ascii, but
 135+ E8B7 4E 49 54 49 >
 135+ E8BB 4F 4E 53    >
 135+ E8BE             >                org     $-1                 // alter last byte of Name just above to set
 135+ E8BD D3          >                db      {b $} | END_BIT     // msb as name end
 135+ E8BE             >
 135+ E8BE A8 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 135+ E8C0             >Prev_Ptr        defl    Heap_Ptr
 135+ E8C0             >
 135+ E8C0             >mirror_Ptr      defl    $
 135+ E8C0             >
 135+ E8C0 42 AD       >                dw      Dict_Ptr + 2        // xt
 135+ E8C2             >Heap_Ptr        defl    $ - $E000           // save current HP
 135+ E8C2             >
 135+ E8C2             >Current_HP      defl  $ - $E000             // used to set HP once!
 135+ E8C2             >
 135+ E8C2             >//              ______________________________________________________________________
 135+ E8C2             >//              Dictionary part
 135+ E8C2             >
 135+ E8C2             >                org     Dict_Ptr
 135+ AD40             >
 135+ AD40 C0 28       >                dw      mirror_Ptr - $E000 + Heap_offset
 135+ AD42             >
 135+ AD42             >DEFINITIONS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 135+ AD42 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 135+ AD45             >
 135+ AD45             >
 135+ AD45             >                endif           ; ok        // for other definitions it "points" the correct handler
 135+ AD45             >                // Use of "; ok" to suppress "warning[fwdref]"
 135+ AD45             >
 135+ AD45             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 136+ AD45 7E A3 C7 A1                  dw      CONTEXT, FETCH          // context @
 137+ AD49 84 A3 D1 A1                  dw      CURRENT, STORE          // current !
 138+ AD4D 90 A0                        dw      EXIT                    // ;
 139+ AD4F
 140+ AD4F              //  ______________________________________________________________________
 141+ AD4F              //
 142+ AD4F              // (            -- cccc )
 143+ AD4F              // the following text is interpreted as a comment until a closing )
 144+ AD4F                              Colon_Def COMMENT_BRAKET, "(", is_immediate
 144+ AD4F             >                New_Def  COMMENT_BRAKET, "(", Enter_Ptr, is_immediate ; ok
 144+ AD4F             >
 144+ AD4F             >Dict_Ptr        defl    $
 144+ AD4F             >
 144+ AD4F             >//              ______________________________________________________________________
 144+ AD4F             >//              Heap part
 144+ AD4F             >
 144+ AD4F             >
 144+ AD4F             >                org     (Heap_Ptr & $1FFF) + $E000
 144+ E8C2             >
 144+ E8C2             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 144+ E8C2             >Latest_Definition defl  Heap_Ptr
 144+ E8C2             >
 144+ E8C2             >                // dummy db directives used to calculate length of namec
 144+ E8C2 28          >                db      "("
 144+ E8C3             >len_NFA         defl    $ - temp_NFA
 144+ E8C3             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 144+ E8C2             >
 144+ E8C2 C1          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 144+ E8C3 28          >                db      "("               // name string in 7-bit ascii, but
 144+ E8C4             >                org     $-1                 // alter last byte of Name just above to set
 144+ E8C3 A8          >                db      {b $} | END_BIT     // msb as name end
 144+ E8C4             >
 144+ E8C4 B2 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 144+ E8C6             >Prev_Ptr        defl    Heap_Ptr
 144+ E8C6             >
 144+ E8C6             >mirror_Ptr      defl    $
 144+ E8C6             >
 144+ E8C6 51 AD       >                dw      Dict_Ptr + 2        // xt
 144+ E8C8             >Heap_Ptr        defl    $ - $E000           // save current HP
 144+ E8C8             >
 144+ E8C8             >Current_HP      defl  $ - $E000             // used to set HP once!
 144+ E8C8             >
 144+ E8C8             >//              ______________________________________________________________________
 144+ E8C8             >//              Dictionary part
 144+ E8C8             >
 144+ E8C8             >                org     Dict_Ptr
 144+ AD4F             >
 144+ AD4F C6 28       >                dw      mirror_Ptr - $E000 + Heap_offset
 144+ AD51             >
 144+ AD51             >COMMENT_BRAKET:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 144+ AD51 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 144+ AD54             >
 144+ AD54             >
 144+ AD54             >                endif           ; ok        // for other definitions it "points" the correct handler
 144+ AD54             >                // Use of "; ok" to suppress "warning[fwdref]"
 144+ AD54             >
 144+ AD54             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 145+ AD54 E1 9B 29 00                  dw      LIT, ")"                // [char] )
 146+ AD58 02 A9 4E A1                  dw      WORD, DROP              // word drop
 147+ AD5C 90 A0                        dw      EXIT                    // ;
 148+ AD5E
 149+ AD5E              //  ______________________________________________________________________
 150+ AD5E              //
 151+ AD5E              // quit         --
 152+ AD5E              // \ Erase the return-stack, stop any compilation and give controlo to the console. No message is issued.
 153+ AD5E                              Colon_Def QUIT, "QUIT", is_normal
 153+ AD5E             >                New_Def  QUIT, "QUIT", Enter_Ptr, is_normal ; ok
 153+ AD5E             >
 153+ AD5E             >Dict_Ptr        defl    $
 153+ AD5E             >
 153+ AD5E             >//              ______________________________________________________________________
 153+ AD5E             >//              Heap part
 153+ AD5E             >
 153+ AD5E             >
 153+ AD5E             >                org     (Heap_Ptr & $1FFF) + $E000
 153+ E8C8             >
 153+ E8C8             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 153+ E8C8             >Latest_Definition defl  Heap_Ptr
 153+ E8C8             >
 153+ E8C8             >                // dummy db directives used to calculate length of namec
 153+ E8C8 51 55 49 54 >                db      "QUIT"
 153+ E8CC             >len_NFA         defl    $ - temp_NFA
 153+ E8CC             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 153+ E8C8             >
 153+ E8C8 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 153+ E8C9 51 55 49 54 >                db      "QUIT"               // name string in 7-bit ascii, but
 153+ E8CD             >                org     $-1                 // alter last byte of Name just above to set
 153+ E8CC D4          >                db      {b $} | END_BIT     // msb as name end
 153+ E8CD             >
 153+ E8CD C2 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 153+ E8CF             >Prev_Ptr        defl    Heap_Ptr
 153+ E8CF             >
 153+ E8CF             >mirror_Ptr      defl    $
 153+ E8CF             >
 153+ E8CF 60 AD       >                dw      Dict_Ptr + 2        // xt
 153+ E8D1             >Heap_Ptr        defl    $ - $E000           // save current HP
 153+ E8D1             >
 153+ E8D1             >Current_HP      defl  $ - $E000             // used to set HP once!
 153+ E8D1             >
 153+ E8D1             >//              ______________________________________________________________________
 153+ E8D1             >//              Dictionary part
 153+ E8D1             >
 153+ E8D1             >                org     Dict_Ptr
 153+ AD5E             >
 153+ AD5E CF 28       >                dw      mirror_Ptr - $E000 + Heap_offset
 153+ AD60             >
 153+ AD60             >QUIT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 153+ AD60 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 153+ AD63             >
 153+ AD63             >
 153+ AD63             >                endif           ; ok        // for other definitions it "points" the correct handler
 153+ AD63             >                // Use of "; ok" to suppress "warning[fwdref]"
 153+ AD63             >
 153+ AD63             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 154+ AD63
 155+ AD63 CC A3 C7 A1                  dw      SOURCE_ID, FETCH        // source-id @
 156+ AD67 3D 9F 4E A1                  dw      F_CLOSE, DROP           // f_close drop
 157+ AD6B BF A2 CC A3                  dw      ZERO, SOURCE_ID, STORE  // 0 source-id !
 157+ AD6F D1 A1
 158+ AD71 BF A2 60 A3                  dw      ZERO, BLK, STORE        // 0 blk !
 158+ AD75 D1 A1
 159+ AD77 B0 A6                        dw      SQUARED_OPEN            // [compile] [
 160+ AD79                                                              // begin
 161+ AD79              Quit_Begin:
 162+ AD79 1E A3 C7 A1                  dw      R0, FETCH, RPSTORE      //      r0 @ rp!
 162+ AD7D 8B A0
 163+ AD7F F4 9D                        dw      CR                      //      cr
 164+ AD81 9F A8                        dw      QUERY                   //      query
 165+ AD83              Next_Breakpoint_1:
 166+ AD83 BF AC                        dw      INTERPRET               //      interpret
 167+ AD85 8A A3 C7 A1                  dw      STATE, FETCH, ZEQUAL    //      state @ 0=
 167+ AD89 B5 A0
 168+ AD8B                                                              //      if
 169+ AD8B 33 9C                        dw      ZBRANCH
 170+ AD8D 07 00                        dw      Quit_Endif - $
 171+ AD8F 4D A9                        dw          C_DOT_QUOTE
 172+ AD91 02 6F 6B                     db          2, "ok"             //          .( ok)
 173+ AD94              Quit_Endif:                                     //      else
 174+ AD94                                                              // again
 175+ AD94 26 9C                        dw      BRANCH
 176+ AD96 E3 FF                        dw      Quit_Begin - $
 177+ AD98 90 A0                        dw      EXIT                    // ;
 178+ AD9A
 179+ AD9A              //  ______________________________________________________________________
 180+ AD9A              //
 181+ AD9A              // abort        --
 182+ AD9A                              Colon_Def ABORT, "ABORT", is_normal
 182+ AD9A             >                New_Def  ABORT, "ABORT", Enter_Ptr, is_normal ; ok
 182+ AD9A             >
 182+ AD9A             >Dict_Ptr        defl    $
 182+ AD9A             >
 182+ AD9A             >//              ______________________________________________________________________
 182+ AD9A             >//              Heap part
 182+ AD9A             >
 182+ AD9A             >
 182+ AD9A             >                org     (Heap_Ptr & $1FFF) + $E000
 182+ E8D1             >
 182+ E8D1             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 182+ E8D1             >Latest_Definition defl  Heap_Ptr
 182+ E8D1             >
 182+ E8D1             >                // dummy db directives used to calculate length of namec
 182+ E8D1 41 42 4F 52 >                db      "ABORT"
 182+ E8D5 54          >
 182+ E8D6             >len_NFA         defl    $ - temp_NFA
 182+ E8D6             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 182+ E8D1             >
 182+ E8D1 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 182+ E8D2 41 42 4F 52 >                db      "ABORT"               // name string in 7-bit ascii, but
 182+ E8D6 54          >
 182+ E8D7             >                org     $-1                 // alter last byte of Name just above to set
 182+ E8D6 D4          >                db      {b $} | END_BIT     // msb as name end
 182+ E8D7             >
 182+ E8D7 C8 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 182+ E8D9             >Prev_Ptr        defl    Heap_Ptr
 182+ E8D9             >
 182+ E8D9             >mirror_Ptr      defl    $
 182+ E8D9             >
 182+ E8D9 9C AD       >                dw      Dict_Ptr + 2        // xt
 182+ E8DB             >Heap_Ptr        defl    $ - $E000           // save current HP
 182+ E8DB             >
 182+ E8DB             >Current_HP      defl  $ - $E000             // used to set HP once!
 182+ E8DB             >
 182+ E8DB             >//              ______________________________________________________________________
 182+ E8DB             >//              Dictionary part
 182+ E8DB             >
 182+ E8DB             >                org     Dict_Ptr
 182+ AD9A             >
 182+ AD9A D9 28       >                dw      mirror_Ptr - $E000 + Heap_offset
 182+ AD9C             >
 182+ AD9C             >ABORT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 182+ AD9C CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 182+ AD9F             >
 182+ AD9F             >
 182+ AD9F             >                endif           ; ok        // for other definitions it "points" the correct handler
 182+ AD9F             >                // Use of "; ok" to suppress "warning[fwdref]"
 182+ AD9F             >
 182+ AD9F             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 183+ AD9F 18 A3 C7 A1                  dw      S0, FETCH, SPSTORE      // s0 @ sp!
 183+ ADA3 80 A0
 184+ ADA5 F9 A6                        dw      DECIMAL                 // decimal
 185+ ADA7 35 AD                        dw      FORTH                   // [compile] forth
 186+ ADA9 42 AD                        dw      DEFINITIONS             // definitions
 187+ ADAB              Autoexec_Ptr:
 188+ ADAB 07 B8                        dw      AUTOEXEC                // autoexec, patched to noop
 189+ ADAD 60 AD                        dw      QUIT                    // quit
 190+ ADAF 90 A0                        dw      EXIT                    // ;
 191+ ADB1
 192+ ADB1              //  ______________________________________________________________________
 193+ ADB1              //
 194+ ADB1              // warm         --
 195+ ADB1                              Colon_Def WARM, "WARM", is_normal
 195+ ADB1             >                New_Def  WARM, "WARM", Enter_Ptr, is_normal ; ok
 195+ ADB1             >
 195+ ADB1             >Dict_Ptr        defl    $
 195+ ADB1             >
 195+ ADB1             >//              ______________________________________________________________________
 195+ ADB1             >//              Heap part
 195+ ADB1             >
 195+ ADB1             >
 195+ ADB1             >                org     (Heap_Ptr & $1FFF) + $E000
 195+ E8DB             >
 195+ E8DB             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 195+ E8DB             >Latest_Definition defl  Heap_Ptr
 195+ E8DB             >
 195+ E8DB             >                // dummy db directives used to calculate length of namec
 195+ E8DB 57 41 52 4D >                db      "WARM"
 195+ E8DF             >len_NFA         defl    $ - temp_NFA
 195+ E8DF             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 195+ E8DB             >
 195+ E8DB 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 195+ E8DC 57 41 52 4D >                db      "WARM"               // name string in 7-bit ascii, but
 195+ E8E0             >                org     $-1                 // alter last byte of Name just above to set
 195+ E8DF CD          >                db      {b $} | END_BIT     // msb as name end
 195+ E8E0             >
 195+ E8E0 D1 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 195+ E8E2             >Prev_Ptr        defl    Heap_Ptr
 195+ E8E2             >
 195+ E8E2             >mirror_Ptr      defl    $
 195+ E8E2             >
 195+ E8E2 B3 AD       >                dw      Dict_Ptr + 2        // xt
 195+ E8E4             >Heap_Ptr        defl    $ - $E000           // save current HP
 195+ E8E4             >
 195+ E8E4             >Current_HP      defl  $ - $E000             // used to set HP once!
 195+ E8E4             >
 195+ E8E4             >//              ______________________________________________________________________
 195+ E8E4             >//              Dictionary part
 195+ E8E4             >
 195+ E8E4             >                org     Dict_Ptr
 195+ ADB1             >
 195+ ADB1 E2 28       >                dw      mirror_Ptr - $E000 + Heap_offset
 195+ ADB3             >
 195+ ADB3             >WARM:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 195+ ADB3 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 195+ ADB6             >
 195+ ADB6             >
 195+ ADB6             >                endif           ; ok        // for other definitions it "points" the correct handler
 195+ ADB6             >                // Use of "; ok" to suppress "warning[fwdref]"
 195+ ADB6             >
 195+ ADB6             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 196+ ADB6 6F B0                        dw      BLK_INIT                // blk-init
 197+ ADB8 93 B7                        dw      SPLASH                  // splash
 198+ ADBA E1 9B 07 00                  dw      LIT, 7, EMIT            // 7 emit
 198+ ADBE 9E A4
 199+ ADC0 9C AD                        dw      ABORT                   // abort
 200+ ADC2 90 A0                        dw      EXIT                    // exit
 201+ ADC4
 202+ ADC4              //  ______________________________________________________________________
 203+ ADC4              //
 204+ ADC4              // cold         --
 205+ ADC4                              Colon_Def COLD, "COLD", is_normal
 205+ ADC4             >                New_Def  COLD, "COLD", Enter_Ptr, is_normal ; ok
 205+ ADC4             >
 205+ ADC4             >Dict_Ptr        defl    $
 205+ ADC4             >
 205+ ADC4             >//              ______________________________________________________________________
 205+ ADC4             >//              Heap part
 205+ ADC4             >
 205+ ADC4             >
 205+ ADC4             >                org     (Heap_Ptr & $1FFF) + $E000
 205+ E8E4             >
 205+ E8E4             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 205+ E8E4             >Latest_Definition defl  Heap_Ptr
 205+ E8E4             >
 205+ E8E4             >                // dummy db directives used to calculate length of namec
 205+ E8E4 43 4F 4C 44 >                db      "COLD"
 205+ E8E8             >len_NFA         defl    $ - temp_NFA
 205+ E8E8             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 205+ E8E4             >
 205+ E8E4 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 205+ E8E5 43 4F 4C 44 >                db      "COLD"               // name string in 7-bit ascii, but
 205+ E8E9             >                org     $-1                 // alter last byte of Name just above to set
 205+ E8E8 C4          >                db      {b $} | END_BIT     // msb as name end
 205+ E8E9             >
 205+ E8E9 DB 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 205+ E8EB             >Prev_Ptr        defl    Heap_Ptr
 205+ E8EB             >
 205+ E8EB             >mirror_Ptr      defl    $
 205+ E8EB             >
 205+ E8EB C6 AD       >                dw      Dict_Ptr + 2        // xt
 205+ E8ED             >Heap_Ptr        defl    $ - $E000           // save current HP
 205+ E8ED             >
 205+ E8ED             >Current_HP      defl  $ - $E000             // used to set HP once!
 205+ E8ED             >
 205+ E8ED             >//              ______________________________________________________________________
 205+ E8ED             >//              Dictionary part
 205+ E8ED             >
 205+ E8ED             >                org     Dict_Ptr
 205+ ADC4             >
 205+ ADC4 EB 28       >                dw      mirror_Ptr - $E000 + Heap_offset
 205+ ADC6             >
 205+ ADC6             >COLD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 205+ ADC6 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 205+ ADC9             >
 205+ ADC9             >
 205+ ADC9             >                endif           ; ok        // for other definitions it "points" the correct handler
 205+ ADC9             >                // Use of "; ok" to suppress "warning[fwdref]"
 205+ ADC9             >
 205+ ADC9             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 206+ ADC9 E1 9B B6 9B                  dw      LIT, S0_origin          // [ hex $12 +origin ] Literal
 207+ ADCD E1 9B D2 9B                  dw      LIT, USER_Pointer       // [ hex $3E +origin ] literal
 208+ ADD1 C7 A1                        dw      FETCH                   // @
 209+ ADD3 E1 9B 06 00                  dw      LIT, 6, PLUS            // 6 +
 209+ ADD7 E3 A0
 210+ ADD9 E1 9B 16 00                  dw      LIT, 22                 // 22
 211+ ADDD CB 9F                        dw      CMOVE
 212+ ADDF E1 9B B0 9B                  dw      LIT, Latest_origin      // [ hex 0C +origin ] literal
 213+ ADE3 C7 A1                        dw      FETCH                   // @
 214+ ADE5 E1 9B 3C AD                  dw      LIT, Forth_Latest_Ptr   // [ ' forth >body 4 + ] Literal
 215+ ADE9 D1 A1                        dw      STORE                   // !
 216+ ADEB BF A2 5A A3                  dw      ZERO, NMODE, STORE      // 0 nmode !
 216+ ADEF D1 A1
 217+ ADF1 48 A3 C7 A1                  dw      FIRST, FETCH, DUP       // first @ dup
 217+ ADF5 69 A1
 218+ ADF7 B4 A3 D1 A1                  dw      USE, STORE              // use !
 219+ ADFB BA A3 D1 A1                  dw      PREV, STORE             // prev !
 220+ ADFF E1 9B 04 00                  dw      LIT, 4, PLACE, STORE    // 4 place !
 220+ AE03 C6 A3 D1 A1
 221+ AE07              //              dw      LIT, 8
 222+ AE07              //              dw      LIT, FLAGS2, CSTORE     // 8 5C6A c!
 223+ AE07
 224+ AE07 B3 AD        Warm_Start:     dw      WARM
 225+ AE09 C6 AD        Cold_Start:     dw      COLD
 226+ AE0B 90 A0                        dw      EXIT
 227+ AE0D
 228+ AE0D              //  ______________________________________________________________________
 229+ AE0D              WarmRoutine:
 230+ AE0D              ColdRoutine:
 231+ AE0D DD 21 D8 9B                  ld      ix, Next_Ptr            // Inner Interpreter Pointer
 232+ AE11
 233+ AE11 D9                           exx
 234+ AE12 E5                           push    hl                      // save Basic's return address
 235+ AE13 D9                           exx
 236+ AE14 ED 73 AC 9B                  ld      (SP_Basic), sp
 237+ AE18
 238+ AE18                              // pre-set the four main 16-bit registers
 239+ AE18 ED 7B B6 9B                  ld      sp, (S0_origin)         // Calculator Stack Pointer
 240+ AE1C 2A B8 9B                     ld      hl, (R0_origin)         // Return Stack Pointer
 241+ AE1F                              // ld      de, (R0_origin)         // Return Stack Pointer
 242+ AE1F                              ldrphl
 242+ AE1F 22 D4 9B    >                ld      (RP_Pointer),hl
 243+ AE22 EB                           ex      de, hl
 244+ AE23 01 07 AE                     ld      bc, Warm_Start          // Instruction Pointer
 245+ AE26
 246+ AE26 38 02                        jr      c, Warm_Skip
 247+ AE28 03                           inc     bc
 248+ AE29 03                           inc     bc
 249+ AE2A              Warm_Skip:
 250+ AE2A                              next
 250+ AE2A DD E9       >                jp      (ix)
 251+ AE2C
 252+ AE2C              //  ______________________________________________________________________
 253+ AE2C              //
 254+ AE2C              // basic        --
 255+ AE2C                              New_Def BASIC, "BASIC", is_code, is_normal
 255+ AE2C             >
 255+ AE2C             >Dict_Ptr        defl    $
 255+ AE2C             >
 255+ AE2C             >//              ______________________________________________________________________
 255+ AE2C             >//              Heap part
 255+ AE2C             >
 255+ AE2C             >
 255+ AE2C             >                org     (Heap_Ptr & $1FFF) + $E000
 255+ E8ED             >
 255+ E8ED             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 255+ E8ED             >Latest_Definition defl  Heap_Ptr
 255+ E8ED             >
 255+ E8ED             >                // dummy db directives used to calculate length of namec
 255+ E8ED 42 41 53 49 >                db      "BASIC"
 255+ E8F1 43          >
 255+ E8F2             >len_NFA         defl    $ - temp_NFA
 255+ E8F2             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 255+ E8ED             >
 255+ E8ED 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 255+ E8EE 42 41 53 49 >                db      "BASIC"               // name string in 7-bit ascii, but
 255+ E8F2 43          >
 255+ E8F3             >                org     $-1                 // alter last byte of Name just above to set
 255+ E8F2 C3          >                db      {b $} | END_BIT     // msb as name end
 255+ E8F3             >
 255+ E8F3 E4 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 255+ E8F5             >Prev_Ptr        defl    Heap_Ptr
 255+ E8F5             >
 255+ E8F5             >mirror_Ptr      defl    $
 255+ E8F5             >
 255+ E8F5 2E AE       >                dw      Dict_Ptr + 2        // xt
 255+ E8F7             >Heap_Ptr        defl    $ - $E000           // save current HP
 255+ E8F7             >
 255+ E8F7             >Current_HP      defl  $ - $E000             // used to set HP once!
 255+ E8F7             >
 255+ E8F7             >//              ______________________________________________________________________
 255+ E8F7             >//              Dictionary part
 255+ E8F7             >
 255+ E8F7             >                org     Dict_Ptr
 255+ AE2C             >
 255+ AE2C F5 28       >                dw      mirror_Ptr - $E000 + Heap_offset
 255+ AE2E             >
 255+ AE2E             >BASIC:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
 255+ AE2E ~           >                call    runcode ; ok        // for primitive definitions  actual code
 255+ AE2E ~           >
 255+ AE2E ~           >
 255+ AE2E             >                endif           ; ok        // for other definitions it "points" the correct handler
 255+ AE2E             >                // Use of "; ok" to suppress "warning[fwdref]"
 255+ AE2E             >
 255+ AE2E             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 256+ AE2E C1                           pop     bc                      // return  TOS  value to Basic
 257+ AE2F 21 00 00                     ld      hl, 0
 258+ AE32 39                           add     hl, sp
 259+ AE33 ED 7B AC 9B                  ld      sp, (SP_Basic)          // restore Basic's SP
 260+ AE37              //              nop
 261+ AE37 22 AC 9B                     ld      (SP_Basic),hl           // but also save Forth's
 262+ AE3A D9                           exx
 263+ AE3B E1                           pop     hl                      // restore h'l'
 264+ AE3C D9                           exx
 265+ AE3D C9                           ret                             // to where USR Basic was left
 266+ AE3E
 267+ AE3E              //  ______________________________________________________________________
 268+ AE3E              //
 269+ AE3E              // +-           n1 n2 -- n3
 270+ AE3E              // leaves n1 with the sign of n2 as n3.
 271+ AE3E                              Colon_Def PLUS_MINUS, "+-", is_normal
 271+ AE3E             >                New_Def  PLUS_MINUS, "+-", Enter_Ptr, is_normal ; ok
 271+ AE3E             >
 271+ AE3E             >Dict_Ptr        defl    $
 271+ AE3E             >
 271+ AE3E             >//              ______________________________________________________________________
 271+ AE3E             >//              Heap part
 271+ AE3E             >
 271+ AE3E             >
 271+ AE3E             >                org     (Heap_Ptr & $1FFF) + $E000
 271+ E8F7             >
 271+ E8F7             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 271+ E8F7             >Latest_Definition defl  Heap_Ptr
 271+ E8F7             >
 271+ E8F7             >                // dummy db directives used to calculate length of namec
 271+ E8F7 2B 2D       >                db      "+-"
 271+ E8F9             >len_NFA         defl    $ - temp_NFA
 271+ E8F9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 271+ E8F7             >
 271+ E8F7 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 271+ E8F8 2B 2D       >                db      "+-"               // name string in 7-bit ascii, but
 271+ E8FA             >                org     $-1                 // alter last byte of Name just above to set
 271+ E8F9 AD          >                db      {b $} | END_BIT     // msb as name end
 271+ E8FA             >
 271+ E8FA ED 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 271+ E8FC             >Prev_Ptr        defl    Heap_Ptr
 271+ E8FC             >
 271+ E8FC             >mirror_Ptr      defl    $
 271+ E8FC             >
 271+ E8FC 40 AE       >                dw      Dict_Ptr + 2        // xt
 271+ E8FE             >Heap_Ptr        defl    $ - $E000           // save current HP
 271+ E8FE             >
 271+ E8FE             >Current_HP      defl  $ - $E000             // used to set HP once!
 271+ E8FE             >
 271+ E8FE             >//              ______________________________________________________________________
 271+ E8FE             >//              Dictionary part
 271+ E8FE             >
 271+ E8FE             >                org     Dict_Ptr
 271+ AE3E             >
 271+ AE3E FC 28       >                dw      mirror_Ptr - $E000 + Heap_offset
 271+ AE40             >
 271+ AE40             >PLUS_MINUS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 271+ AE40 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 271+ AE43             >
 271+ AE43             >
 271+ AE43             >                endif           ; ok        // for other definitions it "points" the correct handler
 271+ AE43             >                // Use of "; ok" to suppress "warning[fwdref]"
 271+ AE43             >
 271+ AE43             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 272+ AE43 C8 A0                        dw      ZLESS                   // 0<
 273+ AE45                                                              // if
 274+ AE45 33 9C                        dw      ZBRANCH
 275+ AE47 04 00                        dw      Plus_Minus_Endif - $
 276+ AE49 24 A1                        dw          MINUS               //      minus
 277+ AE4B              Plus_Minus_Endif:                               // endif
 278+ AE4B 90 A0                        dw      EXIT                    // ;
 279+ AE4D
 280+ AE4D              //  ______________________________________________________________________
 281+ AE4D              //
 282+ AE4D              // d+-          d1 n -- d2
 283+ AE4D              // leaves d1 with the sign of n as d2.
 284+ AE4D                              Colon_Def DPLUS_MINUS, "D+-", is_normal
 284+ AE4D             >                New_Def  DPLUS_MINUS, "D+-", Enter_Ptr, is_normal ; ok
 284+ AE4D             >
 284+ AE4D             >Dict_Ptr        defl    $
 284+ AE4D             >
 284+ AE4D             >//              ______________________________________________________________________
 284+ AE4D             >//              Heap part
 284+ AE4D             >
 284+ AE4D             >
 284+ AE4D             >                org     (Heap_Ptr & $1FFF) + $E000
 284+ E8FE             >
 284+ E8FE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 284+ E8FE             >Latest_Definition defl  Heap_Ptr
 284+ E8FE             >
 284+ E8FE             >                // dummy db directives used to calculate length of namec
 284+ E8FE 44 2B 2D    >                db      "D+-"
 284+ E901             >len_NFA         defl    $ - temp_NFA
 284+ E901             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 284+ E8FE             >
 284+ E8FE 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 284+ E8FF 44 2B 2D    >                db      "D+-"               // name string in 7-bit ascii, but
 284+ E902             >                org     $-1                 // alter last byte of Name just above to set
 284+ E901 AD          >                db      {b $} | END_BIT     // msb as name end
 284+ E902             >
 284+ E902 F7 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 284+ E904             >Prev_Ptr        defl    Heap_Ptr
 284+ E904             >
 284+ E904             >mirror_Ptr      defl    $
 284+ E904             >
 284+ E904 4F AE       >                dw      Dict_Ptr + 2        // xt
 284+ E906             >Heap_Ptr        defl    $ - $E000           // save current HP
 284+ E906             >
 284+ E906             >Current_HP      defl  $ - $E000             // used to set HP once!
 284+ E906             >
 284+ E906             >//              ______________________________________________________________________
 284+ E906             >//              Dictionary part
 284+ E906             >
 284+ E906             >                org     Dict_Ptr
 284+ AE4D             >
 284+ AE4D 04 29       >                dw      mirror_Ptr - $E000 + Heap_offset
 284+ AE4F             >
 284+ AE4F             >DPLUS_MINUS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 284+ AE4F CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 284+ AE52             >
 284+ AE52             >
 284+ AE52             >                endif           ; ok        // for other definitions it "points" the correct handler
 284+ AE52             >                // Use of "; ok" to suppress "warning[fwdref]"
 284+ AE52             >
 284+ AE52             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 285+ AE52 C8 A0                        dw      ZLESS                   // 0<
 286+ AE54                                                              // if
 287+ AE54 33 9C                        dw      ZBRANCH
 288+ AE56 04 00                        dw      DPlus_Minus_Endif - $
 289+ AE58 32 A1                        dw          DMINUS              //      dminus
 290+ AE5A              DPlus_Minus_Endif:                              // endif
 291+ AE5A 90 A0                        dw      EXIT                    // ;
 292+ AE5C
 293+ AE5C              //  ______________________________________________________________________
 294+ AE5C              //
 295+ AE5C              // abs          n1 -- n2
 296+ AE5C                              Colon_Def ABS_OP, "ABS", is_normal
 296+ AE5C             >                New_Def  ABS_OP, "ABS", Enter_Ptr, is_normal ; ok
 296+ AE5C             >
 296+ AE5C             >Dict_Ptr        defl    $
 296+ AE5C             >
 296+ AE5C             >//              ______________________________________________________________________
 296+ AE5C             >//              Heap part
 296+ AE5C             >
 296+ AE5C             >
 296+ AE5C             >                org     (Heap_Ptr & $1FFF) + $E000
 296+ E906             >
 296+ E906             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 296+ E906             >Latest_Definition defl  Heap_Ptr
 296+ E906             >
 296+ E906             >                // dummy db directives used to calculate length of namec
 296+ E906 41 42 53    >                db      "ABS"
 296+ E909             >len_NFA         defl    $ - temp_NFA
 296+ E909             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 296+ E906             >
 296+ E906 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 296+ E907 41 42 53    >                db      "ABS"               // name string in 7-bit ascii, but
 296+ E90A             >                org     $-1                 // alter last byte of Name just above to set
 296+ E909 D3          >                db      {b $} | END_BIT     // msb as name end
 296+ E90A             >
 296+ E90A FE 28       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 296+ E90C             >Prev_Ptr        defl    Heap_Ptr
 296+ E90C             >
 296+ E90C             >mirror_Ptr      defl    $
 296+ E90C             >
 296+ E90C 5E AE       >                dw      Dict_Ptr + 2        // xt
 296+ E90E             >Heap_Ptr        defl    $ - $E000           // save current HP
 296+ E90E             >
 296+ E90E             >Current_HP      defl  $ - $E000             // used to set HP once!
 296+ E90E             >
 296+ E90E             >//              ______________________________________________________________________
 296+ E90E             >//              Dictionary part
 296+ E90E             >
 296+ E90E             >                org     Dict_Ptr
 296+ AE5C             >
 296+ AE5C 0C 29       >                dw      mirror_Ptr - $E000 + Heap_offset
 296+ AE5E             >
 296+ AE5E             >ABS_OP:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 296+ AE5E CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 296+ AE61             >
 296+ AE61             >
 296+ AE61             >                endif           ; ok        // for other definitions it "points" the correct handler
 296+ AE61             >                // Use of "; ok" to suppress "warning[fwdref]"
 296+ AE61             >
 296+ AE61             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 297+ AE61 69 A1                        dw      DUP                     // dup
 298+ AE63 40 AE                        dw      PLUS_MINUS              // +-
 299+ AE65 90 A0                        dw      EXIT                    // ;
 300+ AE67
 301+ AE67              //  ______________________________________________________________________
 302+ AE67              //
 303+ AE67              // dabs         d1 -- d2
 304+ AE67                              Colon_Def DABS, "DABS", is_normal
 304+ AE67             >                New_Def  DABS, "DABS", Enter_Ptr, is_normal ; ok
 304+ AE67             >
 304+ AE67             >Dict_Ptr        defl    $
 304+ AE67             >
 304+ AE67             >//              ______________________________________________________________________
 304+ AE67             >//              Heap part
 304+ AE67             >
 304+ AE67             >
 304+ AE67             >                org     (Heap_Ptr & $1FFF) + $E000
 304+ E90E             >
 304+ E90E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 304+ E90E             >Latest_Definition defl  Heap_Ptr
 304+ E90E             >
 304+ E90E             >                // dummy db directives used to calculate length of namec
 304+ E90E 44 41 42 53 >                db      "DABS"
 304+ E912             >len_NFA         defl    $ - temp_NFA
 304+ E912             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 304+ E90E             >
 304+ E90E 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 304+ E90F 44 41 42 53 >                db      "DABS"               // name string in 7-bit ascii, but
 304+ E913             >                org     $-1                 // alter last byte of Name just above to set
 304+ E912 D3          >                db      {b $} | END_BIT     // msb as name end
 304+ E913             >
 304+ E913 06 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 304+ E915             >Prev_Ptr        defl    Heap_Ptr
 304+ E915             >
 304+ E915             >mirror_Ptr      defl    $
 304+ E915             >
 304+ E915 69 AE       >                dw      Dict_Ptr + 2        // xt
 304+ E917             >Heap_Ptr        defl    $ - $E000           // save current HP
 304+ E917             >
 304+ E917             >Current_HP      defl  $ - $E000             // used to set HP once!
 304+ E917             >
 304+ E917             >//              ______________________________________________________________________
 304+ E917             >//              Dictionary part
 304+ E917             >
 304+ E917             >                org     Dict_Ptr
 304+ AE67             >
 304+ AE67 15 29       >                dw      mirror_Ptr - $E000 + Heap_offset
 304+ AE69             >
 304+ AE69             >DABS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 304+ AE69 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 304+ AE6C             >
 304+ AE6C             >
 304+ AE6C             >                endif           ; ok        // for other definitions it "points" the correct handler
 304+ AE6C             >                // Use of "; ok" to suppress "warning[fwdref]"
 304+ AE6C             >
 304+ AE6C             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 305+ AE6C 69 A1                        dw      DUP                     // dup
 306+ AE6E 4F AE                        dw      DPLUS_MINUS             // d+-
 307+ AE70 90 A0                        dw      EXIT                    // ;
 308+ AE72
 309+ AE72              //  ______________________________________________________________________
 310+ AE72              //
 311+ AE72              // m*           n1 n2 -- d
 312+ AE72              // multiply two integer giving a double
 313+ AE72                              Colon_Def MMUL, "M*", is_normal
 313+ AE72             >                New_Def  MMUL, "M*", Enter_Ptr, is_normal ; ok
 313+ AE72             >
 313+ AE72             >Dict_Ptr        defl    $
 313+ AE72             >
 313+ AE72             >//              ______________________________________________________________________
 313+ AE72             >//              Heap part
 313+ AE72             >
 313+ AE72             >
 313+ AE72             >                org     (Heap_Ptr & $1FFF) + $E000
 313+ E917             >
 313+ E917             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 313+ E917             >Latest_Definition defl  Heap_Ptr
 313+ E917             >
 313+ E917             >                // dummy db directives used to calculate length of namec
 313+ E917 4D 2A       >                db      "M*"
 313+ E919             >len_NFA         defl    $ - temp_NFA
 313+ E919             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 313+ E917             >
 313+ E917 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 313+ E918 4D 2A       >                db      "M*"               // name string in 7-bit ascii, but
 313+ E91A             >                org     $-1                 // alter last byte of Name just above to set
 313+ E919 AA          >                db      {b $} | END_BIT     // msb as name end
 313+ E91A             >
 313+ E91A 0E 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 313+ E91C             >Prev_Ptr        defl    Heap_Ptr
 313+ E91C             >
 313+ E91C             >mirror_Ptr      defl    $
 313+ E91C             >
 313+ E91C 74 AE       >                dw      Dict_Ptr + 2        // xt
 313+ E91E             >Heap_Ptr        defl    $ - $E000           // save current HP
 313+ E91E             >
 313+ E91E             >Current_HP      defl  $ - $E000             // used to set HP once!
 313+ E91E             >
 313+ E91E             >//              ______________________________________________________________________
 313+ E91E             >//              Dictionary part
 313+ E91E             >
 313+ E91E             >                org     Dict_Ptr
 313+ AE72             >
 313+ AE72 1C 29       >                dw      mirror_Ptr - $E000 + Heap_offset
 313+ AE74             >
 313+ AE74             >MMUL:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 313+ AE74 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 313+ AE77             >
 313+ AE77             >
 313+ AE77             >                endif           ; ok        // for other definitions it "points" the correct handler
 313+ AE77             >                // Use of "; ok" to suppress "warning[fwdref]"
 313+ AE77             >
 313+ AE77             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 314+ AE77 A5 A1 68 A0                  dw      TWO_DUP, XOR_OP, TO_R   // 2dup xor >r
 314+ AE7B 9A A0
 315+ AE7D 5E AE 62 A1                  dw      ABS_OP, SWAP            // abs swap
 316+ AE81 5E AE EF 9F                  dw      ABS_OP, UM_MUL          // abs um*
 317+ AE85 A5 A0 4F AE                  dw      R_TO, DPLUS_MINUS       // r> d+-
 318+ AE89 90 A0                        dw      EXIT                    // ;
 319+ AE8B
 320+ AE8B              //  ______________________________________________________________________
 321+ AE8B              //
 322+ AE8B              // sm/rem       d n -- q r
 323+ AE8B              // Symmetric division: divides a double into n giving quotient q and remainder r
 324+ AE8B              // the remainder has the sign of d.
 325+ AE8B                              Colon_Def SMDIVM, "SM/REM", is_normal
 325+ AE8B             >                New_Def  SMDIVM, "SM/REM", Enter_Ptr, is_normal ; ok
 325+ AE8B             >
 325+ AE8B             >Dict_Ptr        defl    $
 325+ AE8B             >
 325+ AE8B             >//              ______________________________________________________________________
 325+ AE8B             >//              Heap part
 325+ AE8B             >
 325+ AE8B             >
 325+ AE8B             >                org     (Heap_Ptr & $1FFF) + $E000
 325+ E91E             >
 325+ E91E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 325+ E91E             >Latest_Definition defl  Heap_Ptr
 325+ E91E             >
 325+ E91E             >                // dummy db directives used to calculate length of namec
 325+ E91E 53 4D 2F 52 >                db      "SM/REM"
 325+ E922 45 4D       >
 325+ E924             >len_NFA         defl    $ - temp_NFA
 325+ E924             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 325+ E91E             >
 325+ E91E 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 325+ E91F 53 4D 2F 52 >                db      "SM/REM"               // name string in 7-bit ascii, but
 325+ E923 45 4D       >
 325+ E925             >                org     $-1                 // alter last byte of Name just above to set
 325+ E924 CD          >                db      {b $} | END_BIT     // msb as name end
 325+ E925             >
 325+ E925 17 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 325+ E927             >Prev_Ptr        defl    Heap_Ptr
 325+ E927             >
 325+ E927             >mirror_Ptr      defl    $
 325+ E927             >
 325+ E927 8D AE       >                dw      Dict_Ptr + 2        // xt
 325+ E929             >Heap_Ptr        defl    $ - $E000           // save current HP
 325+ E929             >
 325+ E929             >Current_HP      defl  $ - $E000             // used to set HP once!
 325+ E929             >
 325+ E929             >//              ______________________________________________________________________
 325+ E929             >//              Dictionary part
 325+ E929             >
 325+ E929             >                org     Dict_Ptr
 325+ AE8B             >
 325+ AE8B 27 29       >                dw      mirror_Ptr - $E000 + Heap_offset
 325+ AE8D             >
 325+ AE8D             >SMDIVM:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 325+ AE8D CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 325+ AE90             >
 325+ AE90             >
 325+ AE90             >                endif           ; ok        // for other definitions it "points" the correct handler
 325+ AE90             >                // Use of "; ok" to suppress "warning[fwdref]"
 325+ AE90             >
 325+ AE90             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 326+ AE90 45 A1 9A A0                  dw      OVER, TO_R, TO_R        // over >r >r
 326+ AE94 9A A0
 327+ AE96 69 AE B0 A0                  dw      DABS, R_OP, ABS_OP      // dabs r abs
 327+ AE9A 5E AE
 328+ AE9C 17 A0                        dw      UMDIVMOD                // um/mod
 329+ AE9E A5 A0                        dw      R_TO                    // r>
 330+ AEA0 B0 A0 68 A0                  dw      R_OP, XOR_OP            // r xor
 331+ AEA4 40 AE 62 A1                  dw      PLUS_MINUS, SWAP        // +- swap
 332+ AEA8 A5 A0                        dw      R_TO                    // r>
 333+ AEAA 40 AE 62 A1                  dw      PLUS_MINUS, SWAP        // +- swap
 334+ AEAE 90 A0                        dw      EXIT                    // ;
 335+ AEB0
 336+ AEB0              //  ______________________________________________________________________
 337+ AEB0              //
 338+ AEB0              // fm/mod       d n -- q r
 339+ AEB0              // Floored division: divides a double into n giving quotient q and remainder r
 340+ AEB0              // the remainder has the sign of d.
 341+ AEB0                              Colon_Def FMDIVM, "FM/MOD", is_normal
 341+ AEB0             >                New_Def  FMDIVM, "FM/MOD", Enter_Ptr, is_normal ; ok
 341+ AEB0             >
 341+ AEB0             >Dict_Ptr        defl    $
 341+ AEB0             >
 341+ AEB0             >//              ______________________________________________________________________
 341+ AEB0             >//              Heap part
 341+ AEB0             >
 341+ AEB0             >
 341+ AEB0             >                org     (Heap_Ptr & $1FFF) + $E000
 341+ E929             >
 341+ E929             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 341+ E929             >Latest_Definition defl  Heap_Ptr
 341+ E929             >
 341+ E929             >                // dummy db directives used to calculate length of namec
 341+ E929 46 4D 2F 4D >                db      "FM/MOD"
 341+ E92D 4F 44       >
 341+ E92F             >len_NFA         defl    $ - temp_NFA
 341+ E92F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 341+ E929             >
 341+ E929 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 341+ E92A 46 4D 2F 4D >                db      "FM/MOD"               // name string in 7-bit ascii, but
 341+ E92E 4F 44       >
 341+ E930             >                org     $-1                 // alter last byte of Name just above to set
 341+ E92F C4          >                db      {b $} | END_BIT     // msb as name end
 341+ E930             >
 341+ E930 1E 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 341+ E932             >Prev_Ptr        defl    Heap_Ptr
 341+ E932             >
 341+ E932             >mirror_Ptr      defl    $
 341+ E932             >
 341+ E932 B2 AE       >                dw      Dict_Ptr + 2        // xt
 341+ E934             >Heap_Ptr        defl    $ - $E000           // save current HP
 341+ E934             >
 341+ E934             >Current_HP      defl  $ - $E000             // used to set HP once!
 341+ E934             >
 341+ E934             >//              ______________________________________________________________________
 341+ E934             >//              Dictionary part
 341+ E934             >
 341+ E934             >                org     Dict_Ptr
 341+ AEB0             >
 341+ AEB0 32 29       >                dw      mirror_Ptr - $E000 + Heap_offset
 341+ AEB2             >
 341+ AEB2             >FMDIVM:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 341+ AEB2 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 341+ AEB5             >
 341+ AEB5             >
 341+ AEB5             >                endif           ; ok        // for other definitions it "points" the correct handler
 341+ AEB5             >                // Use of "; ok" to suppress "warning[fwdref]"
 341+ AEB5             >
 341+ AEB5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 342+ AEB5 69 A1 9A A0                  dw      DUP, TO_R               // dup >r
 343+ AEB9 8D AE                        dw      SMDIVM
 344+ AEBB 45 A1 69 A1                  dw      OVER, DUP
 345+ AEBF B5 A0 B5 A0                  dw      ZEQUAL, ZEQUAL
 346+ AEC3 62 A1 C8 A0                  dw      SWAP, ZLESS
 347+ AEC7 B0 A0 C8 A0                  dw      R_OP, ZLESS
 348+ AECB 68 A0 4A A0                  dw      XOR_OP, AND_OP
 349+ AECF 33 9C                        dw      ZBRANCH
 350+ AED1 10 00                        dw      Fm_Mod_Else - $
 351+ AED3 03 A1                        dw          ONE_SUBTRACT
 352+ AED5 62 A1 A5 A0                  dw          SWAP, R_TO
 353+ AED9 E3 A0 62 A1                  dw          PLUS, SWAP
 354+ AEDD 26 9C                        dw      BRANCH
 355+ AEDF 06 00                        dw      Fm_Mod_Endif - $
 356+ AEE1              Fm_Mod_Else:
 357+ AEE1 A5 A0 4E A1                  dw          R_TO, DROP
 358+ AEE5              Fm_Mod_Endif:
 359+ AEE5 90 A0                        dw      EXIT
 360+ AEE7              //              dw      TWO_DUP                 // 2dup
 361+ AEE7              //              dw      XOR_OP, TO_R, TO_R      // xor >r >r
 362+ AEE7              //              dw      DABS, R_OP, ABS_OP      // dabs r abs
 363+ AEE7              //              dw      UMDIVMOD                // um/mod
 364+ AEE7              //              dw      SWAP                    // swap
 365+ AEE7              //              dw      II, ZLESS               // i'
 366+ AEE7              //              dw      ONE, AND_OP, PLUS       // 0< 1 and +
 367+ AEE7              //              dw      R_TO                    // r>
 368+ AEE7              //              dw      PLUS_MINUS, SWAP        // +- swap
 369+ AEE7              //              dw      R_OP                    // r@
 370+ AEE7              //              dw      ZLESS                   // i'
 371+ AEE7              //              dw      ONE, AND_OP, PLUS       // 0< 1 and +
 372+ AEE7              //              dw      R_TO                    // r>
 373+ AEE7              //              dw      PLUS_MINUS              // +- swap
 374+ AEE7              //              dw      EXIT                    // ;
 375+ AEE7
 376+ AEE7              //  ______________________________________________________________________
 377+ AEE7              //
 378+ AEE7              // m/mod        d n -- q r
 379+ AEE7              // multiply two integer giving a double
 380+ AEE7                              Colon_Def MDIVM, "M/MOD", is_normal
 380+ AEE7             >                New_Def  MDIVM, "M/MOD", Enter_Ptr, is_normal ; ok
 380+ AEE7             >
 380+ AEE7             >Dict_Ptr        defl    $
 380+ AEE7             >
 380+ AEE7             >//              ______________________________________________________________________
 380+ AEE7             >//              Heap part
 380+ AEE7             >
 380+ AEE7             >
 380+ AEE7             >                org     (Heap_Ptr & $1FFF) + $E000
 380+ E934             >
 380+ E934             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 380+ E934             >Latest_Definition defl  Heap_Ptr
 380+ E934             >
 380+ E934             >                // dummy db directives used to calculate length of namec
 380+ E934 4D 2F 4D 4F >                db      "M/MOD"
 380+ E938 44          >
 380+ E939             >len_NFA         defl    $ - temp_NFA
 380+ E939             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 380+ E934             >
 380+ E934 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 380+ E935 4D 2F 4D 4F >                db      "M/MOD"               // name string in 7-bit ascii, but
 380+ E939 44          >
 380+ E93A             >                org     $-1                 // alter last byte of Name just above to set
 380+ E939 C4          >                db      {b $} | END_BIT     // msb as name end
 380+ E93A             >
 380+ E93A 29 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 380+ E93C             >Prev_Ptr        defl    Heap_Ptr
 380+ E93C             >
 380+ E93C             >mirror_Ptr      defl    $
 380+ E93C             >
 380+ E93C E9 AE       >                dw      Dict_Ptr + 2        // xt
 380+ E93E             >Heap_Ptr        defl    $ - $E000           // save current HP
 380+ E93E             >
 380+ E93E             >Current_HP      defl  $ - $E000             // used to set HP once!
 380+ E93E             >
 380+ E93E             >//              ______________________________________________________________________
 380+ E93E             >//              Dictionary part
 380+ E93E             >
 380+ E93E             >                org     Dict_Ptr
 380+ AEE7             >
 380+ AEE7 3C 29       >                dw      mirror_Ptr - $E000 + Heap_offset
 380+ AEE9             >
 380+ AEE9             >MDIVM:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 380+ AEE9 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 380+ AEEC             >
 380+ AEEC             >
 380+ AEEC             >                endif           ; ok        // for other definitions it "points" the correct handler
 380+ AEEC             >                // Use of "; ok" to suppress "warning[fwdref]"
 380+ AEEC             >
 380+ AEEC             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 381+ AEEC 8D AE                        dw      SMDIVM
 382+ AEEE 90 A0                        dw      EXIT                    // ;
 383+ AEF0
 384+ AEF0              //  ______________________________________________________________________
 385+ AEF0              //
 386+ AEF0              // m/           d n -- q
 387+ AEF0              // multiply two integer giving a double
 388+ AEF0                              Colon_Def MDIV, "M/", is_normal
 388+ AEF0             >                New_Def  MDIV, "M/", Enter_Ptr, is_normal ; ok
 388+ AEF0             >
 388+ AEF0             >Dict_Ptr        defl    $
 388+ AEF0             >
 388+ AEF0             >//              ______________________________________________________________________
 388+ AEF0             >//              Heap part
 388+ AEF0             >
 388+ AEF0             >
 388+ AEF0             >                org     (Heap_Ptr & $1FFF) + $E000
 388+ E93E             >
 388+ E93E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 388+ E93E             >Latest_Definition defl  Heap_Ptr
 388+ E93E             >
 388+ E93E             >                // dummy db directives used to calculate length of namec
 388+ E93E 4D 2F       >                db      "M/"
 388+ E940             >len_NFA         defl    $ - temp_NFA
 388+ E940             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 388+ E93E             >
 388+ E93E 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 388+ E93F 4D 2F       >                db      "M/"               // name string in 7-bit ascii, but
 388+ E941             >                org     $-1                 // alter last byte of Name just above to set
 388+ E940 AF          >                db      {b $} | END_BIT     // msb as name end
 388+ E941             >
 388+ E941 34 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 388+ E943             >Prev_Ptr        defl    Heap_Ptr
 388+ E943             >
 388+ E943             >mirror_Ptr      defl    $
 388+ E943             >
 388+ E943 F2 AE       >                dw      Dict_Ptr + 2        // xt
 388+ E945             >Heap_Ptr        defl    $ - $E000           // save current HP
 388+ E945             >
 388+ E945             >Current_HP      defl  $ - $E000             // used to set HP once!
 388+ E945             >
 388+ E945             >//              ______________________________________________________________________
 388+ E945             >//              Dictionary part
 388+ E945             >
 388+ E945             >                org     Dict_Ptr
 388+ AEF0             >
 388+ AEF0 43 29       >                dw      mirror_Ptr - $E000 + Heap_offset
 388+ AEF2             >
 388+ AEF2             >MDIV:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 388+ AEF2 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 388+ AEF5             >
 388+ AEF5             >
 388+ AEF5             >                endif           ; ok        // for other definitions it "points" the correct handler
 388+ AEF5             >                // Use of "; ok" to suppress "warning[fwdref]"
 388+ AEF5             >
 388+ AEF5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 389+ AEF5 E9 AE 53 A1                  dw      MDIVM, NIP
 390+ AEF9 90 A0                        dw      EXIT                    // ;
 391+ AEFB
 392+ AEFB              //  ______________________________________________________________________
 393+ AEFB              //
 394+ AEFB              // *            n1 n2 -- n3
 395+ AEFB              // multiply two integer
 396+ AEFB                              Colon_Def MUL, "*", is_normal
 396+ AEFB             >                New_Def  MUL, "*", Enter_Ptr, is_normal ; ok
 396+ AEFB             >
 396+ AEFB             >Dict_Ptr        defl    $
 396+ AEFB             >
 396+ AEFB             >//              ______________________________________________________________________
 396+ AEFB             >//              Heap part
 396+ AEFB             >
 396+ AEFB             >
 396+ AEFB             >                org     (Heap_Ptr & $1FFF) + $E000
 396+ E945             >
 396+ E945             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 396+ E945             >Latest_Definition defl  Heap_Ptr
 396+ E945             >
 396+ E945             >                // dummy db directives used to calculate length of namec
 396+ E945 2A          >                db      "*"
 396+ E946             >len_NFA         defl    $ - temp_NFA
 396+ E946             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 396+ E945             >
 396+ E945 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 396+ E946 2A          >                db      "*"               // name string in 7-bit ascii, but
 396+ E947             >                org     $-1                 // alter last byte of Name just above to set
 396+ E946 AA          >                db      {b $} | END_BIT     // msb as name end
 396+ E947             >
 396+ E947 3E 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 396+ E949             >Prev_Ptr        defl    Heap_Ptr
 396+ E949             >
 396+ E949             >mirror_Ptr      defl    $
 396+ E949             >
 396+ E949 FD AE       >                dw      Dict_Ptr + 2        // xt
 396+ E94B             >Heap_Ptr        defl    $ - $E000           // save current HP
 396+ E94B             >
 396+ E94B             >Current_HP      defl  $ - $E000             // used to set HP once!
 396+ E94B             >
 396+ E94B             >//              ______________________________________________________________________
 396+ E94B             >//              Dictionary part
 396+ E94B             >
 396+ E94B             >                org     Dict_Ptr
 396+ AEFB             >
 396+ AEFB 49 29       >                dw      mirror_Ptr - $E000 + Heap_offset
 396+ AEFD             >
 396+ AEFD             >MUL:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 396+ AEFD CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 396+ AF00             >
 396+ AF00             >
 396+ AF00             >                endif           ; ok        // for other definitions it "points" the correct handler
 396+ AF00             >                // Use of "; ok" to suppress "warning[fwdref]"
 396+ AF00             >
 396+ AF00             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 397+ AF00 74 AE 4E A1                  dw      MMUL, DROP              // m* drop
 398+ AF04 90 A0                        dw      EXIT                    // ;
 399+ AF06
 400+ AF06              //  ______________________________________________________________________
 401+ AF06              //
 402+ AF06              // /mod         n1 n2 -- n3 n4
 403+ AF06              // leaves quotient n4 and remainder n3 of the integer division n1 / n2.
 404+ AF06              // The remainder has the sign of n1
 405+ AF06                              Colon_Def DIVMOD, "/MOD", is_normal
 405+ AF06             >                New_Def  DIVMOD, "/MOD", Enter_Ptr, is_normal ; ok
 405+ AF06             >
 405+ AF06             >Dict_Ptr        defl    $
 405+ AF06             >
 405+ AF06             >//              ______________________________________________________________________
 405+ AF06             >//              Heap part
 405+ AF06             >
 405+ AF06             >
 405+ AF06             >                org     (Heap_Ptr & $1FFF) + $E000
 405+ E94B             >
 405+ E94B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 405+ E94B             >Latest_Definition defl  Heap_Ptr
 405+ E94B             >
 405+ E94B             >                // dummy db directives used to calculate length of namec
 405+ E94B 2F 4D 4F 44 >                db      "/MOD"
 405+ E94F             >len_NFA         defl    $ - temp_NFA
 405+ E94F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 405+ E94B             >
 405+ E94B 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 405+ E94C 2F 4D 4F 44 >                db      "/MOD"               // name string in 7-bit ascii, but
 405+ E950             >                org     $-1                 // alter last byte of Name just above to set
 405+ E94F C4          >                db      {b $} | END_BIT     // msb as name end
 405+ E950             >
 405+ E950 45 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 405+ E952             >Prev_Ptr        defl    Heap_Ptr
 405+ E952             >
 405+ E952             >mirror_Ptr      defl    $
 405+ E952             >
 405+ E952 08 AF       >                dw      Dict_Ptr + 2        // xt
 405+ E954             >Heap_Ptr        defl    $ - $E000           // save current HP
 405+ E954             >
 405+ E954             >Current_HP      defl  $ - $E000             // used to set HP once!
 405+ E954             >
 405+ E954             >//              ______________________________________________________________________
 405+ E954             >//              Dictionary part
 405+ E954             >
 405+ E954             >                org     Dict_Ptr
 405+ AF06             >
 405+ AF06 52 29       >                dw      mirror_Ptr - $E000 + Heap_offset
 405+ AF08             >
 405+ AF08             >DIVMOD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 405+ AF08 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 405+ AF0B             >
 405+ AF0B             >
 405+ AF0B             >                endif           ; ok        // for other definitions it "points" the correct handler
 405+ AF0B             >                // Use of "; ok" to suppress "warning[fwdref]"
 405+ AF0B             >
 405+ AF0B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 406+ AF0B 9A A0 18 A4                  dw      TO_R, S_TO_D, R_TO      // >r s->d r>
 406+ AF0F A5 A0
 407+ AF11 E9 AE                        dw      MDIVM                   // m/mod
 408+ AF13 90 A0                        dw      EXIT                    // ;
 409+ AF15
 410+ AF15              //  ______________________________________________________________________
 411+ AF15              //
 412+ AF15              // /            n1 n2 -- n3
 413+ AF15              // division
 414+ AF15                              Colon_Def DIV, "/", is_normal
 414+ AF15             >                New_Def  DIV, "/", Enter_Ptr, is_normal ; ok
 414+ AF15             >
 414+ AF15             >Dict_Ptr        defl    $
 414+ AF15             >
 414+ AF15             >//              ______________________________________________________________________
 414+ AF15             >//              Heap part
 414+ AF15             >
 414+ AF15             >
 414+ AF15             >                org     (Heap_Ptr & $1FFF) + $E000
 414+ E954             >
 414+ E954             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 414+ E954             >Latest_Definition defl  Heap_Ptr
 414+ E954             >
 414+ E954             >                // dummy db directives used to calculate length of namec
 414+ E954 2F          >                db      "/"
 414+ E955             >len_NFA         defl    $ - temp_NFA
 414+ E955             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 414+ E954             >
 414+ E954 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 414+ E955 2F          >                db      "/"               // name string in 7-bit ascii, but
 414+ E956             >                org     $-1                 // alter last byte of Name just above to set
 414+ E955 AF          >                db      {b $} | END_BIT     // msb as name end
 414+ E956             >
 414+ E956 4B 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 414+ E958             >Prev_Ptr        defl    Heap_Ptr
 414+ E958             >
 414+ E958             >mirror_Ptr      defl    $
 414+ E958             >
 414+ E958 17 AF       >                dw      Dict_Ptr + 2        // xt
 414+ E95A             >Heap_Ptr        defl    $ - $E000           // save current HP
 414+ E95A             >
 414+ E95A             >Current_HP      defl  $ - $E000             // used to set HP once!
 414+ E95A             >
 414+ E95A             >//              ______________________________________________________________________
 414+ E95A             >//              Dictionary part
 414+ E95A             >
 414+ E95A             >                org     Dict_Ptr
 414+ AF15             >
 414+ AF15 58 29       >                dw      mirror_Ptr - $E000 + Heap_offset
 414+ AF17             >
 414+ AF17             >DIV:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 414+ AF17 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 414+ AF1A             >
 414+ AF1A             >
 414+ AF1A             >                endif           ; ok        // for other definitions it "points" the correct handler
 414+ AF1A             >                // Use of "; ok" to suppress "warning[fwdref]"
 414+ AF1A             >
 414+ AF1A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 415+ AF1A 08 AF 53 A1                  dw      DIVMOD, NIP             // /mod nip
 416+ AF1E 90 A0                        dw      EXIT                    // ;
 417+ AF20
 418+ AF20              //  ______________________________________________________________________
 419+ AF20              //
 420+ AF20              // mod          n1 n2 -- n3
 421+ AF20                              Colon_Def MOD, "MOD", is_normal
 421+ AF20             >                New_Def  MOD, "MOD", Enter_Ptr, is_normal ; ok
 421+ AF20             >
 421+ AF20             >Dict_Ptr        defl    $
 421+ AF20             >
 421+ AF20             >//              ______________________________________________________________________
 421+ AF20             >//              Heap part
 421+ AF20             >
 421+ AF20             >
 421+ AF20             >                org     (Heap_Ptr & $1FFF) + $E000
 421+ E95A             >
 421+ E95A             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 421+ E95A             >Latest_Definition defl  Heap_Ptr
 421+ E95A             >
 421+ E95A             >                // dummy db directives used to calculate length of namec
 421+ E95A 4D 4F 44    >                db      "MOD"
 421+ E95D             >len_NFA         defl    $ - temp_NFA
 421+ E95D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 421+ E95A             >
 421+ E95A 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 421+ E95B 4D 4F 44    >                db      "MOD"               // name string in 7-bit ascii, but
 421+ E95E             >                org     $-1                 // alter last byte of Name just above to set
 421+ E95D C4          >                db      {b $} | END_BIT     // msb as name end
 421+ E95E             >
 421+ E95E 54 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 421+ E960             >Prev_Ptr        defl    Heap_Ptr
 421+ E960             >
 421+ E960             >mirror_Ptr      defl    $
 421+ E960             >
 421+ E960 22 AF       >                dw      Dict_Ptr + 2        // xt
 421+ E962             >Heap_Ptr        defl    $ - $E000           // save current HP
 421+ E962             >
 421+ E962             >Current_HP      defl  $ - $E000             // used to set HP once!
 421+ E962             >
 421+ E962             >//              ______________________________________________________________________
 421+ E962             >//              Dictionary part
 421+ E962             >
 421+ E962             >                org     Dict_Ptr
 421+ AF20             >
 421+ AF20 60 29       >                dw      mirror_Ptr - $E000 + Heap_offset
 421+ AF22             >
 421+ AF22             >MOD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 421+ AF22 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 421+ AF25             >
 421+ AF25             >
 421+ AF25             >                endif           ; ok        // for other definitions it "points" the correct handler
 421+ AF25             >                // Use of "; ok" to suppress "warning[fwdref]"
 421+ AF25             >
 421+ AF25             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 422+ AF25 08 AF 4E A1                  dw      DIVMOD, DROP            // /mod drop
 423+ AF29 90 A0                        dw      EXIT                    // ;
 424+ AF2B
 425+ AF2B              //  ______________________________________________________________________
 426+ AF2B              //
 427+ AF2B              // */mod        n1 n2 n3 -- n4 n5
 428+ AF2B              // leaves the quotient n5 and the remainder n4 of the operation
 429+ AF2B              // (n1 * n2) / n3. The intermediate passage through a double number
 430+ AF2B              // avoids loss of precision
 431+ AF2B                              Colon_Def MUL_DIV_MOD, "*/MOD", is_normal
 431+ AF2B             >                New_Def  MUL_DIV_MOD, "*/MOD", Enter_Ptr, is_normal ; ok
 431+ AF2B             >
 431+ AF2B             >Dict_Ptr        defl    $
 431+ AF2B             >
 431+ AF2B             >//              ______________________________________________________________________
 431+ AF2B             >//              Heap part
 431+ AF2B             >
 431+ AF2B             >
 431+ AF2B             >                org     (Heap_Ptr & $1FFF) + $E000
 431+ E962             >
 431+ E962             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 431+ E962             >Latest_Definition defl  Heap_Ptr
 431+ E962             >
 431+ E962             >                // dummy db directives used to calculate length of namec
 431+ E962 2A 2F 4D 4F >                db      "*/MOD"
 431+ E966 44          >
 431+ E967             >len_NFA         defl    $ - temp_NFA
 431+ E967             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 431+ E962             >
 431+ E962 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 431+ E963 2A 2F 4D 4F >                db      "*/MOD"               // name string in 7-bit ascii, but
 431+ E967 44          >
 431+ E968             >                org     $-1                 // alter last byte of Name just above to set
 431+ E967 C4          >                db      {b $} | END_BIT     // msb as name end
 431+ E968             >
 431+ E968 5A 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 431+ E96A             >Prev_Ptr        defl    Heap_Ptr
 431+ E96A             >
 431+ E96A             >mirror_Ptr      defl    $
 431+ E96A             >
 431+ E96A 2D AF       >                dw      Dict_Ptr + 2        // xt
 431+ E96C             >Heap_Ptr        defl    $ - $E000           // save current HP
 431+ E96C             >
 431+ E96C             >Current_HP      defl  $ - $E000             // used to set HP once!
 431+ E96C             >
 431+ E96C             >//              ______________________________________________________________________
 431+ E96C             >//              Dictionary part
 431+ E96C             >
 431+ E96C             >                org     Dict_Ptr
 431+ AF2B             >
 431+ AF2B 6A 29       >                dw      mirror_Ptr - $E000 + Heap_offset
 431+ AF2D             >
 431+ AF2D             >MUL_DIV_MOD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 431+ AF2D CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 431+ AF30             >
 431+ AF30             >
 431+ AF30             >                endif           ; ok        // for other definitions it "points" the correct handler
 431+ AF30             >                // Use of "; ok" to suppress "warning[fwdref]"
 431+ AF30             >
 431+ AF30             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 432+ AF30 9A A0 74 AE                  dw      TO_R, MMUL              // >r  m*
 433+ AF34 A5 A0 E9 AE                  dw      R_TO, MDIVM             // r>  m/mod
 434+ AF38 90 A0                        dw      EXIT                    // ;
 435+ AF3A
 436+ AF3A              //  ______________________________________________________________________
 437+ AF3A              //
 438+ AF3A              // */          n1 n2 n3 -- n4
 439+ AF3A              // (n1 * n2) / n3. The intermediate passage through a double number avoids loss of precision
 440+ AF3A                              Colon_Def MUL_DIV, "*/", is_normal
 440+ AF3A             >                New_Def  MUL_DIV, "*/", Enter_Ptr, is_normal ; ok
 440+ AF3A             >
 440+ AF3A             >Dict_Ptr        defl    $
 440+ AF3A             >
 440+ AF3A             >//              ______________________________________________________________________
 440+ AF3A             >//              Heap part
 440+ AF3A             >
 440+ AF3A             >
 440+ AF3A             >                org     (Heap_Ptr & $1FFF) + $E000
 440+ E96C             >
 440+ E96C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 440+ E96C             >Latest_Definition defl  Heap_Ptr
 440+ E96C             >
 440+ E96C             >                // dummy db directives used to calculate length of namec
 440+ E96C 2A 2F       >                db      "*/"
 440+ E96E             >len_NFA         defl    $ - temp_NFA
 440+ E96E             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 440+ E96C             >
 440+ E96C 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 440+ E96D 2A 2F       >                db      "*/"               // name string in 7-bit ascii, but
 440+ E96F             >                org     $-1                 // alter last byte of Name just above to set
 440+ E96E AF          >                db      {b $} | END_BIT     // msb as name end
 440+ E96F             >
 440+ E96F 62 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 440+ E971             >Prev_Ptr        defl    Heap_Ptr
 440+ E971             >
 440+ E971             >mirror_Ptr      defl    $
 440+ E971             >
 440+ E971 3C AF       >                dw      Dict_Ptr + 2        // xt
 440+ E973             >Heap_Ptr        defl    $ - $E000           // save current HP
 440+ E973             >
 440+ E973             >Current_HP      defl  $ - $E000             // used to set HP once!
 440+ E973             >
 440+ E973             >//              ______________________________________________________________________
 440+ E973             >//              Dictionary part
 440+ E973             >
 440+ E973             >                org     Dict_Ptr
 440+ AF3A             >
 440+ AF3A 71 29       >                dw      mirror_Ptr - $E000 + Heap_offset
 440+ AF3C             >
 440+ AF3C             >MUL_DIV:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 440+ AF3C CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 440+ AF3F             >
 440+ AF3F             >
 440+ AF3F             >                endif           ; ok        // for other definitions it "points" the correct handler
 440+ AF3F             >                // Use of "; ok" to suppress "warning[fwdref]"
 440+ AF3F             >
 440+ AF3F             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 441+ AF3F 2D AF                        dw     MUL_DIV_MOD              // */mod
 442+ AF41 53 A1                        dw     NIP                      // nip
 443+ AF43 90 A0                        dw     EXIT                     // ;
 444+ AF45
 445+ AF45
 446+ AF45              //  ______________________________________________________________________
 447+ AF45              //
 448+ AF45              // m/mod        ud1 u2 -- u3 ud4
 449+ AF45              // mixed operation: it leaves the remainder u3 and the quotient ud4 of ud1 / u1.
 450+ AF45              // All terms are unsigned.
 451+ AF45              //              Colon_Def MDIV_MOD, "M/MOD", is_normal
 452+ AF45              //              dw      TO_R                    // >r           ( ud1 )
 453+ AF45              //              dw      ZERO, R_OP, UMDIVMOD    // 0 r um/mod   ( l rem1 h/r )
 454+ AF45              //              dw      R_TO, SWAP, TO_R        // r> swap >r   ( l rem )
 455+ AF45              //              dw      UMDIVMOD                // um/mod       ( rem2 l/r )
 456+ AF45              //              dw      R_TO                    // r>           ( rem2 l/r h/r )
 457+ AF45              //              dw      EXIT                    // ;
 458+ AF45
 459+ AF45              //  ______________________________________________________________________
 460+ AF45              //
 461+ AF45              // (line)       n1 n2 -- a b
 462+ AF45              // sends the line n1 of block n2 to the disk buffer.
 463+ AF45              // it returns the address a and ca counter b = C/L meaning a whole line.
 464+ AF45                              Colon_Def CLINE, "(LINE)", is_normal
 464+ AF45             >                New_Def  CLINE, "(LINE)", Enter_Ptr, is_normal ; ok
 464+ AF45             >
 464+ AF45             >Dict_Ptr        defl    $
 464+ AF45             >
 464+ AF45             >//              ______________________________________________________________________
 464+ AF45             >//              Heap part
 464+ AF45             >
 464+ AF45             >
 464+ AF45             >                org     (Heap_Ptr & $1FFF) + $E000
 464+ E973             >
 464+ E973             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 464+ E973             >Latest_Definition defl  Heap_Ptr
 464+ E973             >
 464+ E973             >                // dummy db directives used to calculate length of namec
 464+ E973 28 4C 49 4E >                db      "(LINE)"
 464+ E977 45 29       >
 464+ E979             >len_NFA         defl    $ - temp_NFA
 464+ E979             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 464+ E973             >
 464+ E973 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 464+ E974 28 4C 49 4E >                db      "(LINE)"               // name string in 7-bit ascii, but
 464+ E978 45 29       >
 464+ E97A             >                org     $-1                 // alter last byte of Name just above to set
 464+ E979 A9          >                db      {b $} | END_BIT     // msb as name end
 464+ E97A             >
 464+ E97A 6C 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 464+ E97C             >Prev_Ptr        defl    Heap_Ptr
 464+ E97C             >
 464+ E97C             >mirror_Ptr      defl    $
 464+ E97C             >
 464+ E97C 47 AF       >                dw      Dict_Ptr + 2        // xt
 464+ E97E             >Heap_Ptr        defl    $ - $E000           // save current HP
 464+ E97E             >
 464+ E97E             >Current_HP      defl  $ - $E000             // used to set HP once!
 464+ E97E             >
 464+ E97E             >//              ______________________________________________________________________
 464+ E97E             >//              Dictionary part
 464+ E97E             >
 464+ E97E             >                org     Dict_Ptr
 464+ AF45             >
 464+ AF45 7C 29       >                dw      mirror_Ptr - $E000 + Heap_offset
 464+ AF47             >
 464+ AF47             >CLINE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 464+ AF47 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 464+ AF4A             >
 464+ AF4A             >
 464+ AF4A             >                endif           ; ok        // for other definitions it "points" the correct handler
 464+ AF4A             >                // Use of "; ok" to suppress "warning[fwdref]"
 464+ AF4A             >
 464+ AF4A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 465+ AF4A 9A A0                        dw      TO_R                    // >r
 466+ AF4C E9 A2                        dw      CL                      // c/l
 467+ AF4E F0 A2 2D AF                  dw      BBUF, MUL_DIV_MOD       // */mod
 468+ AF52 A5 A0                        dw      R_TO                    // r>
 469+ AF54 F7 A2 FD AE                  dw      BSCR, MUL, PLUS         // b/scr * +
 469+ AF58 E3 A0
 470+ AF5A 5E B1                        dw      BLOCK                   // block   ( forward )
 471+ AF5C E3 A0                        dw      PLUS                    // +
 472+ AF5E E9 A2                        dw      CL                      // c/l
 473+ AF60 90 A0                        dw      EXIT                    // ;
 474+ AF62
 475+ AF62              //  ______________________________________________________________________
 476+ AF62              //
 477+ AF62              // .line        n1 n2 --
 478+ AF62              // Sends to output line  n1  of screen n2.
 479+ AF62                              Colon_Def DOT_LINE, ".LINE", is_normal
 479+ AF62             >                New_Def  DOT_LINE, ".LINE", Enter_Ptr, is_normal ; ok
 479+ AF62             >
 479+ AF62             >Dict_Ptr        defl    $
 479+ AF62             >
 479+ AF62             >//              ______________________________________________________________________
 479+ AF62             >//              Heap part
 479+ AF62             >
 479+ AF62             >
 479+ AF62             >                org     (Heap_Ptr & $1FFF) + $E000
 479+ E97E             >
 479+ E97E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 479+ E97E             >Latest_Definition defl  Heap_Ptr
 479+ E97E             >
 479+ E97E             >                // dummy db directives used to calculate length of namec
 479+ E97E 2E 4C 49 4E >                db      ".LINE"
 479+ E982 45          >
 479+ E983             >len_NFA         defl    $ - temp_NFA
 479+ E983             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 479+ E97E             >
 479+ E97E 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 479+ E97F 2E 4C 49 4E >                db      ".LINE"               // name string in 7-bit ascii, but
 479+ E983 45          >
 479+ E984             >                org     $-1                 // alter last byte of Name just above to set
 479+ E983 C5          >                db      {b $} | END_BIT     // msb as name end
 479+ E984             >
 479+ E984 73 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 479+ E986             >Prev_Ptr        defl    Heap_Ptr
 479+ E986             >
 479+ E986             >mirror_Ptr      defl    $
 479+ E986             >
 479+ E986 64 AF       >                dw      Dict_Ptr + 2        // xt
 479+ E988             >Heap_Ptr        defl    $ - $E000           // save current HP
 479+ E988             >
 479+ E988             >Current_HP      defl  $ - $E000             // used to set HP once!
 479+ E988             >
 479+ E988             >//              ______________________________________________________________________
 479+ E988             >//              Dictionary part
 479+ E988             >
 479+ E988             >                org     Dict_Ptr
 479+ AF62             >
 479+ AF62 86 29       >                dw      mirror_Ptr - $E000 + Heap_offset
 479+ AF64             >
 479+ AF64             >DOT_LINE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 479+ AF64 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 479+ AF67             >
 479+ AF67             >
 479+ AF67             >                endif           ; ok        // for other definitions it "points" the correct handler
 479+ AF67             >                // Use of "; ok" to suppress "warning[fwdref]"
 479+ AF67             >
 479+ AF67             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 480+ AF67 47 AF C7 A7                  dw      CLINE, LTRAILING, TYPE  // (line) -trailing type
 480+ AF6B B0 A7
 481+ AF6D 90 A0                        dw      EXIT                    // ;
 482+ AF6F
 483+ AF6F              //  ______________________________________________________________________
 484+ AF6F              //
 485+ AF6F              // message       n1 n2 --
 486+ AF6F              // prints error message to current channel.
 487+ AF6F              // if WARNING is 0, prints "MSG#n".
 488+ AF6F              // if WARNING is 1, prints line n of screen 4.
 489+ AF6F              // if WARNING is -1, see ERROR
 490+ AF6F              // value can be negative or beyond block 4.
 491+ AF6F                              Colon_Def MESSAGE, "MESSAGE", is_normal
 491+ AF6F             >                New_Def  MESSAGE, "MESSAGE", Enter_Ptr, is_normal ; ok
 491+ AF6F             >
 491+ AF6F             >Dict_Ptr        defl    $
 491+ AF6F             >
 491+ AF6F             >//              ______________________________________________________________________
 491+ AF6F             >//              Heap part
 491+ AF6F             >
 491+ AF6F             >
 491+ AF6F             >                org     (Heap_Ptr & $1FFF) + $E000
 491+ E988             >
 491+ E988             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 491+ E988             >Latest_Definition defl  Heap_Ptr
 491+ E988             >
 491+ E988             >                // dummy db directives used to calculate length of namec
 491+ E988 4D 45 53 53 >                db      "MESSAGE"
 491+ E98C 41 47 45    >
 491+ E98F             >len_NFA         defl    $ - temp_NFA
 491+ E98F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 491+ E988             >
 491+ E988 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 491+ E989 4D 45 53 53 >                db      "MESSAGE"               // name string in 7-bit ascii, but
 491+ E98D 41 47 45    >
 491+ E990             >                org     $-1                 // alter last byte of Name just above to set
 491+ E98F C5          >                db      {b $} | END_BIT     // msb as name end
 491+ E990             >
 491+ E990 7E 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 491+ E992             >Prev_Ptr        defl    Heap_Ptr
 491+ E992             >
 491+ E992             >mirror_Ptr      defl    $
 491+ E992             >
 491+ E992 71 AF       >                dw      Dict_Ptr + 2        // xt
 491+ E994             >Heap_Ptr        defl    $ - $E000           // save current HP
 491+ E994             >
 491+ E994             >Current_HP      defl  $ - $E000             // used to set HP once!
 491+ E994             >
 491+ E994             >//              ______________________________________________________________________
 491+ E994             >//              Dictionary part
 491+ E994             >
 491+ E994             >                org     Dict_Ptr
 491+ AF6F             >
 491+ AF6F 92 29       >                dw      mirror_Ptr - $E000 + Heap_offset
 491+ AF71             >
 491+ AF71             >MESSAGE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 491+ AF71 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 491+ AF74             >
 491+ AF74             >
 491+ AF74             >                endif           ; ok        // for other definitions it "points" the correct handler
 491+ AF74             >                // Use of "; ok" to suppress "warning[fwdref]"
 491+ AF74             >
 491+ AF74             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 492+ AF74 30 A3 C7 A1                  dw      WARNING, FETCH          // warning @
 493+ AF78                                                              // if
 494+ AF78 33 9C                        dw      ZBRANCH
 495+ AF7A 18 00                        dw      Message_Else - $
 496+ AF7C E1 9B 04 00                  dw          LIT, 4              //      4
 497+ AF80 78 A3 C7 A1                  dw          OFFSET, FETCH       //      offset @
 498+ AF84 F7 A2 17 AF                  dw          BSCR, DIV, SUBTRACT //      b/scr / -
 498+ AF88 23 A4
 499+ AF8A 64 AF                        dw          DOT_LINE            //      .line
 500+ AF8C B5 A4                        dw          SPACE               //      space
 501+ AF8E                                                              // else
 502+ AF8E
 503+ AF8E 26 9C                        dw      BRANCH
 504+ AF90 0B 00                        dw      Message_ENdif - $
 505+ AF92              Message_Else:
 506+ AF92 4D A9                        dw          C_DOT_QUOTE         //      .( msg#)
 507+ AF94 04 6D 73 67                  db          4, "msg#"
 507+ AF98 23
 508+ AF99 A2 B6                        dw          DOT                 //      .  ( forward )
 509+ AF9B              Message_ENdif:                                  // endif
 510+ AF9B 90 A0                        dw      EXIT                    // ;
 511+ AF9D
 512+ AF9D
 513+ AF9D              //  ______________________________________________________________________
 514+ AF9D              //
 515+ AF9D              // device
 516+ AF9D                              Variable_Def DEVICE,   "DEVICE",   2
 516+ AF9D             >                New_Def  DEVICE, "DEVICE", Variable_Ptr, is_normal
 516+ AF9D             >
 516+ AF9D             >Dict_Ptr        defl    $
 516+ AF9D             >
 516+ AF9D             >//              ______________________________________________________________________
 516+ AF9D             >//              Heap part
 516+ AF9D             >
 516+ AF9D             >
 516+ AF9D             >                org     (Heap_Ptr & $1FFF) + $E000
 516+ E994             >
 516+ E994             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 516+ E994             >Latest_Definition defl  Heap_Ptr
 516+ E994             >
 516+ E994             >                // dummy db directives used to calculate length of namec
 516+ E994 44 45 56 49 >                db      "DEVICE"
 516+ E998 43 45       >
 516+ E99A             >len_NFA         defl    $ - temp_NFA
 516+ E99A             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 516+ E994             >
 516+ E994 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 516+ E995 44 45 56 49 >                db      "DEVICE"               // name string in 7-bit ascii, but
 516+ E999 43 45       >
 516+ E99B             >                org     $-1                 // alter last byte of Name just above to set
 516+ E99A C5          >                db      {b $} | END_BIT     // msb as name end
 516+ E99B             >
 516+ E99B 88 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 516+ E99D             >Prev_Ptr        defl    Heap_Ptr
 516+ E99D             >
 516+ E99D             >mirror_Ptr      defl    $
 516+ E99D             >
 516+ E99D 9F AF       >                dw      Dict_Ptr + 2        // xt
 516+ E99F             >Heap_Ptr        defl    $ - $E000           // save current HP
 516+ E99F             >
 516+ E99F             >Current_HP      defl  $ - $E000             // used to set HP once!
 516+ E99F             >
 516+ E99F             >//              ______________________________________________________________________
 516+ E99F             >//              Dictionary part
 516+ E99F             >
 516+ E99F             >                org     Dict_Ptr
 516+ AF9D             >
 516+ AF9D 9D 29       >                dw      mirror_Ptr - $E000 + Heap_offset
 516+ AF9F             >
 516+ AF9F             >DEVICE:          if Variable_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 516+ AF9F CD A6 A2    >                call    Variable_Ptr ; ok        // for primitive definitions  actual code
 516+ AFA2             >
 516+ AFA2             >
 516+ AFA2             >                endif           ; ok        // for other definitions it "points" the correct handler
 516+ AFA2             >                // Use of "; ok" to suppress "warning[fwdref]"
 516+ AFA2             >
 516+ AFA2             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 516+ AFA2 02 00       >                dw      2
 517+ AFA4
 518+ AFA4              //  ______________________________________________________________________
 519+ AFA4
# file closed: C:\Zx\CSpect\Projects\vForth17_MMU7/source/L2.asm
 123  AFA4                              include "next-opt1.asm"
# file opened: C:\Zx\CSpect\Projects\vForth17_MMU7/source/next-opt1.asm
   1+ AFA4              //  ______________________________________________________________________
   2+ AFA4              //
   3+ AFA4              //  next-opt.asm
   4+ AFA4              //
   5+ AFA4              //  ZX Spectrum Next - peculiar definitions
   6+ AFA4              //  ______________________________________________________________________
   7+ AFA4
   8+ AFA4              //  ______________________________________________________________________
   9+ AFA4              //
  10+ AFA4              // reg@         n -- b
  11+ AFA4              // read Next REGister n giving byte b
  12+ AFA4              //
  13+ AFA4              //              Colon_Def REG_FETCH, "REG@", is_normal
  14+ AFA4              //              dw      LIT, $243B
  15+ AFA4              //              dw      PSTORE
  16+ AFA4              //              dw      LIT, $253B
  17+ AFA4              //              dw      PFETCH
  18+ AFA4              //              dw      EXIT
  19+ AFA4                              New_Def REG_FETCH, "REG@", is_code, is_normal
  19+ AFA4             >
  19+ AFA4             >Dict_Ptr        defl    $
  19+ AFA4             >
  19+ AFA4             >//              ______________________________________________________________________
  19+ AFA4             >//              Heap part
  19+ AFA4             >
  19+ AFA4             >
  19+ AFA4             >                org     (Heap_Ptr & $1FFF) + $E000
  19+ E99F             >
  19+ E99F             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  19+ E99F             >Latest_Definition defl  Heap_Ptr
  19+ E99F             >
  19+ E99F             >                // dummy db directives used to calculate length of namec
  19+ E99F 52 45 47 40 >                db      "REG@"
  19+ E9A3             >len_NFA         defl    $ - temp_NFA
  19+ E9A3             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  19+ E99F             >
  19+ E99F 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  19+ E9A0 52 45 47 40 >                db      "REG@"               // name string in 7-bit ascii, but
  19+ E9A4             >                org     $-1                 // alter last byte of Name just above to set
  19+ E9A3 C0          >                db      {b $} | END_BIT     // msb as name end
  19+ E9A4             >
  19+ E9A4 94 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
  19+ E9A6             >Prev_Ptr        defl    Heap_Ptr
  19+ E9A6             >
  19+ E9A6             >mirror_Ptr      defl    $
  19+ E9A6             >
  19+ E9A6 A6 AF       >                dw      Dict_Ptr + 2        // xt
  19+ E9A8             >Heap_Ptr        defl    $ - $E000           // save current HP
  19+ E9A8             >
  19+ E9A8             >Current_HP      defl  $ - $E000             // used to set HP once!
  19+ E9A8             >
  19+ E9A8             >//              ______________________________________________________________________
  19+ E9A8             >//              Dictionary part
  19+ E9A8             >
  19+ E9A8             >                org     Dict_Ptr
  19+ AFA4             >
  19+ AFA4 A6 29       >                dw      mirror_Ptr - $E000 + Heap_offset
  19+ AFA6             >
  19+ AFA6             >REG_FETCH:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
  19+ AFA6 ~           >                call    runcode ; ok        // for primitive definitions  actual code
  19+ AFA6 ~           >
  19+ AFA6 ~           >
  19+ AFA6             >                endif           ; ok        // for other definitions it "points" the correct handler
  19+ AFA6             >                // Use of "; ok" to suppress "warning[fwdref]"
  19+ AFA6             >
  19+ AFA6             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  20+ AFA6 D9                           exx
  21+ AFA7 01 3B 24                     ld      bc, $243B
  22+ AFAA E1                           pop     hl
  23+ AFAB ED 69                        out     (c), l
  24+ AFAD 04                           inc     b
  25+ AFAE ED 68                        in      l, (c)
  26+ AFB0 E5                           push    hl
  27+ AFB1 D9                           exx
  28+ AFB2                              next
  28+ AFB2 DD E9       >                jp      (ix)
  29+ AFB4
  30+ AFB4
  31+ AFB4              //  ______________________________________________________________________
  32+ AFB4              //
  33+ AFB4              // reg!         b n --
  34+ AFB4              // write value b to Next REGister n
  35+ AFB4              //
  36+ AFB4              //              Colon_Def REG_STORE, "REG!", is_normal
  37+ AFB4              //              dw      LIT, $243B
  38+ AFB4              //              dw      PSTORE
  39+ AFB4              //              dw      LIT, $253B
  40+ AFB4              //              dw      PSTORE
  41+ AFB4              //              dw      EXIT
  42+ AFB4                              New_Def REG_STORE, "REG!", is_code, is_normal
  42+ AFB4             >
  42+ AFB4             >Dict_Ptr        defl    $
  42+ AFB4             >
  42+ AFB4             >//              ______________________________________________________________________
  42+ AFB4             >//              Heap part
  42+ AFB4             >
  42+ AFB4             >
  42+ AFB4             >                org     (Heap_Ptr & $1FFF) + $E000
  42+ E9A8             >
  42+ E9A8             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  42+ E9A8             >Latest_Definition defl  Heap_Ptr
  42+ E9A8             >
  42+ E9A8             >                // dummy db directives used to calculate length of namec
  42+ E9A8 52 45 47 21 >                db      "REG!"
  42+ E9AC             >len_NFA         defl    $ - temp_NFA
  42+ E9AC             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  42+ E9A8             >
  42+ E9A8 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  42+ E9A9 52 45 47 21 >                db      "REG!"               // name string in 7-bit ascii, but
  42+ E9AD             >                org     $-1                 // alter last byte of Name just above to set
  42+ E9AC A1          >                db      {b $} | END_BIT     // msb as name end
  42+ E9AD             >
  42+ E9AD 9F 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
  42+ E9AF             >Prev_Ptr        defl    Heap_Ptr
  42+ E9AF             >
  42+ E9AF             >mirror_Ptr      defl    $
  42+ E9AF             >
  42+ E9AF B6 AF       >                dw      Dict_Ptr + 2        // xt
  42+ E9B1             >Heap_Ptr        defl    $ - $E000           // save current HP
  42+ E9B1             >
  42+ E9B1             >Current_HP      defl  $ - $E000             // used to set HP once!
  42+ E9B1             >
  42+ E9B1             >//              ______________________________________________________________________
  42+ E9B1             >//              Dictionary part
  42+ E9B1             >
  42+ E9B1             >                org     Dict_Ptr
  42+ AFB4             >
  42+ AFB4 AF 29       >                dw      mirror_Ptr - $E000 + Heap_offset
  42+ AFB6             >
  42+ AFB6             >REG_STORE:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
  42+ AFB6 ~           >                call    runcode ; ok        // for primitive definitions  actual code
  42+ AFB6 ~           >
  42+ AFB6 ~           >
  42+ AFB6             >                endif           ; ok        // for other definitions it "points" the correct handler
  42+ AFB6             >                // Use of "; ok" to suppress "warning[fwdref]"
  42+ AFB6             >
  42+ AFB6             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  43+ AFB6 D9                           exx
  44+ AFB7 01 3B 24                     ld      bc, $243B
  45+ AFBA E1                           pop     hl
  46+ AFBB ED 69                        out     (c), l
  47+ AFBD 04                           inc     b
  48+ AFBE E1                           pop     hl
  49+ AFBF ED 69                        out     (c), l
  50+ AFC1 D9                           exx
  51+ AFC2                              next
  51+ AFC2 DD E9       >                jp      (ix)
  52+ AFC4
  53+ AFC4
  54+ AFC4              //  ______________________________________________________________________
  55+ AFC4              //
  56+ AFC4              // m_p3dos      n1 n2 n3 n4 a -- n5 n6 n7 n8  f
  57+ AFC4              // NextZXOS call wrapper.
  58+ AFC4              //  n1 = hl register parameter value
  59+ AFC4              //  n2 = de register parameter value
  60+ AFC4              //  n3 = bc register parameter value
  61+ AFC4              //  n4 =  a register parameter value
  62+ AFC4              //   a = routine address in ROM 3
  63+ AFC4              // ----
  64+ AFC4              //  n5 = hl returned value
  65+ AFC4              //  n6 = de returned value
  66+ AFC4              //  n7 = bc returned value
  67+ AFC4              //  n8 =  a returned value
  68+ AFC4              //   f
  69+ AFC4                              New_Def M_P3DOS, "M_P3DOS", is_code, is_normal
  69+ AFC4             >
  69+ AFC4             >Dict_Ptr        defl    $
  69+ AFC4             >
  69+ AFC4             >//              ______________________________________________________________________
  69+ AFC4             >//              Heap part
  69+ AFC4             >
  69+ AFC4             >
  69+ AFC4             >                org     (Heap_Ptr & $1FFF) + $E000
  69+ E9B1             >
  69+ E9B1             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  69+ E9B1             >Latest_Definition defl  Heap_Ptr
  69+ E9B1             >
  69+ E9B1             >                // dummy db directives used to calculate length of namec
  69+ E9B1 4D 5F 50 33 >                db      "M_P3DOS"
  69+ E9B5 44 4F 53    >
  69+ E9B8             >len_NFA         defl    $ - temp_NFA
  69+ E9B8             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  69+ E9B1             >
  69+ E9B1 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  69+ E9B2 4D 5F 50 33 >                db      "M_P3DOS"               // name string in 7-bit ascii, but
  69+ E9B6 44 4F 53    >
  69+ E9B9             >                org     $-1                 // alter last byte of Name just above to set
  69+ E9B8 D3          >                db      {b $} | END_BIT     // msb as name end
  69+ E9B9             >
  69+ E9B9 A8 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
  69+ E9BB             >Prev_Ptr        defl    Heap_Ptr
  69+ E9BB             >
  69+ E9BB             >mirror_Ptr      defl    $
  69+ E9BB             >
  69+ E9BB C6 AF       >                dw      Dict_Ptr + 2        // xt
  69+ E9BD             >Heap_Ptr        defl    $ - $E000           // save current HP
  69+ E9BD             >
  69+ E9BD             >Current_HP      defl  $ - $E000             // used to set HP once!
  69+ E9BD             >
  69+ E9BD             >//              ______________________________________________________________________
  69+ E9BD             >//              Dictionary part
  69+ E9BD             >
  69+ E9BD             >                org     Dict_Ptr
  69+ AFC4             >
  69+ AFC4 BB 29       >                dw      mirror_Ptr - $E000 + Heap_offset
  69+ AFC6             >
  69+ AFC6             >M_P3DOS:          if is_code != 0 ; ok        // This is the start address of the direct jp(hl)
  69+ AFC6 ~           >                call    runcode ; ok        // for primitive definitions  actual code
  69+ AFC6 ~           >
  69+ AFC6 ~           >
  69+ AFC6             >                endif           ; ok        // for other definitions it "points" the correct handler
  69+ AFC6             >                // Use of "; ok" to suppress "warning[fwdref]"
  69+ AFC6             >
  69+ AFC6             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  70+ AFC6 D9                            exx
  71+ AFC7 E1                            pop     hl                  // dos call entry address a  //  n1 n2 n3 n4
  72+ AFC8 D1                            pop     de                  // a register argument       //  n1 n2 n3
  73+ AFC9 7B                            ld      a, e
  74+ AFCA C1                            pop     bc                  // bc' argument              //  n1 n2
  75+ AFCB D1                            pop     de                  // de' argument              //  n1
  76+ AFCC E3                            ex      (sp), hl            // hl' argument and entry address in TOS
  77+ AFCD D9                           exx
  78+ AFCE E1                           pop     hl                  // entry address a
  79+ AFCF DD E5                        push    ix
  80+ AFD1 D5                           push    de
  81+ AFD2 C5                           push    bc
  82+ AFD3 EB                           ex      de, hl              // de is entry address
  83+ AFD4              //              ld      (SP_Saved), sp
  84+ AFD4              //              ld      sp, Cold_origin - 5
  85+ AFD4 0E 07                        ld      c, 7                // use 7 RAM Bank
  86+ AFD6
  87+ AFD6 CF                           rst     08
  88+ AFD7 94                           db      $94
  89+ AFD8
  90+ AFD8              //              ld      sp, (SP_Saved)
  91+ AFD8              //              push    ix
  92+ AFD8              //              pop     hl
  93+ AFD8              //              ld      (IX_Echo), hl
  94+ AFD8 DD 22 D6 9B                  ld      (IX_Echo), ix
  95+ AFDC
  96+ AFDC D9                           exx
  97+ AFDD C1                           pop     bc
  98+ AFDE D1                           pop     de
  99+ AFDF DD E1                        pop     ix
 100+ AFE1 D9                            exx
 101+ AFE2 E5                            push    hl
 102+ AFE3 D5                            push    de
 103+ AFE4 C5                            push    bc
 104+ AFE5 26 00                         ld      h, 0
 105+ AFE7 6F                            ld      l, a
 106+ AFE8 E5                            push    hl
 107+ AFE9 D9                           exx
 108+ AFEA ED 62                        sbc     hl, hl              // -1 for OK ; 0 for KO but now...
 109+ AFEC 23                           inc     hl                  //  0 for OK ; 1 for ko
 110+ AFED E5                           push    hl
 111+ AFEE                              next
 111+ AFEE DD E9       >                jp      (ix)
 112+ AFF0
 113+ AFF0              //  ______________________________________________________________________
 114+ AFF0              //
 115+ AFF0              // blk-fh
 116+ AFF0                              Variable_Def BLK_FH,   "BLK-FH",   1
 116+ AFF0             >                New_Def  BLK_FH, "BLK-FH", Variable_Ptr, is_normal
 116+ AFF0             >
 116+ AFF0             >Dict_Ptr        defl    $
 116+ AFF0             >
 116+ AFF0             >//              ______________________________________________________________________
 116+ AFF0             >//              Heap part
 116+ AFF0             >
 116+ AFF0             >
 116+ AFF0             >                org     (Heap_Ptr & $1FFF) + $E000
 116+ E9BD             >
 116+ E9BD             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 116+ E9BD             >Latest_Definition defl  Heap_Ptr
 116+ E9BD             >
 116+ E9BD             >                // dummy db directives used to calculate length of namec
 116+ E9BD 42 4C 4B 2D >                db      "BLK-FH"
 116+ E9C1 46 48       >
 116+ E9C3             >len_NFA         defl    $ - temp_NFA
 116+ E9C3             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 116+ E9BD             >
 116+ E9BD 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 116+ E9BE 42 4C 4B 2D >                db      "BLK-FH"               // name string in 7-bit ascii, but
 116+ E9C2 46 48       >
 116+ E9C4             >                org     $-1                 // alter last byte of Name just above to set
 116+ E9C3 C8          >                db      {b $} | END_BIT     // msb as name end
 116+ E9C4             >
 116+ E9C4 B1 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 116+ E9C6             >Prev_Ptr        defl    Heap_Ptr
 116+ E9C6             >
 116+ E9C6             >mirror_Ptr      defl    $
 116+ E9C6             >
 116+ E9C6 F2 AF       >                dw      Dict_Ptr + 2        // xt
 116+ E9C8             >Heap_Ptr        defl    $ - $E000           // save current HP
 116+ E9C8             >
 116+ E9C8             >Current_HP      defl  $ - $E000             // used to set HP once!
 116+ E9C8             >
 116+ E9C8             >//              ______________________________________________________________________
 116+ E9C8             >//              Dictionary part
 116+ E9C8             >
 116+ E9C8             >                org     Dict_Ptr
 116+ AFF0             >
 116+ AFF0 C6 29       >                dw      mirror_Ptr - $E000 + Heap_offset
 116+ AFF2             >
 116+ AFF2             >BLK_FH:          if Variable_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 116+ AFF2 CD A6 A2    >                call    Variable_Ptr ; ok        // for primitive definitions  actual code
 116+ AFF5             >
 116+ AFF5             >
 116+ AFF5             >                endif           ; ok        // for other definitions it "points" the correct handler
 116+ AFF5             >                // Use of "; ok" to suppress "warning[fwdref]"
 116+ AFF5             >
 116+ AFF5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 116+ AFF5 01 00       >                dw      1
 117+ AFF7
 118+ AFF7                              New_Def BLK_FNAME,   "BLK-FNAME", Create_Ptr, is_normal
 118+ AFF7             >
 118+ AFF7             >Dict_Ptr        defl    $
 118+ AFF7             >
 118+ AFF7             >//              ______________________________________________________________________
 118+ AFF7             >//              Heap part
 118+ AFF7             >
 118+ AFF7             >
 118+ AFF7             >                org     (Heap_Ptr & $1FFF) + $E000
 118+ E9C8             >
 118+ E9C8             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 118+ E9C8             >Latest_Definition defl  Heap_Ptr
 118+ E9C8             >
 118+ E9C8             >                // dummy db directives used to calculate length of namec
 118+ E9C8 42 4C 4B 2D >                db      "BLK-FNAME"
 118+ E9CC 46 4E 41 4D >
 118+ E9D0 45          >
 118+ E9D1             >len_NFA         defl    $ - temp_NFA
 118+ E9D1             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 118+ E9C8             >
 118+ E9C8 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 118+ E9C9 42 4C 4B 2D >                db      "BLK-FNAME"               // name string in 7-bit ascii, but
 118+ E9CD 46 4E 41 4D >
 118+ E9D1 45          >
 118+ E9D2             >                org     $-1                 // alter last byte of Name just above to set
 118+ E9D1 C5          >                db      {b $} | END_BIT     // msb as name end
 118+ E9D2             >
 118+ E9D2 BD 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 118+ E9D4             >Prev_Ptr        defl    Heap_Ptr
 118+ E9D4             >
 118+ E9D4             >mirror_Ptr      defl    $
 118+ E9D4             >
 118+ E9D4 F9 AF       >                dw      Dict_Ptr + 2        // xt
 118+ E9D6             >Heap_Ptr        defl    $ - $E000           // save current HP
 118+ E9D6             >
 118+ E9D6             >Current_HP      defl  $ - $E000             // used to set HP once!
 118+ E9D6             >
 118+ E9D6             >//              ______________________________________________________________________
 118+ E9D6             >//              Dictionary part
 118+ E9D6             >
 118+ E9D6             >                org     Dict_Ptr
 118+ AFF7             >
 118+ AFF7 D4 29       >                dw      mirror_Ptr - $E000 + Heap_offset
 118+ AFF9             >
 118+ AFF9             >BLK_FNAME:          if Create_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 118+ AFF9 CD 03 AC    >                call    Create_Ptr ; ok        // for primitive definitions  actual code
 118+ AFFC             >
 118+ AFFC             >
 118+ AFFC             >                endif           ; ok        // for other definitions it "points" the correct handler
 118+ AFFC             >                // Use of "; ok" to suppress "warning[fwdref]"
 118+ AFFC             >
 118+ AFFC             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 119+ AFFC 0E 21 42 6C                  db      14, "!Blocks-64.bin", 0
 119+ B000 6F 63 6B 73
 119+ B004 2D 36 34 2E
 119+ B008 62 69 6E 00
 120+ B00C 00 00 00...                  ds      24
 121+ B024
 122+ B024              //  ______________________________________________________________________
 123+ B024              //
 124+ B024              // blk-seek     n --
 125+ B024              // seek block n  within blocks!.bin  file
 126+ B024                              Colon_Def BLK_SEEK, "BLK-SEEK", is_normal
 126+ B024             >                New_Def  BLK_SEEK, "BLK-SEEK", Enter_Ptr, is_normal ; ok
 126+ B024             >
 126+ B024             >Dict_Ptr        defl    $
 126+ B024             >
 126+ B024             >//              ______________________________________________________________________
 126+ B024             >//              Heap part
 126+ B024             >
 126+ B024             >
 126+ B024             >                org     (Heap_Ptr & $1FFF) + $E000
 126+ E9D6             >
 126+ E9D6             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 126+ E9D6             >Latest_Definition defl  Heap_Ptr
 126+ E9D6             >
 126+ E9D6             >                // dummy db directives used to calculate length of namec
 126+ E9D6 42 4C 4B 2D >                db      "BLK-SEEK"
 126+ E9DA 53 45 45 4B >
 126+ E9DE             >len_NFA         defl    $ - temp_NFA
 126+ E9DE             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 126+ E9D6             >
 126+ E9D6 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 126+ E9D7 42 4C 4B 2D >                db      "BLK-SEEK"               // name string in 7-bit ascii, but
 126+ E9DB 53 45 45 4B >
 126+ E9DF             >                org     $-1                 // alter last byte of Name just above to set
 126+ E9DE CB          >                db      {b $} | END_BIT     // msb as name end
 126+ E9DF             >
 126+ E9DF C8 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 126+ E9E1             >Prev_Ptr        defl    Heap_Ptr
 126+ E9E1             >
 126+ E9E1             >mirror_Ptr      defl    $
 126+ E9E1             >
 126+ E9E1 26 B0       >                dw      Dict_Ptr + 2        // xt
 126+ E9E3             >Heap_Ptr        defl    $ - $E000           // save current HP
 126+ E9E3             >
 126+ E9E3             >Current_HP      defl  $ - $E000             // used to set HP once!
 126+ E9E3             >
 126+ E9E3             >//              ______________________________________________________________________
 126+ E9E3             >//              Dictionary part
 126+ E9E3             >
 126+ E9E3             >                org     Dict_Ptr
 126+ B024             >
 126+ B024 E1 29       >                dw      mirror_Ptr - $E000 + Heap_offset
 126+ B026             >
 126+ B026             >BLK_SEEK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 126+ B026 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 126+ B029             >
 126+ B029             >
 126+ B029             >                endif           ; ok        // for other definitions it "points" the correct handler
 126+ B029             >                // Use of "; ok" to suppress "warning[fwdref]"
 126+ B029             >
 126+ B029             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 127+ B029 F0 A2 74 AE                  dw  BBUF, MMUL
 128+ B02D F2 AF C7 A1                  dw  BLK_FH, FETCH
 129+ B031 21 9F                        dw  F_SEEK
 130+ B033 E1 9B 2D 00                  dw  LIT, $2D, QERROR
 130+ B037 20 A6
 131+ B039 90 A0                        dw  EXIT
 132+ B03B
 133+ B03B              //  ______________________________________________________________________
 134+ B03B              //
 135+ B03B              // blk-read     n --
 136+ B03B              // seek block n  within blocks!.bin  file
 137+ B03B                              Colon_Def BLK_READ, "BLK-READ", is_normal
 137+ B03B             >                New_Def  BLK_READ, "BLK-READ", Enter_Ptr, is_normal ; ok
 137+ B03B             >
 137+ B03B             >Dict_Ptr        defl    $
 137+ B03B             >
 137+ B03B             >//              ______________________________________________________________________
 137+ B03B             >//              Heap part
 137+ B03B             >
 137+ B03B             >
 137+ B03B             >                org     (Heap_Ptr & $1FFF) + $E000
 137+ E9E3             >
 137+ E9E3             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 137+ E9E3             >Latest_Definition defl  Heap_Ptr
 137+ E9E3             >
 137+ E9E3             >                // dummy db directives used to calculate length of namec
 137+ E9E3 42 4C 4B 2D >                db      "BLK-READ"
 137+ E9E7 52 45 41 44 >
 137+ E9EB             >len_NFA         defl    $ - temp_NFA
 137+ E9EB             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 137+ E9E3             >
 137+ E9E3 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 137+ E9E4 42 4C 4B 2D >                db      "BLK-READ"               // name string in 7-bit ascii, but
 137+ E9E8 52 45 41 44 >
 137+ E9EC             >                org     $-1                 // alter last byte of Name just above to set
 137+ E9EB C4          >                db      {b $} | END_BIT     // msb as name end
 137+ E9EC             >
 137+ E9EC D6 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 137+ E9EE             >Prev_Ptr        defl    Heap_Ptr
 137+ E9EE             >
 137+ E9EE             >mirror_Ptr      defl    $
 137+ E9EE             >
 137+ E9EE 3D B0       >                dw      Dict_Ptr + 2        // xt
 137+ E9F0             >Heap_Ptr        defl    $ - $E000           // save current HP
 137+ E9F0             >
 137+ E9F0             >Current_HP      defl  $ - $E000             // used to set HP once!
 137+ E9F0             >
 137+ E9F0             >//              ______________________________________________________________________
 137+ E9F0             >//              Dictionary part
 137+ E9F0             >
 137+ E9F0             >                org     Dict_Ptr
 137+ B03B             >
 137+ B03B EE 29       >                dw      mirror_Ptr - $E000 + Heap_offset
 137+ B03D             >
 137+ B03D             >BLK_READ:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 137+ B03D CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 137+ B040             >
 137+ B040             >
 137+ B040             >                endif           ; ok        // for other definitions it "points" the correct handler
 137+ B040             >                // Use of "; ok" to suppress "warning[fwdref]"
 137+ B040             >
 137+ B040             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 138+ B040 26 B0                        dw  BLK_SEEK
 139+ B042 F0 A2                        dw  BBUF
 140+ B044 F2 AF C7 A1                  dw  BLK_FH, FETCH
 141+ B048 6D 9F                        dw  F_READ
 142+ B04A E1 9B 2E 00                  dw  LIT, $2E, QERROR
 142+ B04E 20 A6
 143+ B050 4E A1                        dw  DROP
 144+ B052 90 A0                        dw  EXIT
 145+ B054
 146+ B054              //  ______________________________________________________________________
 147+ B054              //
 148+ B054              // blk-write     n --
 149+ B054              // seek block n  within blocks!.bin  file
 150+ B054                              Colon_Def BLK_WRITE, "BLK-WRITE", is_normal
 150+ B054             >                New_Def  BLK_WRITE, "BLK-WRITE", Enter_Ptr, is_normal ; ok
 150+ B054             >
 150+ B054             >Dict_Ptr        defl    $
 150+ B054             >
 150+ B054             >//              ______________________________________________________________________
 150+ B054             >//              Heap part
 150+ B054             >
 150+ B054             >
 150+ B054             >                org     (Heap_Ptr & $1FFF) + $E000
 150+ E9F0             >
 150+ E9F0             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 150+ E9F0             >Latest_Definition defl  Heap_Ptr
 150+ E9F0             >
 150+ E9F0             >                // dummy db directives used to calculate length of namec
 150+ E9F0 42 4C 4B 2D >                db      "BLK-WRITE"
 150+ E9F4 57 52 49 54 >
 150+ E9F8 45          >
 150+ E9F9             >len_NFA         defl    $ - temp_NFA
 150+ E9F9             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 150+ E9F0             >
 150+ E9F0 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 150+ E9F1 42 4C 4B 2D >                db      "BLK-WRITE"               // name string in 7-bit ascii, but
 150+ E9F5 57 52 49 54 >
 150+ E9F9 45          >
 150+ E9FA             >                org     $-1                 // alter last byte of Name just above to set
 150+ E9F9 C5          >                db      {b $} | END_BIT     // msb as name end
 150+ E9FA             >
 150+ E9FA E3 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 150+ E9FC             >Prev_Ptr        defl    Heap_Ptr
 150+ E9FC             >
 150+ E9FC             >mirror_Ptr      defl    $
 150+ E9FC             >
 150+ E9FC 56 B0       >                dw      Dict_Ptr + 2        // xt
 150+ E9FE             >Heap_Ptr        defl    $ - $E000           // save current HP
 150+ E9FE             >
 150+ E9FE             >Current_HP      defl  $ - $E000             // used to set HP once!
 150+ E9FE             >
 150+ E9FE             >//              ______________________________________________________________________
 150+ E9FE             >//              Dictionary part
 150+ E9FE             >
 150+ E9FE             >                org     Dict_Ptr
 150+ B054             >
 150+ B054 FC 29       >                dw      mirror_Ptr - $E000 + Heap_offset
 150+ B056             >
 150+ B056             >BLK_WRITE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 150+ B056 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 150+ B059             >
 150+ B059             >
 150+ B059             >                endif           ; ok        // for other definitions it "points" the correct handler
 150+ B059             >                // Use of "; ok" to suppress "warning[fwdref]"
 150+ B059             >
 150+ B059             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 151+ B059 26 B0                        dw  BLK_SEEK
 152+ B05B F0 A2                        dw  BBUF
 153+ B05D F2 AF C7 A1                  dw  BLK_FH, FETCH
 154+ B061 88 9F                        dw  F_WRITE
 155+ B063 E1 9B 2F 00                  dw  LIT, $2F, QERROR
 155+ B067 20 A6
 156+ B069 4E A1                        dw  DROP
 157+ B06B 90 A0                        dw  EXIT
 158+ B06D
 159+ B06D              //  ______________________________________________________________________
 160+ B06D              //
 161+ B06D              // blk-init     n --
 162+ B06D              // seek block n  within blocks!.bin  file
 163+ B06D                              Colon_Def BLK_INIT, "BLK-INIT", is_normal
 163+ B06D             >                New_Def  BLK_INIT, "BLK-INIT", Enter_Ptr, is_normal ; ok
 163+ B06D             >
 163+ B06D             >Dict_Ptr        defl    $
 163+ B06D             >
 163+ B06D             >//              ______________________________________________________________________
 163+ B06D             >//              Heap part
 163+ B06D             >
 163+ B06D             >
 163+ B06D             >                org     (Heap_Ptr & $1FFF) + $E000
 163+ E9FE             >
 163+ E9FE             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 163+ E9FE             >Latest_Definition defl  Heap_Ptr
 163+ E9FE             >
 163+ E9FE             >                // dummy db directives used to calculate length of namec
 163+ E9FE 42 4C 4B 2D >                db      "BLK-INIT"
 163+ EA02 49 4E 49 54 >
 163+ EA06             >len_NFA         defl    $ - temp_NFA
 163+ EA06             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 163+ E9FE             >
 163+ E9FE 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 163+ E9FF 42 4C 4B 2D >                db      "BLK-INIT"               // name string in 7-bit ascii, but
 163+ EA03 49 4E 49 54 >
 163+ EA07             >                org     $-1                 // alter last byte of Name just above to set
 163+ EA06 D4          >                db      {b $} | END_BIT     // msb as name end
 163+ EA07             >
 163+ EA07 F0 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 163+ EA09             >Prev_Ptr        defl    Heap_Ptr
 163+ EA09             >
 163+ EA09             >mirror_Ptr      defl    $
 163+ EA09             >
 163+ EA09 6F B0       >                dw      Dict_Ptr + 2        // xt
 163+ EA0B             >Heap_Ptr        defl    $ - $E000           // save current HP
 163+ EA0B             >
 163+ EA0B             >Current_HP      defl  $ - $E000             // used to set HP once!
 163+ EA0B             >
 163+ EA0B             >//              ______________________________________________________________________
 163+ EA0B             >//              Dictionary part
 163+ EA0B             >
 163+ EA0B             >                org     Dict_Ptr
 163+ B06D             >
 163+ B06D 09 2A       >                dw      mirror_Ptr - $E000 + Heap_offset
 163+ B06F             >
 163+ B06F             >BLK_INIT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 163+ B06F CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 163+ B072             >
 163+ B072             >
 163+ B072             >                endif           ; ok        // for other definitions it "points" the correct handler
 163+ B072             >                // Use of "; ok" to suppress "warning[fwdref]"
 163+ B072             >
 163+ B072             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 164+ B072 F2 AF C7 A1                  dw  BLK_FH, FETCH, F_CLOSE, DROP
 164+ B076 3D 9F 4E A1
 165+ B07A F9 AF FC A0                  dw  BLK_FNAME, ONE_PLUS
 166+ B07E E4 A3 D4 A2                  dw  HERE, THREE, F_OPEN         // open for update (read+write)
 166+ B082 98 9F
 167+ B084 E1 9B 2C 00                  dw  LIT, $2C, QERROR
 167+ B088 20 A6
 168+ B08A F2 AF D1 A1                  dw  BLK_FH, STORE
 169+ B08E 90 A0                        dw  EXIT
 170+ B090
 171+ B090              //  ______________________________________________________________________
 172+ B090              //
 173+ B090              // #sec
 174+ B090              // number of 512-Byte "sectors" available on thie sysstem.
 175+ B090              // it adds up to 16 MByte of data that can be used as source or pool for almost anything.
 176+ B090
 177+ B090                              Constant_Def NSEC , "#SEC", 32767
 177+ B090             >                New_Def  NSEC, "#SEC", Constant_Ptr, is_normal
 177+ B090             >
 177+ B090             >Dict_Ptr        defl    $
 177+ B090             >
 177+ B090             >//              ______________________________________________________________________
 177+ B090             >//              Heap part
 177+ B090             >
 177+ B090             >
 177+ B090             >                org     (Heap_Ptr & $1FFF) + $E000
 177+ EA0B             >
 177+ EA0B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 177+ EA0B             >Latest_Definition defl  Heap_Ptr
 177+ EA0B             >
 177+ EA0B             >                // dummy db directives used to calculate length of namec
 177+ EA0B 23 53 45 43 >                db      "#SEC"
 177+ EA0F             >len_NFA         defl    $ - temp_NFA
 177+ EA0F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 177+ EA0B             >
 177+ EA0B 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 177+ EA0C 23 53 45 43 >                db      "#SEC"               // name string in 7-bit ascii, but
 177+ EA10             >                org     $-1                 // alter last byte of Name just above to set
 177+ EA0F C3          >                db      {b $} | END_BIT     // msb as name end
 177+ EA10             >
 177+ EA10 FE 29       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 177+ EA12             >Prev_Ptr        defl    Heap_Ptr
 177+ EA12             >
 177+ EA12             >mirror_Ptr      defl    $
 177+ EA12             >
 177+ EA12 92 B0       >                dw      Dict_Ptr + 2        // xt
 177+ EA14             >Heap_Ptr        defl    $ - $E000           // save current HP
 177+ EA14             >
 177+ EA14             >Current_HP      defl  $ - $E000             // used to set HP once!
 177+ EA14             >
 177+ EA14             >//              ______________________________________________________________________
 177+ EA14             >//              Dictionary part
 177+ EA14             >
 177+ EA14             >                org     Dict_Ptr
 177+ B090             >
 177+ B090 12 2A       >                dw      mirror_Ptr - $E000 + Heap_offset
 177+ B092             >
 177+ B092             >NSEC:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 177+ B092 CD 93 A2    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 177+ B095             >
 177+ B095             >
 177+ B095             >                endif           ; ok        // for other definitions it "points" the correct handler
 177+ B095             >                // Use of "; ok" to suppress "warning[fwdref]"
 177+ B095             >
 177+ B095             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 177+ B095 FF 7F       >                dw      32767
 178+ B097
 179+ B097              //  ______________________________________________________________________
 180+ B097
 181+ B097
 182+ B097
# file closed: C:\Zx\CSpect\Projects\vForth17_MMU7/source/next-opt1.asm
 124  B097                              include "L3.asm"
# file opened: C:\Zx\CSpect\Projects\vForth17_MMU7/source/L3.asm
   1+ B097              //  ______________________________________________________________________
   2+ B097              //
   3+ B097              //  L3.asm
   4+ B097              //
   5+ B097              //  Continuation of L2.asm
   6+ B097              //  I/O Block definitions
   7+ B097              //  ______________________________________________________________________
   8+ B097
   9+ B097
  10+ B097              //  ______________________________________________________________________
  11+ B097              //
  12+ B097              // r/w          a n f --
  13+ B097              // read/write block n depending on flag f, true-flag means read, false-flag means write.
  14+ B097                              Colon_Def READ_WRITE, "R/W", is_normal
  14+ B097             >                New_Def  READ_WRITE, "R/W", Enter_Ptr, is_normal ; ok
  14+ B097             >
  14+ B097             >Dict_Ptr        defl    $
  14+ B097             >
  14+ B097             >//              ______________________________________________________________________
  14+ B097             >//              Heap part
  14+ B097             >
  14+ B097             >
  14+ B097             >                org     (Heap_Ptr & $1FFF) + $E000
  14+ EA14             >
  14+ EA14             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  14+ EA14             >Latest_Definition defl  Heap_Ptr
  14+ EA14             >
  14+ EA14             >                // dummy db directives used to calculate length of namec
  14+ EA14 52 2F 57    >                db      "R/W"
  14+ EA17             >len_NFA         defl    $ - temp_NFA
  14+ EA17             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  14+ EA14             >
  14+ EA14 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  14+ EA15 52 2F 57    >                db      "R/W"               // name string in 7-bit ascii, but
  14+ EA18             >                org     $-1                 // alter last byte of Name just above to set
  14+ EA17 D7          >                db      {b $} | END_BIT     // msb as name end
  14+ EA18             >
  14+ EA18 0B 2A       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
  14+ EA1A             >Prev_Ptr        defl    Heap_Ptr
  14+ EA1A             >
  14+ EA1A             >mirror_Ptr      defl    $
  14+ EA1A             >
  14+ EA1A 99 B0       >                dw      Dict_Ptr + 2        // xt
  14+ EA1C             >Heap_Ptr        defl    $ - $E000           // save current HP
  14+ EA1C             >
  14+ EA1C             >Current_HP      defl  $ - $E000             // used to set HP once!
  14+ EA1C             >
  14+ EA1C             >//              ______________________________________________________________________
  14+ EA1C             >//              Dictionary part
  14+ EA1C             >
  14+ EA1C             >                org     Dict_Ptr
  14+ B097             >
  14+ B097 1A 2A       >                dw      mirror_Ptr - $E000 + Heap_offset
  14+ B099             >
  14+ B099             >READ_WRITE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
  14+ B099 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
  14+ B09C             >
  14+ B09C             >
  14+ B09C             >                endif           ; ok        // for other definitions it "points" the correct handler
  14+ B09C             >                // Use of "; ok" to suppress "warning[fwdref]"
  14+ B09C             >
  14+ B09C             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  15+ B09C 9A A0                        dw      TO_R                    // >r
  16+ B09E 03 A1                        dw      ONE_SUBTRACT            // 1-
  17+ B0A0 69 A1 C8 A0                  dw      DUP, ZLESS              // dup 0<
  18+ B0A4 45 A1 92 B0                  dw      OVER, NSEC              // over #sec
  19+ B0A8 03 A1 5D A4                  dw      ONE_SUBTRACT, GREATER   // 1- >
  20+ B0AC 59 A0                        dw      OR_OP                   // or
  21+ B0AE E1 9B 06 00                  dw      LIT, 6, QERROR          // 6 ?error
  21+ B0B2 20 A6
  22+ B0B4 A5 A0                        dw      R_TO                    // r>
  23+ B0B6                                                              // if
  24+ B0B6 33 9C                        dw      ZBRANCH
  25+ B0B8 08 00                        dw      Read_Write_Else - $
  26+ B0BA 3D B0                        dw          BLK_READ            //      blk-read
  27+ B0BC 26 9C                        dw      BRANCH
  28+ B0BE 04 00                        dw      Read_Write_Endif - $
  29+ B0C0              Read_Write_Else:                                // else
  30+ B0C0 56 B0                        dw          BLK_WRITE           //      blk-write
  31+ B0C2              Read_Write_Endif:                               // endif
  32+ B0C2 90 A0                        dw      EXIT                    // ;
  33+ B0C4
  34+ B0C4
  35+ B0C4              //  ______________________________________________________________________
  36+ B0C4              //
  37+ B0C4              // +buf        a1 -- a2 f
  38+ B0C4              // advences to next buffer, cyclically rotating along them
  39+ B0C4                              Colon_Def PBUF, "+BUF", is_normal
  39+ B0C4             >                New_Def  PBUF, "+BUF", Enter_Ptr, is_normal ; ok
  39+ B0C4             >
  39+ B0C4             >Dict_Ptr        defl    $
  39+ B0C4             >
  39+ B0C4             >//              ______________________________________________________________________
  39+ B0C4             >//              Heap part
  39+ B0C4             >
  39+ B0C4             >
  39+ B0C4             >                org     (Heap_Ptr & $1FFF) + $E000
  39+ EA1C             >
  39+ EA1C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  39+ EA1C             >Latest_Definition defl  Heap_Ptr
  39+ EA1C             >
  39+ EA1C             >                // dummy db directives used to calculate length of namec
  39+ EA1C 2B 42 55 46 >                db      "+BUF"
  39+ EA20             >len_NFA         defl    $ - temp_NFA
  39+ EA20             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  39+ EA1C             >
  39+ EA1C 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  39+ EA1D 2B 42 55 46 >                db      "+BUF"               // name string in 7-bit ascii, but
  39+ EA21             >                org     $-1                 // alter last byte of Name just above to set
  39+ EA20 C6          >                db      {b $} | END_BIT     // msb as name end
  39+ EA21             >
  39+ EA21 14 2A       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
  39+ EA23             >Prev_Ptr        defl    Heap_Ptr
  39+ EA23             >
  39+ EA23             >mirror_Ptr      defl    $
  39+ EA23             >
  39+ EA23 C6 B0       >                dw      Dict_Ptr + 2        // xt
  39+ EA25             >Heap_Ptr        defl    $ - $E000           // save current HP
  39+ EA25             >
  39+ EA25             >Current_HP      defl  $ - $E000             // used to set HP once!
  39+ EA25             >
  39+ EA25             >//              ______________________________________________________________________
  39+ EA25             >//              Dictionary part
  39+ EA25             >
  39+ EA25             >                org     Dict_Ptr
  39+ B0C4             >
  39+ B0C4 23 2A       >                dw      mirror_Ptr - $E000 + Heap_offset
  39+ B0C6             >
  39+ B0C6             >PBUF:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
  39+ B0C6 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
  39+ B0C9             >
  39+ B0C9             >
  39+ B0C9             >                endif           ; ok        // for other definitions it "points" the correct handler
  39+ B0C9             >                // Use of "; ok" to suppress "warning[fwdref]"
  39+ B0C9             >
  39+ B0C9             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  40+ B0C9 E1 9B 04 02                  dw      LIT, 516, PLUS          // 516 +
  40+ B0CD E3 A0
  41+ B0CF 69 A1 4E A3                  dw      DUP, LIMIT, FETCH       // dup limit @
  41+ B0D3 C7 A1
  42+ B0D5 2F A4                        dw      EQUALS                  // =
  43+ B0D7                                                              // if
  44+ B0D7 33 9C                        dw      ZBRANCH
  45+ B0D9 08 00                        dw      PBuf_Endif - $
  46+ B0DB 4E A1                        dw          DROP                //      drop
  47+ B0DD 48 A3 C7 A1                  dw          FIRST, FETCH        //      first @
  48+ B0E1              PBuf_Endif:                                     // endif
  49+ B0E1 69 A1 BA A3                  dw      DUP, PREV, FETCH        // dup prev @
  49+ B0E5 C7 A1
  50+ B0E7 23 A4                        dw      SUBTRACT                // -
  51+ B0E9 90 A0                        dw      EXIT                    // ;
  52+ B0EB
  53+ B0EB              //  ______________________________________________________________________
  54+ B0EB              //
  55+ B0EB              // update       --
  56+ B0EB              // mark the last used block to be written to disk
  57+ B0EB                              Colon_Def UPDATE, "UPDATE", is_normal
  57+ B0EB             >                New_Def  UPDATE, "UPDATE", Enter_Ptr, is_normal ; ok
  57+ B0EB             >
  57+ B0EB             >Dict_Ptr        defl    $
  57+ B0EB             >
  57+ B0EB             >//              ______________________________________________________________________
  57+ B0EB             >//              Heap part
  57+ B0EB             >
  57+ B0EB             >
  57+ B0EB             >                org     (Heap_Ptr & $1FFF) + $E000
  57+ EA25             >
  57+ EA25             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  57+ EA25             >Latest_Definition defl  Heap_Ptr
  57+ EA25             >
  57+ EA25             >                // dummy db directives used to calculate length of namec
  57+ EA25 55 50 44 41 >                db      "UPDATE"
  57+ EA29 54 45       >
  57+ EA2B             >len_NFA         defl    $ - temp_NFA
  57+ EA2B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  57+ EA25             >
  57+ EA25 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  57+ EA26 55 50 44 41 >                db      "UPDATE"               // name string in 7-bit ascii, but
  57+ EA2A 54 45       >
  57+ EA2C             >                org     $-1                 // alter last byte of Name just above to set
  57+ EA2B C5          >                db      {b $} | END_BIT     // msb as name end
  57+ EA2C             >
  57+ EA2C 1C 2A       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
  57+ EA2E             >Prev_Ptr        defl    Heap_Ptr
  57+ EA2E             >
  57+ EA2E             >mirror_Ptr      defl    $
  57+ EA2E             >
  57+ EA2E ED B0       >                dw      Dict_Ptr + 2        // xt
  57+ EA30             >Heap_Ptr        defl    $ - $E000           // save current HP
  57+ EA30             >
  57+ EA30             >Current_HP      defl  $ - $E000             // used to set HP once!
  57+ EA30             >
  57+ EA30             >//              ______________________________________________________________________
  57+ EA30             >//              Dictionary part
  57+ EA30             >
  57+ EA30             >                org     Dict_Ptr
  57+ B0EB             >
  57+ B0EB 2E 2A       >                dw      mirror_Ptr - $E000 + Heap_offset
  57+ B0ED             >
  57+ B0ED             >UPDATE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
  57+ B0ED CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
  57+ B0F0             >
  57+ B0F0             >
  57+ B0F0             >                endif           ; ok        // for other definitions it "points" the correct handler
  57+ B0F0             >                // Use of "; ok" to suppress "warning[fwdref]"
  57+ B0F0             >
  57+ B0F0             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  58+ B0F0 BA A3 C7 A1                  dw      PREV, FETCH, FETCH      // prev @ @
  58+ B0F4 C7 A1
  59+ B0F6 E1 9B 00 80                  dw      LIT, $8000, OR_OP       // $8000, or
  59+ B0FA 59 A0
  60+ B0FC BA A3 C7 A1                  dw      PREV, FETCH, STORE      // prev @ !
  60+ B100 D1 A1
  61+ B102 90 A0                        dw      EXIT                    // ;
  62+ B104
  63+ B104
  64+ B104              //  ______________________________________________________________________
  65+ B104              //
  66+ B104              // empty-buffers --
  67+ B104                              Colon_Def EMPTY_BUFFERS, "EMPTY-BUFFERS", is_normal
  67+ B104             >                New_Def  EMPTY_BUFFERS, "EMPTY-BUFFERS", Enter_Ptr, is_normal ; ok
  67+ B104             >
  67+ B104             >Dict_Ptr        defl    $
  67+ B104             >
  67+ B104             >//              ______________________________________________________________________
  67+ B104             >//              Heap part
  67+ B104             >
  67+ B104             >
  67+ B104             >                org     (Heap_Ptr & $1FFF) + $E000
  67+ EA30             >
  67+ EA30             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  67+ EA30             >Latest_Definition defl  Heap_Ptr
  67+ EA30             >
  67+ EA30             >                // dummy db directives used to calculate length of namec
  67+ EA30 45 4D 50 54 >                db      "EMPTY-BUFFERS"
  67+ EA34 59 2D 42 55 >
  67+ EA38 46 46 45 52 >
  67+ EA3C 53          >
  67+ EA3D             >len_NFA         defl    $ - temp_NFA
  67+ EA3D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  67+ EA30             >
  67+ EA30 8D          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  67+ EA31 45 4D 50 54 >                db      "EMPTY-BUFFERS"               // name string in 7-bit ascii, but
  67+ EA35 59 2D 42 55 >
  67+ EA39 46 46 45 52 >
  67+ EA3D 53          >
  67+ EA3E             >                org     $-1                 // alter last byte of Name just above to set
  67+ EA3D D3          >                db      {b $} | END_BIT     // msb as name end
  67+ EA3E             >
  67+ EA3E 25 2A       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
  67+ EA40             >Prev_Ptr        defl    Heap_Ptr
  67+ EA40             >
  67+ EA40             >mirror_Ptr      defl    $
  67+ EA40             >
  67+ EA40 06 B1       >                dw      Dict_Ptr + 2        // xt
  67+ EA42             >Heap_Ptr        defl    $ - $E000           // save current HP
  67+ EA42             >
  67+ EA42             >Current_HP      defl  $ - $E000             // used to set HP once!
  67+ EA42             >
  67+ EA42             >//              ______________________________________________________________________
  67+ EA42             >//              Dictionary part
  67+ EA42             >
  67+ EA42             >                org     Dict_Ptr
  67+ B104             >
  67+ B104 40 2A       >                dw      mirror_Ptr - $E000 + Heap_offset
  67+ B106             >
  67+ B106             >EMPTY_BUFFERS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
  67+ B106 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
  67+ B109             >
  67+ B109             >
  67+ B109             >                endif           ; ok        // for other definitions it "points" the correct handler
  67+ B109             >                // Use of "; ok" to suppress "warning[fwdref]"
  67+ B109             >
  67+ B109             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  68+ B109 48 A3 C7 A1                  dw      FIRST, FETCH            // first @
  69+ B10D 4E A3 C7 A1                  dw      LIMIT, FETCH            // limit @
  70+ B111 45 A1 23 A4                  dw      OVER, SUBTRACT, ERASE   // over - erase
  70+ B115 CA A8
  71+ B117 90 A0                        dw      EXIT                    // ;
  72+ B119
  73+ B119              //  ______________________________________________________________________
  74+ B119              //
  75+ B119              // buffer       n -- a
  76+ B119              // read block n and gives the address to a buffer
  77+ B119              // any block previously inside the buffer, if modified, is rewritten to
  78+ B119              // disk before reading the block n.
  79+ B119
  80+ B119                              Colon_Def BUFFER, "BUFFER", is_normal
  80+ B119             >                New_Def  BUFFER, "BUFFER", Enter_Ptr, is_normal ; ok
  80+ B119             >
  80+ B119             >Dict_Ptr        defl    $
  80+ B119             >
  80+ B119             >//              ______________________________________________________________________
  80+ B119             >//              Heap part
  80+ B119             >
  80+ B119             >
  80+ B119             >                org     (Heap_Ptr & $1FFF) + $E000
  80+ EA42             >
  80+ EA42             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
  80+ EA42             >Latest_Definition defl  Heap_Ptr
  80+ EA42             >
  80+ EA42             >                // dummy db directives used to calculate length of namec
  80+ EA42 42 55 46 46 >                db      "BUFFER"
  80+ EA46 45 52       >
  80+ EA48             >len_NFA         defl    $ - temp_NFA
  80+ EA48             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
  80+ EA42             >
  80+ EA42 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
  80+ EA43 42 55 46 46 >                db      "BUFFER"               // name string in 7-bit ascii, but
  80+ EA47 45 52       >
  80+ EA49             >                org     $-1                 // alter last byte of Name just above to set
  80+ EA48 D2          >                db      {b $} | END_BIT     // msb as name end
  80+ EA49             >
  80+ EA49 30 2A       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
  80+ EA4B             >Prev_Ptr        defl    Heap_Ptr
  80+ EA4B             >
  80+ EA4B             >mirror_Ptr      defl    $
  80+ EA4B             >
  80+ EA4B 1B B1       >                dw      Dict_Ptr + 2        // xt
  80+ EA4D             >Heap_Ptr        defl    $ - $E000           // save current HP
  80+ EA4D             >
  80+ EA4D             >Current_HP      defl  $ - $E000             // used to set HP once!
  80+ EA4D             >
  80+ EA4D             >//              ______________________________________________________________________
  80+ EA4D             >//              Dictionary part
  80+ EA4D             >
  80+ EA4D             >                org     Dict_Ptr
  80+ B119             >
  80+ B119 4B 2A       >                dw      mirror_Ptr - $E000 + Heap_offset
  80+ B11B             >
  80+ B11B             >BUFFER:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
  80+ B11B CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
  80+ B11E             >
  80+ B11E             >
  80+ B11E             >                endif           ; ok        // for other definitions it "points" the correct handler
  80+ B11E             >                // Use of "; ok" to suppress "warning[fwdref]"
  80+ B11E             >
  80+ B11E             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
  81+ B11E B4 A3 C7 A1                  dw      USE, FETCH              // use @
  82+ B122 69 A1 9A A0                  dw      DUP, TO_R               // dup >r
  83+ B126                                                              // begin
  84+ B126              Buffer_Begin:
  85+ B126 C6 B0                        dw          PBUF                //      +buf
  86+ B128                                                              // until
  87+ B128 33 9C                        dw      ZBRANCH
  88+ B12A FC FF                        dw      Buffer_Begin - $
  89+ B12C B4 A3 D1 A1                  dw      USE, STORE              // use !
  90+ B130 B0 A0 C7 A1                  dw      R_OP, FETCH, ZLESS      // r @ 0<
  90+ B134 C8 A0
  91+ B136                                                              // if
  92+ B136 33 9C                        dw      ZBRANCH
  93+ B138 14 00                        dw      Buffer_Endif - $
  94+ B13A B0 A0 12 A1                  dw          R_OP, CELL_PLUS     //      r cell+
  95+ B13E B0 A0 C7 A1                  dw          R_OP, FETCH         //      r fetch
  96+ B142 E1 9B FF 7F                  dw          LIT, $7FFF          //      7FFF
  97+ B146 4A A0                        dw          AND_OP              //      and
  98+ B148 BF A2 99 B0                  dw          ZERO, READ_WRITE    //      0 r/w
  99+ B14C              Buffer_Endif:                                   // endif
 100+ B14C B0 A0 D1 A1                  dw      R_OP, STORE             // r !
 101+ B150 B0 A0 BA A3                  dw      R_OP, PREV, STORE       // r prev !
 101+ B154 D1 A1
 102+ B156 A5 A0 12 A1                  dw      R_TO, CELL_PLUS         // r> cell+
 103+ B15A 90 A0                        dw      EXIT                    // ;
 104+ B15C
 105+ B15C              //  ______________________________________________________________________
 106+ B15C              //
 107+ B15C              // block        n -- a
 108+ B15C              // Leaves the buffer address that contains the block n.
 109+ B15C              // If the block is not already present, it will be loaded from disk
 110+ B15C              // The block previously inside the buffer, if modified, is rewritten to
 111+ B15C              // disk before reading the block n.
 112+ B15C              // See also BUFFER, R/W, UPDATE, FLUSH.
 113+ B15C
 114+ B15C                              Colon_Def BLOCK, "BLOCK", is_normal
 114+ B15C             >                New_Def  BLOCK, "BLOCK", Enter_Ptr, is_normal ; ok
 114+ B15C             >
 114+ B15C             >Dict_Ptr        defl    $
 114+ B15C             >
 114+ B15C             >//              ______________________________________________________________________
 114+ B15C             >//              Heap part
 114+ B15C             >
 114+ B15C             >
 114+ B15C             >                org     (Heap_Ptr & $1FFF) + $E000
 114+ EA4D             >
 114+ EA4D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 114+ EA4D             >Latest_Definition defl  Heap_Ptr
 114+ EA4D             >
 114+ EA4D             >                // dummy db directives used to calculate length of namec
 114+ EA4D 42 4C 4F 43 >                db      "BLOCK"
 114+ EA51 4B          >
 114+ EA52             >len_NFA         defl    $ - temp_NFA
 114+ EA52             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 114+ EA4D             >
 114+ EA4D 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 114+ EA4E 42 4C 4F 43 >                db      "BLOCK"               // name string in 7-bit ascii, but
 114+ EA52 4B          >
 114+ EA53             >                org     $-1                 // alter last byte of Name just above to set
 114+ EA52 CB          >                db      {b $} | END_BIT     // msb as name end
 114+ EA53             >
 114+ EA53 42 2A       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 114+ EA55             >Prev_Ptr        defl    Heap_Ptr
 114+ EA55             >
 114+ EA55             >mirror_Ptr      defl    $
 114+ EA55             >
 114+ EA55 5E B1       >                dw      Dict_Ptr + 2        // xt
 114+ EA57             >Heap_Ptr        defl    $ - $E000           // save current HP
 114+ EA57             >
 114+ EA57             >Current_HP      defl  $ - $E000             // used to set HP once!
 114+ EA57             >
 114+ EA57             >//              ______________________________________________________________________
 114+ EA57             >//              Dictionary part
 114+ EA57             >
 114+ EA57             >                org     Dict_Ptr
 114+ B15C             >
 114+ B15C 55 2A       >                dw      mirror_Ptr - $E000 + Heap_offset
 114+ B15E             >
 114+ B15E             >BLOCK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 114+ B15E CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 114+ B161             >
 114+ B161             >
 114+ B161             >                endif           ; ok        // for other definitions it "points" the correct handler
 114+ B161             >                // Use of "; ok" to suppress "warning[fwdref]"
 114+ B161             >
 114+ B161             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 115+ B161 78 A3 C7 A1                  dw      OFFSET, FETCH           // offset @
 116+ B165 E3 A0 9A A0                  dw      PLUS, TO_R              // + >r
 117+ B169 BA A3 C7 A1                  dw      PREV, FETCH             // prev @
 118+ B16D 69 A1 C7 A1                  dw      DUP, FETCH              // dup @
 119+ B171 B0 A0 23 A4                  dw      R_OP, SUBTRACT          // r -
 120+ B175 69 A1 E3 A0                  dw      DUP, PLUS               // dup +  ( trick: check equality without most significant bit )
 121+ B179                                                              // if
 122+ B179 33 9C                        dw        ZBRANCH
 123+ B17B 32 00                        dw        Block_Endif_1 - $
 124+ B17D              Block_Begin:                                    //      begin
 125+ B17D C6 B0 B5 A0                  dw          PBUF, ZEQUAL        //          +buf 0
 126+ B181                                                              //          if
 127+ B181 33 9C                        dw          ZBRANCH
 128+ B183 12 00                        dw          Block_Endif_2 - $
 129+ B185 4E A1                        dw              DROP            //              drop
 130+ B187 B0 A0 1B B1                  dw              R_OP, BUFFER    //              r buffer
 131+ B18B 69 A1                        dw              DUP             //              dup
 132+ B18D B0 A0 C6 A2                  dw              R_OP, ONE       //              r 1
 133+ B191 99 B0                        dw              READ_WRITE      //              r/w
 134+ B193 1F A1                        dw              TWO_MINUS       //              2-
 135+ B195              Block_Endif_2:                                  //          endif
 136+ B195 69 A1 C7 A1                  dw          DUP, FETCH, R_OP    //          dup @ r
 136+ B199 B0 A0
 137+ B19B 23 A4 69 A1                  dw          SUBTRACT, DUP       //          - dup
 138+ B19F E3 A0 B5 A0                  dw          PLUS, ZEQUAL        //          + 0=
 139+ B1A3                                                              //      until
 140+ B1A3 33 9C                        dw        ZBRANCH
 141+ B1A5 D8 FF                        dw        Block_Begin - $
 142+ B1A7 69 A1 BA A3                  dw        DUP, PREV, STORE      //      dup prev !
 142+ B1AB D1 A1
 143+ B1AD              Block_Endif_1:                                  // endif
 144+ B1AD A5 A0 4E A1                  dw      R_TO, DROP, CELL_PLUS   // r> drop cell+
 144+ B1B1 12 A1
 145+ B1B3 90 A0                        dw      EXIT                    // ;
 146+ B1B5
 147+ B1B5              //  ______________________________________________________________________
 148+ B1B5              //
 149+ B1B5              // #buff        -- n
 150+ B1B5              // number of buffers available. must be the difference between LIMIT and FIRST divided by 516
 151+ B1B5                              Constant_Def NBUFF,   "#BUFF", 7
 151+ B1B5             >                New_Def  NBUFF, "#BUFF", Constant_Ptr, is_normal
 151+ B1B5             >
 151+ B1B5             >Dict_Ptr        defl    $
 151+ B1B5             >
 151+ B1B5             >//              ______________________________________________________________________
 151+ B1B5             >//              Heap part
 151+ B1B5             >
 151+ B1B5             >
 151+ B1B5             >                org     (Heap_Ptr & $1FFF) + $E000
 151+ EA57             >
 151+ EA57             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 151+ EA57             >Latest_Definition defl  Heap_Ptr
 151+ EA57             >
 151+ EA57             >                // dummy db directives used to calculate length of namec
 151+ EA57 23 42 55 46 >                db      "#BUFF"
 151+ EA5B 46          >
 151+ EA5C             >len_NFA         defl    $ - temp_NFA
 151+ EA5C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 151+ EA57             >
 151+ EA57 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 151+ EA58 23 42 55 46 >                db      "#BUFF"               // name string in 7-bit ascii, but
 151+ EA5C 46          >
 151+ EA5D             >                org     $-1                 // alter last byte of Name just above to set
 151+ EA5C C6          >                db      {b $} | END_BIT     // msb as name end
 151+ EA5D             >
 151+ EA5D 4D 2A       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 151+ EA5F             >Prev_Ptr        defl    Heap_Ptr
 151+ EA5F             >
 151+ EA5F             >mirror_Ptr      defl    $
 151+ EA5F             >
 151+ EA5F B7 B1       >                dw      Dict_Ptr + 2        // xt
 151+ EA61             >Heap_Ptr        defl    $ - $E000           // save current HP
 151+ EA61             >
 151+ EA61             >Current_HP      defl  $ - $E000             // used to set HP once!
 151+ EA61             >
 151+ EA61             >//              ______________________________________________________________________
 151+ EA61             >//              Dictionary part
 151+ EA61             >
 151+ EA61             >                org     Dict_Ptr
 151+ B1B5             >
 151+ B1B5 5F 2A       >                dw      mirror_Ptr - $E000 + Heap_offset
 151+ B1B7             >
 151+ B1B7             >NBUFF:          if Constant_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 151+ B1B7 CD 93 A2    >                call    Constant_Ptr ; ok        // for primitive definitions  actual code
 151+ B1BA             >
 151+ B1BA             >
 151+ B1BA             >                endif           ; ok        // for other definitions it "points" the correct handler
 151+ B1BA             >                // Use of "; ok" to suppress "warning[fwdref]"
 151+ B1BA             >
 151+ B1BA             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 151+ B1BA 07 00       >                dw      7
 152+ B1BC
 153+ B1BC              //  ______________________________________________________________________
 154+ B1BC              //
 155+ B1BC              // flush        --
 156+ B1BC                              Colon_Def FLUSH, "FLUSH", is_normal
 156+ B1BC             >                New_Def  FLUSH, "FLUSH", Enter_Ptr, is_normal ; ok
 156+ B1BC             >
 156+ B1BC             >Dict_Ptr        defl    $
 156+ B1BC             >
 156+ B1BC             >//              ______________________________________________________________________
 156+ B1BC             >//              Heap part
 156+ B1BC             >
 156+ B1BC             >
 156+ B1BC             >                org     (Heap_Ptr & $1FFF) + $E000
 156+ EA61             >
 156+ EA61             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 156+ EA61             >Latest_Definition defl  Heap_Ptr
 156+ EA61             >
 156+ EA61             >                // dummy db directives used to calculate length of namec
 156+ EA61 46 4C 55 53 >                db      "FLUSH"
 156+ EA65 48          >
 156+ EA66             >len_NFA         defl    $ - temp_NFA
 156+ EA66             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 156+ EA61             >
 156+ EA61 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 156+ EA62 46 4C 55 53 >                db      "FLUSH"               // name string in 7-bit ascii, but
 156+ EA66 48          >
 156+ EA67             >                org     $-1                 // alter last byte of Name just above to set
 156+ EA66 C8          >                db      {b $} | END_BIT     // msb as name end
 156+ EA67             >
 156+ EA67 57 2A       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 156+ EA69             >Prev_Ptr        defl    Heap_Ptr
 156+ EA69             >
 156+ EA69             >mirror_Ptr      defl    $
 156+ EA69             >
 156+ EA69 BE B1       >                dw      Dict_Ptr + 2        // xt
 156+ EA6B             >Heap_Ptr        defl    $ - $E000           // save current HP
 156+ EA6B             >
 156+ EA6B             >Current_HP      defl  $ - $E000             // used to set HP once!
 156+ EA6B             >
 156+ EA6B             >//              ______________________________________________________________________
 156+ EA6B             >//              Dictionary part
 156+ EA6B             >
 156+ EA6B             >                org     Dict_Ptr
 156+ B1BC             >
 156+ B1BC 69 2A       >                dw      mirror_Ptr - $E000 + Heap_offset
 156+ B1BE             >
 156+ B1BE             >FLUSH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 156+ B1BE CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 156+ B1C1             >
 156+ B1C1             >
 156+ B1C1             >                endif           ; ok        // for other definitions it "points" the correct handler
 156+ B1C1             >                // Use of "; ok" to suppress "warning[fwdref]"
 156+ B1C1             >
 156+ B1C1             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 157+ B1C1 B7 B1 FC A0                  dw      NBUFF, ONE_PLUS, ZERO   // #buff 1+ 0
 157+ B1C5 BF A2
 158+ B1C7              Flush_Do:                                       // do
 159+ B1C7 72 9C                        dw      C_DO
 160+ B1C9 BF A2 1B B1                  dw      ZERO, BUFFER, DROP      //      0 buffer drop
 160+ B1CD 4E A1
 161+ B1CF                                                              // loop
 162+ B1CF 1E 9C F8 FF                  dw      C_LOOP, Flush_Do - $
 163+ B1D3 F2 AF C7 A1                  dw      BLK_FH, FETCH           // blk-fh @     ( ZX-Next dependance )
 164+ B1D7 49 9F 4E A1                  dw      F_SYNC, DROP            // f_sync drop
 165+ B1DB 90 A0                        dw      EXIT                    // exit
 166+ B1DD
 167+ B1DD              //  ______________________________________________________________________
 168+ B1DD              //
 169+ B1DD              // f_getline    a m fh -- n
 170+ B1DD              // Given an open filehandle read next line (terminated with $0D or $0A)
 171+ B1DD              // Address a is left for subsequent processing
 172+ B1DD              // and n as the actual number of byte read, that is the length of line
 173+ B1DD                              Colon_Def F_GETLINE, "F_GETLINE", is_normal
 173+ B1DD             >                New_Def  F_GETLINE, "F_GETLINE", Enter_Ptr, is_normal ; ok
 173+ B1DD             >
 173+ B1DD             >Dict_Ptr        defl    $
 173+ B1DD             >
 173+ B1DD             >//              ______________________________________________________________________
 173+ B1DD             >//              Heap part
 173+ B1DD             >
 173+ B1DD             >
 173+ B1DD             >                org     (Heap_Ptr & $1FFF) + $E000
 173+ EA6B             >
 173+ EA6B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 173+ EA6B             >Latest_Definition defl  Heap_Ptr
 173+ EA6B             >
 173+ EA6B             >                // dummy db directives used to calculate length of namec
 173+ EA6B 46 5F 47 45 >                db      "F_GETLINE"
 173+ EA6F 54 4C 49 4E >
 173+ EA73 45          >
 173+ EA74             >len_NFA         defl    $ - temp_NFA
 173+ EA74             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 173+ EA6B             >
 173+ EA6B 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 173+ EA6C 46 5F 47 45 >                db      "F_GETLINE"               // name string in 7-bit ascii, but
 173+ EA70 54 4C 49 4E >
 173+ EA74 45          >
 173+ EA75             >                org     $-1                 // alter last byte of Name just above to set
 173+ EA74 C5          >                db      {b $} | END_BIT     // msb as name end
 173+ EA75             >
 173+ EA75 61 2A       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 173+ EA77             >Prev_Ptr        defl    Heap_Ptr
 173+ EA77             >
 173+ EA77             >mirror_Ptr      defl    $
 173+ EA77             >
 173+ EA77 DF B1       >                dw      Dict_Ptr + 2        // xt
 173+ EA79             >Heap_Ptr        defl    $ - $E000           // save current HP
 173+ EA79             >
 173+ EA79             >Current_HP      defl  $ - $E000             // used to set HP once!
 173+ EA79             >
 173+ EA79             >//              ______________________________________________________________________
 173+ EA79             >//              Dictionary part
 173+ EA79             >
 173+ EA79             >                org     Dict_Ptr
 173+ B1DD             >
 173+ B1DD 77 2A       >                dw      mirror_Ptr - $E000 + Heap_offset
 173+ B1DF             >
 173+ B1DF             >F_GETLINE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 173+ B1DF CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 173+ B1E2             >
 173+ B1E2             >
 173+ B1E2             >                endif           ; ok        // for other definitions it "points" the correct handler
 173+ B1E2             >                // Use of "; ok" to suppress "warning[fwdref]"
 173+ B1E2             >
 173+ B1E2             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 174+ B1E2 9A A0                        dw      TO_R                    // >r               ( a  m  )     \  fh
 175+ B1E4 59 A1                        dw      TUCK                    // tuck             ( m a m )
 176+ B1E6 B0 A0 55 9F                  dw      R_OP, F_FGETPOS         // r f_fgetpos      ( m a m d f )
 177+ B1EA E1 9B 2C 00                  dw      LIT, 44, QERROR         // 44 ?error        ( m a m d )
 177+ B1EE 20 A6
 178+ B1F0
 179+ B1F0 98 A1 45 A1                  dw      TWO_SWAP, OVER          // 2swap over       ( m d a m )
 180+ B1F4 FC A0 62 A1                  dw      ONE_PLUS, SWAP          // 1+ swap          ( m d a a+1 m )
 181+ B1F8
 182+ B1F8 B0 A0 6D 9F                  dw      R_OP, F_READ            // r f_read         ( m d a n f )
 183+ B1FC E1 9B 2E 00                  dw      LIT, 46, QERROR         // 46 ?error        ( m d a n )
 183+ B200 20 A6
 184+ B202                                                              // if ( at least 1 chr was read )  \  fh
 185+ B202 33 9C                        dw      ZBRANCH
 186+ B204 3C 00                        dw      FGetline_Else - $
 187+ B206 E1 9B 0A 00                  dw          LIT, 10, ENCLOSE    //      10 enclose       ( m d a x b x )
 187+ B20A 67 9D
 188+ B20C 4E A1 53 A1                  dw          DROP, NIP           //      drop nip         ( m d a b )
 189+ B210 62 A1                        dw          SWAP                //      drop swap        ( m d b a )
 190+ B212 E1 9B 0D 00                  dw          LIT, 13, ENCLOSE    //      13 enclose       ( m d b a x c x )
 190+ B216 67 9D
 191+ B218 4E A1 53 A1                  dw          DROP, NIP           //      drop nip         ( m d b a c )
 192+ B21C 70 A1 68 A4                  dw          ROT, MIN            //      rot min          ( m d a n )
 193+ B220 69 A1 D2 A3                  dw          DUP, SPAN, STORE    //      dup span !       ( m d a n )
 193+ B224 D1 A1
 194+ B226 69 A1 9A A0                  dw          DUP, TO_R           //      dup >r           ( m d a n )      \ fh n
 195+ B22A 98 A1 A5 A0                  dw          TWO_SWAP, R_TO      //      2swap r>         ( m a n d n )    \ fh
 196+ B22E BF A2 ED A0                  dw          ZERO, DPLUS         //      0 d+             ( m a n d+n )
 197+ B232 A5 A0 21 9F                  dw          R_TO, F_SEEK        //      r> f_seek        ( m a n f )
 198+ B236 E1 9B 2D 00                  dw          LIT, 45, QERROR     //      45 ?error        ( m a n )
 198+ B23A 20 A6
 199+ B23C                                                              // else
 200+ B23C 26 9C                        dw      BRANCH
 201+ B23E 0C 00                        dw      FGetline_Endif - $
 202+ B240              FGetline_Else:
 203+ B240 A5 A0                        dw          R_TO                //      r>              ( m d a fh )
 204+ B242 98 A1 92 A1                  dw          TWO_SWAP, TWO_DROP  //      2swap 2drop     ( m a fh )
 205+ B246 4E A1 BF A2                  dw          DROP, ZERO          //      drop, 0         ( m a 0 )
 206+ B24A              FGetline_Endif:                                 // endif
 207+ B24A 9A A0 69 A1                  dw      TO_R, DUP, DUP          // >r dup dup           ( m a a a )
 207+ B24E 69 A1
 208+ B250 FC A0 62 A1                  dw      ONE_PLUS, SWAP          // 1+ swap              ( m a a+1 a )
 209+ B254 B0 A0 CB 9F                  dw      R_OP, CMOVE             // r cmove              ( m a )
 210+ B258 A5 A1 E3 A0                  dw      TWO_DUP, PLUS           // 2dup +               ( m a m+a )
 211+ B25C BF A2 62 A1                  dw      ZERO, SWAP              // 0 swap
 212+ B260 17 A1 D1 A1                  dw      CELL_MINUS,  STORE      // cell-  !             ( m a )
 213+ B264 B0 A0 E3 A0                  dw      R_OP, PLUS, ONE_SUBTRACT// r + 1-               ( m a+n1 )
 213+ B268 03 A1
 214+ B26A 62 A1 B0 A0                  dw      SWAP, R_OP, SUBTRACT    // swap r -             ( a+n+1 m-n )
 214+ B26E 23 A4
 215+ B270 D5 A8                        dw      BLANK                   // blank
 216+ B272 A5 A0                        dw      R_TO                    // r>                   ( n )
 217+ B274 90 A0                        dw      EXIT                    // ;
 218+ B276
 219+ B276              //  ______________________________________________________________________
 220+ B276              //
 221+ B276              // f_include    fh --
 222+ B276              // Given a filehandle includes the source from file
 223+ B276                              Colon_Def F_INCLUDE, "F_INCLUDE", is_normal
 223+ B276             >                New_Def  F_INCLUDE, "F_INCLUDE", Enter_Ptr, is_normal ; ok
 223+ B276             >
 223+ B276             >Dict_Ptr        defl    $
 223+ B276             >
 223+ B276             >//              ______________________________________________________________________
 223+ B276             >//              Heap part
 223+ B276             >
 223+ B276             >
 223+ B276             >                org     (Heap_Ptr & $1FFF) + $E000
 223+ EA79             >
 223+ EA79             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 223+ EA79             >Latest_Definition defl  Heap_Ptr
 223+ EA79             >
 223+ EA79             >                // dummy db directives used to calculate length of namec
 223+ EA79 46 5F 49 4E >                db      "F_INCLUDE"
 223+ EA7D 43 4C 55 44 >
 223+ EA81 45          >
 223+ EA82             >len_NFA         defl    $ - temp_NFA
 223+ EA82             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 223+ EA79             >
 223+ EA79 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 223+ EA7A 46 5F 49 4E >                db      "F_INCLUDE"               // name string in 7-bit ascii, but
 223+ EA7E 43 4C 55 44 >
 223+ EA82 45          >
 223+ EA83             >                org     $-1                 // alter last byte of Name just above to set
 223+ EA82 C5          >                db      {b $} | END_BIT     // msb as name end
 223+ EA83             >
 223+ EA83 6B 2A       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 223+ EA85             >Prev_Ptr        defl    Heap_Ptr
 223+ EA85             >
 223+ EA85             >mirror_Ptr      defl    $
 223+ EA85             >
 223+ EA85 78 B2       >                dw      Dict_Ptr + 2        // xt
 223+ EA87             >Heap_Ptr        defl    $ - $E000           // save current HP
 223+ EA87             >
 223+ EA87             >Current_HP      defl  $ - $E000             // used to set HP once!
 223+ EA87             >
 223+ EA87             >//              ______________________________________________________________________
 223+ EA87             >//              Dictionary part
 223+ EA87             >
 223+ EA87             >                org     Dict_Ptr
 223+ B276             >
 223+ B276 85 2A       >                dw      mirror_Ptr - $E000 + Heap_offset
 223+ B278             >
 223+ B278             >F_INCLUDE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 223+ B278 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 223+ B27B             >
 223+ B27B             >
 223+ B27B             >                endif           ; ok        // for other definitions it "points" the correct handler
 223+ B27B             >                // Use of "; ok" to suppress "warning[fwdref]"
 223+ B27B             >
 223+ B27B             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 224+ B27B 60 A3 C7 A1                  dw      BLK, FETCH, TO_R        // blk @ >r
 224+ B27F 9A A0
 225+ B281 66 A3 C7 A1                  dw      TO_IN, FETCH, TO_R      // >in @ >r
 225+ B285 9A A0
 226+ B287 CC A3 C7 A1                  dw      SOURCE_ID, FETCH, TO_R  // source-id @ >r
 226+ B28B 9A A0
 227+ B28D B0 A0                        dw      R_OP                    // r
 228+ B28F                                                              // if
 229+ B28F 33 9C                        dw      ZBRANCH
 230+ B291 20 00                        dw      FInclude_Else_1 - $
 231+ B293 B0 A0 55 9F                  dw          R_OP, F_FGETPOS     //      r f_getpos
 232+ B297 E1 9B 2C 00                  dw          LIT, 44, QERROR     //      44 ?error
 232+ B29B 20 A6
 233+ B29D 66 A3 C7 A1                  dw          TO_IN, FETCH        //      >in @ 2-
 234+ B2A1 1F A1                        dw          TWO_MINUS
 235+ B2A3 D2 A3 C7 A1                  dw          SPAN, FETCH         //      span @ -
 236+ B2A7 23 A4                        dw          SUBTRACT
 237+ B2A9 18 A4 ED A0                  dw          S_TO_D, DPLUS       //      s>d d+
 238+ B2AD                                                              // else
 239+ B2AD 26 9C                        dw      BRANCH
 240+ B2AF 06 00                        dw      FInclude_Endif_1 - $
 241+ B2B1              FInclude_Else_1:
 242+ B2B1 BF A2 BF A2                  dw          ZERO, ZERO          //      0 0
 243+ B2B5                                                              // endif
 244+ B2B5              FInclude_Endif_1:
 245+ B2B5 9A A0 9A A0                  dw      TO_R, TO_R              // >r >r
 246+ B2B9 CC A3 D1 A1                  dw      SOURCE_ID, STORE        // source-id !
 247+ B2BD              FInclude_Begin:                                 // begin
 248+ B2BD C6 A2 5E B1                  dw          ONE, BLOCK, BBUF    //      1 block b/buf
 248+ B2C1 F0 A2
 249+ B2C3 A5 A1 D5 A8                  dw          TWO_DUP, BLANK      //      2dup blank
 250+ B2C7 62 A1 FC A0                  dw          SWAP, ONE_PLUS      //      swap 1+
 251+ B2CB 62 A1 17 A1                  dw          SWAP, CELL_MINUS    //      swap cell-
 252+ B2CF CC A3 C7 A1                  dw          SOURCE_ID, FETCH    //      source-id @
 253+ B2D3 DF B1                        dw          F_GETLINE           //      f_getline
 254+ B2D5                                                              // while
 255+ B2D5 33 9C                        dw      ZBRANCH
 256+ B2D7 14 00                        dw      FInclude_Repeat - $
 257+ B2D9 C6 A2 60 A3                  dw          ONE, BLK, STORE     //      1 blk !
 257+ B2DD D1 A1
 258+ B2DF BF A2 66 A3                  dw          ZERO, TO_IN, STORE  //      0 >in !
 258+ B2E3 D1 A1
 259+ B2E5 BF AC                        dw          INTERPRET           //      interpret
 260+ B2E7 26 9C                        dw      BRANCH
 261+ B2E9 D4 FF                        dw      FInclude_Begin - $
 262+ B2EB              FInclude_Repeat:                                // repeat
 263+ B2EB CC A3 C7 A1                  dw      SOURCE_ID, FETCH        // source-id @
 264+ B2EF BF A2 CC A3                  dw      ZERO, SOURCE_ID, STORE  // 0 source-id !
 264+ B2F3 D1 A1
 265+ B2F5 3D 9F                        dw      F_CLOSE                 // f_close
 266+ B2F7 E1 9B 2A 00                  dw      LIT, 42, QERROR         // 42 ?error
 266+ B2FB 20 A6
 267+ B2FD A5 A0 A5 A0                  dw      R_TO, R_TO, R_TO        // r> r> r>
 267+ B301 A5 A0
 268+ B303 69 A1 CC A3                  dw      DUP, SOURCE_ID, STORE   // dup source-id !
 268+ B307 D1 A1
 269+ B309                                                              // if
 270+ B309 33 9C                        dw      ZBRANCH
 271+ B30B 12 00                        dw      FInclude_Else_2 - $
 272+ B30D CC A3 C7 A1                  dw          SOURCE_ID, FETCH    //      source-id @
 273+ B311 21 9F                        dw          F_SEEK              //      f_seek
 274+ B313 E1 9B 2B 00                  dw          LIT, 43, QERROR     //      43, ?error
 274+ B317 20 A6
 275+ B319                                                              // else
 276+ B319 26 9C                        dw      BRANCH
 277+ B31B 04 00                        dw      FInclude_Endif_2 - $
 278+ B31D              FInclude_Else_2:
 279+ B31D 92 A1                        dw          TWO_DROP            //      2drop
 280+ B31F              FInclude_Endif_2:                               // endif
 281+ B31F A5 A0 66 A3                  dw      R_TO, TO_IN, STORE      // r> >in !
 281+ B323 D1 A1
 282+ B325 A5 A0 60 A3                  dw      R_TO, BLK, STORE        // r> blk !
 282+ B329 D1 A1
 283+ B32B 90 A0                        dw      EXIT                    // ;
 284+ B32D
 285+ B32D              //  ______________________________________________________________________
 286+ B32D              //
 287+ B32D              // open<         -- fh
 288+ B32D              // Open the following filename and return it file-handle
 289+ B32D              // Used in the form OPEN CCCC
 290+ B32D                              Colon_Def OPEN_FH, "OPEN<", is_normal
 290+ B32D             >                New_Def  OPEN_FH, "OPEN<", Enter_Ptr, is_normal ; ok
 290+ B32D             >
 290+ B32D             >Dict_Ptr        defl    $
 290+ B32D             >
 290+ B32D             >//              ______________________________________________________________________
 290+ B32D             >//              Heap part
 290+ B32D             >
 290+ B32D             >
 290+ B32D             >                org     (Heap_Ptr & $1FFF) + $E000
 290+ EA87             >
 290+ EA87             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 290+ EA87             >Latest_Definition defl  Heap_Ptr
 290+ EA87             >
 290+ EA87             >                // dummy db directives used to calculate length of namec
 290+ EA87 4F 50 45 4E >                db      "OPEN<"
 290+ EA8B 3C          >
 290+ EA8C             >len_NFA         defl    $ - temp_NFA
 290+ EA8C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 290+ EA87             >
 290+ EA87 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 290+ EA88 4F 50 45 4E >                db      "OPEN<"               // name string in 7-bit ascii, but
 290+ EA8C 3C          >
 290+ EA8D             >                org     $-1                 // alter last byte of Name just above to set
 290+ EA8C BC          >                db      {b $} | END_BIT     // msb as name end
 290+ EA8D             >
 290+ EA8D 79 2A       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 290+ EA8F             >Prev_Ptr        defl    Heap_Ptr
 290+ EA8F             >
 290+ EA8F             >mirror_Ptr      defl    $
 290+ EA8F             >
 290+ EA8F 2F B3       >                dw      Dict_Ptr + 2        // xt
 290+ EA91             >Heap_Ptr        defl    $ - $E000           // save current HP
 290+ EA91             >
 290+ EA91             >Current_HP      defl  $ - $E000             // used to set HP once!
 290+ EA91             >
 290+ EA91             >//              ______________________________________________________________________
 290+ EA91             >//              Dictionary part
 290+ EA91             >
 290+ EA91             >                org     Dict_Ptr
 290+ B32D             >
 290+ B32D 8F 2A       >                dw      mirror_Ptr - $E000 + Heap_offset
 290+ B32F             >
 290+ B32F             >OPEN_FH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 290+ B32F CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 290+ B332             >
 290+ B332             >
 290+ B332             >                endif           ; ok        // for other definitions it "points" the correct handler
 290+ B332             >                // Use of "; ok" to suppress "warning[fwdref]"
 290+ B332             >
 290+ B332             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 291+ B332 E2 A2                        dw      BL
 292+ B334 02 A9 5C A7                  dw      WORD, COUNT, OVER       // bl word count over
 292+ B338 45 A1
 293+ B33A E3 A0 BF A2                  dw      PLUS, ZERO, SWAP, STORE // + 0 swap !
 293+ B33E 62 A1 D1 A1
 294+ B342 F3 A8 C6 A2                  dw      PAD, ONE, F_OPEN        // pad 1 f_open
 294+ B346 98 9F
 295+ B348 E1 9B 2B 00                  dw      LIT, 43                 // 43
 296+ B34C 20 A6                        dw      QERROR                  // ?error
 297+ B34E 90 A0                        dw      EXIT                    // ;
 298+ B350
 299+ B350              //  ______________________________________________________________________
 300+ B350              //
 301+ B350              // include      -- cccc
 302+ B350              // Include the following filename
 303+ B350                              Colon_Def INCLUDE, "INCLUDE", is_normal
 303+ B350             >                New_Def  INCLUDE, "INCLUDE", Enter_Ptr, is_normal ; ok
 303+ B350             >
 303+ B350             >Dict_Ptr        defl    $
 303+ B350             >
 303+ B350             >//              ______________________________________________________________________
 303+ B350             >//              Heap part
 303+ B350             >
 303+ B350             >
 303+ B350             >                org     (Heap_Ptr & $1FFF) + $E000
 303+ EA91             >
 303+ EA91             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 303+ EA91             >Latest_Definition defl  Heap_Ptr
 303+ EA91             >
 303+ EA91             >                // dummy db directives used to calculate length of namec
 303+ EA91 49 4E 43 4C >                db      "INCLUDE"
 303+ EA95 55 44 45    >
 303+ EA98             >len_NFA         defl    $ - temp_NFA
 303+ EA98             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 303+ EA91             >
 303+ EA91 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 303+ EA92 49 4E 43 4C >                db      "INCLUDE"               // name string in 7-bit ascii, but
 303+ EA96 55 44 45    >
 303+ EA99             >                org     $-1                 // alter last byte of Name just above to set
 303+ EA98 C5          >                db      {b $} | END_BIT     // msb as name end
 303+ EA99             >
 303+ EA99 87 2A       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 303+ EA9B             >Prev_Ptr        defl    Heap_Ptr
 303+ EA9B             >
 303+ EA9B             >mirror_Ptr      defl    $
 303+ EA9B             >
 303+ EA9B 52 B3       >                dw      Dict_Ptr + 2        // xt
 303+ EA9D             >Heap_Ptr        defl    $ - $E000           // save current HP
 303+ EA9D             >
 303+ EA9D             >Current_HP      defl  $ - $E000             // used to set HP once!
 303+ EA9D             >
 303+ EA9D             >//              ______________________________________________________________________
 303+ EA9D             >//              Dictionary part
 303+ EA9D             >
 303+ EA9D             >                org     Dict_Ptr
 303+ B350             >
 303+ B350 9B 2A       >                dw      mirror_Ptr - $E000 + Heap_offset
 303+ B352             >
 303+ B352             >INCLUDE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 303+ B352 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 303+ B355             >
 303+ B355             >
 303+ B355             >                endif           ; ok        // for other definitions it "points" the correct handler
 303+ B355             >                // Use of "; ok" to suppress "warning[fwdref]"
 303+ B355             >
 303+ B355             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 304+ B355 2F B3                        dw      OPEN_FH                 // open
 305+ B357 69 A1 78 B2                  dw      DUP, F_INCLUDE          // dup f_include
 306+ B35B 3D 9F 4E A1                  dw      F_CLOSE, DROP           // f_close drop
 307+ B35F 90 A0                        dw      EXIT                    // ;
 308+ B361
 309+ B361              //  ______________________________________________________________________
 310+ B361              //
 311+ B361              // needs
 312+ B361              // check for cccc exists in vocabulary
 313+ B361              // if it doesn't then  INCLUDE  inc/cccc.F
 314+ B361
 315+ B361              // temp filename cccc.f as counted string zero-padded
 316+ B361                              New_Def NEEDS_W,   "NEEDS-W", Create_Ptr, is_normal
 316+ B361             >
 316+ B361             >Dict_Ptr        defl    $
 316+ B361             >
 316+ B361             >//              ______________________________________________________________________
 316+ B361             >//              Heap part
 316+ B361             >
 316+ B361             >
 316+ B361             >                org     (Heap_Ptr & $1FFF) + $E000
 316+ EA9D             >
 316+ EA9D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 316+ EA9D             >Latest_Definition defl  Heap_Ptr
 316+ EA9D             >
 316+ EA9D             >                // dummy db directives used to calculate length of namec
 316+ EA9D 4E 45 45 44 >                db      "NEEDS-W"
 316+ EAA1 53 2D 57    >
 316+ EAA4             >len_NFA         defl    $ - temp_NFA
 316+ EAA4             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 316+ EA9D             >
 316+ EA9D 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 316+ EA9E 4E 45 45 44 >                db      "NEEDS-W"               // name string in 7-bit ascii, but
 316+ EAA2 53 2D 57    >
 316+ EAA5             >                org     $-1                 // alter last byte of Name just above to set
 316+ EAA4 D7          >                db      {b $} | END_BIT     // msb as name end
 316+ EAA5             >
 316+ EAA5 91 2A       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 316+ EAA7             >Prev_Ptr        defl    Heap_Ptr
 316+ EAA7             >
 316+ EAA7             >mirror_Ptr      defl    $
 316+ EAA7             >
 316+ EAA7 63 B3       >                dw      Dict_Ptr + 2        // xt
 316+ EAA9             >Heap_Ptr        defl    $ - $E000           // save current HP
 316+ EAA9             >
 316+ EAA9             >Current_HP      defl  $ - $E000             // used to set HP once!
 316+ EAA9             >
 316+ EAA9             >//              ______________________________________________________________________
 316+ EAA9             >//              Dictionary part
 316+ EAA9             >
 316+ EAA9             >                org     Dict_Ptr
 316+ B361             >
 316+ B361 A7 2A       >                dw      mirror_Ptr - $E000 + Heap_offset
 316+ B363             >
 316+ B363             >NEEDS_W:          if Create_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 316+ B363 CD 03 AC    >                call    Create_Ptr ; ok        // for primitive definitions  actual code
 316+ B366             >
 316+ B366             >
 316+ B366             >                endif           ; ok        // for other definitions it "points" the correct handler
 316+ B366             >                // Use of "; ok" to suppress "warning[fwdref]"
 316+ B366             >
 316+ B366             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 317+ B366 00 00 00...                  ds      35                      // 32 + .f + 0x00 = len 35
 318+ B389              // temp complete path+filename
 319+ B389                              New_Def NEEDS_FN,  "NEEDS-FN", Create_Ptr, is_normal
 319+ B389             >
 319+ B389             >Dict_Ptr        defl    $
 319+ B389             >
 319+ B389             >//              ______________________________________________________________________
 319+ B389             >//              Heap part
 319+ B389             >
 319+ B389             >
 319+ B389             >                org     (Heap_Ptr & $1FFF) + $E000
 319+ EAA9             >
 319+ EAA9             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 319+ EAA9             >Latest_Definition defl  Heap_Ptr
 319+ EAA9             >
 319+ EAA9             >                // dummy db directives used to calculate length of namec
 319+ EAA9 4E 45 45 44 >                db      "NEEDS-FN"
 319+ EAAD 53 2D 46 4E >
 319+ EAB1             >len_NFA         defl    $ - temp_NFA
 319+ EAB1             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 319+ EAA9             >
 319+ EAA9 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 319+ EAAA 4E 45 45 44 >                db      "NEEDS-FN"               // name string in 7-bit ascii, but
 319+ EAAE 53 2D 46 4E >
 319+ EAB2             >                org     $-1                 // alter last byte of Name just above to set
 319+ EAB1 CE          >                db      {b $} | END_BIT     // msb as name end
 319+ EAB2             >
 319+ EAB2 9D 2A       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 319+ EAB4             >Prev_Ptr        defl    Heap_Ptr
 319+ EAB4             >
 319+ EAB4             >mirror_Ptr      defl    $
 319+ EAB4             >
 319+ EAB4 8B B3       >                dw      Dict_Ptr + 2        // xt
 319+ EAB6             >Heap_Ptr        defl    $ - $E000           // save current HP
 319+ EAB6             >
 319+ EAB6             >Current_HP      defl  $ - $E000             // used to set HP once!
 319+ EAB6             >
 319+ EAB6             >//              ______________________________________________________________________
 319+ EAB6             >//              Dictionary part
 319+ EAB6             >
 319+ EAB6             >                org     Dict_Ptr
 319+ B389             >
 319+ B389 B4 2A       >                dw      mirror_Ptr - $E000 + Heap_offset
 319+ B38B             >
 319+ B38B             >NEEDS_FN:          if Create_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 319+ B38B CD 03 AC    >                call    Create_Ptr ; ok        // for primitive definitions  actual code
 319+ B38E             >
 319+ B38E             >
 319+ B38E             >                endif           ; ok        // for other definitions it "points" the correct handler
 319+ B38E             >                // Use of "; ok" to suppress "warning[fwdref]"
 319+ B38E             >
 319+ B38E             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 320+ B38E 00 00 00...                  ds      40
 321+ B3B6              // constant path
 322+ B3B6                              New_Def NEEDS_INC,  "NEEDS-INC", Create_Ptr, is_normal
 322+ B3B6             >
 322+ B3B6             >Dict_Ptr        defl    $
 322+ B3B6             >
 322+ B3B6             >//              ______________________________________________________________________
 322+ B3B6             >//              Heap part
 322+ B3B6             >
 322+ B3B6             >
 322+ B3B6             >                org     (Heap_Ptr & $1FFF) + $E000
 322+ EAB6             >
 322+ EAB6             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 322+ EAB6             >Latest_Definition defl  Heap_Ptr
 322+ EAB6             >
 322+ EAB6             >                // dummy db directives used to calculate length of namec
 322+ EAB6 4E 45 45 44 >                db      "NEEDS-INC"
 322+ EABA 53 2D 49 4E >
 322+ EABE 43          >
 322+ EABF             >len_NFA         defl    $ - temp_NFA
 322+ EABF             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 322+ EAB6             >
 322+ EAB6 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 322+ EAB7 4E 45 45 44 >                db      "NEEDS-INC"               // name string in 7-bit ascii, but
 322+ EABB 53 2D 49 4E >
 322+ EABF 43          >
 322+ EAC0             >                org     $-1                 // alter last byte of Name just above to set
 322+ EABF C3          >                db      {b $} | END_BIT     // msb as name end
 322+ EAC0             >
 322+ EAC0 A9 2A       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 322+ EAC2             >Prev_Ptr        defl    Heap_Ptr
 322+ EAC2             >
 322+ EAC2             >mirror_Ptr      defl    $
 322+ EAC2             >
 322+ EAC2 B8 B3       >                dw      Dict_Ptr + 2        // xt
 322+ EAC4             >Heap_Ptr        defl    $ - $E000           // save current HP
 322+ EAC4             >
 322+ EAC4             >Current_HP      defl  $ - $E000             // used to set HP once!
 322+ EAC4             >
 322+ EAC4             >//              ______________________________________________________________________
 322+ EAC4             >//              Dictionary part
 322+ EAC4             >
 322+ EAC4             >                org     Dict_Ptr
 322+ B3B6             >
 322+ B3B6 C2 2A       >                dw      mirror_Ptr - $E000 + Heap_offset
 322+ B3B8             >
 322+ B3B8             >NEEDS_INC:          if Create_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 322+ B3B8 CD 03 AC    >                call    Create_Ptr ; ok        // for primitive definitions  actual code
 322+ B3BB             >
 322+ B3BB             >
 322+ B3BB             >                endif           ; ok        // for other definitions it "points" the correct handler
 322+ B3BB             >                // Use of "; ok" to suppress "warning[fwdref]"
 322+ B3BB             >
 322+ B3BB             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 323+ B3BB 04 69 6E 63                  db      4, "inc/", 0
 323+ B3BF 2F 00
 324+ B3C1                              New_Def NEEDS_LIB,  "NEEDS-LIB", Create_Ptr, is_normal
 324+ B3C1             >
 324+ B3C1             >Dict_Ptr        defl    $
 324+ B3C1             >
 324+ B3C1             >//              ______________________________________________________________________
 324+ B3C1             >//              Heap part
 324+ B3C1             >
 324+ B3C1             >
 324+ B3C1             >                org     (Heap_Ptr & $1FFF) + $E000
 324+ EAC4             >
 324+ EAC4             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 324+ EAC4             >Latest_Definition defl  Heap_Ptr
 324+ EAC4             >
 324+ EAC4             >                // dummy db directives used to calculate length of namec
 324+ EAC4 4E 45 45 44 >                db      "NEEDS-LIB"
 324+ EAC8 53 2D 4C 49 >
 324+ EACC 42          >
 324+ EACD             >len_NFA         defl    $ - temp_NFA
 324+ EACD             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 324+ EAC4             >
 324+ EAC4 89          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 324+ EAC5 4E 45 45 44 >                db      "NEEDS-LIB"               // name string in 7-bit ascii, but
 324+ EAC9 53 2D 4C 49 >
 324+ EACD 42          >
 324+ EACE             >                org     $-1                 // alter last byte of Name just above to set
 324+ EACD C2          >                db      {b $} | END_BIT     // msb as name end
 324+ EACE             >
 324+ EACE B6 2A       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 324+ EAD0             >Prev_Ptr        defl    Heap_Ptr
 324+ EAD0             >
 324+ EAD0             >mirror_Ptr      defl    $
 324+ EAD0             >
 324+ EAD0 C3 B3       >                dw      Dict_Ptr + 2        // xt
 324+ EAD2             >Heap_Ptr        defl    $ - $E000           // save current HP
 324+ EAD2             >
 324+ EAD2             >Current_HP      defl  $ - $E000             // used to set HP once!
 324+ EAD2             >
 324+ EAD2             >//              ______________________________________________________________________
 324+ EAD2             >//              Dictionary part
 324+ EAD2             >
 324+ EAD2             >                org     Dict_Ptr
 324+ B3C1             >
 324+ B3C1 D0 2A       >                dw      mirror_Ptr - $E000 + Heap_offset
 324+ B3C3             >
 324+ B3C3             >NEEDS_LIB:          if Create_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 324+ B3C3 CD 03 AC    >                call    Create_Ptr ; ok        // for primitive definitions  actual code
 324+ B3C6             >
 324+ B3C6             >
 324+ B3C6             >                endif           ; ok        // for other definitions it "points" the correct handler
 324+ B3C6             >                // Use of "; ok" to suppress "warning[fwdref]"
 324+ B3C6             >
 324+ B3C6             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 325+ B3C6 04 6C 69 62                  db      4, "lib/", 0
 325+ B3CA 2F 00
 326+ B3CC
 327+ B3CC              // Concatenate path at a and filename and include it
 328+ B3CC              // No error is issued if filename doesn't exist.
 329+ B3CC                              Colon_Def NEEDS_SLASH, "NEEDS/", is_normal
 329+ B3CC             >                New_Def  NEEDS_SLASH, "NEEDS/", Enter_Ptr, is_normal ; ok
 329+ B3CC             >
 329+ B3CC             >Dict_Ptr        defl    $
 329+ B3CC             >
 329+ B3CC             >//              ______________________________________________________________________
 329+ B3CC             >//              Heap part
 329+ B3CC             >
 329+ B3CC             >
 329+ B3CC             >                org     (Heap_Ptr & $1FFF) + $E000
 329+ EAD2             >
 329+ EAD2             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 329+ EAD2             >Latest_Definition defl  Heap_Ptr
 329+ EAD2             >
 329+ EAD2             >                // dummy db directives used to calculate length of namec
 329+ EAD2 4E 45 45 44 >                db      "NEEDS/"
 329+ EAD6 53 2F       >
 329+ EAD8             >len_NFA         defl    $ - temp_NFA
 329+ EAD8             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 329+ EAD2             >
 329+ EAD2 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 329+ EAD3 4E 45 45 44 >                db      "NEEDS/"               // name string in 7-bit ascii, but
 329+ EAD7 53 2F       >
 329+ EAD9             >                org     $-1                 // alter last byte of Name just above to set
 329+ EAD8 AF          >                db      {b $} | END_BIT     // msb as name end
 329+ EAD9             >
 329+ EAD9 C4 2A       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 329+ EADB             >Prev_Ptr        defl    Heap_Ptr
 329+ EADB             >
 329+ EADB             >mirror_Ptr      defl    $
 329+ EADB             >
 329+ EADB CE B3       >                dw      Dict_Ptr + 2        // xt
 329+ EADD             >Heap_Ptr        defl    $ - $E000           // save current HP
 329+ EADD             >
 329+ EADD             >Current_HP      defl  $ - $E000             // used to set HP once!
 329+ EADD             >
 329+ EADD             >//              ______________________________________________________________________
 329+ EADD             >//              Dictionary part
 329+ EADD             >
 329+ EADD             >                org     Dict_Ptr
 329+ B3CC             >
 329+ B3CC DB 2A       >                dw      mirror_Ptr - $E000 + Heap_offset
 329+ B3CE             >
 329+ B3CE             >NEEDS_SLASH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 329+ B3CE CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 329+ B3D1             >
 329+ B3D1             >
 329+ B3D1             >                endif           ; ok        // for other definitions it "points" the correct handler
 329+ B3D1             >                // Use of "; ok" to suppress "warning[fwdref]"
 329+ B3D1             >
 329+ B3D1             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 330+ B3D1 5C A7 59 A1                  dw      COUNT, TUCK             // n a n
 331+ B3D5 8B B3 62 A1                  dw      NEEDS_FN, SWAP, CMOVE   // n        \ Path
 331+ B3D9 CB 9F
 332+ B3DB 8B B3 E3 A0                  dw      NEEDS_FN, PLUS          // a1+n     \ Concat
 333+ B3DF 63 B3 FC A0                  dw      NEEDS_W, ONE_PLUS, SWAP
 333+ B3E3 62 A1
 334+ B3E5 E1 9B 23 00                  dw      LIT, 35
 335+ B3E9 CB 9F                        dw      CMOVE
 336+ B3EB 8B B3                        dw      NEEDS_FN
 337+ B3ED F3 A8 C6 A2                  dw      PAD, ONE, F_OPEN
 337+ B3F1 98 9F
 338+ B3F3 B5 A0                        dw      ZEQUAL
 339+ B3F5 33 9C                        dw      ZBRANCH
 340+ B3F7 08 00                        dw      Needs_1 - $
 341+ B3F9 78 B2                        dw          F_INCLUDE
 342+ B3FB 26 9C                        dw      BRANCH
 343+ B3FD 04 00                        dw      Needs_2 - $
 344+ B3FF              Needs_1:
 345+ B3FF              //              dw          NEEDS_W, COUNT, TYPE, SPACE
 346+ B3FF              //              dw          LIT, 43, MESSAGE
 347+ B3FF 4E A1                        dw          DROP
 348+ B401              Needs_2:
 349+ B401 90 A0                        dw      EXIT                    // ;
 350+ B403
 351+ B403
 352+ B403                              New_Def NDOM,   "NDOM", Create_Ptr, is_normal
 352+ B403             >
 352+ B403             >Dict_Ptr        defl    $
 352+ B403             >
 352+ B403             >//              ______________________________________________________________________
 352+ B403             >//              Heap part
 352+ B403             >
 352+ B403             >
 352+ B403             >                org     (Heap_Ptr & $1FFF) + $E000
 352+ EADD             >
 352+ EADD             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 352+ EADD             >Latest_Definition defl  Heap_Ptr
 352+ EADD             >
 352+ EADD             >                // dummy db directives used to calculate length of namec
 352+ EADD 4E 44 4F 4D >                db      "NDOM"
 352+ EAE1             >len_NFA         defl    $ - temp_NFA
 352+ EAE1             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 352+ EADD             >
 352+ EADD 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 352+ EADE 4E 44 4F 4D >                db      "NDOM"               // name string in 7-bit ascii, but
 352+ EAE2             >                org     $-1                 // alter last byte of Name just above to set
 352+ EAE1 CD          >                db      {b $} | END_BIT     // msb as name end
 352+ EAE2             >
 352+ EAE2 D2 2A       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 352+ EAE4             >Prev_Ptr        defl    Heap_Ptr
 352+ EAE4             >
 352+ EAE4             >mirror_Ptr      defl    $
 352+ EAE4             >
 352+ EAE4 05 B4       >                dw      Dict_Ptr + 2        // xt
 352+ EAE6             >Heap_Ptr        defl    $ - $E000           // save current HP
 352+ EAE6             >
 352+ EAE6             >Current_HP      defl  $ - $E000             // used to set HP once!
 352+ EAE6             >
 352+ EAE6             >//              ______________________________________________________________________
 352+ EAE6             >//              Dictionary part
 352+ EAE6             >
 352+ EAE6             >                org     Dict_Ptr
 352+ B403             >
 352+ B403 E4 2A       >                dw      mirror_Ptr - $E000 + Heap_offset
 352+ B405             >
 352+ B405             >NDOM:          if Create_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 352+ B405 CD 03 AC    >                call    Create_Ptr ; ok        // for primitive definitions  actual code
 352+ B408             >
 352+ B408             >
 352+ B408             >                endif           ; ok        // for other definitions it "points" the correct handler
 352+ B408             >                // Use of "; ok" to suppress "warning[fwdref]"
 352+ B408             >
 352+ B408             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 353+ B408              //              db $3A, $3F, $2F, $2A, $7C, $5C, $3C, $3E, $22
 354+ B408 3A 3F 2F 2A                  db ':?/*|\<>"'
 354+ B40C 7C 5C 3C 3E
 354+ B410 22
 355+ B411 00                           db 0
 356+ B412
 357+ B412                              New_Def NCDM,   "NCDM", Create_Ptr, is_normal
 357+ B412             >
 357+ B412             >Dict_Ptr        defl    $
 357+ B412             >
 357+ B412             >//              ______________________________________________________________________
 357+ B412             >//              Heap part
 357+ B412             >
 357+ B412             >
 357+ B412             >                org     (Heap_Ptr & $1FFF) + $E000
 357+ EAE6             >
 357+ EAE6             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 357+ EAE6             >Latest_Definition defl  Heap_Ptr
 357+ EAE6             >
 357+ EAE6             >                // dummy db directives used to calculate length of namec
 357+ EAE6 4E 43 44 4D >                db      "NCDM"
 357+ EAEA             >len_NFA         defl    $ - temp_NFA
 357+ EAEA             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 357+ EAE6             >
 357+ EAE6 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 357+ EAE7 4E 43 44 4D >                db      "NCDM"               // name string in 7-bit ascii, but
 357+ EAEB             >                org     $-1                 // alter last byte of Name just above to set
 357+ EAEA CD          >                db      {b $} | END_BIT     // msb as name end
 357+ EAEB             >
 357+ EAEB DD 2A       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 357+ EAED             >Prev_Ptr        defl    Heap_Ptr
 357+ EAED             >
 357+ EAED             >mirror_Ptr      defl    $
 357+ EAED             >
 357+ EAED 14 B4       >                dw      Dict_Ptr + 2        // xt
 357+ EAEF             >Heap_Ptr        defl    $ - $E000           // save current HP
 357+ EAEF             >
 357+ EAEF             >Current_HP      defl  $ - $E000             // used to set HP once!
 357+ EAEF             >
 357+ EAEF             >//              ______________________________________________________________________
 357+ EAEF             >//              Dictionary part
 357+ EAEF             >
 357+ EAEF             >                org     Dict_Ptr
 357+ B412             >
 357+ B412 ED 2A       >                dw      mirror_Ptr - $E000 + Heap_offset
 357+ B414             >
 357+ B414             >NCDM:          if Create_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 357+ B414 CD 03 AC    >                call    Create_Ptr ; ok        // for primitive definitions  actual code
 357+ B417             >
 357+ B417             >
 357+ B417             >                endif           ; ok        // for other definitions it "points" the correct handler
 357+ B417             >                // Use of "; ok" to suppress "warning[fwdref]"
 357+ B417             >
 357+ B417             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 358+ B417              //              db $5F, $5E, $25, $26, $24, $5F, $7B, $7D, $7E
 359+ B417 5F 5E 25 26                  db '_^%&$_{}~'
 359+ B41B 24 5F 7B 7D
 359+ B41F 7E
 360+ B420 00                           db 0
 361+ B421
 362+ B421              // Replace illegal character in filename using the map here above
 363+ B421              // at the moment we need only  "
 364+ B421                              Colon_Def NEEDS_CHECK, "MAP-FN", is_normal
 364+ B421             >                New_Def  NEEDS_CHECK, "MAP-FN", Enter_Ptr, is_normal ; ok
 364+ B421             >
 364+ B421             >Dict_Ptr        defl    $
 364+ B421             >
 364+ B421             >//              ______________________________________________________________________
 364+ B421             >//              Heap part
 364+ B421             >
 364+ B421             >
 364+ B421             >                org     (Heap_Ptr & $1FFF) + $E000
 364+ EAEF             >
 364+ EAEF             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 364+ EAEF             >Latest_Definition defl  Heap_Ptr
 364+ EAEF             >
 364+ EAEF             >                // dummy db directives used to calculate length of namec
 364+ EAEF 4D 41 50 2D >                db      "MAP-FN"
 364+ EAF3 46 4E       >
 364+ EAF5             >len_NFA         defl    $ - temp_NFA
 364+ EAF5             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 364+ EAEF             >
 364+ EAEF 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 364+ EAF0 4D 41 50 2D >                db      "MAP-FN"               // name string in 7-bit ascii, but
 364+ EAF4 46 4E       >
 364+ EAF6             >                org     $-1                 // alter last byte of Name just above to set
 364+ EAF5 CE          >                db      {b $} | END_BIT     // msb as name end
 364+ EAF6             >
 364+ EAF6 E6 2A       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 364+ EAF8             >Prev_Ptr        defl    Heap_Ptr
 364+ EAF8             >
 364+ EAF8             >mirror_Ptr      defl    $
 364+ EAF8             >
 364+ EAF8 23 B4       >                dw      Dict_Ptr + 2        // xt
 364+ EAFA             >Heap_Ptr        defl    $ - $E000           // save current HP
 364+ EAFA             >
 364+ EAFA             >Current_HP      defl  $ - $E000             // used to set HP once!
 364+ EAFA             >
 364+ EAFA             >//              ______________________________________________________________________
 364+ EAFA             >//              Dictionary part
 364+ EAFA             >
 364+ EAFA             >                org     Dict_Ptr
 364+ B421             >
 364+ B421 F8 2A       >                dw      mirror_Ptr - $E000 + Heap_offset
 364+ B423             >
 364+ B423             >NEEDS_CHECK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 364+ B423 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 364+ B426             >
 364+ B426             >
 364+ B426             >                endif           ; ok        // for other definitions it "points" the correct handler
 364+ B426             >                // Use of "; ok" to suppress "warning[fwdref]"
 364+ B426             >
 364+ B426             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 365+ B426 5C A7 69 A7                  dw      COUNT, BOUNDS
 366+ B42A 72 9C                        dw      C_DO
 367+ B42C              Needs_3:
 368+ B42C 14 B4 05 B4                  dw          NCDM, NDOM, LIT, 10
 368+ B430 E1 9B 0A 00
 369+ B434 78 9C DC A1                  dw          I, CFETCH
 370+ B438 99 9D                        dw          C_MAP
 371+ B43A 78 9C E5 A1                  dw          I, CSTORE
 372+ B43E              Needs_4:
 373+ B43E 1E 9C                        dw      C_LOOP
 374+ B440 EC FF                        dw      Needs_3 - $
 375+ B442 90 A0                        dw      EXIT
 376+ B444
 377+ B444
 378+ B444              // include  "path/cccc.f" if cccc is not defined
 379+ B444              // filename cccc.f is temporary stored at NEEDS-W
 380+ B444                              Colon_Def NEEDS_PATH, "NEEDS-F", is_normal
 380+ B444             >                New_Def  NEEDS_PATH, "NEEDS-F", Enter_Ptr, is_normal ; ok
 380+ B444             >
 380+ B444             >Dict_Ptr        defl    $
 380+ B444             >
 380+ B444             >//              ______________________________________________________________________
 380+ B444             >//              Heap part
 380+ B444             >
 380+ B444             >
 380+ B444             >                org     (Heap_Ptr & $1FFF) + $E000
 380+ EAFA             >
 380+ EAFA             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 380+ EAFA             >Latest_Definition defl  Heap_Ptr
 380+ EAFA             >
 380+ EAFA             >                // dummy db directives used to calculate length of namec
 380+ EAFA 4E 45 45 44 >                db      "NEEDS-F"
 380+ EAFE 53 2D 46    >
 380+ EB01             >len_NFA         defl    $ - temp_NFA
 380+ EB01             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 380+ EAFA             >
 380+ EAFA 87          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 380+ EAFB 4E 45 45 44 >                db      "NEEDS-F"               // name string in 7-bit ascii, but
 380+ EAFF 53 2D 46    >
 380+ EB02             >                org     $-1                 // alter last byte of Name just above to set
 380+ EB01 C6          >                db      {b $} | END_BIT     // msb as name end
 380+ EB02             >
 380+ EB02 EF 2A       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 380+ EB04             >Prev_Ptr        defl    Heap_Ptr
 380+ EB04             >
 380+ EB04             >mirror_Ptr      defl    $
 380+ EB04             >
 380+ EB04 46 B4       >                dw      Dict_Ptr + 2        // xt
 380+ EB06             >Heap_Ptr        defl    $ - $E000           // save current HP
 380+ EB06             >
 380+ EB06             >Current_HP      defl  $ - $E000             // used to set HP once!
 380+ EB06             >
 380+ EB06             >//              ______________________________________________________________________
 380+ EB06             >//              Dictionary part
 380+ EB06             >
 380+ EB06             >                org     Dict_Ptr
 380+ B444             >
 380+ B444 04 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 380+ B446             >
 380+ B446             >NEEDS_PATH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 380+ B446 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 380+ B449             >
 380+ B449             >
 380+ B449             >                endif           ; ok        // for other definitions it "points" the correct handler
 380+ B449             >                // Use of "; ok" to suppress "warning[fwdref]"
 380+ B449             >
 380+ B449             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 381+ B449 FC AA                        dw      LFIND
 382+ B44B 33 9C                        dw      ZBRANCH
 383+ B44D 0A 00                        dw      Needs_5 - $
 384+ B44F
 385+ B44F 4E A1 92 A1                  dw          DROP, TWO_DROP
 386+ B453 26 9C                        dw      BRANCH
 387+ B455 2C 00                        dw      Needs_6 - $
 388+ B457              Needs_5:
 389+ B457 63 B3                        dw          NEEDS_W
 390+ B459 E1 9B 23 00                  dw          LIT, 35
 391+ B45D CA A8                        dw          ERASE                   // a
 392+ B45F E4 A3 DC A1                  dw          HERE, CFETCH, ONE_PLUS  // a n
 392+ B463 FC A0
 393+ B465 E4 A3 45 A1                  dw          HERE, OVER              // a n here n
 394+ B469 63 B3 62 A1                  dw          NEEDS_W, SWAP, CMOVE    // a n
 394+ B46D CB 9F
 395+ B46F 63 B3 23 B4                  dw          NEEDS_W, NEEDS_CHECK
 396+ B473 63 B3 E3 A0                  dw          NEEDS_W, PLUS           // a a1+1
 397+ B477 E1 9B 2E 66                  dw          LIT, $662E              // a a1+1 ".F"
 398+ B47B 62 A1 D1 A1                  dw          SWAP, STORE             // a
 399+ B47F CE B3                        dw          NEEDS_SLASH
 400+ B481              Needs_6:
 401+ B481 90 A0                        dw      EXIT
 402+ B483
 403+ B483
 404+ B483              // check for cccc exists in vocabulary
 405+ B483              // if it doesn't then  INCLUDE  inc/cccc.F
 406+ B483              // search in inc subdirectory
 407+ B483                              Colon_Def NEEDS, "NEEDS", is_normal
 407+ B483             >                New_Def  NEEDS, "NEEDS", Enter_Ptr, is_normal ; ok
 407+ B483             >
 407+ B483             >Dict_Ptr        defl    $
 407+ B483             >
 407+ B483             >//              ______________________________________________________________________
 407+ B483             >//              Heap part
 407+ B483             >
 407+ B483             >
 407+ B483             >                org     (Heap_Ptr & $1FFF) + $E000
 407+ EB06             >
 407+ EB06             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 407+ EB06             >Latest_Definition defl  Heap_Ptr
 407+ EB06             >
 407+ EB06             >                // dummy db directives used to calculate length of namec
 407+ EB06 4E 45 45 44 >                db      "NEEDS"
 407+ EB0A 53          >
 407+ EB0B             >len_NFA         defl    $ - temp_NFA
 407+ EB0B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 407+ EB06             >
 407+ EB06 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 407+ EB07 4E 45 45 44 >                db      "NEEDS"               // name string in 7-bit ascii, but
 407+ EB0B 53          >
 407+ EB0C             >                org     $-1                 // alter last byte of Name just above to set
 407+ EB0B D3          >                db      {b $} | END_BIT     // msb as name end
 407+ EB0C             >
 407+ EB0C FA 2A       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 407+ EB0E             >Prev_Ptr        defl    Heap_Ptr
 407+ EB0E             >
 407+ EB0E             >mirror_Ptr      defl    $
 407+ EB0E             >
 407+ EB0E 85 B4       >                dw      Dict_Ptr + 2        // xt
 407+ EB10             >Heap_Ptr        defl    $ - $E000           // save current HP
 407+ EB10             >
 407+ EB10             >Current_HP      defl  $ - $E000             // used to set HP once!
 407+ EB10             >
 407+ EB10             >//              ______________________________________________________________________
 407+ EB10             >//              Dictionary part
 407+ EB10             >
 407+ EB10             >                org     Dict_Ptr
 407+ B483             >
 407+ B483 0E 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 407+ B485             >
 407+ B485             >NEEDS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 407+ B485 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 407+ B488             >
 407+ B488             >
 407+ B488             >                endif           ; ok        // for other definitions it "points" the correct handler
 407+ B488             >                // Use of "; ok" to suppress "warning[fwdref]"
 407+ B488             >
 407+ B488             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 408+ B488 66 A3 C7 A1                  dw      TO_IN, FETCH
 409+ B48C 69 A1                        dw      DUP
 410+ B48E B8 B3 46 B4                  dw      NEEDS_INC, NEEDS_PATH
 411+ B492 66 A3 D1 A1                  dw      TO_IN, STORE
 412+ B496 C3 B3 46 B4                  dw      NEEDS_LIB, NEEDS_PATH
 413+ B49A 66 A3 D1 A1                  dw      TO_IN, STORE
 414+ B49E FC AA                        dw      LFIND
 415+ B4A0 33 9C                        dw      ZBRANCH
 416+ B4A2 08 00                        dw      Needs_10 - $
 417+ B4A4 92 A1                        dw          TWO_DROP
 418+ B4A6 26 9C                        dw      BRANCH
 419+ B4A8 10 00                        dw      Needs_11 - $
 420+ B4AA              Needs_10:
 421+ B4AA 63 B3 5C A7                  dw      NEEDS_W, COUNT, TYPE, SPACE
 421+ B4AE B0 A7 B5 A4
 422+ B4B2 E1 9B 2B 00                  dw      LIT, 43, MESSAGE
 422+ B4B6 71 AF
 423+ B4B8              Needs_11:
 424+ B4B8 90 A0                        dw      EXIT
 425+ B4BA
 426+ B4BA
 427+ B4BA              //  ______________________________________________________________________
 428+ B4BA              //
 429+ B4BA              // load         n --
 430+ B4BA                              Colon_Def LOAD, "LOAD", is_normal
 430+ B4BA             >                New_Def  LOAD, "LOAD", Enter_Ptr, is_normal ; ok
 430+ B4BA             >
 430+ B4BA             >Dict_Ptr        defl    $
 430+ B4BA             >
 430+ B4BA             >//              ______________________________________________________________________
 430+ B4BA             >//              Heap part
 430+ B4BA             >
 430+ B4BA             >
 430+ B4BA             >                org     (Heap_Ptr & $1FFF) + $E000
 430+ EB10             >
 430+ EB10             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 430+ EB10             >Latest_Definition defl  Heap_Ptr
 430+ EB10             >
 430+ EB10             >                // dummy db directives used to calculate length of namec
 430+ EB10 4C 4F 41 44 >                db      "LOAD"
 430+ EB14             >len_NFA         defl    $ - temp_NFA
 430+ EB14             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 430+ EB10             >
 430+ EB10 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 430+ EB11 4C 4F 41 44 >                db      "LOAD"               // name string in 7-bit ascii, but
 430+ EB15             >                org     $-1                 // alter last byte of Name just above to set
 430+ EB14 C4          >                db      {b $} | END_BIT     // msb as name end
 430+ EB15             >
 430+ EB15 06 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 430+ EB17             >Prev_Ptr        defl    Heap_Ptr
 430+ EB17             >
 430+ EB17             >mirror_Ptr      defl    $
 430+ EB17             >
 430+ EB17 BC B4       >                dw      Dict_Ptr + 2        // xt
 430+ EB19             >Heap_Ptr        defl    $ - $E000           // save current HP
 430+ EB19             >
 430+ EB19             >Current_HP      defl  $ - $E000             // used to set HP once!
 430+ EB19             >
 430+ EB19             >//              ______________________________________________________________________
 430+ EB19             >//              Dictionary part
 430+ EB19             >
 430+ EB19             >                org     Dict_Ptr
 430+ B4BA             >
 430+ B4BA 17 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 430+ B4BC             >
 430+ B4BC             >LOAD:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 430+ B4BC CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 430+ B4BF             >
 430+ B4BF             >
 430+ B4BF             >                endif           ; ok        // for other definitions it "points" the correct handler
 430+ B4BF             >                // Use of "; ok" to suppress "warning[fwdref]"
 430+ B4BF             >
 430+ B4BF             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 431+ B4BF 60 A3 C7 A1                  dw      BLK, FETCH, TO_R        // blk @ >r
 431+ B4C3 9A A0
 432+ B4C5 66 A3 C7 A1                  dw      TO_IN, FETCH, TO_R      // >in @ >r
 432+ B4C9 9A A0
 433+ B4CB
 434+ B4CB BF A2 66 A3                  dw      ZERO, TO_IN, STORE      // 0 >in !
 434+ B4CF D1 A1
 435+ B4D1 F7 A2 FD AE                  dw      BSCR, MUL, BLK, STORE   // b/scr * blk !
 435+ B4D5 60 A3 D1 A1
 436+ B4D9 BF AC                        dw      INTERPRET               // interpret
 437+ B4DB
 438+ B4DB A5 A0 66 A3                  dw      R_TO, TO_IN, STORE      // r> >in !
 438+ B4DF D1 A1
 439+ B4E1 A5 A0 60 A3                  dw      R_TO, BLK, STORE        // r> blk !
 439+ B4E5 D1 A1
 440+ B4E7 90 A0                        dw      EXIT                    // ;
 441+ B4E9
 442+ B4E9              //  ______________________________________________________________________
 443+ B4E9              //
 444+ B4E9              // -->          --
 445+ B4E9                              Colon_Def LOAD_NEXT, "-->", is_immediate
 445+ B4E9             >                New_Def  LOAD_NEXT, "-->", Enter_Ptr, is_immediate ; ok
 445+ B4E9             >
 445+ B4E9             >Dict_Ptr        defl    $
 445+ B4E9             >
 445+ B4E9             >//              ______________________________________________________________________
 445+ B4E9             >//              Heap part
 445+ B4E9             >
 445+ B4E9             >
 445+ B4E9             >                org     (Heap_Ptr & $1FFF) + $E000
 445+ EB19             >
 445+ EB19             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 445+ EB19             >Latest_Definition defl  Heap_Ptr
 445+ EB19             >
 445+ EB19             >                // dummy db directives used to calculate length of namec
 445+ EB19 2D 2D 3E    >                db      "-->"
 445+ EB1C             >len_NFA         defl    $ - temp_NFA
 445+ EB1C             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 445+ EB19             >
 445+ EB19 C3          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 445+ EB1A 2D 2D 3E    >                db      "-->"               // name string in 7-bit ascii, but
 445+ EB1D             >                org     $-1                 // alter last byte of Name just above to set
 445+ EB1C BE          >                db      {b $} | END_BIT     // msb as name end
 445+ EB1D             >
 445+ EB1D 10 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 445+ EB1F             >Prev_Ptr        defl    Heap_Ptr
 445+ EB1F             >
 445+ EB1F             >mirror_Ptr      defl    $
 445+ EB1F             >
 445+ EB1F EB B4       >                dw      Dict_Ptr + 2        // xt
 445+ EB21             >Heap_Ptr        defl    $ - $E000           // save current HP
 445+ EB21             >
 445+ EB21             >Current_HP      defl  $ - $E000             // used to set HP once!
 445+ EB21             >
 445+ EB21             >//              ______________________________________________________________________
 445+ EB21             >//              Dictionary part
 445+ EB21             >
 445+ EB21             >                org     Dict_Ptr
 445+ B4E9             >
 445+ B4E9 1F 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 445+ B4EB             >
 445+ B4EB             >LOAD_NEXT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 445+ B4EB CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 445+ B4EE             >
 445+ B4EE             >
 445+ B4EE             >                endif           ; ok        // for other definitions it "points" the correct handler
 445+ B4EE             >                // Use of "; ok" to suppress "warning[fwdref]"
 445+ B4EE             >
 445+ B4EE             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 446+ B4EE 7D A6                        dw      QLOADING                // ?loading
 447+ B4F0 BF A2 66 A3                  dw      ZERO, TO_IN, STORE      // 0 >in !
 447+ B4F4 D1 A1
 448+ B4F6 F7 A2                        dw      BSCR                    // b/scr
 449+ B4F8 60 A3 C7 A1                  dw      BLK, FETCH              // blk @
 450+ B4FC 45 A1                        dw      OVER                    // over
 451+ B4FE 22 AF                        dw      MOD                     // mod
 452+ B500 23 A4                        dw      SUBTRACT                // -
 453+ B502 60 A3 AF A1                  dw      BLK, PLUSSTORE          // +!
 454+ B506 90 A0                        dw      EXIT                    // ;
 455+ B508
 456+ B508              //  ______________________________________________________________________
 457+ B508              //
 458+ B508              // '            -- xt
 459+ B508                              Colon_Def TICK, "'", is_normal
 459+ B508             >                New_Def  TICK, "'", Enter_Ptr, is_normal ; ok
 459+ B508             >
 459+ B508             >Dict_Ptr        defl    $
 459+ B508             >
 459+ B508             >//              ______________________________________________________________________
 459+ B508             >//              Heap part
 459+ B508             >
 459+ B508             >
 459+ B508             >                org     (Heap_Ptr & $1FFF) + $E000
 459+ EB21             >
 459+ EB21             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 459+ EB21             >Latest_Definition defl  Heap_Ptr
 459+ EB21             >
 459+ EB21             >                // dummy db directives used to calculate length of namec
 459+ EB21 27          >                db      "'"
 459+ EB22             >len_NFA         defl    $ - temp_NFA
 459+ EB22             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 459+ EB21             >
 459+ EB21 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 459+ EB22 27          >                db      "'"               // name string in 7-bit ascii, but
 459+ EB23             >                org     $-1                 // alter last byte of Name just above to set
 459+ EB22 A7          >                db      {b $} | END_BIT     // msb as name end
 459+ EB23             >
 459+ EB23 19 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 459+ EB25             >Prev_Ptr        defl    Heap_Ptr
 459+ EB25             >
 459+ EB25             >mirror_Ptr      defl    $
 459+ EB25             >
 459+ EB25 0A B5       >                dw      Dict_Ptr + 2        // xt
 459+ EB27             >Heap_Ptr        defl    $ - $E000           // save current HP
 459+ EB27             >
 459+ EB27             >Current_HP      defl  $ - $E000             // used to set HP once!
 459+ EB27             >
 459+ EB27             >//              ______________________________________________________________________
 459+ EB27             >//              Dictionary part
 459+ EB27             >
 459+ EB27             >                org     Dict_Ptr
 459+ B508             >
 459+ B508 25 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 459+ B50A             >
 459+ B50A             >TICK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 459+ B50A CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 459+ B50D             >
 459+ B50D             >
 459+ B50D             >                endif           ; ok        // for other definitions it "points" the correct handler
 459+ B50D             >                // Use of "; ok" to suppress "warning[fwdref]"
 459+ B50D             >
 459+ B50D             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 460+ B50D FC AA                        dw      LFIND                   // -find
 461+ B50F B5 A0                        dw      ZEQUAL                  // 0=
 462+ B511 BF A2 20 A6                  dw      ZERO, QERROR            // 0 ?error
 463+ B515 4E A1                        dw      DROP                    // drop
 464+ B517 90 A0                        dw      EXIT                    // ;
 465+ B519
 466+ B519              //  ______________________________________________________________________
 467+ B519              //
 468+ B519              // forget       -- cccc
 469+ B519                              Colon_Def FORGET, "FORGET", is_normal
 469+ B519             >                New_Def  FORGET, "FORGET", Enter_Ptr, is_normal ; ok
 469+ B519             >
 469+ B519             >Dict_Ptr        defl    $
 469+ B519             >
 469+ B519             >//              ______________________________________________________________________
 469+ B519             >//              Heap part
 469+ B519             >
 469+ B519             >
 469+ B519             >                org     (Heap_Ptr & $1FFF) + $E000
 469+ EB27             >
 469+ EB27             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 469+ EB27             >Latest_Definition defl  Heap_Ptr
 469+ EB27             >
 469+ EB27             >                // dummy db directives used to calculate length of namec
 469+ EB27 46 4F 52 47 >                db      "FORGET"
 469+ EB2B 45 54       >
 469+ EB2D             >len_NFA         defl    $ - temp_NFA
 469+ EB2D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 469+ EB27             >
 469+ EB27 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 469+ EB28 46 4F 52 47 >                db      "FORGET"               // name string in 7-bit ascii, but
 469+ EB2C 45 54       >
 469+ EB2E             >                org     $-1                 // alter last byte of Name just above to set
 469+ EB2D D4          >                db      {b $} | END_BIT     // msb as name end
 469+ EB2E             >
 469+ EB2E 21 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 469+ EB30             >Prev_Ptr        defl    Heap_Ptr
 469+ EB30             >
 469+ EB30             >mirror_Ptr      defl    $
 469+ EB30             >
 469+ EB30 1B B5       >                dw      Dict_Ptr + 2        // xt
 469+ EB32             >Heap_Ptr        defl    $ - $E000           // save current HP
 469+ EB32             >
 469+ EB32             >Current_HP      defl  $ - $E000             // used to set HP once!
 469+ EB32             >
 469+ EB32             >//              ______________________________________________________________________
 469+ EB32             >//              Dictionary part
 469+ EB32             >
 469+ EB32             >                org     Dict_Ptr
 469+ B519             >
 469+ B519 30 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 469+ B51B             >
 469+ B51B             >FORGET:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 469+ B51B CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 469+ B51E             >
 469+ B51E             >
 469+ B51E             >                endif           ; ok        // for other definitions it "points" the correct handler
 469+ B51E             >                // Use of "; ok" to suppress "warning[fwdref]"
 469+ B51E             >
 469+ B51E             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 470+ B51E 84 A3 C7 A1                  dw      CURRENT, FETCH          // current @
 471+ B522 7E A3 C7 A1                  dw      CONTEXT, FETCH          // context @
 472+ B526 23 A4 E1 9B                  dw      SUBTRACT, LIT, 23, QERROR // - 23 ?error
 472+ B52A 17 00 20 A6
 473+ B52E 0A B5 9F A5                  dw      TICK, TO_BODY           // ' >body
 474+ B532 69 A1 36 A3                  dw      DUP, FENCE, FETCH       // dup fence @
 474+ B536 C7 A1
 475+ B538 3A A4 E1 9B                  dw      ULESS, LIT, 21, QERROR  // u< 21 ?error
 475+ B53C 15 00 20 A6
 476+ B540 69 A1 D4 A5                  dw      DUP, NFA                // dup nfa
 477+ B544
 478+ B544                          //  dw      DUP
 479+ B544                          //  dw      LIT, $E000, LESS
 480+ B544                          //  dw      MMU7_FETCH, ONE, EQUALS
 481+ B544                          //  dw      OR_OP, NOT_OP
 482+ B544                          //  dw      ZBRANCH
 483+ B544                          //  dw      Forget_then - $
 484+ B544
 485+ B544 DD A4 00 A5                  dw      MMU7_FETCH, FROM_FAR
 486+ B548 54 A3 D1 A1                  dw      HP, STORE
 487+ B54C 69 A1 C9 A5                  dw      DUP, CFA, CELL_MINUS
 487+ B550 17 A1
 488+ B552              // Forget_then:
 489+ B552 3C A3 D1 A1                  dw      DP, STORE               // dp !
 490+ B556 DF A5 C7 A1                  dw      LFA, FETCH              // lfa @
 491+ B55A 7E A3 C7 A1                  dw      CONTEXT, FETCH, STORE   // context @ !
 491+ B55E D1 A1
 492+ B560 90 A0                        dw      EXIT                    // ;
 493+ B562
 494+ B562              //  ______________________________________________________________________
 495+ B562              //
 496+ B562              // marker       -- cccc
 497+ B562                              Colon_Def MARKER, "MARKER", is_immediate
 497+ B562             >                New_Def  MARKER, "MARKER", Enter_Ptr, is_immediate ; ok
 497+ B562             >
 497+ B562             >Dict_Ptr        defl    $
 497+ B562             >
 497+ B562             >//              ______________________________________________________________________
 497+ B562             >//              Heap part
 497+ B562             >
 497+ B562             >
 497+ B562             >                org     (Heap_Ptr & $1FFF) + $E000
 497+ EB32             >
 497+ EB32             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 497+ EB32             >Latest_Definition defl  Heap_Ptr
 497+ EB32             >
 497+ EB32             >                // dummy db directives used to calculate length of namec
 497+ EB32 4D 41 52 4B >                db      "MARKER"
 497+ EB36 45 52       >
 497+ EB38             >len_NFA         defl    $ - temp_NFA
 497+ EB38             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 497+ EB32             >
 497+ EB32 C6          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 497+ EB33 4D 41 52 4B >                db      "MARKER"               // name string in 7-bit ascii, but
 497+ EB37 45 52       >
 497+ EB39             >                org     $-1                 // alter last byte of Name just above to set
 497+ EB38 D2          >                db      {b $} | END_BIT     // msb as name end
 497+ EB39             >
 497+ EB39 27 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 497+ EB3B             >Prev_Ptr        defl    Heap_Ptr
 497+ EB3B             >
 497+ EB3B             >mirror_Ptr      defl    $
 497+ EB3B             >
 497+ EB3B 64 B5       >                dw      Dict_Ptr + 2        // xt
 497+ EB3D             >Heap_Ptr        defl    $ - $E000           // save current HP
 497+ EB3D             >
 497+ EB3D             >Current_HP      defl  $ - $E000             // used to set HP once!
 497+ EB3D             >
 497+ EB3D             >//              ______________________________________________________________________
 497+ EB3D             >//              Dictionary part
 497+ EB3D             >
 497+ EB3D             >                org     Dict_Ptr
 497+ B562             >
 497+ B562 3B 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 497+ B564             >
 497+ B564             >MARKER:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 497+ B564 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 497+ B567             >
 497+ B567             >
 497+ B567             >                endif           ; ok        // for other definitions it "points" the correct handler
 497+ B567             >                // Use of "; ok" to suppress "warning[fwdref]"
 497+ B567             >
 497+ B567             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 498+ B567 34 A7                        dw      CBUILDS
 499+ B569 42 A3 C7 A1                  dw      VOC_LINK, FETCH, COMMA
 499+ B56D FA A3
 500+ B56F 84 A3 C7 A1                  dw      CURRENT, FETCH, COMMA
 500+ B573 FA A3
 501+ B575 7E A3 C7 A1                  dw      CONTEXT, FETCH, COMMA
 501+ B579 FA A3
 502+ B57B 84 A3 C7 A1                  dw      CURRENT, FETCH, FETCH,  COMMA
 502+ B57F C7 A1 FA A3
 503+ B583 90 A5 EE A5                  dw      LATEST, PFA, LFA, FETCH, COMMA
 503+ B587 DF A5 C7 A1
 503+ B58B FA A3
 504+ B58D 3F A7                        dw      DOES_TO
 505+ B58F 69 A1 C7 A1                  dw      DUP, FETCH, VOC_LINK, STORE, CELL_PLUS
 505+ B593 42 A3 D1 A1
 505+ B597 12 A1
 506+ B599 69 A1 C7 A1                  dw      DUP, FETCH, CURRENT, STORE, CELL_PLUS
 506+ B59D 84 A3 D1 A1
 506+ B5A1 12 A1
 507+ B5A3 69 A1 C7 A1                  dw      DUP, FETCH, CONTEXT, STORE, CELL_PLUS
 507+ B5A7 7E A3 D1 A1
 507+ B5AB 12 A1
 508+ B5AD 69 A1 C7 A1                  dw      DUP, FETCH
 509+ B5B1                          //  dw      DUP, QHEAPP
 510+ B5B1                          //  dw      ZBRANCH
 511+ B5B1                          //  dw      Marker_then - $
 512+ B5B1 69 A1 54 A3                  dw          DUP, HP, STORE
 512+ B5B5 D1 A1
 513+ B5B7 EE A5 C9 A5                  dw          PFA, CFA, CELL_MINUS
 513+ B5BB 17 A1
 514+ B5BD              // Marker_then:
 515+ B5BD 3C A3 D1 A1                  dw      DP, STORE, CELL_PLUS
 515+ B5C1 12 A1
 516+ B5C3 C7 A1 84 A3                  dw      FETCH, CURRENT, FETCH, STORE
 516+ B5C7 C7 A1 D1 A1
 517+ B5CB 90 A0                        dw      EXIT
 518+ B5CD
 519+ B5CD              //  ______________________________________________________________________
 520+ B5CD              //
 521+ B5CD              // spaces       n --
 522+ B5CD                              Colon_Def SPACES, "SPACES", is_normal
 522+ B5CD             >                New_Def  SPACES, "SPACES", Enter_Ptr, is_normal ; ok
 522+ B5CD             >
 522+ B5CD             >Dict_Ptr        defl    $
 522+ B5CD             >
 522+ B5CD             >//              ______________________________________________________________________
 522+ B5CD             >//              Heap part
 522+ B5CD             >
 522+ B5CD             >
 522+ B5CD             >                org     (Heap_Ptr & $1FFF) + $E000
 522+ EB3D             >
 522+ EB3D             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 522+ EB3D             >Latest_Definition defl  Heap_Ptr
 522+ EB3D             >
 522+ EB3D             >                // dummy db directives used to calculate length of namec
 522+ EB3D 53 50 41 43 >                db      "SPACES"
 522+ EB41 45 53       >
 522+ EB43             >len_NFA         defl    $ - temp_NFA
 522+ EB43             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 522+ EB3D             >
 522+ EB3D 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 522+ EB3E 53 50 41 43 >                db      "SPACES"               // name string in 7-bit ascii, but
 522+ EB42 45 53       >
 522+ EB44             >                org     $-1                 // alter last byte of Name just above to set
 522+ EB43 D3          >                db      {b $} | END_BIT     // msb as name end
 522+ EB44             >
 522+ EB44 32 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 522+ EB46             >Prev_Ptr        defl    Heap_Ptr
 522+ EB46             >
 522+ EB46             >mirror_Ptr      defl    $
 522+ EB46             >
 522+ EB46 CF B5       >                dw      Dict_Ptr + 2        // xt
 522+ EB48             >Heap_Ptr        defl    $ - $E000           // save current HP
 522+ EB48             >
 522+ EB48             >Current_HP      defl  $ - $E000             // used to set HP once!
 522+ EB48             >
 522+ EB48             >//              ______________________________________________________________________
 522+ EB48             >//              Dictionary part
 522+ EB48             >
 522+ EB48             >                org     Dict_Ptr
 522+ B5CD             >
 522+ B5CD 46 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 522+ B5CF             >
 522+ B5CF             >SPACES:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 522+ B5CF CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 522+ B5D2             >
 522+ B5D2             >
 522+ B5D2             >                endif           ; ok        // for other definitions it "points" the correct handler
 522+ B5D2             >                // Use of "; ok" to suppress "warning[fwdref]"
 522+ B5D2             >
 522+ B5D2             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 523+ B5D2 BF A2 7B A4                  dw      ZERO, MAX
 524+ B5D6 BF A2 4A 9C                  dw      ZERO, C_Q_DO
 525+ B5DA 08 00                        dw      Spaces_Leave - $
 526+ B5DC              Spaces_Loop:
 527+ B5DC B5 A4                        dw          SPACE
 528+ B5DE 1E 9C                        dw      C_LOOP
 529+ B5E0 FC FF                        dw      Spaces_Loop - $
 530+ B5E2              Spaces_Leave:
 531+ B5E2 90 A0                        dw      EXIT                    // ;
 532+ B5E4
 533+ B5E4              //  ______________________________________________________________________
 534+ B5E4              //
 535+ B5E4              // <#           --
 536+ B5E4                              Colon_Def BEGIN_DASH, "<#", is_normal
 536+ B5E4             >                New_Def  BEGIN_DASH, "<#", Enter_Ptr, is_normal ; ok
 536+ B5E4             >
 536+ B5E4             >Dict_Ptr        defl    $
 536+ B5E4             >
 536+ B5E4             >//              ______________________________________________________________________
 536+ B5E4             >//              Heap part
 536+ B5E4             >
 536+ B5E4             >
 536+ B5E4             >                org     (Heap_Ptr & $1FFF) + $E000
 536+ EB48             >
 536+ EB48             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 536+ EB48             >Latest_Definition defl  Heap_Ptr
 536+ EB48             >
 536+ EB48             >                // dummy db directives used to calculate length of namec
 536+ EB48 3C 23       >                db      "<#"
 536+ EB4A             >len_NFA         defl    $ - temp_NFA
 536+ EB4A             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 536+ EB48             >
 536+ EB48 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 536+ EB49 3C 23       >                db      "<#"               // name string in 7-bit ascii, but
 536+ EB4B             >                org     $-1                 // alter last byte of Name just above to set
 536+ EB4A A3          >                db      {b $} | END_BIT     // msb as name end
 536+ EB4B             >
 536+ EB4B 3D 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 536+ EB4D             >Prev_Ptr        defl    Heap_Ptr
 536+ EB4D             >
 536+ EB4D             >mirror_Ptr      defl    $
 536+ EB4D             >
 536+ EB4D E6 B5       >                dw      Dict_Ptr + 2        // xt
 536+ EB4F             >Heap_Ptr        defl    $ - $E000           // save current HP
 536+ EB4F             >
 536+ EB4F             >Current_HP      defl  $ - $E000             // used to set HP once!
 536+ EB4F             >
 536+ EB4F             >//              ______________________________________________________________________
 536+ EB4F             >//              Dictionary part
 536+ EB4F             >
 536+ EB4F             >                org     Dict_Ptr
 536+ B5E4             >
 536+ B5E4 4D 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 536+ B5E6             >
 536+ B5E6             >BEGIN_DASH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 536+ B5E6 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 536+ B5E9             >
 536+ B5E9             >
 536+ B5E9             >                endif           ; ok        // for other definitions it "points" the correct handler
 536+ B5E9             >                // Use of "; ok" to suppress "warning[fwdref]"
 536+ B5E9             >
 536+ B5E9             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 537+ B5E9 F3 A8 AE A3                  dw      PAD, HLD, STORE
 537+ B5ED D1 A1
 538+ B5EF 90 A0                        dw      EXIT
 539+ B5F1
 540+ B5F1              //  ______________________________________________________________________
 541+ B5F1              //
 542+ B5F1              // #>           --
 543+ B5F1                              Colon_Def DASH_END, "#>", is_normal
 543+ B5F1             >                New_Def  DASH_END, "#>", Enter_Ptr, is_normal ; ok
 543+ B5F1             >
 543+ B5F1             >Dict_Ptr        defl    $
 543+ B5F1             >
 543+ B5F1             >//              ______________________________________________________________________
 543+ B5F1             >//              Heap part
 543+ B5F1             >
 543+ B5F1             >
 543+ B5F1             >                org     (Heap_Ptr & $1FFF) + $E000
 543+ EB4F             >
 543+ EB4F             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 543+ EB4F             >Latest_Definition defl  Heap_Ptr
 543+ EB4F             >
 543+ EB4F             >                // dummy db directives used to calculate length of namec
 543+ EB4F 23 3E       >                db      "#>"
 543+ EB51             >len_NFA         defl    $ - temp_NFA
 543+ EB51             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 543+ EB4F             >
 543+ EB4F 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 543+ EB50 23 3E       >                db      "#>"               // name string in 7-bit ascii, but
 543+ EB52             >                org     $-1                 // alter last byte of Name just above to set
 543+ EB51 BE          >                db      {b $} | END_BIT     // msb as name end
 543+ EB52             >
 543+ EB52 48 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 543+ EB54             >Prev_Ptr        defl    Heap_Ptr
 543+ EB54             >
 543+ EB54             >mirror_Ptr      defl    $
 543+ EB54             >
 543+ EB54 F3 B5       >                dw      Dict_Ptr + 2        // xt
 543+ EB56             >Heap_Ptr        defl    $ - $E000           // save current HP
 543+ EB56             >
 543+ EB56             >Current_HP      defl  $ - $E000             // used to set HP once!
 543+ EB56             >
 543+ EB56             >//              ______________________________________________________________________
 543+ EB56             >//              Dictionary part
 543+ EB56             >
 543+ EB56             >                org     Dict_Ptr
 543+ B5F1             >
 543+ B5F1 54 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 543+ B5F3             >
 543+ B5F3             >DASH_END:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 543+ B5F3 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 543+ B5F6             >
 543+ B5F6             >
 543+ B5F6             >                endif           ; ok        // for other definitions it "points" the correct handler
 543+ B5F6             >                // Use of "; ok" to suppress "warning[fwdref]"
 543+ B5F6             >
 543+ B5F6             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 544+ B5F6 92 A1                        dw      TWO_DROP
 545+ B5F8 AE A3 C7 A1                  dw      HLD, FETCH, PAD, OVER, SUBTRACT
 545+ B5FC F3 A8 45 A1
 545+ B600 23 A4
 546+ B602 90 A0                        dw      EXIT
 547+ B604
 548+ B604              //  ______________________________________________________________________
 549+ B604              //
 550+ B604              // sign         n d -- d
 551+ B604                              Colon_Def SIGN, "SIGN", is_normal
 551+ B604             >                New_Def  SIGN, "SIGN", Enter_Ptr, is_normal ; ok
 551+ B604             >
 551+ B604             >Dict_Ptr        defl    $
 551+ B604             >
 551+ B604             >//              ______________________________________________________________________
 551+ B604             >//              Heap part
 551+ B604             >
 551+ B604             >
 551+ B604             >                org     (Heap_Ptr & $1FFF) + $E000
 551+ EB56             >
 551+ EB56             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 551+ EB56             >Latest_Definition defl  Heap_Ptr
 551+ EB56             >
 551+ EB56             >                // dummy db directives used to calculate length of namec
 551+ EB56 53 49 47 4E >                db      "SIGN"
 551+ EB5A             >len_NFA         defl    $ - temp_NFA
 551+ EB5A             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 551+ EB56             >
 551+ EB56 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 551+ EB57 53 49 47 4E >                db      "SIGN"               // name string in 7-bit ascii, but
 551+ EB5B             >                org     $-1                 // alter last byte of Name just above to set
 551+ EB5A CE          >                db      {b $} | END_BIT     // msb as name end
 551+ EB5B             >
 551+ EB5B 4F 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 551+ EB5D             >Prev_Ptr        defl    Heap_Ptr
 551+ EB5D             >
 551+ EB5D             >mirror_Ptr      defl    $
 551+ EB5D             >
 551+ EB5D 06 B6       >                dw      Dict_Ptr + 2        // xt
 551+ EB5F             >Heap_Ptr        defl    $ - $E000           // save current HP
 551+ EB5F             >
 551+ EB5F             >Current_HP      defl  $ - $E000             // used to set HP once!
 551+ EB5F             >
 551+ EB5F             >//              ______________________________________________________________________
 551+ EB5F             >//              Dictionary part
 551+ EB5F             >
 551+ EB5F             >                org     Dict_Ptr
 551+ B604             >
 551+ B604 5D 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 551+ B606             >
 551+ B606             >SIGN:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 551+ B606 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 551+ B609             >
 551+ B609             >
 551+ B609             >                endif           ; ok        // for other definitions it "points" the correct handler
 551+ B609             >                // Use of "; ok" to suppress "warning[fwdref]"
 551+ B609             >
 551+ B609             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 552+ B609 C8 A0                        dw      ZLESS
 553+ B60B 33 9C                        dw      ZBRANCH
 554+ B60D 08 00                        dw      Sign_Endif - $
 555+ B60F E1 9B 2D 00                  dw          LIT, 45, HOLD
 555+ B613 E0 A8
 556+ B615              Sign_Endif:
 557+ B615 90 A0                        dw      EXIT
 558+ B617
 559+ B617              //  ______________________________________________________________________
 560+ B617              //
 561+ B617              // #           d1 -- d2
 562+ B617                              Colon_Def DASH, "#", is_normal
 562+ B617             >                New_Def  DASH, "#", Enter_Ptr, is_normal ; ok
 562+ B617             >
 562+ B617             >Dict_Ptr        defl    $
 562+ B617             >
 562+ B617             >//              ______________________________________________________________________
 562+ B617             >//              Heap part
 562+ B617             >
 562+ B617             >
 562+ B617             >                org     (Heap_Ptr & $1FFF) + $E000
 562+ EB5F             >
 562+ EB5F             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 562+ EB5F             >Latest_Definition defl  Heap_Ptr
 562+ EB5F             >
 562+ EB5F             >                // dummy db directives used to calculate length of namec
 562+ EB5F 23          >                db      "#"
 562+ EB60             >len_NFA         defl    $ - temp_NFA
 562+ EB60             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 562+ EB5F             >
 562+ EB5F 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 562+ EB60 23          >                db      "#"               // name string in 7-bit ascii, but
 562+ EB61             >                org     $-1                 // alter last byte of Name just above to set
 562+ EB60 A3          >                db      {b $} | END_BIT     // msb as name end
 562+ EB61             >
 562+ EB61 56 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 562+ EB63             >Prev_Ptr        defl    Heap_Ptr
 562+ EB63             >
 562+ EB63             >mirror_Ptr      defl    $
 562+ EB63             >
 562+ EB63 19 B6       >                dw      Dict_Ptr + 2        // xt
 562+ EB65             >Heap_Ptr        defl    $ - $E000           // save current HP
 562+ EB65             >
 562+ EB65             >Current_HP      defl  $ - $E000             // used to set HP once!
 562+ EB65             >
 562+ EB65             >//              ______________________________________________________________________
 562+ EB65             >//              Dictionary part
 562+ EB65             >
 562+ EB65             >                org     Dict_Ptr
 562+ B617             >
 562+ B617 63 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 562+ B619             >
 562+ B619             >DASH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 562+ B619 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 562+ B61C             >
 562+ B61C             >
 562+ B61C             >                endif           ; ok        // for other definitions it "points" the correct handler
 562+ B61C             >                // Use of "; ok" to suppress "warning[fwdref]"
 562+ B61C             >
 562+ B61C             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 563+ B61C 90 A3 C7 A1                  dw      BASE, FETCH
 564+ B620
 565+ B620 9A A0                        dw      TO_R                    // >r           ( ud1 )
 566+ B622 BF A2 B0 A0                  dw      ZERO, R_OP, UMDIVMOD    // 0 r um/mod   ( l rem1 h/r )
 566+ B626 17 A0
 567+ B628 A5 A0 62 A1                  dw      R_TO, SWAP, TO_R        // r> swap >r   ( l rem )
 567+ B62C 9A A0
 568+ B62E 17 A0                        dw      UMDIVMOD                // um/mod       ( rem2 l/r )
 569+ B630 A5 A0                        dw      R_TO                    // r>           ( rem2 l/r h/r )
 570+ B632
 571+ B632 70 A1                        dw      ROT
 572+ B634 E1 9B 09 00                  dw      LIT, 9, OVER, LESS
 572+ B638 45 A1 48 A4
 573+ B63C 33 9C                        dw      ZBRANCH
 574+ B63E 08 00                        dw      Dash_Endif - $
 575+ B640 E1 9B 07 00                  dw          LIT, 7, PLUS
 575+ B644 E3 A0
 576+ B646              Dash_Endif:
 577+ B646
 578+ B646 E1 9B 30 00                  dw      LIT, 48, PLUS, HOLD
 578+ B64A E3 A0 E0 A8
 579+ B64E 90 A0                        dw      EXIT
 580+ B650
 581+ B650              //  ______________________________________________________________________
 582+ B650              //
 583+ B650              // #s           d1 -- d2
 584+ B650                              Colon_Def DASHES, "#S", is_normal
 584+ B650             >                New_Def  DASHES, "#S", Enter_Ptr, is_normal ; ok
 584+ B650             >
 584+ B650             >Dict_Ptr        defl    $
 584+ B650             >
 584+ B650             >//              ______________________________________________________________________
 584+ B650             >//              Heap part
 584+ B650             >
 584+ B650             >
 584+ B650             >                org     (Heap_Ptr & $1FFF) + $E000
 584+ EB65             >
 584+ EB65             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 584+ EB65             >Latest_Definition defl  Heap_Ptr
 584+ EB65             >
 584+ EB65             >                // dummy db directives used to calculate length of namec
 584+ EB65 23 53       >                db      "#S"
 584+ EB67             >len_NFA         defl    $ - temp_NFA
 584+ EB67             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 584+ EB65             >
 584+ EB65 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 584+ EB66 23 53       >                db      "#S"               // name string in 7-bit ascii, but
 584+ EB68             >                org     $-1                 // alter last byte of Name just above to set
 584+ EB67 D3          >                db      {b $} | END_BIT     // msb as name end
 584+ EB68             >
 584+ EB68 5F 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 584+ EB6A             >Prev_Ptr        defl    Heap_Ptr
 584+ EB6A             >
 584+ EB6A             >mirror_Ptr      defl    $
 584+ EB6A             >
 584+ EB6A 52 B6       >                dw      Dict_Ptr + 2        // xt
 584+ EB6C             >Heap_Ptr        defl    $ - $E000           // save current HP
 584+ EB6C             >
 584+ EB6C             >Current_HP      defl  $ - $E000             // used to set HP once!
 584+ EB6C             >
 584+ EB6C             >//              ______________________________________________________________________
 584+ EB6C             >//              Dictionary part
 584+ EB6C             >
 584+ EB6C             >                org     Dict_Ptr
 584+ B650             >
 584+ B650 6A 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 584+ B652             >
 584+ B652             >DASHES:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 584+ B652 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 584+ B655             >
 584+ B655             >
 584+ B655             >                endif           ; ok        // for other definitions it "points" the correct handler
 584+ B655             >                // Use of "; ok" to suppress "warning[fwdref]"
 584+ B655             >
 584+ B655             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 585+ B655              Dashes_Begin:
 586+ B655 19 B6 A5 A1                  dw      DASH, TWO_DUP
 587+ B659 59 A0 B5 A0                  dw          OR_OP, ZEQUAL
 588+ B65D 33 9C                        dw      ZBRANCH
 589+ B65F F6 FF                        dw      Dashes_Begin - $
 590+ B661 90 A0                        dw      EXIT
 591+ B663
 592+ B663              //  ______________________________________________________________________
 593+ B663              //
 594+ B663              // d.r          d n --
 595+ B663                              Colon_Def D_DOT_R, "D.R", is_normal
 595+ B663             >                New_Def  D_DOT_R, "D.R", Enter_Ptr, is_normal ; ok
 595+ B663             >
 595+ B663             >Dict_Ptr        defl    $
 595+ B663             >
 595+ B663             >//              ______________________________________________________________________
 595+ B663             >//              Heap part
 595+ B663             >
 595+ B663             >
 595+ B663             >                org     (Heap_Ptr & $1FFF) + $E000
 595+ EB6C             >
 595+ EB6C             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 595+ EB6C             >Latest_Definition defl  Heap_Ptr
 595+ EB6C             >
 595+ EB6C             >                // dummy db directives used to calculate length of namec
 595+ EB6C 44 2E 52    >                db      "D.R"
 595+ EB6F             >len_NFA         defl    $ - temp_NFA
 595+ EB6F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 595+ EB6C             >
 595+ EB6C 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 595+ EB6D 44 2E 52    >                db      "D.R"               // name string in 7-bit ascii, but
 595+ EB70             >                org     $-1                 // alter last byte of Name just above to set
 595+ EB6F D2          >                db      {b $} | END_BIT     // msb as name end
 595+ EB70             >
 595+ EB70 65 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 595+ EB72             >Prev_Ptr        defl    Heap_Ptr
 595+ EB72             >
 595+ EB72             >mirror_Ptr      defl    $
 595+ EB72             >
 595+ EB72 65 B6       >                dw      Dict_Ptr + 2        // xt
 595+ EB74             >Heap_Ptr        defl    $ - $E000           // save current HP
 595+ EB74             >
 595+ EB74             >Current_HP      defl  $ - $E000             // used to set HP once!
 595+ EB74             >
 595+ EB74             >//              ______________________________________________________________________
 595+ EB74             >//              Dictionary part
 595+ EB74             >
 595+ EB74             >                org     Dict_Ptr
 595+ B663             >
 595+ B663 72 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 595+ B665             >
 595+ B665             >D_DOT_R:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 595+ B665 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 595+ B668             >
 595+ B668             >
 595+ B668             >                endif           ; ok        // for other definitions it "points" the correct handler
 595+ B668             >                // Use of "; ok" to suppress "warning[fwdref]"
 595+ B668             >
 595+ B668             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 596+ B668 9A A0                        dw      TO_R
 597+ B66A 59 A1 69 AE                  dw      TUCK, DABS
 598+ B66E E6 B5 52 B6                  dw      BEGIN_DASH, DASHES, ROT, SIGN, DASH_END
 598+ B672 70 A1 06 B6
 598+ B676 F3 B5
 599+ B678 A5 A0                        dw      R_TO
 600+ B67A 45 A1 23 A4                  dw      OVER, SUBTRACT, SPACES, TYPE
 600+ B67E CF B5 B0 A7
 601+ B682 90 A0                        dw      EXIT
 602+ B684
 603+ B684              //  ______________________________________________________________________
 604+ B684              //
 605+ B684              // .r           n1 n2 --
 606+ B684                              Colon_Def DOT_R, ".R", is_normal
 606+ B684             >                New_Def  DOT_R, ".R", Enter_Ptr, is_normal ; ok
 606+ B684             >
 606+ B684             >Dict_Ptr        defl    $
 606+ B684             >
 606+ B684             >//              ______________________________________________________________________
 606+ B684             >//              Heap part
 606+ B684             >
 606+ B684             >
 606+ B684             >                org     (Heap_Ptr & $1FFF) + $E000
 606+ EB74             >
 606+ EB74             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 606+ EB74             >Latest_Definition defl  Heap_Ptr
 606+ EB74             >
 606+ EB74             >                // dummy db directives used to calculate length of namec
 606+ EB74 2E 52       >                db      ".R"
 606+ EB76             >len_NFA         defl    $ - temp_NFA
 606+ EB76             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 606+ EB74             >
 606+ EB74 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 606+ EB75 2E 52       >                db      ".R"               // name string in 7-bit ascii, but
 606+ EB77             >                org     $-1                 // alter last byte of Name just above to set
 606+ EB76 D2          >                db      {b $} | END_BIT     // msb as name end
 606+ EB77             >
 606+ EB77 6C 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 606+ EB79             >Prev_Ptr        defl    Heap_Ptr
 606+ EB79             >
 606+ EB79             >mirror_Ptr      defl    $
 606+ EB79             >
 606+ EB79 86 B6       >                dw      Dict_Ptr + 2        // xt
 606+ EB7B             >Heap_Ptr        defl    $ - $E000           // save current HP
 606+ EB7B             >
 606+ EB7B             >Current_HP      defl  $ - $E000             // used to set HP once!
 606+ EB7B             >
 606+ EB7B             >//              ______________________________________________________________________
 606+ EB7B             >//              Dictionary part
 606+ EB7B             >
 606+ EB7B             >                org     Dict_Ptr
 606+ B684             >
 606+ B684 79 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 606+ B686             >
 606+ B686             >DOT_R:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 606+ B686 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 606+ B689             >
 606+ B689             >
 606+ B689             >                endif           ; ok        // for other definitions it "points" the correct handler
 606+ B689             >                // Use of "; ok" to suppress "warning[fwdref]"
 606+ B689             >
 606+ B689             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 607+ B689 9A A0                        dw      TO_R
 608+ B68B 18 A4 A5 A0                  dw      S_TO_D, R_TO
 609+ B68F 65 B6                        dw      D_DOT_R
 610+ B691 90 A0                        dw      EXIT
 611+ B693
 612+ B693              //  ______________________________________________________________________
 613+ B693              //
 614+ B693              // d.           d --
 615+ B693                              Colon_Def D_DOT, "D.", is_normal
 615+ B693             >                New_Def  D_DOT, "D.", Enter_Ptr, is_normal ; ok
 615+ B693             >
 615+ B693             >Dict_Ptr        defl    $
 615+ B693             >
 615+ B693             >//              ______________________________________________________________________
 615+ B693             >//              Heap part
 615+ B693             >
 615+ B693             >
 615+ B693             >                org     (Heap_Ptr & $1FFF) + $E000
 615+ EB7B             >
 615+ EB7B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 615+ EB7B             >Latest_Definition defl  Heap_Ptr
 615+ EB7B             >
 615+ EB7B             >                // dummy db directives used to calculate length of namec
 615+ EB7B 44 2E       >                db      "D."
 615+ EB7D             >len_NFA         defl    $ - temp_NFA
 615+ EB7D             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 615+ EB7B             >
 615+ EB7B 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 615+ EB7C 44 2E       >                db      "D."               // name string in 7-bit ascii, but
 615+ EB7E             >                org     $-1                 // alter last byte of Name just above to set
 615+ EB7D AE          >                db      {b $} | END_BIT     // msb as name end
 615+ EB7E             >
 615+ EB7E 74 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 615+ EB80             >Prev_Ptr        defl    Heap_Ptr
 615+ EB80             >
 615+ EB80             >mirror_Ptr      defl    $
 615+ EB80             >
 615+ EB80 95 B6       >                dw      Dict_Ptr + 2        // xt
 615+ EB82             >Heap_Ptr        defl    $ - $E000           // save current HP
 615+ EB82             >
 615+ EB82             >Current_HP      defl  $ - $E000             // used to set HP once!
 615+ EB82             >
 615+ EB82             >//              ______________________________________________________________________
 615+ EB82             >//              Dictionary part
 615+ EB82             >
 615+ EB82             >                org     Dict_Ptr
 615+ B693             >
 615+ B693 80 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 615+ B695             >
 615+ B695             >D_DOT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 615+ B695 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 615+ B698             >
 615+ B698             >
 615+ B698             >                endif           ; ok        // for other definitions it "points" the correct handler
 615+ B698             >                // Use of "; ok" to suppress "warning[fwdref]"
 615+ B698             >
 615+ B698             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 616+ B698 BF A2 65 B6                  dw      ZERO, D_DOT_R, SPACE
 616+ B69C B5 A4
 617+ B69E 90 A0                        dw      EXIT
 618+ B6A0
 619+ B6A0              //  ______________________________________________________________________
 620+ B6A0              //
 621+ B6A0              // .            n --
 622+ B6A0                              Colon_Def DOT, ".", is_normal
 622+ B6A0             >                New_Def  DOT, ".", Enter_Ptr, is_normal ; ok
 622+ B6A0             >
 622+ B6A0             >Dict_Ptr        defl    $
 622+ B6A0             >
 622+ B6A0             >//              ______________________________________________________________________
 622+ B6A0             >//              Heap part
 622+ B6A0             >
 622+ B6A0             >
 622+ B6A0             >                org     (Heap_Ptr & $1FFF) + $E000
 622+ EB82             >
 622+ EB82             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 622+ EB82             >Latest_Definition defl  Heap_Ptr
 622+ EB82             >
 622+ EB82             >                // dummy db directives used to calculate length of namec
 622+ EB82 2E          >                db      "."
 622+ EB83             >len_NFA         defl    $ - temp_NFA
 622+ EB83             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 622+ EB82             >
 622+ EB82 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 622+ EB83 2E          >                db      "."               // name string in 7-bit ascii, but
 622+ EB84             >                org     $-1                 // alter last byte of Name just above to set
 622+ EB83 AE          >                db      {b $} | END_BIT     // msb as name end
 622+ EB84             >
 622+ EB84 7B 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 622+ EB86             >Prev_Ptr        defl    Heap_Ptr
 622+ EB86             >
 622+ EB86             >mirror_Ptr      defl    $
 622+ EB86             >
 622+ EB86 A2 B6       >                dw      Dict_Ptr + 2        // xt
 622+ EB88             >Heap_Ptr        defl    $ - $E000           // save current HP
 622+ EB88             >
 622+ EB88             >Current_HP      defl  $ - $E000             // used to set HP once!
 622+ EB88             >
 622+ EB88             >//              ______________________________________________________________________
 622+ EB88             >//              Dictionary part
 622+ EB88             >
 622+ EB88             >                org     Dict_Ptr
 622+ B6A0             >
 622+ B6A0 86 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 622+ B6A2             >
 622+ B6A2             >DOT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 622+ B6A2 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 622+ B6A5             >
 622+ B6A5             >
 622+ B6A5             >                endif           ; ok        // for other definitions it "points" the correct handler
 622+ B6A5             >                // Use of "; ok" to suppress "warning[fwdref]"
 622+ B6A5             >
 622+ B6A5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 623+ B6A5 18 A4 95 B6                  dw      S_TO_D, D_DOT
 624+ B6A9 90 A0                        dw      EXIT
 625+ B6AB
 626+ B6AB              //  ______________________________________________________________________
 627+ B6AB              //
 628+ B6AB              // ?            n --
 629+ B6AB                              Colon_Def QUESTION, "?", is_normal
 629+ B6AB             >                New_Def  QUESTION, "?", Enter_Ptr, is_normal ; ok
 629+ B6AB             >
 629+ B6AB             >Dict_Ptr        defl    $
 629+ B6AB             >
 629+ B6AB             >//              ______________________________________________________________________
 629+ B6AB             >//              Heap part
 629+ B6AB             >
 629+ B6AB             >
 629+ B6AB             >                org     (Heap_Ptr & $1FFF) + $E000
 629+ EB88             >
 629+ EB88             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 629+ EB88             >Latest_Definition defl  Heap_Ptr
 629+ EB88             >
 629+ EB88             >                // dummy db directives used to calculate length of namec
 629+ EB88 3F          >                db      "?"
 629+ EB89             >len_NFA         defl    $ - temp_NFA
 629+ EB89             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 629+ EB88             >
 629+ EB88 81          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 629+ EB89 3F          >                db      "?"               // name string in 7-bit ascii, but
 629+ EB8A             >                org     $-1                 // alter last byte of Name just above to set
 629+ EB89 BF          >                db      {b $} | END_BIT     // msb as name end
 629+ EB8A             >
 629+ EB8A 82 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 629+ EB8C             >Prev_Ptr        defl    Heap_Ptr
 629+ EB8C             >
 629+ EB8C             >mirror_Ptr      defl    $
 629+ EB8C             >
 629+ EB8C AD B6       >                dw      Dict_Ptr + 2        // xt
 629+ EB8E             >Heap_Ptr        defl    $ - $E000           // save current HP
 629+ EB8E             >
 629+ EB8E             >Current_HP      defl  $ - $E000             // used to set HP once!
 629+ EB8E             >
 629+ EB8E             >//              ______________________________________________________________________
 629+ EB8E             >//              Dictionary part
 629+ EB8E             >
 629+ EB8E             >                org     Dict_Ptr
 629+ B6AB             >
 629+ B6AB 8C 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 629+ B6AD             >
 629+ B6AD             >QUESTION:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 629+ B6AD CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 629+ B6B0             >
 629+ B6B0             >
 629+ B6B0             >                endif           ; ok        // for other definitions it "points" the correct handler
 629+ B6B0             >                // Use of "; ok" to suppress "warning[fwdref]"
 629+ B6B0             >
 629+ B6B0             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 630+ B6B0 C7 A1 A2 B6                  dw      FETCH, DOT
 631+ B6B4 90 A0                        dw      EXIT
 632+ B6B6
 633+ B6B6              //  ______________________________________________________________________
 634+ B6B6              //
 635+ B6B6              // u.           u --
 636+ B6B6                              Colon_Def U_DOT, "U.", is_normal
 636+ B6B6             >                New_Def  U_DOT, "U.", Enter_Ptr, is_normal ; ok
 636+ B6B6             >
 636+ B6B6             >Dict_Ptr        defl    $
 636+ B6B6             >
 636+ B6B6             >//              ______________________________________________________________________
 636+ B6B6             >//              Heap part
 636+ B6B6             >
 636+ B6B6             >
 636+ B6B6             >                org     (Heap_Ptr & $1FFF) + $E000
 636+ EB8E             >
 636+ EB8E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 636+ EB8E             >Latest_Definition defl  Heap_Ptr
 636+ EB8E             >
 636+ EB8E             >                // dummy db directives used to calculate length of namec
 636+ EB8E 55 2E       >                db      "U."
 636+ EB90             >len_NFA         defl    $ - temp_NFA
 636+ EB90             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 636+ EB8E             >
 636+ EB8E 82          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 636+ EB8F 55 2E       >                db      "U."               // name string in 7-bit ascii, but
 636+ EB91             >                org     $-1                 // alter last byte of Name just above to set
 636+ EB90 AE          >                db      {b $} | END_BIT     // msb as name end
 636+ EB91             >
 636+ EB91 88 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 636+ EB93             >Prev_Ptr        defl    Heap_Ptr
 636+ EB93             >
 636+ EB93             >mirror_Ptr      defl    $
 636+ EB93             >
 636+ EB93 B8 B6       >                dw      Dict_Ptr + 2        // xt
 636+ EB95             >Heap_Ptr        defl    $ - $E000           // save current HP
 636+ EB95             >
 636+ EB95             >Current_HP      defl  $ - $E000             // used to set HP once!
 636+ EB95             >
 636+ EB95             >//              ______________________________________________________________________
 636+ EB95             >//              Dictionary part
 636+ EB95             >
 636+ EB95             >                org     Dict_Ptr
 636+ B6B6             >
 636+ B6B6 93 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 636+ B6B8             >
 636+ B6B8             >U_DOT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 636+ B6B8 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 636+ B6BB             >
 636+ B6BB             >
 636+ B6BB             >                endif           ; ok        // for other definitions it "points" the correct handler
 636+ B6BB             >                // Use of "; ok" to suppress "warning[fwdref]"
 636+ B6BB             >
 636+ B6BB             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 637+ B6BB BF A2 95 B6                  dw      ZERO, D_DOT
 638+ B6BF 90 A0                        dw      EXIT
 639+ B6C1
 640+ B6C1              //  ______________________________________________________________________
 641+ B6C1              //
 642+ B6C1              // words        --
 643+ B6C1                              Colon_Def WORDS, "WORDS", is_normal
 643+ B6C1             >                New_Def  WORDS, "WORDS", Enter_Ptr, is_normal ; ok
 643+ B6C1             >
 643+ B6C1             >Dict_Ptr        defl    $
 643+ B6C1             >
 643+ B6C1             >//              ______________________________________________________________________
 643+ B6C1             >//              Heap part
 643+ B6C1             >
 643+ B6C1             >
 643+ B6C1             >                org     (Heap_Ptr & $1FFF) + $E000
 643+ EB95             >
 643+ EB95             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 643+ EB95             >Latest_Definition defl  Heap_Ptr
 643+ EB95             >
 643+ EB95             >                // dummy db directives used to calculate length of namec
 643+ EB95 57 4F 52 44 >                db      "WORDS"
 643+ EB99 53          >
 643+ EB9A             >len_NFA         defl    $ - temp_NFA
 643+ EB9A             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 643+ EB95             >
 643+ EB95 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 643+ EB96 57 4F 52 44 >                db      "WORDS"               // name string in 7-bit ascii, but
 643+ EB9A 53          >
 643+ EB9B             >                org     $-1                 // alter last byte of Name just above to set
 643+ EB9A D3          >                db      {b $} | END_BIT     // msb as name end
 643+ EB9B             >
 643+ EB9B 8E 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 643+ EB9D             >Prev_Ptr        defl    Heap_Ptr
 643+ EB9D             >
 643+ EB9D             >mirror_Ptr      defl    $
 643+ EB9D             >
 643+ EB9D C3 B6       >                dw      Dict_Ptr + 2        // xt
 643+ EB9F             >Heap_Ptr        defl    $ - $E000           // save current HP
 643+ EB9F             >
 643+ EB9F             >Current_HP      defl  $ - $E000             // used to set HP once!
 643+ EB9F             >
 643+ EB9F             >//              ______________________________________________________________________
 643+ EB9F             >//              Dictionary part
 643+ EB9F             >
 643+ EB9F             >                org     Dict_Ptr
 643+ B6C1             >
 643+ B6C1 9D 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 643+ B6C3             >
 643+ B6C3             >WORDS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 643+ B6C3 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 643+ B6C6             >
 643+ B6C6             >
 643+ B6C6             >                endif           ; ok        // for other definitions it "points" the correct handler
 643+ B6C6             >                // Use of "; ok" to suppress "warning[fwdref]"
 643+ B6C6             >
 643+ B6C6             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 644+ B6C6 E1 9B 80 00                  dw      LIT, 128, OUT, STORE
 644+ B6CA 6C A3 D1 A1
 645+ B6CE 7E A3 C7 A1                  dw      CONTEXT, FETCH, FETCH
 645+ B6D2 C7 A1
 646+ B6D4              Words_Begin:
 647+ B6D4 26 A5                        dw          FAR // Q TO HEAP
 648+ B6D6 69 A1 DC A1                  dw          DUP, CFETCH, LIT, $1F, AND_OP
 648+ B6DA E1 9B 1F 00
 648+ B6DE 4A A0
 649+ B6E0 6C A3 C7 A1                  dw          OUT, FETCH, PLUS
 649+ B6E4 E3 A0
 650+ B6E6 E9 A2 48 A4                  dw          CL, LESS, ZEQUAL
 650+ B6EA B5 A0
 651+ B6EC 33 9C                        dw          ZBRANCH
 652+ B6EE 0A 00                        dw          Words_Endif - $
 653+ B6F0 F4 9D BF A2                  dw              CR, ZERO, OUT, STORE
 653+ B6F4 6C A3 D1 A1
 654+ B6F8              Words_Endif:
 655+ B6F8 69 A1 4A AB                  dw          DUP, ID_DOT
 656+ B6FC C6 A2 C0 A4                  dw          ONE, TRAVERSE, ONE_PLUS, FETCH
 656+ B700 FC A0 C7 A1
 657+ B704 69 A1 B5 A0                  dw          DUP, ZEQUAL
 658+ B708 F1 9E 59 A0                  dw          QTERMINAL, OR_OP
 659+ B70C 33 9C                        dw      ZBRANCH
 660+ B70E C6 FF                        dw      Words_Begin - $
 661+ B710 4E A1                        dw      DROP
 662+ B712 90 A0                        dw      EXIT
 663+ B714
 664+ B714              //  ______________________________________________________________________
 665+ B714              //
 666+ B714              // list         n --
 667+ B714                              Colon_Def LIST, "LIST", is_normal
 667+ B714             >                New_Def  LIST, "LIST", Enter_Ptr, is_normal ; ok
 667+ B714             >
 667+ B714             >Dict_Ptr        defl    $
 667+ B714             >
 667+ B714             >//              ______________________________________________________________________
 667+ B714             >//              Heap part
 667+ B714             >
 667+ B714             >
 667+ B714             >                org     (Heap_Ptr & $1FFF) + $E000
 667+ EB9F             >
 667+ EB9F             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 667+ EB9F             >Latest_Definition defl  Heap_Ptr
 667+ EB9F             >
 667+ EB9F             >                // dummy db directives used to calculate length of namec
 667+ EB9F 4C 49 53 54 >                db      "LIST"
 667+ EBA3             >len_NFA         defl    $ - temp_NFA
 667+ EBA3             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 667+ EB9F             >
 667+ EB9F 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 667+ EBA0 4C 49 53 54 >                db      "LIST"               // name string in 7-bit ascii, but
 667+ EBA4             >                org     $-1                 // alter last byte of Name just above to set
 667+ EBA3 D4          >                db      {b $} | END_BIT     // msb as name end
 667+ EBA4             >
 667+ EBA4 95 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 667+ EBA6             >Prev_Ptr        defl    Heap_Ptr
 667+ EBA6             >
 667+ EBA6             >mirror_Ptr      defl    $
 667+ EBA6             >
 667+ EBA6 16 B7       >                dw      Dict_Ptr + 2        // xt
 667+ EBA8             >Heap_Ptr        defl    $ - $E000           // save current HP
 667+ EBA8             >
 667+ EBA8             >Current_HP      defl  $ - $E000             // used to set HP once!
 667+ EBA8             >
 667+ EBA8             >//              ______________________________________________________________________
 667+ EBA8             >//              Dictionary part
 667+ EBA8             >
 667+ EBA8             >                org     Dict_Ptr
 667+ B714             >
 667+ B714 A6 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 667+ B716             >
 667+ B716             >LIST:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 667+ B716 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 667+ B719             >
 667+ B719             >
 667+ B719             >                endif           ; ok        // for other definitions it "points" the correct handler
 667+ B719             >                // Use of "; ok" to suppress "warning[fwdref]"
 667+ B719             >
 667+ B719             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 668+ B719 F9 A6 F4 9D                  dw      DECIMAL, CR
 669+ B71D 69 A1 72 A3                  dw      DUP, SCR, STORE
 669+ B721 D1 A1
 670+ B723 4D A9                        dw      C_DOT_QUOTE
 671+ B725 05 53 63 72                  db      5, "Scr# "
 671+ B729 23 20
 672+ B72B A2 B6                        dw      DOT
 673+ B72D FE A2 BF A2                  dw      LSCR, ZERO, C_DO
 673+ B731 72 9C
 674+ B733              List_Loop:
 675+ B733 F4 9D                        dw          CR
 676+ B735 78 9C D4 A2                  dw          I, THREE
 677+ B739 86 B6 B5 A4                  dw          DOT_R, SPACE
 678+ B73D 78 9C 72 A3                  dw          I, SCR, FETCH, DOT_LINE
 678+ B741 C7 A1 64 AF
 679+ B745 F1 9E                        dw          QTERMINAL
 680+ B747 33 9C                        dw          ZBRANCH
 681+ B749 06 00                        dw          List_Endif - $
 682+ B74B 3E 9C                        dw              C_LEAVE
 683+ B74D 06 00                        dw              List_Leave - $
 684+ B74F              List_Endif:
 685+ B74F 1E 9C                        dw      C_LOOP
 686+ B751 E2 FF                        dw      List_Loop - $
 687+ B753              List_Leave:
 688+ B753 F4 9D                        dw      CR
 689+ B755 90 A0                        dw      EXIT
 690+ B757
 691+ B757              //  ______________________________________________________________________
 692+ B757              //
 693+ B757              // index        n1 n2 --
 694+ B757                              Colon_Def INDEX, "INDEX", is_normal
 694+ B757             >                New_Def  INDEX, "INDEX", Enter_Ptr, is_normal ; ok
 694+ B757             >
 694+ B757             >Dict_Ptr        defl    $
 694+ B757             >
 694+ B757             >//              ______________________________________________________________________
 694+ B757             >//              Heap part
 694+ B757             >
 694+ B757             >
 694+ B757             >                org     (Heap_Ptr & $1FFF) + $E000
 694+ EBA8             >
 694+ EBA8             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 694+ EBA8             >Latest_Definition defl  Heap_Ptr
 694+ EBA8             >
 694+ EBA8             >                // dummy db directives used to calculate length of namec
 694+ EBA8 49 4E 44 45 >                db      "INDEX"
 694+ EBAC 58          >
 694+ EBAD             >len_NFA         defl    $ - temp_NFA
 694+ EBAD             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 694+ EBA8             >
 694+ EBA8 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 694+ EBA9 49 4E 44 45 >                db      "INDEX"               // name string in 7-bit ascii, but
 694+ EBAD 58          >
 694+ EBAE             >                org     $-1                 // alter last byte of Name just above to set
 694+ EBAD D8          >                db      {b $} | END_BIT     // msb as name end
 694+ EBAE             >
 694+ EBAE 9F 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 694+ EBB0             >Prev_Ptr        defl    Heap_Ptr
 694+ EBB0             >
 694+ EBB0             >mirror_Ptr      defl    $
 694+ EBB0             >
 694+ EBB0 59 B7       >                dw      Dict_Ptr + 2        // xt
 694+ EBB2             >Heap_Ptr        defl    $ - $E000           // save current HP
 694+ EBB2             >
 694+ EBB2             >Current_HP      defl  $ - $E000             // used to set HP once!
 694+ EBB2             >
 694+ EBB2             >//              ______________________________________________________________________
 694+ EBB2             >//              Dictionary part
 694+ EBB2             >
 694+ EBB2             >                org     Dict_Ptr
 694+ B757             >
 694+ B757 B0 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 694+ B759             >
 694+ B759             >INDEX:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 694+ B759 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 694+ B75C             >
 694+ B75C             >
 694+ B75C             >                endif           ; ok        // for other definitions it "points" the correct handler
 694+ B75C             >                // Use of "; ok" to suppress "warning[fwdref]"
 694+ B75C             >
 694+ B75C             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 695+ B75C FC A0 62 A1                  dw      ONE_PLUS, SWAP, C_DO
 695+ B760 72 9C
 696+ B762              Index_Loop:
 697+ B762 F4 9D 78 9C                  dw          CR, I, THREE
 697+ B766 D4 A2
 698+ B768 86 B6 B5 A4                  dw          DOT_R, SPACE
 699+ B76C BF A2 78 9C                  dw          ZERO, I, DOT_LINE
 699+ B770 64 AF
 700+ B772 F1 9E                        dw          QTERMINAL
 701+ B774 33 9C                        dw          ZBRANCH
 702+ B776 06 00                        dw          Index_Endif - $
 703+ B778 3E 9C                        dw              C_LEAVE
 704+ B77A 06 00                        dw              Index_Leave - $
 705+ B77C              Index_Endif:
 706+ B77C 1E 9C                        dw      C_LOOP
 707+ B77E E4 FF                        dw      Index_Loop - $
 708+ B780              Index_Leave:
 709+ B780 F4 9D                        dw      CR
 710+ B782 90 A0                        dw      EXIT
 711+ B784
 712+ B784              //  ______________________________________________________________________
 713+ B784              //
 714+ B784              // cls          --
 715+ B784                              Colon_Def CLS, "CLS", is_normal
 715+ B784             >                New_Def  CLS, "CLS", Enter_Ptr, is_normal ; ok
 715+ B784             >
 715+ B784             >Dict_Ptr        defl    $
 715+ B784             >
 715+ B784             >//              ______________________________________________________________________
 715+ B784             >//              Heap part
 715+ B784             >
 715+ B784             >
 715+ B784             >                org     (Heap_Ptr & $1FFF) + $E000
 715+ EBB2             >
 715+ EBB2             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 715+ EBB2             >Latest_Definition defl  Heap_Ptr
 715+ EBB2             >
 715+ EBB2             >                // dummy db directives used to calculate length of namec
 715+ EBB2 43 4C 53    >                db      "CLS"
 715+ EBB5             >len_NFA         defl    $ - temp_NFA
 715+ EBB5             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 715+ EBB2             >
 715+ EBB2 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 715+ EBB3 43 4C 53    >                db      "CLS"               // name string in 7-bit ascii, but
 715+ EBB6             >                org     $-1                 // alter last byte of Name just above to set
 715+ EBB5 D3          >                db      {b $} | END_BIT     // msb as name end
 715+ EBB6             >
 715+ EBB6 A8 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 715+ EBB8             >Prev_Ptr        defl    Heap_Ptr
 715+ EBB8             >
 715+ EBB8             >mirror_Ptr      defl    $
 715+ EBB8             >
 715+ EBB8 86 B7       >                dw      Dict_Ptr + 2        // xt
 715+ EBBA             >Heap_Ptr        defl    $ - $E000           // save current HP
 715+ EBBA             >
 715+ EBBA             >Current_HP      defl  $ - $E000             // used to set HP once!
 715+ EBBA             >
 715+ EBBA             >//              ______________________________________________________________________
 715+ EBBA             >//              Dictionary part
 715+ EBBA             >
 715+ EBBA             >                org     Dict_Ptr
 715+ B784             >
 715+ B784 B8 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 715+ B786             >
 715+ B786             >CLS:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 715+ B786 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 715+ B789             >
 715+ B789             >
 715+ B789             >                endif           ; ok        // for other definitions it "points" the correct handler
 715+ B789             >                // Use of "; ok" to suppress "warning[fwdref]"
 715+ B789             >
 715+ B789             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 716+ B789 E1 9B 0E 00                  dw      LIT, $0E, EMITC
 716+ B78D E0 9D
 717+ B78F 90 A0                        dw      EXIT
 718+ B791
 719+ B791              //  ______________________________________________________________________
 720+ B791              //
 721+ B791              // splash       --
 722+ B791                              Colon_Def SPLASH, "SPLASH", is_normal
 722+ B791             >                New_Def  SPLASH, "SPLASH", Enter_Ptr, is_normal ; ok
 722+ B791             >
 722+ B791             >Dict_Ptr        defl    $
 722+ B791             >
 722+ B791             >//              ______________________________________________________________________
 722+ B791             >//              Heap part
 722+ B791             >
 722+ B791             >
 722+ B791             >                org     (Heap_Ptr & $1FFF) + $E000
 722+ EBBA             >
 722+ EBBA             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 722+ EBBA             >Latest_Definition defl  Heap_Ptr
 722+ EBBA             >
 722+ EBBA             >                // dummy db directives used to calculate length of namec
 722+ EBBA 53 50 4C 41 >                db      "SPLASH"
 722+ EBBE 53 48       >
 722+ EBC0             >len_NFA         defl    $ - temp_NFA
 722+ EBC0             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 722+ EBBA             >
 722+ EBBA 86          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 722+ EBBB 53 50 4C 41 >                db      "SPLASH"               // name string in 7-bit ascii, but
 722+ EBBF 53 48       >
 722+ EBC1             >                org     $-1                 // alter last byte of Name just above to set
 722+ EBC0 C8          >                db      {b $} | END_BIT     // msb as name end
 722+ EBC1             >
 722+ EBC1 B2 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 722+ EBC3             >Prev_Ptr        defl    Heap_Ptr
 722+ EBC3             >
 722+ EBC3             >mirror_Ptr      defl    $
 722+ EBC3             >
 722+ EBC3 93 B7       >                dw      Dict_Ptr + 2        // xt
 722+ EBC5             >Heap_Ptr        defl    $ - $E000           // save current HP
 722+ EBC5             >
 722+ EBC5             >Current_HP      defl  $ - $E000             // used to set HP once!
 722+ EBC5             >
 722+ EBC5             >//              ______________________________________________________________________
 722+ EBC5             >//              Dictionary part
 722+ EBC5             >
 722+ EBC5             >                org     Dict_Ptr
 722+ B791             >
 722+ B791 C3 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 722+ B793             >
 722+ B793             >SPLASH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 722+ B793 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 722+ B796             >
 722+ B796             >
 722+ B796             >                endif           ; ok        // for other definitions it "points" the correct handler
 722+ B796             >                // Use of "; ok" to suppress "warning[fwdref]"
 722+ B796             >
 722+ B796             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 723+ B796 86 B7                        dw      CLS
 724+ B798 4D A9                        dw      C_DOT_QUOTE
 725+ B79A 57                           db      87
 726+ B79B 76 2D 46 6F                  db      "v-Forth 1.7 NextZXOS version", 13    // 29
 726+ B79F 72 74 68 20
 726+ B7A3 31 2E 37 20
 726+ B7A7 4E 65 78 74
 726+ B7AB 5A 58 4F 53
 726+ B7AF 20 76 65 72
 726+ B7B3 73 69 6F 6E
 726+ B7B7 0D
 727+ B7B8 48 65 61 70                  db      "Heap Vocabulary - build 20230626", 13  // 33
 727+ B7BC 20 56 6F 63
 727+ B7C0 61 62 75 6C
 727+ B7C4 61 72 79 20
 727+ B7C8 2D 20 62 75
 727+ B7CC 69 6C 64 20
 727+ B7D0 32 30 32 33
 727+ B7D4 30 36 32 36
 727+ B7D8 0D
 728+ B7D9 31 39 39 30                  db      "1990-2023 Matteo Vitturi", 13        // 25
 728+ B7DD 2D 32 30 32
 728+ B7E1 33 20 4D 61
 728+ B7E5 74 74 65 6F
 728+ B7E9 20 56 69 74
 728+ B7ED 74 75 72 69
 728+ B7F1 0D
 729+ B7F2 90 A0                        dw      EXIT
 730+ B7F4
 731+ B7F4              //  ______________________________________________________________________
 732+ B7F4              //
 733+ B7F4              // video        --
 734+ B7F4                              Colon_Def VIDEO, "VIDEO", is_normal
 734+ B7F4             >                New_Def  VIDEO, "VIDEO", Enter_Ptr, is_normal ; ok
 734+ B7F4             >
 734+ B7F4             >Dict_Ptr        defl    $
 734+ B7F4             >
 734+ B7F4             >//              ______________________________________________________________________
 734+ B7F4             >//              Heap part
 734+ B7F4             >
 734+ B7F4             >
 734+ B7F4             >                org     (Heap_Ptr & $1FFF) + $E000
 734+ EBC5             >
 734+ EBC5             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 734+ EBC5             >Latest_Definition defl  Heap_Ptr
 734+ EBC5             >
 734+ EBC5             >                // dummy db directives used to calculate length of namec
 734+ EBC5 56 49 44 45 >                db      "VIDEO"
 734+ EBC9 4F          >
 734+ EBCA             >len_NFA         defl    $ - temp_NFA
 734+ EBCA             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 734+ EBC5             >
 734+ EBC5 85          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 734+ EBC6 56 49 44 45 >                db      "VIDEO"               // name string in 7-bit ascii, but
 734+ EBCA 4F          >
 734+ EBCB             >                org     $-1                 // alter last byte of Name just above to set
 734+ EBCA CF          >                db      {b $} | END_BIT     // msb as name end
 734+ EBCB             >
 734+ EBCB BA 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 734+ EBCD             >Prev_Ptr        defl    Heap_Ptr
 734+ EBCD             >
 734+ EBCD             >mirror_Ptr      defl    $
 734+ EBCD             >
 734+ EBCD F6 B7       >                dw      Dict_Ptr + 2        // xt
 734+ EBCF             >Heap_Ptr        defl    $ - $E000           // save current HP
 734+ EBCF             >
 734+ EBCF             >Current_HP      defl  $ - $E000             // used to set HP once!
 734+ EBCF             >
 734+ EBCF             >//              ______________________________________________________________________
 734+ EBCF             >//              Dictionary part
 734+ EBCF             >
 734+ EBCF             >                org     Dict_Ptr
 734+ B7F4             >
 734+ B7F4 CD 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 734+ B7F6             >
 734+ B7F6             >VIDEO:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 734+ B7F6 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 734+ B7F9             >
 734+ B7F9             >
 734+ B7F9             >                endif           ; ok        // for other definitions it "points" the correct handler
 734+ B7F9             >                // Use of "; ok" to suppress "warning[fwdref]"
 734+ B7F9             >
 734+ B7F9             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 735+ B7F9 CD A2 69 A1                  dw      TWO, DUP, DEVICE, STORE
 735+ B7FD 9F AF D1 A1
 736+ B801 05 9F                        dw      SELECT
 737+ B803 90 A0                        dw      EXIT
 738+ B805
 739+ B805              //  ______________________________________________________________________
 740+ B805              //
 741+ B805              // autoexec     --
 742+ B805              // this word is called the first time the Forth system boot to
 743+ B805              // load Screen# 1. Once called it patches itself to prevent furhter runs.
 744+ B805                              Colon_Def AUTOEXEC, "AUTOEXEC", is_normal
 744+ B805             >                New_Def  AUTOEXEC, "AUTOEXEC", Enter_Ptr, is_normal ; ok
 744+ B805             >
 744+ B805             >Dict_Ptr        defl    $
 744+ B805             >
 744+ B805             >//              ______________________________________________________________________
 744+ B805             >//              Heap part
 744+ B805             >
 744+ B805             >
 744+ B805             >                org     (Heap_Ptr & $1FFF) + $E000
 744+ EBCF             >
 744+ EBCF             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 744+ EBCF             >Latest_Definition defl  Heap_Ptr
 744+ EBCF             >
 744+ EBCF             >                // dummy db directives used to calculate length of namec
 744+ EBCF 41 55 54 4F >                db      "AUTOEXEC"
 744+ EBD3 45 58 45 43 >
 744+ EBD7             >len_NFA         defl    $ - temp_NFA
 744+ EBD7             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 744+ EBCF             >
 744+ EBCF 88          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 744+ EBD0 41 55 54 4F >                db      "AUTOEXEC"               // name string in 7-bit ascii, but
 744+ EBD4 45 58 45 43 >
 744+ EBD8             >                org     $-1                 // alter last byte of Name just above to set
 744+ EBD7 C3          >                db      {b $} | END_BIT     // msb as name end
 744+ EBD8             >
 744+ EBD8 C5 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 744+ EBDA             >Prev_Ptr        defl    Heap_Ptr
 744+ EBDA             >
 744+ EBDA             >mirror_Ptr      defl    $
 744+ EBDA             >
 744+ EBDA 07 B8       >                dw      Dict_Ptr + 2        // xt
 744+ EBDC             >Heap_Ptr        defl    $ - $E000           // save current HP
 744+ EBDC             >
 744+ EBDC             >Current_HP      defl  $ - $E000             // used to set HP once!
 744+ EBDC             >
 744+ EBDC             >//              ______________________________________________________________________
 744+ EBDC             >//              Dictionary part
 744+ EBDC             >
 744+ EBDC             >                org     Dict_Ptr
 744+ B805             >
 744+ B805 DA 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 744+ B807             >
 744+ B807             >AUTOEXEC:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 744+ B807 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 744+ B80A             >
 744+ B80A             >
 744+ B80A             >                endif           ; ok        // for other definitions it "points" the correct handler
 744+ B80A             >                // Use of "; ok" to suppress "warning[fwdref]"
 744+ B80A             >
 744+ B80A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 745+ B80A E1 9B 0B 00                  dw      LIT, 11
 746+ B80E E1 9B 86 A2                  dw      LIT, NOOP
 747+ B812 E1 9B AB AD                  dw      LIT, Autoexec_Ptr
 748+ B816 D1 A1                        dw      STORE
 749+ B818 BC B4                        dw      LOAD
 750+ B81A 60 AD                        dw      QUIT
 751+ B81C 90 A0                        dw      EXIT
 752+ B81E
 753+ B81E
 754+ B81E              //  ______________________________________________________________________
 755+ B81E              //
 756+ B81E              // bye     --
 757+ B81E              //
 758+ B81E                              Colon_Def BYE, "BYE", is_normal
 758+ B81E             >                New_Def  BYE, "BYE", Enter_Ptr, is_normal ; ok
 758+ B81E             >
 758+ B81E             >Dict_Ptr        defl    $
 758+ B81E             >
 758+ B81E             >//              ______________________________________________________________________
 758+ B81E             >//              Heap part
 758+ B81E             >
 758+ B81E             >
 758+ B81E             >                org     (Heap_Ptr & $1FFF) + $E000
 758+ EBDC             >
 758+ EBDC             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 758+ EBDC             >Latest_Definition defl  Heap_Ptr
 758+ EBDC             >
 758+ EBDC             >                // dummy db directives used to calculate length of namec
 758+ EBDC 42 59 45    >                db      "BYE"
 758+ EBDF             >len_NFA         defl    $ - temp_NFA
 758+ EBDF             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 758+ EBDC             >
 758+ EBDC 83          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 758+ EBDD 42 59 45    >                db      "BYE"               // name string in 7-bit ascii, but
 758+ EBE0             >                org     $-1                 // alter last byte of Name just above to set
 758+ EBDF C5          >                db      {b $} | END_BIT     // msb as name end
 758+ EBE0             >
 758+ EBE0 CF 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 758+ EBE2             >Prev_Ptr        defl    Heap_Ptr
 758+ EBE2             >
 758+ EBE2             >mirror_Ptr      defl    $
 758+ EBE2             >
 758+ EBE2 20 B8       >                dw      Dict_Ptr + 2        // xt
 758+ EBE4             >Heap_Ptr        defl    $ - $E000           // save current HP
 758+ EBE4             >
 758+ EBE4             >Current_HP      defl  $ - $E000             // used to set HP once!
 758+ EBE4             >
 758+ EBE4             >//              ______________________________________________________________________
 758+ EBE4             >//              Dictionary part
 758+ EBE4             >
 758+ EBE4             >                org     Dict_Ptr
 758+ B81E             >
 758+ B81E E2 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 758+ B820             >
 758+ B820             >BYE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 758+ B820 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 758+ B823             >
 758+ B823             >
 758+ B823             >                endif           ; ok        // for other definitions it "points" the correct handler
 758+ B823             >                // Use of "; ok" to suppress "warning[fwdref]"
 758+ B823             >
 758+ B823             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 759+ B823 BE B1                        dw      FLUSH
 760+ B825 06 B1                        dw      EMPTY_BUFFERS
 761+ B827 F2 AF C7 A1                  dw      BLK_FH, FETCH, F_CLOSE, DROP
 761+ B82B 3D 9F 4E A1
 762+ B82F BF A2 05 A3                  dw      ZERO, PLUS_ORIGIN
 763+ B833 2E AE                        dw      BASIC
 764+ B835
 765+ B835              //  ______________________________________________________________________
 766+ B835              //
 767+ B835              // invv     --
 768+ B835              //
 769+ B835              //              Colon_Def INVV, "INVV", is_normal
 770+ B835              //              dw      LIT, 20, EMITC, ONE, EMITC
 771+ B835              //              dw      EXIT
 772+ B835
 773+ B835              //  ______________________________________________________________________
 774+ B835              //
 775+ B835              // truv     --
 776+ B835              //
 777+ B835              //              Colon_Def TRUV, "TRUV", is_normal
 778+ B835              //              dw      LIT, 20, EMITC, ZERO, EMITC
 779+ B835              //              dw      EXIT
 780+ B835
 781+ B835              //  ______________________________________________________________________
 782+ B835              //
 783+ B835              // mark     --
 784+ B835              //
 785+ B835              //              Colon_Def MARK, "MARK", is_normal
 786+ B835              //              dw      INVV, TYPE, TRUV
 787+ B835              //              dw      EXIT
 788+ B835
 789+ B835              //  ______________________________________________________________________
 790+ B835              //
 791+ B835              // back     --
 792+ B835              //
 793+ B835                              Colon_Def BACK, "BACK", is_normal
 793+ B835             >                New_Def  BACK, "BACK", Enter_Ptr, is_normal ; ok
 793+ B835             >
 793+ B835             >Dict_Ptr        defl    $
 793+ B835             >
 793+ B835             >//              ______________________________________________________________________
 793+ B835             >//              Heap part
 793+ B835             >
 793+ B835             >
 793+ B835             >                org     (Heap_Ptr & $1FFF) + $E000
 793+ EBE4             >
 793+ EBE4             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 793+ EBE4             >Latest_Definition defl  Heap_Ptr
 793+ EBE4             >
 793+ EBE4             >                // dummy db directives used to calculate length of namec
 793+ EBE4 42 41 43 4B >                db      "BACK"
 793+ EBE8             >len_NFA         defl    $ - temp_NFA
 793+ EBE8             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 793+ EBE4             >
 793+ EBE4 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 793+ EBE5 42 41 43 4B >                db      "BACK"               // name string in 7-bit ascii, but
 793+ EBE9             >                org     $-1                 // alter last byte of Name just above to set
 793+ EBE8 CB          >                db      {b $} | END_BIT     // msb as name end
 793+ EBE9             >
 793+ EBE9 DC 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 793+ EBEB             >Prev_Ptr        defl    Heap_Ptr
 793+ EBEB             >
 793+ EBEB             >mirror_Ptr      defl    $
 793+ EBEB             >
 793+ EBEB 37 B8       >                dw      Dict_Ptr + 2        // xt
 793+ EBED             >Heap_Ptr        defl    $ - $E000           // save current HP
 793+ EBED             >
 793+ EBED             >Current_HP      defl  $ - $E000             // used to set HP once!
 793+ EBED             >
 793+ EBED             >//              ______________________________________________________________________
 793+ EBED             >//              Dictionary part
 793+ EBED             >
 793+ EBED             >                org     Dict_Ptr
 793+ B835             >
 793+ B835 EB 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 793+ B837             >
 793+ B837             >BACK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 793+ B837 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 793+ B83A             >
 793+ B83A             >
 793+ B83A             >                endif           ; ok        // for other definitions it "points" the correct handler
 793+ B83A             >                // Use of "; ok" to suppress "warning[fwdref]"
 793+ B83A             >
 793+ B83A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 794+ B83A E4 A3 23 A4                  dw      HERE, SUBTRACT, COMMA
 794+ B83E FA A3
 795+ B840 90 A0                        dw      EXIT
 796+ B842
 797+ B842              //  ______________________________________________________________________
 798+ B842              //
 799+ B842              // if          ( -- a 2 ) \ compile-time
 800+ B842              // IF ... THEN
 801+ B842              // IF ... ELSE ... ENDIF
 802+ B842                              Colon_Def IF, "IF", is_immediate
 802+ B842             >                New_Def  IF, "IF", Enter_Ptr, is_immediate ; ok
 802+ B842             >
 802+ B842             >Dict_Ptr        defl    $
 802+ B842             >
 802+ B842             >//              ______________________________________________________________________
 802+ B842             >//              Heap part
 802+ B842             >
 802+ B842             >
 802+ B842             >                org     (Heap_Ptr & $1FFF) + $E000
 802+ EBED             >
 802+ EBED             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 802+ EBED             >Latest_Definition defl  Heap_Ptr
 802+ EBED             >
 802+ EBED             >                // dummy db directives used to calculate length of namec
 802+ EBED 49 46       >                db      "IF"
 802+ EBEF             >len_NFA         defl    $ - temp_NFA
 802+ EBEF             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 802+ EBED             >
 802+ EBED C2          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 802+ EBEE 49 46       >                db      "IF"               // name string in 7-bit ascii, but
 802+ EBF0             >                org     $-1                 // alter last byte of Name just above to set
 802+ EBEF C6          >                db      {b $} | END_BIT     // msb as name end
 802+ EBF0             >
 802+ EBF0 E4 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 802+ EBF2             >Prev_Ptr        defl    Heap_Ptr
 802+ EBF2             >
 802+ EBF2             >mirror_Ptr      defl    $
 802+ EBF2             >
 802+ EBF2 44 B8       >                dw      Dict_Ptr + 2        // xt
 802+ EBF4             >Heap_Ptr        defl    $ - $E000           // save current HP
 802+ EBF4             >
 802+ EBF4             >Current_HP      defl  $ - $E000             // used to set HP once!
 802+ EBF4             >
 802+ EBF4             >//              ______________________________________________________________________
 802+ EBF4             >//              Dictionary part
 802+ EBF4             >
 802+ EBF4             >                org     Dict_Ptr
 802+ B842             >
 802+ B842 F2 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 802+ B844             >
 802+ B844             >IF:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 802+ B844 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 802+ B847             >
 802+ B847             >
 802+ B847             >                endif           ; ok        // for other definitions it "points" the correct handler
 802+ B847             >                // Use of "; ok" to suppress "warning[fwdref]"
 802+ B847             >
 802+ B847             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 803+ B847 90 A6 33 9C                  dw      COMPILE, ZBRANCH
 804+ B84B E4 A3 BF A2                  dw      HERE, ZERO, COMMA
 804+ B84F FA A3
 805+ B851 CD A2                        dw      TWO
 806+ B853 90 A0                        dw      EXIT
 807+ B855
 808+ B855              //  ______________________________________________________________________
 809+ B855              //
 810+ B855              // then        ( a 2 -- ) \ compile-time
 811+ B855              //
 812+ B855                              Colon_Def THEN, "THEN", is_immediate
 812+ B855             >                New_Def  THEN, "THEN", Enter_Ptr, is_immediate ; ok
 812+ B855             >
 812+ B855             >Dict_Ptr        defl    $
 812+ B855             >
 812+ B855             >//              ______________________________________________________________________
 812+ B855             >//              Heap part
 812+ B855             >
 812+ B855             >
 812+ B855             >                org     (Heap_Ptr & $1FFF) + $E000
 812+ EBF4             >
 812+ EBF4             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 812+ EBF4             >Latest_Definition defl  Heap_Ptr
 812+ EBF4             >
 812+ EBF4             >                // dummy db directives used to calculate length of namec
 812+ EBF4 54 48 45 4E >                db      "THEN"
 812+ EBF8             >len_NFA         defl    $ - temp_NFA
 812+ EBF8             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 812+ EBF4             >
 812+ EBF4 C4          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 812+ EBF5 54 48 45 4E >                db      "THEN"               // name string in 7-bit ascii, but
 812+ EBF9             >                org     $-1                 // alter last byte of Name just above to set
 812+ EBF8 CE          >                db      {b $} | END_BIT     // msb as name end
 812+ EBF9             >
 812+ EBF9 ED 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 812+ EBFB             >Prev_Ptr        defl    Heap_Ptr
 812+ EBFB             >
 812+ EBFB             >mirror_Ptr      defl    $
 812+ EBFB             >
 812+ EBFB 57 B8       >                dw      Dict_Ptr + 2        // xt
 812+ EBFD             >Heap_Ptr        defl    $ - $E000           // save current HP
 812+ EBFD             >
 812+ EBFD             >Current_HP      defl  $ - $E000             // used to set HP once!
 812+ EBFD             >
 812+ EBFD             >//              ______________________________________________________________________
 812+ EBFD             >//              Dictionary part
 812+ EBFD             >
 812+ EBFD             >                org     Dict_Ptr
 812+ B855             >
 812+ B855 FB 2B       >                dw      mirror_Ptr - $E000 + Heap_offset
 812+ B857             >
 812+ B857             >THEN:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 812+ B857 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 812+ B85A             >
 812+ B85A             >
 812+ B85A             >                endif           ; ok        // for other definitions it "points" the correct handler
 812+ B85A             >                // Use of "; ok" to suppress "warning[fwdref]"
 812+ B85A             >
 812+ B85A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 813+ B85A 35 A6                        dw      QCOMP
 814+ B85C CD A2 59 A6                  dw      TWO, QPAIRS
 815+ B860 E4 A3 45 A1                  dw      HERE, OVER, SUBTRACT, SWAP, STORE
 815+ B864 23 A4 62 A1
 815+ B868 D1 A1
 816+ B86A 90 A0                        dw      EXIT
 817+ B86C
 818+ B86C              //  ______________________________________________________________________
 819+ B86C              //
 820+ B86C              // endif       ( a 2 -- ) \ compile-time
 821+ B86C              //
 822+ B86C                              Colon_Def ENDIF, "ENDIF", is_immediate
 822+ B86C             >                New_Def  ENDIF, "ENDIF", Enter_Ptr, is_immediate ; ok
 822+ B86C             >
 822+ B86C             >Dict_Ptr        defl    $
 822+ B86C             >
 822+ B86C             >//              ______________________________________________________________________
 822+ B86C             >//              Heap part
 822+ B86C             >
 822+ B86C             >
 822+ B86C             >                org     (Heap_Ptr & $1FFF) + $E000
 822+ EBFD             >
 822+ EBFD             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 822+ EBFD             >Latest_Definition defl  Heap_Ptr
 822+ EBFD             >
 822+ EBFD             >                // dummy db directives used to calculate length of namec
 822+ EBFD 45 4E 44 49 >                db      "ENDIF"
 822+ EC01 46          >
 822+ EC02             >len_NFA         defl    $ - temp_NFA
 822+ EC02             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 822+ EBFD             >
 822+ EBFD C5          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 822+ EBFE 45 4E 44 49 >                db      "ENDIF"               // name string in 7-bit ascii, but
 822+ EC02 46          >
 822+ EC03             >                org     $-1                 // alter last byte of Name just above to set
 822+ EC02 C6          >                db      {b $} | END_BIT     // msb as name end
 822+ EC03             >
 822+ EC03 F4 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 822+ EC05             >Prev_Ptr        defl    Heap_Ptr
 822+ EC05             >
 822+ EC05             >mirror_Ptr      defl    $
 822+ EC05             >
 822+ EC05 6E B8       >                dw      Dict_Ptr + 2        // xt
 822+ EC07             >Heap_Ptr        defl    $ - $E000           // save current HP
 822+ EC07             >
 822+ EC07             >Current_HP      defl  $ - $E000             // used to set HP once!
 822+ EC07             >
 822+ EC07             >//              ______________________________________________________________________
 822+ EC07             >//              Dictionary part
 822+ EC07             >
 822+ EC07             >                org     Dict_Ptr
 822+ B86C             >
 822+ B86C 05 2C       >                dw      mirror_Ptr - $E000 + Heap_offset
 822+ B86E             >
 822+ B86E             >ENDIF:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 822+ B86E CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 822+ B871             >
 822+ B871             >
 822+ B871             >                endif           ; ok        // for other definitions it "points" the correct handler
 822+ B871             >                // Use of "; ok" to suppress "warning[fwdref]"
 822+ B871             >
 822+ B871             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 823+ B871 57 B8                        dw      THEN
 824+ B873 90 A0                        dw      EXIT
 825+ B875
 826+ B875              //  ______________________________________________________________________
 827+ B875              //
 828+ B875              // else        ( a1 2 -- a2 2 ) \ compile-time
 829+ B875              //
 830+ B875                              Colon_Def ELSE, "ELSE", is_immediate
 830+ B875             >                New_Def  ELSE, "ELSE", Enter_Ptr, is_immediate ; ok
 830+ B875             >
 830+ B875             >Dict_Ptr        defl    $
 830+ B875             >
 830+ B875             >//              ______________________________________________________________________
 830+ B875             >//              Heap part
 830+ B875             >
 830+ B875             >
 830+ B875             >                org     (Heap_Ptr & $1FFF) + $E000
 830+ EC07             >
 830+ EC07             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 830+ EC07             >Latest_Definition defl  Heap_Ptr
 830+ EC07             >
 830+ EC07             >                // dummy db directives used to calculate length of namec
 830+ EC07 45 4C 53 45 >                db      "ELSE"
 830+ EC0B             >len_NFA         defl    $ - temp_NFA
 830+ EC0B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 830+ EC07             >
 830+ EC07 C4          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 830+ EC08 45 4C 53 45 >                db      "ELSE"               // name string in 7-bit ascii, but
 830+ EC0C             >                org     $-1                 // alter last byte of Name just above to set
 830+ EC0B C5          >                db      {b $} | END_BIT     // msb as name end
 830+ EC0C             >
 830+ EC0C FD 2B       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 830+ EC0E             >Prev_Ptr        defl    Heap_Ptr
 830+ EC0E             >
 830+ EC0E             >mirror_Ptr      defl    $
 830+ EC0E             >
 830+ EC0E 77 B8       >                dw      Dict_Ptr + 2        // xt
 830+ EC10             >Heap_Ptr        defl    $ - $E000           // save current HP
 830+ EC10             >
 830+ EC10             >Current_HP      defl  $ - $E000             // used to set HP once!
 830+ EC10             >
 830+ EC10             >//              ______________________________________________________________________
 830+ EC10             >//              Dictionary part
 830+ EC10             >
 830+ EC10             >                org     Dict_Ptr
 830+ B875             >
 830+ B875 0E 2C       >                dw      mirror_Ptr - $E000 + Heap_offset
 830+ B877             >
 830+ B877             >ELSE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 830+ B877 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 830+ B87A             >
 830+ B87A             >
 830+ B87A             >                endif           ; ok        // for other definitions it "points" the correct handler
 830+ B87A             >                // Use of "; ok" to suppress "warning[fwdref]"
 830+ B87A             >
 830+ B87A             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 831+ B87A 35 A6                        dw      QCOMP
 832+ B87C CD A2 59 A6                  dw      TWO, QPAIRS
 833+ B880 90 A6 26 9C                  dw      COMPILE, BRANCH
 834+ B884 E4 A3 BF A2                  dw      HERE, ZERO, COMMA
 834+ B888 FA A3
 835+ B88A 62 A1 CD A2                  dw      SWAP, TWO, THEN
 835+ B88E 57 B8
 836+ B890 CD A2                        dw      TWO
 837+ B892 90 A0                        dw      EXIT
 838+ B894
 839+ B894              //  ______________________________________________________________________
 840+ B894              //
 841+ B894              // begin        ( -- a 1 ) \ compile-time
 842+ B894              // BEGIN ... AGAIN
 843+ B894              // BEGIN ... f UNTIL
 844+ B894              // BEGIN ... f WHILE ... REPEAT
 845+ B894                              Colon_Def BEGIN, "BEGIN", is_immediate
 845+ B894             >                New_Def  BEGIN, "BEGIN", Enter_Ptr, is_immediate ; ok
 845+ B894             >
 845+ B894             >Dict_Ptr        defl    $
 845+ B894             >
 845+ B894             >//              ______________________________________________________________________
 845+ B894             >//              Heap part
 845+ B894             >
 845+ B894             >
 845+ B894             >                org     (Heap_Ptr & $1FFF) + $E000
 845+ EC10             >
 845+ EC10             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 845+ EC10             >Latest_Definition defl  Heap_Ptr
 845+ EC10             >
 845+ EC10             >                // dummy db directives used to calculate length of namec
 845+ EC10 42 45 47 49 >                db      "BEGIN"
 845+ EC14 4E          >
 845+ EC15             >len_NFA         defl    $ - temp_NFA
 845+ EC15             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 845+ EC10             >
 845+ EC10 C5          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 845+ EC11 42 45 47 49 >                db      "BEGIN"               // name string in 7-bit ascii, but
 845+ EC15 4E          >
 845+ EC16             >                org     $-1                 // alter last byte of Name just above to set
 845+ EC15 CE          >                db      {b $} | END_BIT     // msb as name end
 845+ EC16             >
 845+ EC16 07 2C       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 845+ EC18             >Prev_Ptr        defl    Heap_Ptr
 845+ EC18             >
 845+ EC18             >mirror_Ptr      defl    $
 845+ EC18             >
 845+ EC18 96 B8       >                dw      Dict_Ptr + 2        // xt
 845+ EC1A             >Heap_Ptr        defl    $ - $E000           // save current HP
 845+ EC1A             >
 845+ EC1A             >Current_HP      defl  $ - $E000             // used to set HP once!
 845+ EC1A             >
 845+ EC1A             >//              ______________________________________________________________________
 845+ EC1A             >//              Dictionary part
 845+ EC1A             >
 845+ EC1A             >                org     Dict_Ptr
 845+ B894             >
 845+ B894 18 2C       >                dw      mirror_Ptr - $E000 + Heap_offset
 845+ B896             >
 845+ B896             >BEGIN:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 845+ B896 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 845+ B899             >
 845+ B899             >
 845+ B899             >                endif           ; ok        // for other definitions it "points" the correct handler
 845+ B899             >                // Use of "; ok" to suppress "warning[fwdref]"
 845+ B899             >
 845+ B899             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 846+ B899 35 A6                        dw      QCOMP
 847+ B89B E4 A3                        dw      HERE
 848+ B89D CD A2                        dw      TWO
 849+ B89F 90 A0                        dw      EXIT
 850+ B8A1
 851+ B8A1              //  ______________________________________________________________________
 852+ B8A1              //
 853+ B8A1              // again        ( a 1 -- ) \ compile-time
 854+ B8A1                              Colon_Def AGAIN, "AGAIN", is_immediate
 854+ B8A1             >                New_Def  AGAIN, "AGAIN", Enter_Ptr, is_immediate ; ok
 854+ B8A1             >
 854+ B8A1             >Dict_Ptr        defl    $
 854+ B8A1             >
 854+ B8A1             >//              ______________________________________________________________________
 854+ B8A1             >//              Heap part
 854+ B8A1             >
 854+ B8A1             >
 854+ B8A1             >                org     (Heap_Ptr & $1FFF) + $E000
 854+ EC1A             >
 854+ EC1A             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 854+ EC1A             >Latest_Definition defl  Heap_Ptr
 854+ EC1A             >
 854+ EC1A             >                // dummy db directives used to calculate length of namec
 854+ EC1A 41 47 41 49 >                db      "AGAIN"
 854+ EC1E 4E          >
 854+ EC1F             >len_NFA         defl    $ - temp_NFA
 854+ EC1F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 854+ EC1A             >
 854+ EC1A C5          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 854+ EC1B 41 47 41 49 >                db      "AGAIN"               // name string in 7-bit ascii, but
 854+ EC1F 4E          >
 854+ EC20             >                org     $-1                 // alter last byte of Name just above to set
 854+ EC1F CE          >                db      {b $} | END_BIT     // msb as name end
 854+ EC20             >
 854+ EC20 10 2C       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 854+ EC22             >Prev_Ptr        defl    Heap_Ptr
 854+ EC22             >
 854+ EC22             >mirror_Ptr      defl    $
 854+ EC22             >
 854+ EC22 A3 B8       >                dw      Dict_Ptr + 2        // xt
 854+ EC24             >Heap_Ptr        defl    $ - $E000           // save current HP
 854+ EC24             >
 854+ EC24             >Current_HP      defl  $ - $E000             // used to set HP once!
 854+ EC24             >
 854+ EC24             >//              ______________________________________________________________________
 854+ EC24             >//              Dictionary part
 854+ EC24             >
 854+ EC24             >                org     Dict_Ptr
 854+ B8A1             >
 854+ B8A1 22 2C       >                dw      mirror_Ptr - $E000 + Heap_offset
 854+ B8A3             >
 854+ B8A3             >AGAIN:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 854+ B8A3 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 854+ B8A6             >
 854+ B8A6             >
 854+ B8A6             >                endif           ; ok        // for other definitions it "points" the correct handler
 854+ B8A6             >                // Use of "; ok" to suppress "warning[fwdref]"
 854+ B8A6             >
 854+ B8A6             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 855+ B8A6 35 A6                        dw      QCOMP
 856+ B8A8 CD A2 59 A6                  dw      TWO, QPAIRS
 857+ B8AC 90 A6 26 9C                  dw      COMPILE, BRANCH
 858+ B8B0 37 B8                        dw      BACK
 859+ B8B2 90 A0                        dw      EXIT
 860+ B8B4
 861+ B8B4              //  ______________________________________________________________________
 862+ B8B4              //
 863+ B8B4              // until        ( a 1 -- ) \ compile-time
 864+ B8B4                              Colon_Def UNTIL, "UNTIL", is_immediate
 864+ B8B4             >                New_Def  UNTIL, "UNTIL", Enter_Ptr, is_immediate ; ok
 864+ B8B4             >
 864+ B8B4             >Dict_Ptr        defl    $
 864+ B8B4             >
 864+ B8B4             >//              ______________________________________________________________________
 864+ B8B4             >//              Heap part
 864+ B8B4             >
 864+ B8B4             >
 864+ B8B4             >                org     (Heap_Ptr & $1FFF) + $E000
 864+ EC24             >
 864+ EC24             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 864+ EC24             >Latest_Definition defl  Heap_Ptr
 864+ EC24             >
 864+ EC24             >                // dummy db directives used to calculate length of namec
 864+ EC24 55 4E 54 49 >                db      "UNTIL"
 864+ EC28 4C          >
 864+ EC29             >len_NFA         defl    $ - temp_NFA
 864+ EC29             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 864+ EC24             >
 864+ EC24 C5          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 864+ EC25 55 4E 54 49 >                db      "UNTIL"               // name string in 7-bit ascii, but
 864+ EC29 4C          >
 864+ EC2A             >                org     $-1                 // alter last byte of Name just above to set
 864+ EC29 CC          >                db      {b $} | END_BIT     // msb as name end
 864+ EC2A             >
 864+ EC2A 1A 2C       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 864+ EC2C             >Prev_Ptr        defl    Heap_Ptr
 864+ EC2C             >
 864+ EC2C             >mirror_Ptr      defl    $
 864+ EC2C             >
 864+ EC2C B6 B8       >                dw      Dict_Ptr + 2        // xt
 864+ EC2E             >Heap_Ptr        defl    $ - $E000           // save current HP
 864+ EC2E             >
 864+ EC2E             >Current_HP      defl  $ - $E000             // used to set HP once!
 864+ EC2E             >
 864+ EC2E             >//              ______________________________________________________________________
 864+ EC2E             >//              Dictionary part
 864+ EC2E             >
 864+ EC2E             >                org     Dict_Ptr
 864+ B8B4             >
 864+ B8B4 2C 2C       >                dw      mirror_Ptr - $E000 + Heap_offset
 864+ B8B6             >
 864+ B8B6             >UNTIL:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 864+ B8B6 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 864+ B8B9             >
 864+ B8B9             >
 864+ B8B9             >                endif           ; ok        // for other definitions it "points" the correct handler
 864+ B8B9             >                // Use of "; ok" to suppress "warning[fwdref]"
 864+ B8B9             >
 864+ B8B9             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 865+ B8B9 35 A6                        dw      QCOMP
 866+ B8BB CD A2 59 A6                  dw      TWO, QPAIRS
 867+ B8BF 90 A6 33 9C                  dw      COMPILE, ZBRANCH
 868+ B8C3 37 B8                        dw      BACK
 869+ B8C5 90 A0                        dw      EXIT
 870+ B8C7
 871+ B8C7              //  ______________________________________________________________________
 872+ B8C7              //
 873+ B8C7              // end          ( a 1 -- ) \ compile-time
 874+ B8C7                              Colon_Def END, "END", is_immediate
 874+ B8C7             >                New_Def  END, "END", Enter_Ptr, is_immediate ; ok
 874+ B8C7             >
 874+ B8C7             >Dict_Ptr        defl    $
 874+ B8C7             >
 874+ B8C7             >//              ______________________________________________________________________
 874+ B8C7             >//              Heap part
 874+ B8C7             >
 874+ B8C7             >
 874+ B8C7             >                org     (Heap_Ptr & $1FFF) + $E000
 874+ EC2E             >
 874+ EC2E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 874+ EC2E             >Latest_Definition defl  Heap_Ptr
 874+ EC2E             >
 874+ EC2E             >                // dummy db directives used to calculate length of namec
 874+ EC2E 45 4E 44    >                db      "END"
 874+ EC31             >len_NFA         defl    $ - temp_NFA
 874+ EC31             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 874+ EC2E             >
 874+ EC2E C3          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 874+ EC2F 45 4E 44    >                db      "END"               // name string in 7-bit ascii, but
 874+ EC32             >                org     $-1                 // alter last byte of Name just above to set
 874+ EC31 C4          >                db      {b $} | END_BIT     // msb as name end
 874+ EC32             >
 874+ EC32 24 2C       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 874+ EC34             >Prev_Ptr        defl    Heap_Ptr
 874+ EC34             >
 874+ EC34             >mirror_Ptr      defl    $
 874+ EC34             >
 874+ EC34 C9 B8       >                dw      Dict_Ptr + 2        // xt
 874+ EC36             >Heap_Ptr        defl    $ - $E000           // save current HP
 874+ EC36             >
 874+ EC36             >Current_HP      defl  $ - $E000             // used to set HP once!
 874+ EC36             >
 874+ EC36             >//              ______________________________________________________________________
 874+ EC36             >//              Dictionary part
 874+ EC36             >
 874+ EC36             >                org     Dict_Ptr
 874+ B8C7             >
 874+ B8C7 34 2C       >                dw      mirror_Ptr - $E000 + Heap_offset
 874+ B8C9             >
 874+ B8C9             >END:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 874+ B8C9 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 874+ B8CC             >
 874+ B8CC             >
 874+ B8CC             >                endif           ; ok        // for other definitions it "points" the correct handler
 874+ B8CC             >                // Use of "; ok" to suppress "warning[fwdref]"
 874+ B8CC             >
 874+ B8CC             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 875+ B8CC B6 B8                        dw      UNTIL
 876+ B8CE 90 A0                        dw      EXIT
 877+ B8D0
 878+ B8D0              //  ______________________________________________________________________
 879+ B8D0              //
 880+ B8D0              // while        ( a1 1 -- a1 1 a2 4 ) \ compile-time
 881+ B8D0                              Colon_Def WHILE, "WHILE", is_immediate
 881+ B8D0             >                New_Def  WHILE, "WHILE", Enter_Ptr, is_immediate ; ok
 881+ B8D0             >
 881+ B8D0             >Dict_Ptr        defl    $
 881+ B8D0             >
 881+ B8D0             >//              ______________________________________________________________________
 881+ B8D0             >//              Heap part
 881+ B8D0             >
 881+ B8D0             >
 881+ B8D0             >                org     (Heap_Ptr & $1FFF) + $E000
 881+ EC36             >
 881+ EC36             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 881+ EC36             >Latest_Definition defl  Heap_Ptr
 881+ EC36             >
 881+ EC36             >                // dummy db directives used to calculate length of namec
 881+ EC36 57 48 49 4C >                db      "WHILE"
 881+ EC3A 45          >
 881+ EC3B             >len_NFA         defl    $ - temp_NFA
 881+ EC3B             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 881+ EC36             >
 881+ EC36 C5          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 881+ EC37 57 48 49 4C >                db      "WHILE"               // name string in 7-bit ascii, but
 881+ EC3B 45          >
 881+ EC3C             >                org     $-1                 // alter last byte of Name just above to set
 881+ EC3B C5          >                db      {b $} | END_BIT     // msb as name end
 881+ EC3C             >
 881+ EC3C 2E 2C       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 881+ EC3E             >Prev_Ptr        defl    Heap_Ptr
 881+ EC3E             >
 881+ EC3E             >mirror_Ptr      defl    $
 881+ EC3E             >
 881+ EC3E D2 B8       >                dw      Dict_Ptr + 2        // xt
 881+ EC40             >Heap_Ptr        defl    $ - $E000           // save current HP
 881+ EC40             >
 881+ EC40             >Current_HP      defl  $ - $E000             // used to set HP once!
 881+ EC40             >
 881+ EC40             >//              ______________________________________________________________________
 881+ EC40             >//              Dictionary part
 881+ EC40             >
 881+ EC40             >                org     Dict_Ptr
 881+ B8D0             >
 881+ B8D0 3E 2C       >                dw      mirror_Ptr - $E000 + Heap_offset
 881+ B8D2             >
 881+ B8D2             >WHILE:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 881+ B8D2 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 881+ B8D5             >
 881+ B8D5             >
 881+ B8D5             >                endif           ; ok        // for other definitions it "points" the correct handler
 881+ B8D5             >                // Use of "; ok" to suppress "warning[fwdref]"
 881+ B8D5             >
 881+ B8D5             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 882+ B8D5 44 B8                        dw      IF
 883+ B8D7              //              dw      TWO_PLUS // ( that is 4 )
 884+ B8D7 98 A1                        dw      TWO_SWAP
 885+ B8D9 90 A0                        dw      EXIT
 886+ B8DB
 887+ B8DB              //  ______________________________________________________________________
 888+ B8DB              //
 889+ B8DB              // repeat       ( a1 1 a2 4 -- ) \ compile-time
 890+ B8DB                              Colon_Def REPEAT, "REPEAT", is_immediate
 890+ B8DB             >                New_Def  REPEAT, "REPEAT", Enter_Ptr, is_immediate ; ok
 890+ B8DB             >
 890+ B8DB             >Dict_Ptr        defl    $
 890+ B8DB             >
 890+ B8DB             >//              ______________________________________________________________________
 890+ B8DB             >//              Heap part
 890+ B8DB             >
 890+ B8DB             >
 890+ B8DB             >                org     (Heap_Ptr & $1FFF) + $E000
 890+ EC40             >
 890+ EC40             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 890+ EC40             >Latest_Definition defl  Heap_Ptr
 890+ EC40             >
 890+ EC40             >                // dummy db directives used to calculate length of namec
 890+ EC40 52 45 50 45 >                db      "REPEAT"
 890+ EC44 41 54       >
 890+ EC46             >len_NFA         defl    $ - temp_NFA
 890+ EC46             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 890+ EC40             >
 890+ EC40 C6          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 890+ EC41 52 45 50 45 >                db      "REPEAT"               // name string in 7-bit ascii, but
 890+ EC45 41 54       >
 890+ EC47             >                org     $-1                 // alter last byte of Name just above to set
 890+ EC46 D4          >                db      {b $} | END_BIT     // msb as name end
 890+ EC47             >
 890+ EC47 36 2C       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 890+ EC49             >Prev_Ptr        defl    Heap_Ptr
 890+ EC49             >
 890+ EC49             >mirror_Ptr      defl    $
 890+ EC49             >
 890+ EC49 DD B8       >                dw      Dict_Ptr + 2        // xt
 890+ EC4B             >Heap_Ptr        defl    $ - $E000           // save current HP
 890+ EC4B             >
 890+ EC4B             >Current_HP      defl  $ - $E000             // used to set HP once!
 890+ EC4B             >
 890+ EC4B             >//              ______________________________________________________________________
 890+ EC4B             >//              Dictionary part
 890+ EC4B             >
 890+ EC4B             >                org     Dict_Ptr
 890+ B8DB             >
 890+ B8DB 49 2C       >                dw      mirror_Ptr - $E000 + Heap_offset
 890+ B8DD             >
 890+ B8DD             >REPEAT:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 890+ B8DD CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 890+ B8E0             >
 890+ B8E0             >
 890+ B8E0             >                endif           ; ok        // for other definitions it "points" the correct handler
 890+ B8E0             >                // Use of "; ok" to suppress "warning[fwdref]"
 890+ B8E0             >
 890+ B8E0             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 891+ B8E0 A3 B8                        dw      AGAIN
 892+ B8E2              //              dw      TWO_MINUS
 893+ B8E2 57 B8                        dw      THEN
 894+ B8E4 90 A0                        dw      EXIT
 895+ B8E6
 896+ B8E6              //  ______________________________________________________________________
 897+ B8E6              //
 898+ B8E6              // ?do-
 899+ B8E6              // special version of "BACK" used by ?DO and LOOP
 900+ B8E6                              Colon_Def C_DO_BACK, "?DO-", is_normal
 900+ B8E6             >                New_Def  C_DO_BACK, "?DO-", Enter_Ptr, is_normal ; ok
 900+ B8E6             >
 900+ B8E6             >Dict_Ptr        defl    $
 900+ B8E6             >
 900+ B8E6             >//              ______________________________________________________________________
 900+ B8E6             >//              Heap part
 900+ B8E6             >
 900+ B8E6             >
 900+ B8E6             >                org     (Heap_Ptr & $1FFF) + $E000
 900+ EC4B             >
 900+ EC4B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 900+ EC4B             >Latest_Definition defl  Heap_Ptr
 900+ EC4B             >
 900+ EC4B             >                // dummy db directives used to calculate length of namec
 900+ EC4B 3F 44 4F 2D >                db      "?DO-"
 900+ EC4F             >len_NFA         defl    $ - temp_NFA
 900+ EC4F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 900+ EC4B             >
 900+ EC4B 84          >                db      len_NFA | END_BIT | is_normal  // The start of NFA must have msb set to signal the beginning of the sounted string
 900+ EC4C 3F 44 4F 2D >                db      "?DO-"               // name string in 7-bit ascii, but
 900+ EC50             >                org     $-1                 // alter last byte of Name just above to set
 900+ EC4F AD          >                db      {b $} | END_BIT     // msb as name end
 900+ EC50             >
 900+ EC50 40 2C       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 900+ EC52             >Prev_Ptr        defl    Heap_Ptr
 900+ EC52             >
 900+ EC52             >mirror_Ptr      defl    $
 900+ EC52             >
 900+ EC52 E8 B8       >                dw      Dict_Ptr + 2        // xt
 900+ EC54             >Heap_Ptr        defl    $ - $E000           // save current HP
 900+ EC54             >
 900+ EC54             >Current_HP      defl  $ - $E000             // used to set HP once!
 900+ EC54             >
 900+ EC54             >//              ______________________________________________________________________
 900+ EC54             >//              Dictionary part
 900+ EC54             >
 900+ EC54             >                org     Dict_Ptr
 900+ B8E6             >
 900+ B8E6 52 2C       >                dw      mirror_Ptr - $E000 + Heap_offset
 900+ B8E8             >
 900+ B8E8             >C_DO_BACK:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 900+ B8E8 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 900+ B8EB             >
 900+ B8EB             >
 900+ B8EB             >                endif           ; ok        // for other definitions it "points" the correct handler
 900+ B8EB             >                // Use of "; ok" to suppress "warning[fwdref]"
 900+ B8EB             >
 900+ B8EB             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 901+ B8EB 37 B8                        dw      BACK
 902+ B8ED              CDoBack_Begin:
 903+ B8ED 77 A0 A2 A3                  dw      SPFETCH, CSP, FETCH, SUBTRACT
 903+ B8F1 C7 A1 23 A4
 904+ B8F5 33 9C                        dw      ZBRANCH
 905+ B8F7 0A 00                        dw      CDoBack_While - $
 906+ B8F9 0A A1 57 B8                  dw          TWO_PLUS, THEN
 907+ B8FD 26 9C                        dw      BRANCH
 908+ B8FF EE FF                        dw      CDoBack_Begin - $
 909+ B901              CDoBack_While:
 910+ B901 68 A6 A2 A3                  dw      QCSP, CSP, STORE
 910+ B905 D1 A1
 911+ B907 90 A0                        dw      EXIT
 912+ B909
 913+ B909              //  ______________________________________________________________________
 914+ B909              //
 915+ B909              // do
 916+ B909              // DO  ... LOOP
 917+ B909              // DO  ... n +LOOP
 918+ B909              // ?DO ... LOOP
 919+ B909              // ?DO ... n +LOOP
 920+ B909                              Colon_Def DO, "DO", is_immediate
 920+ B909             >                New_Def  DO, "DO", Enter_Ptr, is_immediate ; ok
 920+ B909             >
 920+ B909             >Dict_Ptr        defl    $
 920+ B909             >
 920+ B909             >//              ______________________________________________________________________
 920+ B909             >//              Heap part
 920+ B909             >
 920+ B909             >
 920+ B909             >                org     (Heap_Ptr & $1FFF) + $E000
 920+ EC54             >
 920+ EC54             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 920+ EC54             >Latest_Definition defl  Heap_Ptr
 920+ EC54             >
 920+ EC54             >                // dummy db directives used to calculate length of namec
 920+ EC54 44 4F       >                db      "DO"
 920+ EC56             >len_NFA         defl    $ - temp_NFA
 920+ EC56             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 920+ EC54             >
 920+ EC54 C2          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 920+ EC55 44 4F       >                db      "DO"               // name string in 7-bit ascii, but
 920+ EC57             >                org     $-1                 // alter last byte of Name just above to set
 920+ EC56 CF          >                db      {b $} | END_BIT     // msb as name end
 920+ EC57             >
 920+ EC57 4B 2C       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 920+ EC59             >Prev_Ptr        defl    Heap_Ptr
 920+ EC59             >
 920+ EC59             >mirror_Ptr      defl    $
 920+ EC59             >
 920+ EC59 0B B9       >                dw      Dict_Ptr + 2        // xt
 920+ EC5B             >Heap_Ptr        defl    $ - $E000           // save current HP
 920+ EC5B             >
 920+ EC5B             >Current_HP      defl  $ - $E000             // used to set HP once!
 920+ EC5B             >
 920+ EC5B             >//              ______________________________________________________________________
 920+ EC5B             >//              Dictionary part
 920+ EC5B             >
 920+ EC5B             >                org     Dict_Ptr
 920+ B909             >
 920+ B909 59 2C       >                dw      mirror_Ptr - $E000 + Heap_offset
 920+ B90B             >
 920+ B90B             >DO:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 920+ B90B CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 920+ B90E             >
 920+ B90E             >
 920+ B90E             >                endif           ; ok        // for other definitions it "points" the correct handler
 920+ B90E             >                // Use of "; ok" to suppress "warning[fwdref]"
 920+ B90E             >
 920+ B90E             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 921+ B90E 90 A6 72 9C                  dw      COMPILE, C_DO
 922+ B912 A2 A3 C7 A1                  dw      CSP, FETCH, STORE_CSP
 922+ B916 13 A6
 923+ B918 E4 A3 D4 A2                  dw      HERE, THREE
 924+ B91C 90 A0                        dw      EXIT
 925+ B91E
 926+ B91E              //  ______________________________________________________________________
 927+ B91E              //
 928+ B91E              // loop
 929+ B91E                              Colon_Def LOOP, "LOOP", is_immediate
 929+ B91E             >                New_Def  LOOP, "LOOP", Enter_Ptr, is_immediate ; ok
 929+ B91E             >
 929+ B91E             >Dict_Ptr        defl    $
 929+ B91E             >
 929+ B91E             >//              ______________________________________________________________________
 929+ B91E             >//              Heap part
 929+ B91E             >
 929+ B91E             >
 929+ B91E             >                org     (Heap_Ptr & $1FFF) + $E000
 929+ EC5B             >
 929+ EC5B             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 929+ EC5B             >Latest_Definition defl  Heap_Ptr
 929+ EC5B             >
 929+ EC5B             >                // dummy db directives used to calculate length of namec
 929+ EC5B 4C 4F 4F 50 >                db      "LOOP"
 929+ EC5F             >len_NFA         defl    $ - temp_NFA
 929+ EC5F             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 929+ EC5B             >
 929+ EC5B C4          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 929+ EC5C 4C 4F 4F 50 >                db      "LOOP"               // name string in 7-bit ascii, but
 929+ EC60             >                org     $-1                 // alter last byte of Name just above to set
 929+ EC5F D0          >                db      {b $} | END_BIT     // msb as name end
 929+ EC60             >
 929+ EC60 54 2C       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 929+ EC62             >Prev_Ptr        defl    Heap_Ptr
 929+ EC62             >
 929+ EC62             >mirror_Ptr      defl    $
 929+ EC62             >
 929+ EC62 20 B9       >                dw      Dict_Ptr + 2        // xt
 929+ EC64             >Heap_Ptr        defl    $ - $E000           // save current HP
 929+ EC64             >
 929+ EC64             >Current_HP      defl  $ - $E000             // used to set HP once!
 929+ EC64             >
 929+ EC64             >//              ______________________________________________________________________
 929+ EC64             >//              Dictionary part
 929+ EC64             >
 929+ EC64             >                org     Dict_Ptr
 929+ B91E             >
 929+ B91E 62 2C       >                dw      mirror_Ptr - $E000 + Heap_offset
 929+ B920             >
 929+ B920             >LOOP:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 929+ B920 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 929+ B923             >
 929+ B923             >
 929+ B923             >                endif           ; ok        // for other definitions it "points" the correct handler
 929+ B923             >                // Use of "; ok" to suppress "warning[fwdref]"
 929+ B923             >
 929+ B923             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 930+ B923 D4 A2 59 A6                  dw      THREE, QPAIRS
 931+ B927 90 A6 1E 9C                  dw      COMPILE, C_LOOP
 932+ B92B E8 B8                        dw      C_DO_BACK
 933+ B92D 90 A0                        dw      EXIT
 934+ B92F
 935+ B92F              //  ______________________________________________________________________
 936+ B92F              //
 937+ B92F              // +loop
 938+ B92F                              Colon_Def PLOOP, "+LOOP", is_immediate
 938+ B92F             >                New_Def  PLOOP, "+LOOP", Enter_Ptr, is_immediate ; ok
 938+ B92F             >
 938+ B92F             >Dict_Ptr        defl    $
 938+ B92F             >
 938+ B92F             >//              ______________________________________________________________________
 938+ B92F             >//              Heap part
 938+ B92F             >
 938+ B92F             >
 938+ B92F             >                org     (Heap_Ptr & $1FFF) + $E000
 938+ EC64             >
 938+ EC64             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 938+ EC64             >Latest_Definition defl  Heap_Ptr
 938+ EC64             >
 938+ EC64             >                // dummy db directives used to calculate length of namec
 938+ EC64 2B 4C 4F 4F >                db      "+LOOP"
 938+ EC68 50          >
 938+ EC69             >len_NFA         defl    $ - temp_NFA
 938+ EC69             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 938+ EC64             >
 938+ EC64 C5          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 938+ EC65 2B 4C 4F 4F >                db      "+LOOP"               // name string in 7-bit ascii, but
 938+ EC69 50          >
 938+ EC6A             >                org     $-1                 // alter last byte of Name just above to set
 938+ EC69 D0          >                db      {b $} | END_BIT     // msb as name end
 938+ EC6A             >
 938+ EC6A 5B 2C       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 938+ EC6C             >Prev_Ptr        defl    Heap_Ptr
 938+ EC6C             >
 938+ EC6C             >mirror_Ptr      defl    $
 938+ EC6C             >
 938+ EC6C 31 B9       >                dw      Dict_Ptr + 2        // xt
 938+ EC6E             >Heap_Ptr        defl    $ - $E000           // save current HP
 938+ EC6E             >
 938+ EC6E             >Current_HP      defl  $ - $E000             // used to set HP once!
 938+ EC6E             >
 938+ EC6E             >//              ______________________________________________________________________
 938+ EC6E             >//              Dictionary part
 938+ EC6E             >
 938+ EC6E             >                org     Dict_Ptr
 938+ B92F             >
 938+ B92F 6C 2C       >                dw      mirror_Ptr - $E000 + Heap_offset
 938+ B931             >
 938+ B931             >PLOOP:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 938+ B931 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 938+ B934             >
 938+ B934             >
 938+ B934             >                endif           ; ok        // for other definitions it "points" the correct handler
 938+ B934             >                // Use of "; ok" to suppress "warning[fwdref]"
 938+ B934             >
 938+ B934             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 939+ B934 D4 A2 59 A6                  dw      THREE, QPAIRS
 940+ B938 90 A6 EF 9B                  dw      COMPILE, C_PLOOP
 941+ B93C E8 B8                        dw      C_DO_BACK
 942+ B93E 90 A0                        dw      EXIT
 943+ B940
 944+ B940              //  ______________________________________________________________________
 945+ B940              //
 946+ B940              // ?do
 947+ B940                              Colon_Def QDO, "?DO", is_immediate
 947+ B940             >                New_Def  QDO, "?DO", Enter_Ptr, is_immediate ; ok
 947+ B940             >
 947+ B940             >Dict_Ptr        defl    $
 947+ B940             >
 947+ B940             >//              ______________________________________________________________________
 947+ B940             >//              Heap part
 947+ B940             >
 947+ B940             >
 947+ B940             >                org     (Heap_Ptr & $1FFF) + $E000
 947+ EC6E             >
 947+ EC6E             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 947+ EC6E             >Latest_Definition defl  Heap_Ptr
 947+ EC6E             >
 947+ EC6E             >                // dummy db directives used to calculate length of namec
 947+ EC6E 3F 44 4F    >                db      "?DO"
 947+ EC71             >len_NFA         defl    $ - temp_NFA
 947+ EC71             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 947+ EC6E             >
 947+ EC6E C3          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 947+ EC6F 3F 44 4F    >                db      "?DO"               // name string in 7-bit ascii, but
 947+ EC72             >                org     $-1                 // alter last byte of Name just above to set
 947+ EC71 CF          >                db      {b $} | END_BIT     // msb as name end
 947+ EC72             >
 947+ EC72 64 2C       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 947+ EC74             >Prev_Ptr        defl    Heap_Ptr
 947+ EC74             >
 947+ EC74             >mirror_Ptr      defl    $
 947+ EC74             >
 947+ EC74 42 B9       >                dw      Dict_Ptr + 2        // xt
 947+ EC76             >Heap_Ptr        defl    $ - $E000           // save current HP
 947+ EC76             >
 947+ EC76             >Current_HP      defl  $ - $E000             // used to set HP once!
 947+ EC76             >
 947+ EC76             >//              ______________________________________________________________________
 947+ EC76             >//              Dictionary part
 947+ EC76             >
 947+ EC76             >                org     Dict_Ptr
 947+ B940             >
 947+ B940 74 2C       >                dw      mirror_Ptr - $E000 + Heap_offset
 947+ B942             >
 947+ B942             >QDO:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 947+ B942 CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 947+ B945             >
 947+ B945             >
 947+ B945             >                endif           ; ok        // for other definitions it "points" the correct handler
 947+ B945             >                // Use of "; ok" to suppress "warning[fwdref]"
 947+ B945             >
 947+ B945             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 948+ B945 90 A6 4A 9C                  dw      COMPILE, C_Q_DO
 949+ B949 A2 A3 C7 A1                  dw      CSP, FETCH, STORE_CSP
 949+ B94D 13 A6
 950+ B94F E4 A3 BF A2                  dw      HERE, ZERO, COMMA, ZERO
 950+ B953 FA A3 BF A2
 951+ B957 E4 A3 D4 A2                  dw      HERE, THREE
 952+ B95B 90 A0                        dw      EXIT
 953+ B95D
 954+ B95D              //  ______________________________________________________________________
 955+ B95D              //
 956+ B95D              // \
 957+ B95D                              Colon_Def BACKSLASH, "\\", is_immediate  // this is a single back-slash
 957+ B95D             >                New_Def  BACKSLASH, "\\", Enter_Ptr, is_immediate ; ok
 957+ B95D             >
 957+ B95D             >Dict_Ptr        defl    $
 957+ B95D             >
 957+ B95D             >//              ______________________________________________________________________
 957+ B95D             >//              Heap part
 957+ B95D             >
 957+ B95D             >
 957+ B95D             >                org     (Heap_Ptr & $1FFF) + $E000
 957+ EC76             >
 957+ EC76             >temp_NFA        defl    $                   // save this NFA address to temp_NFA
 957+ EC76             >Latest_Definition defl  Heap_Ptr
 957+ EC76             >
 957+ EC76             >                // dummy db directives used to calculate length of namec
 957+ EC76 5C          >                db      "\\"
 957+ EC77             >len_NFA         defl    $ - temp_NFA
 957+ EC77             >                org     $ - len_NFA         // rewind to temp_NFA and re-do NFA part
 957+ EC76             >
 957+ EC76 C1          >                db      len_NFA | END_BIT | is_immediate  // The start of NFA must have msb set to signal the beginning of the sounted string
 957+ EC77 5C          >                db      "\\"               // name string in 7-bit ascii, but
 957+ EC78             >                org     $-1                 // alter last byte of Name just above to set
 957+ EC77 DC          >                db      {b $} | END_BIT     // msb as name end
 957+ EC78             >
 957+ EC78 6E 2C       >                dw      Prev_Ptr  + Heap_offset     // Link to previous definition Name
 957+ EC7A             >Prev_Ptr        defl    Heap_Ptr
 957+ EC7A             >
 957+ EC7A             >mirror_Ptr      defl    $
 957+ EC7A             >
 957+ EC7A 5F B9       >                dw      Dict_Ptr + 2        // xt
 957+ EC7C             >Heap_Ptr        defl    $ - $E000           // save current HP
 957+ EC7C             >
 957+ EC7C             >Current_HP      defl  $ - $E000             // used to set HP once!
 957+ EC7C             >
 957+ EC7C             >//              ______________________________________________________________________
 957+ EC7C             >//              Dictionary part
 957+ EC7C             >
 957+ EC7C             >                org     Dict_Ptr
 957+ B95D             >
 957+ B95D 7A 2C       >                dw      mirror_Ptr - $E000 + Heap_offset
 957+ B95F             >
 957+ B95F             >BACKSLASH:          if Enter_Ptr != 0 ; ok        // This is the start address of the direct jp(hl)
 957+ B95F CD 6A A2    >                call    Enter_Ptr ; ok        // for primitive definitions  actual code
 957+ B962             >
 957+ B962             >
 957+ B962             >                endif           ; ok        // for other definitions it "points" the correct handler
 957+ B962             >                // Use of "; ok" to suppress "warning[fwdref]"
 957+ B962             >
 957+ B962             >last_NFA        defl    temp_NFA            // keep track of NFA saved above
 958+ B962 60 A3 C7 A1                  dw      BLK, FETCH
 959+ B966 33 9C                        dw      ZBRANCH
 960+ B968 30 00                        dw      Backslash_Else_1 - $
 961+ B96A 60 A3 C7 A1                  dw          BLK, FETCH, ONE, GREATER  // BLOCK 1 is used as temp-line in INCLUDE file
 961+ B96E C6 A2 5D A4
 962+ B972 33 9C                        dw          ZBRANCH
 963+ B974 18 00                        dw          Backslash_Else_2 - $
 964+ B976 66 A3 C7 A1                  dw              TO_IN, FETCH, CL, MOD, CL
 964+ B97A E9 A2 22 AF
 964+ B97E E9 A2
 965+ B980 62 A1 23 A4                  dw              SWAP, SUBTRACT, TO_IN, PLUSSTORE
 965+ B984 66 A3 AF A1
 966+ B988 26 9C                        dw          BRANCH
 967+ B98A 0A 00                        dw          Backslash_Endif_2 - $
 968+ B98C              Backslash_Else_2:
 969+ B98C F0 A2 17 A1                  dw              BBUF, CELL_MINUS, TO_IN, STORE
 969+ B990 66 A3 D1 A1
 970+ B994              Backslash_Endif_2:
 971+ B994 26 9C                        dw      BRANCH
 972+ B996 10 00                        dw      Backslash_Endif_1 - $
 973+ B998              Backslash_Else_1:
 974+ B998 BF A2 24 A3                  dw          ZERO, TIB, FETCH, TO_IN, FETCH, PLUS, STORE
 974+ B99C C7 A1 66 A3
 974+ B9A0 C7 A1 E3 A0
 974+ B9A4 D1 A1
 975+ B9A6              Backslash_Endif_1:
 976+ B9A6 90 A0                        dw      EXIT
 977+ B9A8
 978+ B9A8              Fence_Word:
 979+ B9A8              //  ______________________________________________________________________
 980+ B9A8              //
 981+ B9A8
 982+ B9A8 00           Here_Dictionary db      0
 983+ B9A9
# file closed: C:\Zx\CSpect\Projects\vForth17_MMU7/source/L3.asm
 125  B9A9
 126  B9A9              // now we save the compiled file so we can either run it or debug it
C:\Zx\CSpect\Projects\vForth17_MMU7/source/main.asm(127): warning[nexstack]: [SAVENEX] non-zero data are in stackAddress area, may get overwritten by NEXLOAD
 127  B9A9                              SAVENEX OPEN "output/main.nex", ORIGIN
 128  B9A9                              SAVENEX CORE 3, 0, 0                                // Next core 3.0.0 required as minimum
 129  B9A9                              SAVENEX CFG  0
 130  B9A9                              SAVENEX BANK 2, 0
 131  B9A9                              SAVENEX AUTO
 132  B9A9                              SAVENEX CLOSE
 133  B9A9
 134  B9A9              //              PAGE 7 ;set 7 page to current slot
 135  B9A9              //              SAVEBIN "ram7.bin",$C000,$4000 ;- save 4000h begin from C000h of RAM to file
 136  B9A9              //              SAVEBIN "output/ram2.bin", $8000, 9800 ;- save 3000h begin from 8000h of RAM to file
 137  B9A9
 138  B9A9                              SAVETAP "output/F16d.tap", CODE, "forth17d", ORIGIN, 9999
 139  B9A9                              SAVETAP "output/F16e.tap", CODE, "forth17e", $E000, $2000
 140  B9A9
 141  B9A9                              SAVEBIN "output/forth17d.bin", ORIGIN, 9999
 142  B9A9                              SAVEBIN "output/ram7.bin", $E000, $2000 ;- save 2000h begin from E000h of RAM to file
 143  B9A9
 144  B9A9                              // To load on ZX Spectrum Next you have to type
 145  B9A9                              //      LOAD "ram7.bin" BANK 16
 146  B9A9                              //      LOAD "forth17d.bin" CODE
 147  B9A9
 148  B9A9                              END
# file closed: C:\Zx\CSpect\Projects\vForth17_MMU7/source/main.asm
